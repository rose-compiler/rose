#include <boost/algorithm/string/predicate.hpp>
#include <boost/lexical_cast.hpp>
#include <string>
#include <vector>

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h line 46
namespace stringify { namespace QCodeEdit {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQCodeEditPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QCodeEdit::Position(i);
        if (retval.empty()) {
            retval = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QCodeEdit::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQCodeEditPosition() {
        return stringify::QCodeEdit::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h line 44
namespace stringify { namespace QLanguageDefinition {
    const char* CollapseFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 4095L: return "OpenMask";
            case 16773120L: return "CloseMask";
            case 268435456L: return "Collapsible";
            case 536870912L: return "Collapsed";
            case 1073741824L: return "Closure";
            default: return "";
        }
    }

    std::string CollapseFlag(int64_t i, const std::string &strip) {
        std::string s = CollapseFlag(i);
        if (s.empty())
            s = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CollapseFlag() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            268435456L,
            536870912L,
            1073741824L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQLanguageDefinitionCollapseFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QLanguageDefinition::CollapseFlag(i);
        if (retval.empty()) {
            retval = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QLanguageDefinition::CollapseFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQLanguageDefinitionCollapseFlag() {
        return stringify::QLanguageDefinition::CollapseFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h line 52
namespace stringify { namespace QReliableFileWatch {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "Clean";
            case 1L: return "Recent";
            case 2L: return "Duplicate";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQReliableFileWatchState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QReliableFileWatch::State(i);
        if (retval.empty()) {
            retval = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QReliableFileWatch::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQReliableFileWatchState() {
        return stringify::QReliableFileWatch::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 38
namespace stringify { namespace QPanelLayout {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::Position(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutPosition() {
        return stringify::QPanelLayout::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 87
namespace stringify { namespace QPanelLayout {
    const char* SizeType(int64_t i) {
        switch (i) {
            case 0L: return "MinimumSize";
            case 1L: return "SizeHint";
            default: return "";
        }
    }

    std::string SizeType(int64_t i, const std::string &strip) {
        std::string s = SizeType(i);
        if (s.empty())
            s = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SizeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutSizeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::SizeType(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::SizeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutSizeType() {
        return stringify::QPanelLayout::SizeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 64
namespace stringify { namespace QEditor {
    const char* CodecUpdatePolicy(int64_t i) {
        switch (i) {
            case 0L: return "NoUpdate";
            case 1L: return "UpdateOld";
            case 2L: return "UpdateDefault";
            case 4L: return "UpdateCustom";
            case 7L: return "UpdateAll";
            default: return "";
        }
    }

    std::string CodecUpdatePolicy(int64_t i, const std::string &strip) {
        std::string s = CodecUpdatePolicy(i);
        if (s.empty())
            s = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CodecUpdatePolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorCodecUpdatePolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::CodecUpdatePolicy(i);
        if (retval.empty()) {
            retval = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::CodecUpdatePolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorCodecUpdatePolicy() {
        return stringify::QEditor::CodecUpdatePolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 74
namespace stringify { namespace QEditor {
    const char* EditFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Overwrite";
            case 2L: return "CursorOn";
            case 4L: return "ReadOnly";
            case 8L: return "MousePressed";
            case 16L: return "MaybeDrag";
            case 32L: return "Selection";
            case 64L: return "Persistent";
            case 128L: return "Multiline";
            case 256L: return "FoldedCursor";
            case 4095L: return "Internal";
            case 4096L: return "LineWrap";
            case 65536L: return "CtrlNavigation";
            case 131072L: return "CursorJumpPastWrap";
            case 1048576L: return "ReplaceTabs";
            case 2097152L: return "RemoveTrailing";
            case 4194304L: return "PreserveTrailingIndent";
            case 16777216L: return "AutoCloseChars";
            case 33554432L: return "AutoIndent";
            case 4294963200L: return "Accessible";
            default: return "";
        }
    }

    std::string EditFlag(int64_t i, const std::string &strip) {
        std::string s = EditFlag(i);
        if (s.empty())
            s = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            4095L,
            4096L,
            65536L,
            131072L,
            1048576L,
            2097152L,
            4194304L,
            16777216L,
            33554432L,
            4294963200L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorEditFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::EditFlag(i);
        if (retval.empty()) {
            retval = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::EditFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorEditFlag() {
        return stringify::QEditor::EditFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 493
namespace stringify { namespace QEditor {
    const char* SaveState(int64_t i) {
        switch (i) {
            case 0L: return "Undefined";
            case 1L: return "Saving";
            case 2L: return "Saved";
            case 3L: return "Conflict";
            default: return "";
        }
    }

    std::string SaveState(int64_t i, const std::string &strip) {
        std::string s = SaveState(i);
        if (s.empty())
            s = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SaveState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorSaveState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::SaveState(i);
        if (retval.empty()) {
            retval = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::SaveState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorSaveState() {
        return stringify::QEditor::SaveState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 41
namespace stringify { namespace QNFAAction {
    const char* QNFAAction_(int64_t i) {
        switch (i) {
            case 0L: return "NoAction";
            case 4095L: return "FormatMask";
            case 16773120L: return "ParenMask";
            case 16777216L: return "Highlight";
            case 33554432L: return "Indent";
            case 67108864L: return "ParenOpen";
            case 134217728L: return "ParenClose";
            case 268435456L: return "MatchParen";
            case 536870912L: return "Fold";
            case 1073741824L: return "Ambiguous";
            case 2147483648L: return "Content";
            default: return "";
        }
    }

    std::string QNFAAction_(int64_t i, const std::string &strip) {
        std::string s = QNFAAction_(i);
        if (s.empty())
            s = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QNFAAction_() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQNFAActionQNFAAction_(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFAAction::QNFAAction_(i);
        if (retval.empty()) {
            retval = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFAAction::QNFAAction_::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFAActionQNFAAction_() {
        return stringify::QNFAAction::QNFAAction_();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 129
namespace stringify { namespace QNFADefinition { namespace PMatch {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyQNFADefinitionPMatchType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFADefinition::PMatch::Type(i);
        if (retval.empty()) {
            retval = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFADefinition::PMatch::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFADefinitionPMatchType() {
        return stringify::QNFADefinition::PMatch::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 42
namespace stringify {
    const char* NFAType(int64_t i) {
        switch (i) {
            case 0L: return "Char";
            case 1L: return "Match";
            case 2L: return "CxtBeg";
            case 3L: return "ContextBegin";
            case 4L: return "CxtEnd";
            case 5L: return "ContextEnd";
            case 8L: return "CxtEsc";
            case 9L: return "EscapeSeq";
            case 16L: return "Escaped";
            case 32L: return "Exclusive";
            case 64L: return "StayOnLine";
            case 128L: return "Reserved";
            default: return "";
        }
    }

    std::string NFAType(int64_t i, const std::string &strip) {
        std::string s = NFAType(i);
        if (s.empty())
            s = "(NFAType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            8L,
            9L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAType(i);
        if (retval.empty()) {
            retval = "(NFAType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAType() {
        return stringify::NFAType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 63
namespace stringify {
    const char* NFAAssertion(int64_t i) {
        switch (i) {
            case 0L: return "NoAssertion";
            case 1L: return "ZeroOrOne";
            case 2L: return "ZeroOrMore";
            case 4L: return "OneOrMore";
            case 8L: return "WordStart";
            case 16L: return "WordEnd";
            case 32L: return "Word";
            case 64L: return "NonWord";
            case 128L: return "Digit";
            case 256L: return "NonDigit";
            case 512L: return "Space";
            case 1024L: return "NonSpace";
            case 2048L: return "CaseSensitive";
            default: return "";
        }
    }

    std::string NFAAssertion(int64_t i, const std::string &strip) {
        std::string s = NFAAssertion(i);
        if (s.empty())
            s = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAAssertion() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            2048L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAAssertion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAAssertion(i);
        if (retval.empty()) {
            retval = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAAssertion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAAssertion() {
        return stringify::NFAAssertion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 38
namespace stringify { namespace QParenthesis {
    const char* Role(int64_t i) {
        switch (i) {
            case 1L: return "Open";
            case 2L: return "Close";
            case 4L: return "Indent";
            case 8L: return "Fold";
            case 16L: return "Match";
            default: return "";
        }
    }

    std::string Role(int64_t i, const std::string &strip) {
        std::string s = Role(i);
        if (s.empty())
            s = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Role() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQParenthesisRole(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QParenthesis::Role(i);
        if (retval.empty()) {
            retval = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QParenthesis::Role::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQParenthesisRole() {
        return stringify::QParenthesis::Role();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 69
namespace stringify { namespace QDocumentLine {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Hidden";
            case 2L: return "CollapsedBlockStart";
            case 4L: return "CollapsedBlockEnd";
            case 16L: return "LayoutDirty";
            case 32L: return "FormatsApplied";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentLine::State(i);
        if (retval.empty()) {
            retval = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentLine::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineState() {
        return stringify::QDocumentLine::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h line 37
namespace stringify { namespace QDocumentCommand {
    const char* Command(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Insert";
            case 2L: return "Erase";
            case 3L: return "Replace";
            case 4L: return "Custom";
            default: return "";
        }
    }

    std::string Command(int64_t i, const std::string &strip) {
        std::string s = Command(i);
        if (s.empty())
            s = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Command() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCommandCommand(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCommand::Command(i);
        if (retval.empty()) {
            retval = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCommand::Command::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCommandCommand() {
        return stringify::QDocumentCommand::Command();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 39
namespace stringify { namespace QDocumentCursor {
    const char* MoveFlag(int64_t i) {
        switch (i) {
            case 0L: return "MoveAnchor";
            case 1L: return "KeepAnchor";
            case 2L: return "ThroughWrap";
            default: return "";
        }
    }

    std::string MoveFlag(int64_t i, const std::string &strip) {
        std::string s = MoveFlag(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveFlag(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveFlag() {
        return stringify::QDocumentCursor::MoveFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 48
namespace stringify { namespace QDocumentCursor {
    const char* MoveOperation(int64_t i) {
        switch (i) {
            case 0L: return "NoMove";
            case 1L: return "Up";
            case 2L: return "Down";
            case 3L: return "Left";
            case 4L: return "Right";
            case 5L: return "Start";
            case 6L: return "StartOfLine";
            case 7L: return "StartOfWord";
            case 8L: return "PreviousBlock";
            case 9L: return "PreviousWord";
            case 10L: return "WordLeft";
            case 11L: return "WordRight";
            case 12L: return "End";
            case 13L: return "EndOfLine";
            case 14L: return "EndOfWord";
            case 15L: return "NextWord";
            case 16L: return "NextBlock";
            default: return "";
        }
    }

    std::string MoveOperation(int64_t i, const std::string &strip) {
        std::string s = MoveOperation(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveOperation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveOperation(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveOperation() {
        return stringify::QDocumentCursor::MoveOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 75
namespace stringify { namespace QDocumentCursor {
    const char* SelectionType(int64_t i) {
        switch (i) {
            case 0L: return "WordUnderCursor";
            case 1L: return "LineUnderCursor";
            default: return "";
        }
    }

    std::string SelectionType(int64_t i, const std::string &strip) {
        std::string s = SelectionType(i);
        if (s.empty())
            s = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorSelectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::SelectionType(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::SelectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorSelectionType() {
        return stringify::QDocumentCursor::SelectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 84
namespace stringify { namespace QDocument {
    const char* LineEnding(int64_t i) {
        switch (i) {
            case 0L: return "Conservative";
            case 1L: return "Local";
            case 2L: return "Unix";
            case 3L: return "Windows";
            case 4L: return "Mac";
            default: return "";
        }
    }

    std::string LineEnding(int64_t i, const std::string &strip) {
        std::string s = LineEnding(i);
        if (s.empty())
            s = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LineEnding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineEnding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::LineEnding(i);
        if (retval.empty()) {
            retval = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::LineEnding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineEnding() {
        return stringify::QDocument::LineEnding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 93
namespace stringify { namespace QDocument {
    const char* TextProcessing(int64_t i) {
        switch (i) {
            case 1L: return "RemoveTrailingWS";
            case 2L: return "PreserveIndent";
            case 4L: return "RestoreTrailingIndent";
            default: return "";
        }
    }

    std::string TextProcessing(int64_t i, const std::string &strip) {
        std::string s = TextProcessing(i);
        if (s.empty())
            s = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TextProcessing() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentTextProcessing(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::TextProcessing(i);
        if (retval.empty()) {
            retval = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::TextProcessing::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentTextProcessing() {
        return stringify::QDocument::TextProcessing();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 100
namespace stringify { namespace QDocument {
    const char* WhiteSpaceFlag(int64_t i) {
        switch (i) {
            case 0L: return "ShowNone";
            case 1L: return "ShowTrailing";
            case 2L: return "ShowLeading";
            case 4L: return "ShowTabs";
            default: return "";
        }
    }

    std::string WhiteSpaceFlag(int64_t i, const std::string &strip) {
        std::string s = WhiteSpaceFlag(i);
        if (s.empty())
            s = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhiteSpaceFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentWhiteSpaceFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::WhiteSpaceFlag(i);
        if (retval.empty()) {
            retval = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::WhiteSpaceFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentWhiteSpaceFlag() {
        return stringify::QDocument::WhiteSpaceFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h line 40
namespace stringify { namespace QDocumentSearch {
    const char* Option(int64_t i) {
        switch (i) {
            case 1L: return "WholeWords";
            case 2L: return "CaseSensitive";
            case 4L: return "RegExp";
            case 8L: return "Replace";
            case 16L: return "Prompt";
            case 32L: return "Silent";
            case 64L: return "HighlightAll";
            default: return "";
        }
    }

    std::string Option(int64_t i, const std::string &strip) {
        std::string s = Option(i);
        if (s.empty())
            s = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Option() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentSearchOption(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentSearch::Option(i);
        if (retval.empty()) {
            retval = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentSearch::Option::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentSearchOption() {
        return stringify::QDocumentSearch::Option();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h line 52
namespace stringify { namespace QDocumentCursorHandle {
    const char* Flags(int64_t i) {
        switch (i) {
            case 1L: return "Silent";
            case 2L: return "ColumnMemory";
            case 4L: return "MoveWithinWrapped";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorHandleFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursorHandle::Flags(i);
        if (retval.empty()) {
            retval = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursorHandle::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorHandleFlags() {
        return stringify::QDocumentCursorHandle::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h line 40
namespace stringify { namespace DisplayEdge {
    const char* PaintMode(int64_t i) {
        switch (i) {
            case 0L: return "STRAIGHT";
            case 1L: return "RECTANGULAR";
            case 2L: return "BEZIER_QUAD";
            case 3L: return "BEZIER_CUBIC";
            default: return "";
        }
    }

    std::string PaintMode(int64_t i, const std::string &strip) {
        std::string s = PaintMode(i);
        if (s.empty())
            s = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PaintMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDisplayEdgePaintMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DisplayEdge::PaintMode(i);
        if (retval.empty()) {
            retval = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DisplayEdge::PaintMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDisplayEdgePaintMode() {
        return stringify::DisplayEdge::PaintMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h line 25
namespace stringify { namespace CompilerOutputWidget {
    const char* PatternType(int64_t i) {
        switch (i) {
            case 0L: return "Unknown";
            case 1L: return "Warning";
            case 2L: return "Error";
            default: return "";
        }
    }

    std::string PatternType(int64_t i, const std::string &strip) {
        std::string s = PatternType(i);
        if (s.empty())
            s = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCompilerOutputWidgetPatternType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CompilerOutputWidget::PatternType(i);
        if (retval.empty()) {
            retval = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CompilerOutputWidget::PatternType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCompilerOutputWidgetPatternType() {
        return stringify::CompilerOutputWidget::PatternType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h line 25
namespace stringify { namespace Task {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "BEFORE_START";
            case 1L: return "RUNNING";
            case 2L: return "FINISHED_SUCCESS";
            case 3L: return "FINISHED_ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Task::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaskState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Task::State(i);
        if (retval.empty()) {
            retval = "(Task::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Task::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaskState() {
        return stringify::Task::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h line 20
namespace stringify { namespace DependencyInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "VALID";
            case 1L: return "INVALID";
            case 2L: return "ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDependencyInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DependencyInfo::State(i);
        if (retval.empty()) {
            retval = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DependencyInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDependencyInfoState() {
        return stringify::DependencyInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/util/AstDisplayInfo.h line 14
namespace stringify { namespace AstDisplayInfo {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "ROOT";
            case 1L: return "INCLUDE_ROOT";
            case 2L: return "SRC_FILE";
            case 3L: return "INCLUDE_FILE";
            case 4L: return "NAMESPACE";
            case 5L: return "CLASS";
            case 6L: return "FUNCTION";
            case 7L: return "LOOP";
            case 8L: return "UNKNOWN";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstDisplayInfoNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstDisplayInfo::NodeType(i);
        if (retval.empty()) {
            retval = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstDisplayInfo::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstDisplayInfoNodeType() {
        return stringify::AstDisplayInfo::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp line 91
namespace stringify { namespace QtGradientWidgetPrivate {
    const char* Handle(int64_t i) {
        switch (i) {
            case 0L: return "NoHandle";
            case 1L: return "StartLinearHandle";
            case 2L: return "EndLinearHandle";
            case 3L: return "CentralRadialHandle";
            case 4L: return "FocalRadialHandle";
            case 5L: return "RadiusRadialHandle";
            case 6L: return "CentralConicalHandle";
            case 7L: return "AngleConicalHandle";
            default: return "";
        }
    }

    std::string Handle(int64_t i, const std::string &strip) {
        std::string s = Handle(i);
        if (s.empty())
            s = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Handle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtGradientWidgetPrivateHandle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtGradientWidgetPrivate::Handle(i);
        if (retval.empty()) {
            retval = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtGradientWidgetPrivate::Handle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtGradientWidgetPrivateHandle() {
        return stringify::QtGradientWidgetPrivate::Handle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h line 62
namespace stringify { namespace QtColorLine {
    const char* ColorComponent(int64_t i) {
        switch (i) {
            case 0L: return "Red";
            case 1L: return "Green";
            case 2L: return "Blue";
            case 3L: return "Hue";
            case 4L: return "Saturation";
            case 5L: return "Value";
            case 6L: return "Alpha";
            default: return "";
        }
    }

    std::string ColorComponent(int64_t i, const std::string &strip) {
        std::string s = ColorComponent(i);
        if (s.empty())
            s = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ColorComponent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtColorLineColorComponent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtColorLine::ColorComponent(i);
        if (retval.empty()) {
            retval = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtColorLine::ColorComponent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtColorLineColorComponent() {
        return stringify::QtColorLine::ColorComponent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/failSafe/failSafePragma.h line 31
namespace stringify { namespace FailSafe {
    const char* fail_safe_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_region";
            case 2L: return "e_status_predicate";
            case 3L: return "e_data_predicate";
            case 4L: return "e_tolerance";
            case 5L: return "e_double_redundancy";
            case 6L: return "e_triple_redundancy";
            case 7L: return "e_save";
            case 8L: return "e_assert";
            case 9L: return "e_specifier";
            case 10L: return "e_region_reference";
            case 11L: return "e_error";
            case 12L: return "e_violation";
            case 13L: return "e_recover";
            case 14L: return "e_pre";
            case 15L: return "e_post";
            case 16L: return "e_type_ET1";
            case 17L: return "e_type_ET2";
            case 18L: return "e_violation_NaN";
            case 19L: return "e_violation_SECDED";
            case 20L: return "e_violation_SEGFAULT";
            case 21L: return "e_violation_ANY";
            case 22L: return "e_not_failsafe";
            default: return "";
        }
    }

    std::string fail_safe_enum(int64_t i, const std::string &strip) {
        std::string s = fail_safe_enum(i);
        if (s.empty())
            s = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fail_safe_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFailSafe_fail_safe_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FailSafe::fail_safe_enum(i);
        if (retval.empty()) {
            retval = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FailSafe::fail_safe_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFailSafe_fail_safe_enum() {
        return stringify::FailSafe::fail_safe_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/exampleTest.C line 3
namespace stringify {
    const char* controlEnum(int64_t i) {
        switch (i) {
            case 0L: return "BEGGINING_OF_ENUM";
            case 1L: return "typeInt";
            case 2L: return "typeChar";
            case 3L: return "typeTestStruct";
            case 4L: return "END_OF_ENUM";
            default: return "";
        }
    }

    std::string controlEnum(int64_t i, const std::string &strip) {
        std::string s = controlEnum(i);
        if (s.empty())
            s = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& controlEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_controlEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::controlEnum(i);
        if (retval.empty()) {
            retval = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "controlEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_controlEnum() {
        return stringify::controlEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/GenRepresentation.h line 23
namespace stringify { namespace GenRepresentation {
    const char* TypeOfPrint(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElement";
            case 1L: return "Container";
            case 2L: return "Contained";
            case 3L: return "END_OF_LIST";
            default: return "";
        }
    }

    std::string TypeOfPrint(int64_t i, const std::string &strip) {
        std::string s = TypeOfPrint(i);
        if (s.empty())
            s = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfPrint() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyGenRepresentationTypeOfPrint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::GenRepresentation::TypeOfPrint(i);
        if (retval.empty()) {
            retval = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "GenRepresentation::TypeOfPrint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenRepresentationTypeOfPrint() {
        return stringify::GenRepresentation::TypeOfPrint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 88
namespace stringify {
    const char* ConstructParamEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_CONSTRUCTOR_PARAMETER";
            case 1L: return "CONSTRUCTOR_PARAMETER";
            default: return "";
        }
    }

    std::string ConstructParamEnum(int64_t i, const std::string &strip) {
        std::string s = ConstructParamEnum(i);
        if (s.empty())
            s = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConstructParamEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyConstructParamEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstructParamEnum(i);
        if (retval.empty()) {
            retval = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstructParamEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstructParamEnum() {
        return stringify::ConstructParamEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 93
namespace stringify {
    const char* BuildAccessEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_ACCESS_FUNCTIONS";
            case 1L: return "BUILD_ACCESS_FUNCTIONS";
            case 2L: return "BUILD_FLAG_ACCESS_FUNCTIONS";
            case 3L: return "BUILD_LIST_ACCESS_FUNCTIONS";
            default: return "";
        }
    }

    std::string BuildAccessEnum(int64_t i, const std::string &strip) {
        std::string s = BuildAccessEnum(i);
        if (s.empty())
            s = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BuildAccessEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyBuildAccessEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BuildAccessEnum(i);
        if (retval.empty()) {
            retval = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BuildAccessEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBuildAccessEnum() {
        return stringify::BuildAccessEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 101
namespace stringify {
    const char* CopyConfigEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_COPY_DATA";
            case 1L: return "COPY_DATA";
            case 2L: return "CLONE_PTR";
            case 3L: return "CLONE_TREE";
            default: return "";
        }
    }

    std::string CopyConfigEnum(int64_t i, const std::string &strip) {
        std::string s = CopyConfigEnum(i);
        if (s.empty())
            s = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CopyConfigEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCopyConfigEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CopyConfigEnum(i);
        if (retval.empty()) {
            retval = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CopyConfigEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCopyConfigEnum() {
        return stringify::CopyConfigEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 122
namespace stringify {
    const char* TraversalEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_TRAVERSAL";
            case 1L: return "NO_TRAVERSAL";
            default: return "";
        }
    }

    std::string TraversalEnum(int64_t i, const std::string &strip) {
        std::string s = TraversalEnum(i);
        if (s.empty())
            s = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyTraversalEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TraversalEnum(i);
        if (retval.empty()) {
            retval = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TraversalEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTraversalEnum() {
        return stringify::TraversalEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 127
namespace stringify {
    const char* DeleteEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_DELETE";
            case 1L: return "NO_DELETE";
            default: return "";
        }
    }

    std::string DeleteEnum(int64_t i, const std::string &strip) {
        std::string s = DeleteEnum(i);
        if (s.empty())
            s = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DeleteEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeleteEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DeleteEnum(i);
        if (retval.empty()) {
            retval = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DeleteEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeleteEnum() {
        return stringify::DeleteEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 100
namespace stringify { namespace AstNodeClass {
    const char* locationInTree(int64_t i) {
        switch (i) {
            case 0L: return "LOCAL_LIST";
            case 1L: return "SUBTREE_LIST";
            default: return "";
        }
    }

    std::string locationInTree(int64_t i, const std::string &strip) {
        std::string s = locationInTree(i);
        if (s.empty())
            s = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& locationInTree() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_locationInTree(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::locationInTree(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::locationInTree::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_locationInTree() {
        return stringify::AstNodeClass::locationInTree();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 106
namespace stringify { namespace AstNodeClass {
    const char* includeExcludeMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INCLUDE_LIST";
            case 1L: return "EXCLUDE_LIST";
            default: return "";
        }
    }

    std::string includeExcludeMechanism(int64_t i, const std::string &strip) {
        std::string s = includeExcludeMechanism(i);
        if (s.empty())
            s = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& includeExcludeMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_includeExcludeMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::includeExcludeMechanism(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::includeExcludeMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_includeExcludeMechanism() {
        return stringify::AstNodeClass::includeExcludeMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 309
namespace stringify { namespace AstNodeClass {
    const char* TypeEvaluation(int64_t i) {
        switch (i) {
            case 0L: return "CHAR_POINTER";
            case 1L: return "CONST_CHAR_POINTER";
            case 2L: return "ATTACHEDPREPROCESSINGINFOTYPE";
            case 3L: return "ROSE_HASH_MULTIMAP";
            case 4L: return "ROSE_GRAPH_HASH_MULTIMAP";
            case 5L: return "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP";
            case 6L: return "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP";
            case 7L: return "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP";
            case 8L: return "ROSE_GRAPH_INTEGER_NODE_HASH_MAP";
            case 9L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP";
            case 10L: return "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP";
            case 11L: return "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP";
            case 12L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP";
            case 13L: return "SGCLASS_POINTER";
            case 14L: return "ROSEATTRUBUTESLISTCONTAINER";
            case 15L: return "SGCLASS_POINTER_LIST";
            case 16L: return "SGCLASS_POINTER_VECTOR";
            case 17L: return "SGCLASS_POINTER_VECTOR_NAMED_LIST";
            case 18L: return "STL_CONTAINER";
            case 19L: return "STL_SET";
            case 20L: return "STL_MULTIMAP";
            case 21L: return "STL_MAP";
            case 22L: return "STRING";
            case 23L: return "SGNAME";
            case 24L: return "BIT_VECTOR";
            case 25L: return "MODIFIERCLASS";
            case 26L: return "MODIFIERCLASS_WITHOUTEASYSTORAGE";
            case 27L: return "ASTATTRIBUTEMECHANISM";
            case 28L: return "TO_HANDLE";
            case 29L: return "OSTREAM";
            case 30L: return "ENUM_TYPE";
            case 31L: return "BASIC_DATA_TYPE";
            case 32L: return "SKIP_TYPE";
            case 33L: return "SGCLASS_POINTER_LIST_POINTER";
            default: return "";
        }
    }

    std::string TypeEvaluation(int64_t i, const std::string &strip) {
        std::string s = TypeEvaluation(i);
        if (s.empty())
            s = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeEvaluation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClassTypeEvaluation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::TypeEvaluation(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::TypeEvaluation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClassTypeEvaluation() {
        return stringify::AstNodeClass::TypeEvaluation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 2643
namespace stringify { namespace SgAsmRiscOperation {
    const char* RiscOperator(int64_t i) {
        switch (i) {
            case 0L: return "OP_NONE";
            case 1L: return "OP_bottom";
            case 2L: return "OP_undefined";
            case 3L: return "OP_unspecified";
            case 4L: return "OP_filterCallTarget";
            case 5L: return "OP_filterReturnTarget";
            case 6L: return "OP_filterIndirectJumpTarget";
            case 7L: return "OP_hlt";
            case 8L: return "OP_cpuid";
            case 9L: return "OP_rdtsc";
            case 10L: return "OP_and_";
            case 11L: return "OP_or_";
            case 12L: return "OP_xor_";
            case 13L: return "OP_invert";
            case 14L: return "OP_extract";
            case 15L: return "OP_concat";
            case 16L: return "OP_leastSignificantSetBit";
            case 17L: return "OP_mostSignificantSetBit";
            case 18L: return "OP_rotateLeft";
            case 19L: return "OP_rotateRight";
            case 20L: return "OP_shiftLeft";
            case 21L: return "OP_shiftRight";
            case 22L: return "OP_shiftRightArithmetic";
            case 23L: return "OP_equalToZero";
            case 24L: return "OP_ite";
            case 25L: return "OP_isEqual";
            case 26L: return "OP_isNotEqual";
            case 27L: return "OP_isUnsignedLessThan";
            case 28L: return "OP_isUnsignedLessThanOrEqual";
            case 29L: return "OP_isUnsignedGreaterThan";
            case 30L: return "OP_isUnsignedGreaterThanOrEqual";
            case 31L: return "OP_isSignedLessThan";
            case 32L: return "OP_isSignedLessThanOrEqual";
            case 33L: return "OP_isSignedGreaterThan";
            case 34L: return "OP_isSignedGreaterThanOrEqual";
            case 35L: return "OP_unsignedExtend";
            case 36L: return "OP_signExtend";
            case 37L: return "OP_add";
            case 38L: return "OP_addCarries";
            case 39L: return "OP_subtract";
            case 40L: return "OP_negate";
            case 41L: return "OP_signedDivide";
            case 42L: return "OP_signedModulo";
            case 43L: return "OP_signedMultiply";
            case 44L: return "OP_unsignedDivide";
            case 45L: return "OP_unsignedModulo";
            case 46L: return "OP_unsignedMultiply";
            case 47L: return "OP_interrupt";
            case 48L: return "OP_readRegister";
            case 49L: return "OP_peekRegister";
            case 50L: return "OP_writeRegister";
            case 51L: return "OP_readMemory";
            case 52L: return "OP_peekMemory";
            case 53L: return "OP_writeMemory";
            case 54L: return "OP_N_OPERATORS";
            default: return "";
        }
    }

    std::string RiscOperator(int64_t i, const std::string &strip) {
        std::string s = RiscOperator(i);
        if (s.empty())
            s = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RiscOperator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmRiscOperationRiscOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmRiscOperation::RiscOperator(i);
        if (retval.empty()) {
            retval = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmRiscOperation::RiscOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmRiscOperationRiscOperator() {
        return stringify::SgAsmRiscOperation::RiscOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 3459
namespace stringify { namespace SgAsmFunction {
    const char* MayReturn(int64_t i) {
        switch (i) {
            case 0L: return "RET_UNKNOWN";
            case 1L: return "RET_NEVER";
            case 2L: return "RET_SOMETIMES";
            case 3L: return "RET_ALWAYS";
            default: return "";
        }
    }

    std::string MayReturn(int64_t i, const std::string &strip) {
        std::string s = MayReturn(i);
        if (s.empty())
            s = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayReturn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionMayReturn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::MayReturn(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::MayReturn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionMayReturn() {
        return stringify::SgAsmFunction::MayReturn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 3469
namespace stringify { namespace SgAsmFunction {
    const char* FunctionReason(int64_t i) {
        switch (i) {
            case 0L: return "FUNC_NONE";
            case 1L: return "FUNC_INTERPADFUNC";
            case 2L: return "FUNC_PESCRAMBLER_DISPATCH";
            case 3L: return "FUNC_CONFIGURED";
            case 4L: return "FUNC_CMDLINE";
            case 5L: return "FUNC_SCAN_RO_DATA";
            case 6L: return "FUNC_INSN_RO_DATA";
            case 255L: return "FUNC_MISCMASK";
            case 16384L: return "FUNC_THUNK_TARGET";
            case 32768L: return "FUNC_EXCEPTION_HANDLER";
            case 65536L: return "FUNC_ENTRY_POINT";
            case 131072L: return "FUNC_CALL_TARGET";
            case 262144L: return "FUNC_CALL_INSN";
            case 524288L: return "FUNC_EH_FRAME";
            case 1048576L: return "FUNC_SYMBOL";
            case 2097152L: return "FUNC_PATTERN";
            case 4194304L: return "FUNC_GRAPH";
            case 8388608L: return "FUNC_USERDEF";
            case 16777216L: return "FUNC_PADDING";
            case 33554432L: return "FUNC_DISCONT";
            case 67108864L: return "FUNC_INSNHEAD";
            case 134217728L: return "FUNC_IMPORT";
            case 268435456L: return "FUNC_LEFTOVERS";
            case 536870912L: return "FUNC_INTRABLOCK";
            case 1073741824L: return "FUNC_THUNK";
            case 2147483648L: return "FUNC_EXPORT";
            case 4026499327L: return "FUNC_DEFAULT";
            default: return "";
        }
    }

    std::string FunctionReason(int64_t i, const std::string &strip) {
        std::string s = FunctionReason(i);
        if (s.empty())
            s = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L,
            16384L,
            32768L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4026499327L
        };
        static const std::vector<int64_t> retval(values, values + 27);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionFunctionReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::FunctionReason(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::FunctionReason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionFunctionReason() {
        return stringify::SgAsmFunction::FunctionReason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 3625
namespace stringify { namespace SgAsmFunction {
    const char* function_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_standard";
            case 2L: return "e_library";
            case 3L: return "e_imported";
            case 4L: return "e_thunk";
            case 5L: return "e_last";
            default: return "";
        }
    }

    std::string function_kind_enum(int64_t i, const std::string &strip) {
        std::string s = function_kind_enum(i);
        if (s.empty())
            s = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunction_function_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::function_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::function_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunction_function_kind_enum() {
        return stringify::SgAsmFunction::function_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 3857
namespace stringify { namespace SgAsmBlock {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "BLK_NONE";
            case 1L: return "BLK_FINDDATA";
            case 2L: return "BLK_POSTFUNC";
            case 255L: return "BLK_MISCMASK";
            case 65536L: return "BLK_ENTRY_POINT";
            case 131072L: return "BLK_PADDING";
            case 524288L: return "BLK_FRAGMENT";
            case 1048576L: return "BLK_CFGHEAD";
            case 2097152L: return "BLK_USERDEF";
            case 4194304L: return "BLK_LEFTOVERS";
            case 8388608L: return "BLK_JUMPTABLE";
            case 16777216L: return "BLK_GRAPH1";
            case 33554432L: return "BLK_GRAPH2";
            case 67108864L: return "BLK_GRAPH3";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            255L,
            65536L,
            131072L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmBlockReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmBlock::Reason(i);
        if (retval.empty()) {
            retval = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmBlock::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmBlockReason() {
        return stringify::SgAsmBlock::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 4708
namespace stringify { namespace SgAsmElfFileHeader {
    const char* ObjectType(int64_t i) {
        switch (i) {
            case 0L: return "ET_NONE";
            case 1L: return "ET_REL";
            case 2L: return "ET_EXEC";
            case 3L: return "ET_DYN";
            case 4L: return "ET_CORE";
            case 65024L: return "ET_LOOS";
            case 65279L: return "ET_HIOS";
            case 65280L: return "ET_LOPROC";
            case 65535L: return "ET_HIPROC";
            default: return "";
        }
    }

    std::string ObjectType(int64_t i, const std::string &strip) {
        std::string s = ObjectType(i);
        if (s.empty())
            s = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ObjectType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            65024L,
            65279L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfFileHeaderObjectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfFileHeader::ObjectType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfFileHeader::ObjectType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfFileHeaderObjectType() {
        return stringify::SgAsmElfFileHeader::ObjectType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5128
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionType(int64_t i) {
        switch (i) {
            case 0L: return "SHT_NULL";
            case 1L: return "SHT_PROGBITS";
            case 2L: return "SHT_SYMTAB";
            case 3L: return "SHT_STRTAB";
            case 4L: return "SHT_RELA";
            case 5L: return "SHT_HASH";
            case 6L: return "SHT_DYNAMIC";
            case 7L: return "SHT_NOTE";
            case 8L: return "SHT_NOBITS";
            case 9L: return "SHT_REL";
            case 10L: return "SHT_SHLIB";
            case 11L: return "SHT_DYNSYM";
            case 1610612736L: return "SHT_LOOS";
            case 1879048189L: return "SHT_GNU_verdef";
            case 1879048190L: return "SHT_GNU_verneed";
            case 1879048191L: return "SHT_GNU_versym";
            case 1879048192L: return "SHT_LOPROC";
            case 2147483647L: return "SHT_HIPROC";
            case 2147483648L: return "SHT_LOUSER";
            case 4294967295L: return "SHT_HIUSER";
            default: return "";
        }
    }

    std::string SectionType(int64_t i, const std::string &strip) {
        std::string s = SectionType(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            1610612736L,
            1879048189L,
            1879048190L,
            1879048191L,
            1879048192L,
            2147483647L,
            2147483648L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionType() {
        return stringify::SgAsmElfSectionTableEntry::SectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5155
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SHF_NULL";
            case 1L: return "SHF_WRITE";
            case 2L: return "SHF_ALLOC";
            case 4L: return "SHF_EXECINSTR";
            case 16L: return "SHF_MERGE";
            case 32L: return "SHF_STRINGS";
            case 64L: return "SHF_INFO_LINK";
            case 128L: return "SHF_LINK_ORDER";
            case 256L: return "SHF_OS_NONCONFORMING";
            case 512L: return "SHF_GROUP";
            case 1024L: return "SHF_TLS";
            case 267386880L: return "SHF_MASKOS";
            case 4026531840L: return "SHF_MASKPROC";
            default: return "";
        }
    }

    std::string SectionFlags(int64_t i, const std::string &strip) {
        std::string s = SectionFlags(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionFlags() {
        return stringify::SgAsmElfSectionTableEntry::SectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5557
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentType(int64_t i) {
        switch (i) {
            case 0L: return "PT_NULL";
            case 1L: return "PT_LOAD";
            case 2L: return "PT_DYNAMIC";
            case 3L: return "PT_INTERP";
            case 4L: return "PT_NOTE";
            case 5L: return "PT_SHLIB";
            case 6L: return "PT_PHDR";
            case 7L: return "PT_TLS";
            case 1610612736L: return "PT_LOOS";
            case 1685382480L: return "PT_GNU_EH_FRAME";
            case 1685382481L: return "PT_GNU_STACK";
            case 1685382482L: return "PT_GNU_RELRO";
            case 1694766464L: return "PT_PAX_FLAGS";
            case 1879048186L: return "PT_SUNWBSS";
            case 1879048187L: return "PT_SUNWSTACK";
            case 1879048191L: return "PT_HIOS";
            case 1879048192L: return "PT_LOPROC";
            case 2147483647L: return "PT_HIPROC";
            default: return "";
        }
    }

    std::string SegmentType(int64_t i, const std::string &strip) {
        std::string s = SegmentType(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1610612736L,
            1685382480L,
            1685382481L,
            1685382482L,
            1694766464L,
            1879048186L,
            1879048187L,
            1879048191L,
            1879048192L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentType() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5585
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentFlags(int64_t i) {
        switch (i) {
            case 0L: return "PF_NONE";
            case 1L: return "PF_XPERM";
            case 2L: return "PF_WPERM";
            case 4L: return "PF_RPERM";
            case 1048568L: return "PF_RESERVED";
            case 267386880L: return "PF_OS_MASK";
            case 4026531840L: return "PF_PROC_MASK";
            default: return "";
        }
    }

    std::string SegmentFlags(int64_t i, const std::string &strip) {
        std::string s = SegmentFlags(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            1048568L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentFlags() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5931
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymBinding(int64_t i) {
        switch (i) {
            case 0L: return "STB_LOCAL";
            case 1L: return "STB_GLOBAL";
            case 2L: return "STB_WEAK";
            default: return "";
        }
    }

    std::string ElfSymBinding(int64_t i, const std::string &strip) {
        std::string s = ElfSymBinding(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymBinding() {
        return stringify::SgAsmElfSymbol::ElfSymBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5937
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymType(int64_t i) {
        switch (i) {
            case 0L: return "STT_NOTYPE";
            case 1L: return "STT_OBJECT";
            case 2L: return "STT_FUNC";
            case 3L: return "STT_SECTION";
            case 4L: return "STT_FILE";
            case 5L: return "STT_COMMON";
            case 6L: return "STT_TLS";
            case 10L: return "STT_IFUNC";
            default: return "";
        }
    }

    std::string ElfSymType(int64_t i, const std::string &strip) {
        std::string s = ElfSymType(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymType() {
        return stringify::SgAsmElfSymbol::ElfSymType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 7339
namespace stringify { namespace SgAsmElfRelocEntry {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "R_386_NONE";
            case 1L: return "R_386_32";
            case 2L: return "R_386_PC32";
            case 3L: return "R_386_GOT32";
            case 4L: return "R_386_PLT32";
            case 5L: return "R_386_COPY";
            case 6L: return "R_386_GLOB_DAT";
            case 7L: return "R_386_JMP_SLOT";
            case 8L: return "R_386_RELATIVE";
            case 9L: return "R_386_GOTOFF";
            case 10L: return "R_386_GOTPC";
            case 11L: return "R_386_32PLT";
            case 14L: return "R_386_TLS_TPOFF";
            case 15L: return "R_386_TLS_IE";
            case 16L: return "R_386_TLS_GOTIE";
            case 17L: return "R_386_TLS_LE";
            case 18L: return "R_386_TLS_GD";
            case 19L: return "R_386_TLS_LDM";
            case 20L: return "R_386_16";
            case 21L: return "R_386_PC16";
            case 22L: return "R_386_8";
            case 23L: return "R_386_PC8";
            case 24L: return "R_386_TLS_GD_32";
            case 25L: return "R_386_TLS_GD_PUSH";
            case 26L: return "R_386_TLS_GD_CALL";
            case 27L: return "R_386_TLS_GD_POP";
            case 28L: return "R_386_TLS_LDM_32";
            case 29L: return "R_386_TLS_LDM_PUSH";
            case 30L: return "R_386_TLS_LDM_CALL";
            case 31L: return "R_386_TLS_LDM_POP";
            case 32L: return "R_386_TLS_LDO_32";
            case 33L: return "R_386_TLS_IE_32";
            case 34L: return "R_386_TLS_LE_32";
            case 35L: return "R_386_TLS_DTPMOD32";
            case 36L: return "R_386_TLS_DTPOFF32";
            case 37L: return "R_386_TLS_TPOFF32";
            case 100L: return "R_X86_64_NONE";
            case 101L: return "R_X86_64_64";
            case 102L: return "R_X86_64_PC32";
            case 103L: return "R_X86_64_GOT32";
            case 104L: return "R_X86_64_PLT32";
            case 105L: return "R_X86_64_COPY";
            case 106L: return "R_X86_64_GLOB_DAT";
            case 107L: return "R_X86_64_JUMP_SLOT";
            case 108L: return "R_X86_64_RELATIVE";
            case 109L: return "R_X86_64_GOTPCREL";
            case 110L: return "R_X86_64_32";
            case 111L: return "R_X86_64_32S";
            case 112L: return "R_X86_64_16";
            case 113L: return "R_X86_64_PC16";
            case 114L: return "R_X86_64_8";
            case 115L: return "R_X86_64_PC8";
            case 116L: return "R_X86_64_DTPMOD64";
            case 117L: return "R_X86_64_DTPOFF64";
            case 118L: return "R_X86_64_TPOFF64";
            case 119L: return "R_X86_64_TLSGD";
            case 120L: return "R_X86_64_TLSLD";
            case 121L: return "R_X86_64_DTPOFF32";
            case 122L: return "R_X86_64_GOTTPOFF";
            case 123L: return "R_X86_64_TPOFF32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfRelocEntryRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfRelocEntry::RelocType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfRelocEntry::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfRelocEntryRelocType() {
        return stringify::SgAsmElfRelocEntry::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 7696
namespace stringify { namespace SgAsmElfDynamicEntry {
    const char* EntryType(int64_t i) {
        switch (i) {
            case 0L: return "DT_NULL";
            case 1L: return "DT_NEEDED";
            case 2L: return "DT_PLTRELSZ";
            case 3L: return "DT_PLTGOT";
            case 4L: return "DT_HASH";
            case 5L: return "DT_STRTAB";
            case 6L: return "DT_SYMTAB";
            case 7L: return "DT_RELA";
            case 8L: return "DT_RELASZ";
            case 9L: return "DT_RELAENT";
            case 10L: return "DT_STRSZ";
            case 11L: return "DT_SYMENT";
            case 12L: return "DT_INIT";
            case 13L: return "DT_FINI";
            case 14L: return "DT_SONAME";
            case 15L: return "DT_RPATH";
            case 16L: return "DT_SYMBOLIC";
            case 17L: return "DT_REL";
            case 18L: return "DT_RELSZ";
            case 19L: return "DT_RELENT";
            case 20L: return "DT_PLTREL";
            case 21L: return "DT_DEBUG";
            case 22L: return "DT_TEXTREL";
            case 23L: return "DT_JMPREL";
            case 24L: return "DT_BIND_NOW";
            case 25L: return "DT_INIT_ARRAY";
            case 26L: return "DT_FINI_ARRAY";
            case 27L: return "DT_INIT_ARRAYSZ";
            case 28L: return "DT_FINI_ARRAYSZ";
            case 29L: return "DT_RUNPATH";
            case 30L: return "DT_FLAGS";
            case 32L: return "DT_PREINIT_ARRAY";
            case 33L: return "DT_PREINIT_ARRAYSZ";
            case 34L: return "DT_NUM";
            case 1879047669L: return "DT_GNU_PRELINKED";
            case 1879047670L: return "DT_GNU_CONFLICTSZ";
            case 1879047671L: return "DT_GNU_LIBLISTSZ";
            case 1879047672L: return "DT_CHECKSUM";
            case 1879047673L: return "DT_PLTPADSZ";
            case 1879047674L: return "DT_MOVEENT";
            case 1879047675L: return "DT_MOVESZ";
            case 1879047676L: return "DT_FEATURE_1";
            case 1879047677L: return "DT_POSFLAG_1";
            case 1879047678L: return "DT_SYMINSZ";
            case 1879047679L: return "DT_SYMINENT";
            case 1879047925L: return "DT_GNU_HASH";
            case 1879047926L: return "DT_TLSDESC_PLT";
            case 1879047927L: return "DT_TLSDESC_GOT";
            case 1879047928L: return "DT_GNU_CONFLICT";
            case 1879047929L: return "DT_GNU_LIBLIST";
            case 1879047930L: return "DT_CONFIG";
            case 1879047931L: return "DT_DEPAUDIT";
            case 1879047932L: return "DT_AUDIT";
            case 1879047933L: return "DT_PLTPAD";
            case 1879047934L: return "DT_MOVETAB";
            case 1879047935L: return "DT_SYMINFO";
            case 1879048176L: return "DT_VERSYM";
            case 1879048185L: return "DT_RELACOUNT";
            case 1879048186L: return "DT_RELCOUNT";
            case 1879048187L: return "DT_FLAGS_1";
            case 1879048188L: return "DT_VERDEF";
            case 1879048189L: return "DT_VERDEFNUM";
            case 1879048190L: return "DT_VERNEED";
            case 1879048191L: return "DT_VERNEEDNUM";
            case 2147483645L: return "DT_AUXILIARY";
            case 2147483647L: return "DT_FILTER";
            default: return "";
        }
    }

    std::string EntryType(int64_t i, const std::string &strip) {
        std::string s = EntryType(i);
        if (s.empty())
            s = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EntryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            32L,
            33L,
            34L,
            1879047669L,
            1879047670L,
            1879047671L,
            1879047672L,
            1879047673L,
            1879047674L,
            1879047675L,
            1879047676L,
            1879047677L,
            1879047678L,
            1879047679L,
            1879047925L,
            1879047926L,
            1879047927L,
            1879047928L,
            1879047929L,
            1879047930L,
            1879047931L,
            1879047932L,
            1879047933L,
            1879047934L,
            1879047935L,
            1879048176L,
            1879048185L,
            1879048186L,
            1879048187L,
            1879048188L,
            1879048189L,
            1879048190L,
            1879048191L,
            2147483645L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfDynamicEntryEntryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfDynamicEntry::EntryType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfDynamicEntryEntryType() {
        return stringify::SgAsmElfDynamicEntry::EntryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 10195
namespace stringify { namespace SgAsmPEFileHeader {
    const char* HeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_PROGRAM";
            case 2L: return "HF_EXECUTABLE";
            case 512L: return "HF_FIXED";
            case 8192L: return "HF_LIBRARY";
            case 56829L: return "HF_RESERVED_MASK";
            default: return "";
        }
    }

    std::string HeaderFlags(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags() {
        static const int64_t values[] = {
            0L,
            2L,
            512L,
            8192L,
            56829L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::HeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderHeaderFlags() {
        return stringify::SgAsmPEFileHeader::HeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 10204
namespace stringify { namespace SgAsmPEFileHeader {
    const char* Subsystem(int64_t i) {
        switch (i) {
            case 0L: return "HF_SPEC_UNKNOWN";
            case 1L: return "HF_NATIVE";
            case 2L: return "HF_WINGUI";
            case 3L: return "HF_WINCHAR";
            case 5L: return "HF_OS2CHAR";
            case 7L: return "HF_POSIX";
            default: return "";
        }
    }

    std::string Subsystem(int64_t i, const std::string &strip) {
        std::string s = Subsystem(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subsystem() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderSubsystem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::Subsystem(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::Subsystem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderSubsystem() {
        return stringify::SgAsmPEFileHeader::Subsystem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 10214
namespace stringify { namespace SgAsmPEFileHeader {
    const char* DLLFlags(int64_t i) {
        switch (i) {
            case 1L: return "DLL_PROC_INIT";
            case 2L: return "DLL_PROC_TERM";
            case 4L: return "DLL_THRD_INIT";
            case 8L: return "DLL_THRD_TERM";
            case 65520L: return "DLL_RESERVED_MASK";
            default: return "";
        }
    }

    std::string DLLFlags(int64_t i, const std::string &strip) {
        std::string s = DLLFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DLLFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            65520L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderDLLFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::DLLFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderDLLFlags() {
        return stringify::SgAsmPEFileHeader::DLLFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 10223
namespace stringify { namespace SgAsmPEFileHeader {
    const char* PairPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PAIR_EXPORTS";
            case 1L: return "PAIR_IMPORTS";
            case 2L: return "PAIR_RESOURCES";
            case 3L: return "PAIR_EXCEPTIONS";
            case 4L: return "PAIR_CERTIFICATES";
            case 5L: return "PAIR_BASERELOCS";
            case 6L: return "PAIR_DEBUG";
            case 7L: return "PAIR_ARCHITECTURE";
            case 8L: return "PAIR_GLOBALPTR";
            case 9L: return "PAIR_TLS";
            case 10L: return "PAIR_LOADCONFIG";
            case 11L: return "PAIR_BOUNDIMPORT";
            case 12L: return "PAIR_IAT";
            case 13L: return "PAIR_DELAYIMPORT";
            case 14L: return "PAIR_CLRRUNTIME";
            case 15L: return "PAIR_RESERVED15";
            default: return "";
        }
    }

    std::string PairPurpose(int64_t i, const std::string &strip) {
        std::string s = PairPurpose(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PairPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderPairPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::PairPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderPairPurpose() {
        return stringify::SgAsmPEFileHeader::PairPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 12004
namespace stringify { namespace SgAsmPESectionTableEntry {
    const char* PESectionFlags(int64_t i) {
        switch (i) {
            case 32L: return "OF_CODE";
            case 64L: return "OF_IDATA";
            case 128L: return "OF_UDATA";
            case 512L: return "OF_INFO";
            case 2048L: return "OF_REMOVE";
            case 4096L: return "OF_COMDAT";
            case 16384L: return "OF_NO_DEFER_SPEC_EXC";
            case 32768L: return "OF_GPREL";
            case 1048576L: return "OF_ALIGN_1";
            case 2097152L: return "OF_ALIGN_2";
            case 3145728L: return "OF_ALIGN_4";
            case 4194304L: return "OF_ALIGN_8";
            case 5242880L: return "OF_ALIGN_16";
            case 6291456L: return "OF_ALIGN_32";
            case 7340032L: return "OF_ALIGN_64";
            case 8388608L: return "OF_ALIGN_128";
            case 9437184L: return "OF_ALIGN_256";
            case 10485760L: return "OF_ALIGN_512";
            case 11534336L: return "OF_ALIGN_1k";
            case 12582912L: return "OF_ALIGN_2k";
            case 13631488L: return "OF_ALIGN_4k";
            case 14680064L: return "OF_ALIGN_8k";
            case 15728640L: return "OF_ALIGN_MASK";
            case 16777216L: return "OF_NRELOC_OVFL";
            case 33554432L: return "OF_DISCARDABLE";
            case 67108864L: return "OF_NO_CACHE";
            case 134217728L: return "OF_NO_PAGING";
            case 268435456L: return "OF_SHARED";
            case 536870912L: return "OF_EXECUTABLE";
            case 1073741824L: return "OF_READABLE";
            case 2147483648L: return "OF_WRITABLE";
            default: return "";
        }
    }

    std::string PESectionFlags(int64_t i, const std::string &strip) {
        std::string s = PESectionFlags(i);
        if (s.empty())
            s = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PESectionFlags() {
        static const int64_t values[] = {
            32L,
            64L,
            128L,
            512L,
            2048L,
            4096L,
            16384L,
            32768L,
            1048576L,
            2097152L,
            3145728L,
            4194304L,
            5242880L,
            6291456L,
            7340032L,
            8388608L,
            9437184L,
            10485760L,
            11534336L,
            12582912L,
            13631488L,
            14680064L,
            15728640L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPESectionTableEntryPESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPESectionTableEntry::PESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPESectionTableEntryPESectionFlags() {
        return stringify::SgAsmPESectionTableEntry::PESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 14032
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolDefState(int64_t i) {
        switch (i) {
            case 0L: return "SYM_UNDEFINED";
            case 1L: return "SYM_TENTATIVE";
            case 2L: return "SYM_DEFINED";
            default: return "";
        }
    }

    std::string SymbolDefState(int64_t i, const std::string &strip) {
        std::string s = SymbolDefState(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolDefState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolDefState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolDefState(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolDefState() {
        return stringify::SgAsmGenericSymbol::SymbolDefState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 14039
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolType(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_TYPE";
            case 1L: return "SYM_DATA";
            case 2L: return "SYM_FUNC";
            case 3L: return "SYM_SECTION";
            case 4L: return "SYM_FILE";
            case 5L: return "SYM_ARRAY";
            case 6L: return "SYM_TLS";
            case 7L: return "SYM_REGISTER";
            case 8L: return "SYM_COMMON";
            case 9L: return "SYM_IFUNC";
            default: return "";
        }
    }

    std::string SymbolType(int64_t i, const std::string &strip) {
        std::string s = SymbolType(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolType(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolType() {
        return stringify::SgAsmGenericSymbol::SymbolType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 14053
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolBinding(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_BINDING";
            case 1L: return "SYM_LOCAL";
            case 2L: return "SYM_GLOBAL";
            case 3L: return "SYM_WEAK";
            default: return "";
        }
    }

    std::string SymbolBinding(int64_t i, const std::string &strip) {
        std::string s = SymbolBinding(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolBinding() {
        return stringify::SgAsmGenericSymbol::SymbolBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 14586
namespace stringify { namespace SgAsmGenericSection {
    const char* SectionPurpose(int64_t i) {
        switch (i) {
            case 0L: return "SP_UNSPECIFIED";
            case 1L: return "SP_PROGRAM";
            case 2L: return "SP_HEADER";
            case 3L: return "SP_SYMTAB";
            case 4L: return "SP_OTHER";
            default: return "";
        }
    }

    std::string SectionPurpose(int64_t i, const std::string &strip) {
        std::string s = SectionPurpose(i);
        if (s.empty())
            s = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSectionSectionPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSection::SectionPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSection::SectionPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSectionSectionPurpose() {
        return stringify::SgAsmGenericSection::SectionPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15423
namespace stringify { namespace SgAsmGenericFile {
    const char* AddressSpace(int64_t i) {
        switch (i) {
            case 1L: return "ADDRSP_MEMORY";
            case 2L: return "ADDRSP_FILE";
            case 3L: return "ADDRSP_ALL";
            default: return "";
        }
    }

    std::string AddressSpace(int64_t i, const std::string &strip) {
        std::string s = AddressSpace(i);
        if (s.empty())
            s = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AddressSpace() {
        static const int64_t values[] = {
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileAddressSpace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::AddressSpace(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::AddressSpace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileAddressSpace() {
        return stringify::SgAsmGenericFile::AddressSpace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15430
namespace stringify { namespace SgAsmGenericFile {
    const char* Elasticity(int64_t i) {
        switch (i) {
            case 0L: return "ELASTIC_NONE";
            case 1L: return "ELASTIC_UNREF";
            case 2L: return "ELASTIC_HOLE";
            default: return "";
        }
    }

    std::string Elasticity(int64_t i, const std::string &strip) {
        std::string s = Elasticity(i);
        if (s.empty())
            s = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Elasticity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileElasticity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::Elasticity(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::Elasticity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileElasticity() {
        return stringify::SgAsmGenericFile::Elasticity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15830
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecFamily(int64_t i) {
        switch (i) {
            case 0L: return "FAMILY_UNSPECIFIED";
            case 1L: return "FAMILY_DOS";
            case 2L: return "FAMILY_ELF";
            case 3L: return "FAMILY_LE";
            case 4L: return "FAMILY_LX";
            case 5L: return "FAMILY_NE";
            case 6L: return "FAMILY_PE";
            default: return "";
        }
    }

    std::string ExecFamily(int64_t i, const std::string &strip) {
        std::string s = ExecFamily(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecFamily() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecFamily(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecFamily() {
        return stringify::SgAsmExecutableFileFormat::ExecFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15841
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecABI(int64_t i) {
        switch (i) {
            case 0L: return "ABI_UNSPECIFIED";
            case 1L: return "ABI_OTHER";
            case 2L: return "ABI_86OPEN";
            case 3L: return "ABI_AIX";
            case 4L: return "ABI_ARM";
            case 5L: return "ABI_FREEBSD";
            case 6L: return "ABI_HPUX";
            case 7L: return "ABI_IRIX";
            case 8L: return "ABI_HURD";
            case 9L: return "ABI_LINUX";
            case 10L: return "ABI_MODESTO";
            case 11L: return "ABI_MONTEREY";
            case 12L: return "ABI_MSDOS";
            case 13L: return "ABI_NT";
            case 14L: return "ABI_NETBSD";
            case 15L: return "ABI_OS2";
            case 16L: return "ABI_SOLARIS";
            case 17L: return "ABI_SYSV";
            case 18L: return "ABI_TRU64";
            case 19L: return "ABI_WIN386";
            default: return "";
        }
    }

    std::string ExecABI(int64_t i, const std::string &strip) {
        std::string s = ExecABI(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecABI() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecABI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecABI(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecABI() {
        return stringify::SgAsmExecutableFileFormat::ExecABI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15865
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* InsSetArchitecture(int64_t i) {
        switch (i) {
            case 0L: return "ISA_UNSPECIFIED";
            case 256L: return "ISA_IA32_Family";
            case 257L: return "ISA_IA32_286";
            case 258L: return "ISA_IA32_386";
            case 259L: return "ISA_IA32_486";
            case 260L: return "ISA_IA32_Pentium";
            case 261L: return "ISA_IA32_Cyrix6x86";
            case 262L: return "ISA_IA32_AMDK5";
            case 263L: return "ISA_IA32_PentiumPro";
            case 264L: return "ISA_IA32_PentiumII";
            case 265L: return "ISA_IA32_Athlon";
            case 266L: return "ISA_IA32_Pentium4";
            case 267L: return "ISA_IA32_PentiumM";
            case 512L: return "ISA_X8664_Family";
            case 513L: return "ISA_X8664_Athlon64";
            case 514L: return "ISA_X8664_Prescott";
            case 515L: return "ISA_X8664_IntelCore";
            case 516L: return "ISA_X8664_AMDPhenom";
            case 768L: return "ISA_SPARC_Family";
            case 769L: return "ISA_SPARC_V7";
            case 770L: return "ISA_SPARC_V8";
            case 771L: return "ISA_SPARC_V8E";
            case 772L: return "ISA_SPARC_V9";
            case 773L: return "ISA_SPARC_V9JPS1";
            case 774L: return "ISA_SPARC_V9UA";
            case 775L: return "ISA_SPARC_V9JPS2";
            case 1024L: return "ISA_M68K_Family";
            case 1025L: return "ISA_M68K_68000";
            case 1026L: return "ISA_M68K_68EC000";
            case 1027L: return "ISA_M68K_68HC000";
            case 1028L: return "ISA_M68K_68008";
            case 1029L: return "ISA_M68K_68010";
            case 1030L: return "ISA_M68K_68012";
            case 1031L: return "ISA_M68K_68020";
            case 1032L: return "ISA_M68K_68EC020";
            case 1033L: return "ISA_M68K_68030";
            case 1034L: return "ISA_M68K_68EC030";
            case 1035L: return "ISA_M68K_68040";
            case 1036L: return "ISA_M68K_68EC040";
            case 1037L: return "ISA_M68K_68LC040";
            case 1038L: return "ISA_M68K_68060";
            case 1039L: return "ISA_M68K_ColdFire";
            case 1040L: return "ISA_M68K_DragonBall";
            case 1280L: return "ISA_M88K_Family";
            case 1281L: return "ISA_M88K_88100";
            case 1282L: return "ISA_M88K_88110";
            case 1283L: return "ISA_M88K_88110MP";
            case 1284L: return "ISA_M88K_88120";
            case 1536L: return "ISA_MIPS_Family";
            case 1537L: return "ISA_MIPS_MarkI";
            case 1538L: return "ISA_MIPS_MarkII";
            case 1539L: return "ISA_MIPS_MarkIII";
            case 1540L: return "ISA_MIPS_R2000";
            case 1541L: return "ISA_MIPS_R3000";
            case 1542L: return "ISA_MIPS_R4000";
            case 1543L: return "ISA_MIPS_R4200";
            case 1544L: return "ISA_MIPS_R4300";
            case 1545L: return "ISA_MIPS_R4600";
            case 1546L: return "ISA_MIPS_R4650";
            case 1547L: return "ISA_MIPS_R4700";
            case 1548L: return "ISA_MIPS_R5000";
            case 1549L: return "ISA_MIPS_RM7000";
            case 1550L: return "ISA_MIPS_R8000";
            case 1551L: return "ISA_MIPS_R10000";
            case 1552L: return "ISA_MIPS_R12000";
            case 1553L: return "ISA_MIPS_R14000";
            case 1554L: return "ISA_MIPS_R16000";
            case 1555L: return "ISA_MIPS_R16000A";
            case 1556L: return "ISA_MIPS_16";
            case 1557L: return "ISA_MIPS_FPU";
            case 1558L: return "ISA_MIPS_16FPU";
            case 1792L: return "ISA_I860_Family";
            case 1793L: return "ISA_I860_860XR";
            case 1794L: return "ISA_I860_860XP";
            case 2048L: return "ISA_IA64_Family";
            case 2049L: return "ISA_IA64_Itanium";
            case 2050L: return "ISA_IA64_Itanium2";
            case 2304L: return "ISA_ARM_Family";
            case 2305L: return "ISA_ARM_ARM1";
            case 2306L: return "ISA_ARM_ARM2";
            case 2307L: return "ISA_ARM_ARM3";
            case 2308L: return "ISA_ARM_ARM6";
            case 2309L: return "ISA_ARM_ARM7";
            case 2310L: return "ISA_ARM_ARM7TDMI";
            case 2311L: return "ISA_ARM_StrongARM";
            case 2312L: return "ISA_ARM_ARM8";
            case 2313L: return "ISA_ARM_ARM9TDMI";
            case 2314L: return "ISA_ARM_ARM9E";
            case 2315L: return "ISA_ARM_ARM10E";
            case 2316L: return "ISA_ARM_XScale";
            case 2317L: return "ISA_ARM_ARM11";
            case 2318L: return "ISA_ARM_Cortex";
            case 61440L: return "ISA_OTHER_Family";
            case 61441L: return "ISA_ATT_WE_32100";
            case 61442L: return "ISA_IBM_System_370";
            case 61443L: return "ISA_HPPA";
            case 61444L: return "ISA_Fujitsu_VPP500";
            case 61445L: return "ISA_Sun_v8plus";
            case 61446L: return "ISA_PowerPC";
            case 61447L: return "ISA_PowerPC_64bit";
            case 61448L: return "ISA_IBM_S390";
            case 61449L: return "ISA_NEC_V800_series";
            case 61450L: return "ISA_Fujitsu_FR20";
            case 61451L: return "ISA_TRW_RH_32";
            case 61452L: return "ISA_Motorola_RCE";
            case 61454L: return "ISA_Digital_Alpha_fake";
            case 61455L: return "ISA_Hitachi_SH";
            case 61456L: return "ISA_Siemens_Tricore";
            case 61457L: return "ISA_Argonaut_RISC_Core";
            case 61458L: return "ISA_Hitachi_H8_300";
            case 61459L: return "ISA_Hitachi_H8_300H";
            case 61460L: return "ISA_Hitachi_H8S";
            case 61461L: return "ISA_Hitachi_H8_500";
            case 61462L: return "ISA_Stanford_MIPS_X";
            case 61463L: return "ISA_Motorola_M68HC12";
            case 61464L: return "ISA_Fujitsu_MMA_Multimedia_Accelerator";
            case 61465L: return "ISA_Siemens_PCP";
            case 61466L: return "ISA_Sony_nCPU_embeeded_RISC";
            case 61467L: return "ISA_Denso_NDR1_microprocessor";
            case 61468L: return "ISA_Motorola_Start_Core_processor";
            case 61469L: return "ISA_Toyota_ME16_processor";
            case 61470L: return "ISA_STMicroelectronic_ST100_processor";
            case 61471L: return "ISA_Advanced_Logic_Corp_Tinyj_emb_family";
            case 61472L: return "ISA_AMD_x86_64_architecture";
            case 61473L: return "ISA_Sony_DSP_Processor";
            case 61474L: return "ISA_Siemens_FX66_microcontroller";
            case 61475L: return "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller";
            case 61476L: return "ISA_STMicroelectronics_ST7_8bit_microcontroller";
            case 61477L: return "ISA_Motorola_MC68HC16_microcontroller";
            case 61478L: return "ISA_Motorola_MC68HC11_microcontroller";
            case 61479L: return "ISA_Motorola_MC68HC08_microcontroller";
            case 61480L: return "ISA_Motorola_MC68HC05_microcontroller";
            case 61481L: return "ISA_Silicon_Graphics_SVx";
            case 61482L: return "ISA_STMicroelectronics_ST19_8bit_microcontroller";
            case 61483L: return "ISA_Digital_VAX";
            case 61484L: return "ISA_Axis_Communications_32bit_embedded_processor";
            case 61485L: return "ISA_Infineon_Technologies_32bit_embedded_processor";
            case 61486L: return "ISA_Element_14_64bit_DSP_Processor";
            case 61487L: return "ISA_LSI_Logic_16bit_DSP_Processor";
            case 61488L: return "ISA_Donald_Knuths_educational_64bit_processor";
            case 61489L: return "ISA_Harvard_University_machine_independent_object_files";
            case 61490L: return "ISA_SiTera_Prism";
            case 61491L: return "ISA_Atmel_AVR_8bit_microcontroller";
            case 61492L: return "ISA_Fujitsu_FR30";
            case 61493L: return "ISA_Mitsubishi_D10V";
            case 61494L: return "ISA_Mitsubishi_D30V";
            case 61495L: return "ISA_NEC_v850";
            case 61496L: return "ISA_Mitsubishi_M32R";
            case 61497L: return "ISA_Matsushita_MN10300";
            case 61498L: return "ISA_Matsushita_MN10200";
            case 61499L: return "ISA_picoJava";
            case 61500L: return "ISA_OpenRISC_32bit_embedded_processor";
            case 61501L: return "ISA_ARC_Cores_Tangent_A5";
            case 61502L: return "ISA_Tensilica_Xtensa_Architecture";
            case 61503L: return "ISA_Digital_Alpha";
            case 61504L: return "ISA_Matsushita_AM33";
            case 61505L: return "ISA_EFI_ByteCode";
            case 65280L: return "ISA_FAMILY_MASK";
            case 65535L: return "ISA_OTHER";
            default: return "";
        }
    }

    std::string InsSetArchitecture(int64_t i, const std::string &strip) {
        std::string s = InsSetArchitecture(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsSetArchitecture() {
        static const int64_t values[] = {
            0L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            512L,
            513L,
            514L,
            515L,
            516L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1792L,
            1793L,
            1794L,
            2048L,
            2049L,
            2050L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            61440L,
            61441L,
            61442L,
            61443L,
            61444L,
            61445L,
            61446L,
            61447L,
            61448L,
            61449L,
            61450L,
            61451L,
            61452L,
            61454L,
            61455L,
            61456L,
            61457L,
            61458L,
            61459L,
            61460L,
            61461L,
            61462L,
            61463L,
            61464L,
            61465L,
            61466L,
            61467L,
            61468L,
            61469L,
            61470L,
            61471L,
            61472L,
            61473L,
            61474L,
            61475L,
            61476L,
            61477L,
            61478L,
            61479L,
            61480L,
            61481L,
            61482L,
            61483L,
            61484L,
            61485L,
            61486L,
            61487L,
            61488L,
            61489L,
            61490L,
            61491L,
            61492L,
            61493L,
            61494L,
            61495L,
            61496L,
            61497L,
            61498L,
            61499L,
            61500L,
            61501L,
            61502L,
            61503L,
            61504L,
            61505L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 159);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatInsSetArchitecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::InsSetArchitecture(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatInsSetArchitecture() {
        return stringify::SgAsmExecutableFileFormat::InsSetArchitecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 16044
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PURPOSE_UNSPECIFIED";
            case 1L: return "PURPOSE_OTHER";
            case 2L: return "PURPOSE_EXECUTABLE";
            case 3L: return "PURPOSE_LIBRARY";
            case 4L: return "PURPOSE_CORE_DUMP";
            case 5L: return "PURPOSE_OS_SPECIFIC";
            case 6L: return "PURPOSE_PROC_SPECIFIC";
            default: return "";
        }
    }

    std::string ExecPurpose(int64_t i, const std::string &strip) {
        std::string s = ExecPurpose(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecPurpose() {
        return stringify::SgAsmExecutableFileFormat::ExecPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinaryUnparserBase.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace ArrowMargin {
    const char* Flags(int64_t i) {
        switch (i) {
            case 1L: return "POINTABLE_ENTITY_START";
            case 2L: return "POINTABLE_ENTITY_END";
            case 4L: return "POINTABLE_ENTITY_INSIDE";
            case 8L: return "ALWAYS_RENDER";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserArrowMarginFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserArrowMarginFlags() {
        return stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/AsmUnparser.h line 251
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AsmUnparser {
    const char* Organization(int64_t i) {
        switch (i) {
            case 0L: return "ORGANIZED_BY_AST";
            case 1L: return "ORGANIZED_BY_ADDRESS";
            default: return "";
        }
    }

    std::string Organization(int64_t i, const std::string &strip) {
        std::string s = Organization(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AsmUnparser::Organization)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Organization() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAsmUnparserOrganization(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AsmUnparser::Organization(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AsmUnparser::Organization)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AsmUnparser::Organization::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAsmUnparserOrganization() {
        return stringify::Rose::BinaryAnalysis::AsmUnparser::Organization();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/AsmUnparser_compat.h line 46
namespace stringify {
    const char* ArmSignForExpressionUnparsing(int64_t i) {
        switch (i) {
            case 0L: return "arm_sign_none";
            case 1L: return "arm_sign_plus";
            case 2L: return "arm_sign_minus";
            default: return "";
        }
    }

    std::string ArmSignForExpressionUnparsing(int64_t i, const std::string &strip) {
        std::string s = ArmSignForExpressionUnparsing(i);
        if (s.empty())
            s = "(ArmSignForExpressionUnparsing)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArmSignForExpressionUnparsing() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyArmSignForExpressionUnparsing(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArmSignForExpressionUnparsing(i);
        if (retval.empty()) {
            retval = "(ArmSignForExpressionUnparsing)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArmSignForExpressionUnparsing::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArmSignForExpressionUnparsing() {
        return stringify::ArmSignForExpressionUnparsing();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinaryEdgeArrows.h line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* OutputPart(int64_t i) {
        switch (i) {
            case 0L: return "FIRST_LINE";
            case 1L: return "LAST_LINE";
            case 2L: return "MIDDLE_LINE";
            case 3L: return "INTER_LINE";
            default: return "";
        }
    }

    std::string OutputPart(int64_t i, const std::string &strip) {
        std::string s = OutputPart(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OutputPart() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinaryEdgeArrows.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowStylePreset(int64_t i) {
        switch (i) {
            case 0L: return "UNICODE_1";
            case 1L: return "UNICODE_2";
            case 2L: return "ASCII_1";
            case 3L: return "ASCII_2";
            case 4L: return "ASCII_3";
            default: return "";
        }
    }

    std::string ArrowStylePreset(int64_t i, const std::string &strip) {
        std::string s = ArrowStylePreset(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowStylePreset() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinaryEdgeArrows.h line 68
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowSide(int64_t i) {
        switch (i) {
            case 0L: return "LEFT";
            case 1L: return "RIGHT";
            default: return "";
        }
    }

    std::string ArrowSide(int64_t i, const std::string &strip) {
        std::string s = ArrowSide(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowSide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinarySerialIo.h line 119
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Format(int64_t i) {
        switch (i) {
            case 0L: return "BINARY";
            case 1L: return "TEXT";
            case 2L: return "XML";
            default: return "";
        }
    }

    std::string Format(int64_t i, const std::string &strip) {
        std::string s = Format(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Format(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Format::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoFormat() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Format();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/BinarySerialIo.h line 130
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Savable(int64_t i) {
        switch (i) {
            case 0L: return "NO_OBJECT";
            case 1L: return "PARTITIONER";
            case 2L: return "AST";
            case 65534L: return "END_OF_DATA";
            case 65535L: return "ERROR";
            case 65536L: return "USER_DEFINED";
            case 4294967295L: return "USER_DEFINED_LAST";
            default: return "";
        }
    }

    std::string Savable(int64_t i, const std::string &strip) {
        std::string s = Savable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Savable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            65534L,
            65535L,
            65536L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoSavable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Savable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Savable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoSavable() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Savable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 19
namespace stringify {
    const char* AssociativitySpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_assoc_none";
            case 1L: return "e_assoc_right";
            case 2L: return "e_assoc_left";
            case 3L: return "e_assoc_last";
            default: return "";
        }
    }

    std::string AssociativitySpecifier(int64_t i, const std::string &strip) {
        std::string s = AssociativitySpecifier(i);
        if (s.empty())
            s = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AssociativitySpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociativitySpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AssociativitySpecifier(i);
        if (retval.empty()) {
            retval = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AssociativitySpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociativitySpecifier() {
        return stringify::AssociativitySpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 46
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            case 6L: return "e_else_whitespace_start";
            case 7L: return "e_else_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 74
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* unparsed_as_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_unparsed_as_error";
            case 1L: return "e_unparsed_as_AST";
            case 2L: return "e_unparsed_as_partial_token_sequence";
            case 3L: return "e_unparsed_as_token_stream";
            case 4L: return "e_unparsed_as_last";
            default: return "";
        }
    }

    std::string unparsed_as_enum_type(int64_t i, const std::string &strip) {
        std::string s = unparsed_as_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparsed_as_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/formatSupport/unparse_format.h line 51
namespace stringify {
    const char* Format_Opt(int64_t i) {
        switch (i) {
            case 0L: return "FORMAT_BEFORE_DIRECTIVE";
            case 1L: return "FORMAT_AFTER_DIRECTIVE";
            case 2L: return "FORMAT_BEFORE_STMT";
            case 3L: return "FORMAT_AFTER_STMT";
            case 4L: return "FORMAT_BEFORE_BASIC_BLOCK1";
            case 5L: return "FORMAT_AFTER_BASIC_BLOCK1";
            case 6L: return "FORMAT_BEFORE_BASIC_BLOCK2";
            case 7L: return "FORMAT_AFTER_BASIC_BLOCK2";
            case 8L: return "FORMAT_BEFORE_NESTED_STATEMENT";
            case 9L: return "FORMAT_AFTER_NESTED_STATEMENT";
            default: return "";
        }
    }

    std::string Format_Opt(int64_t i, const std::string &strip) {
        std::string s = Format_Opt(i);
        if (s.empty())
            s = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format_Opt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFormat_Opt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Format_Opt(i);
        if (retval.empty()) {
            retval = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Format_Opt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormat_Opt() {
        return stringify::Format_Opt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/astUnparseAttribute.h line 33
namespace stringify { namespace AstUnparseAttribute {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "e_defaultValue";
            case 1L: return "e_undef";
            case 2L: return "e_before";
            case 3L: return "e_after";
            case 4L: return "e_inside";
            case 5L: return "e_replace";
            case 6L: return "e_before_syntax";
            case 7L: return "e_after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUnparseAttributeRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUnparseAttribute::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUnparseAttribute::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUnparseAttributeRelativePositionType() {
        return stringify::AstUnparseAttribute::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/CxxCodeGeneration/unparseCxx.h line 531
namespace stringify { namespace Unparse_ExprStmt {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(Unparse_ExprStmt::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparse_ExprStmt_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unparse_ExprStmt::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(Unparse_ExprStmt::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unparse_ExprStmt::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparse_ExprStmt_token_sequence_position_enum_type() {
        return stringify::Unparse_ExprStmt::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/unparser.h line 205
namespace stringify { namespace Unparser {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(Unparser::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparser_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unparser::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(Unparser::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unparser::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparser_token_sequence_position_enum_type() {
        return stringify::Unparser::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryFormats/MemoryMap.h line 126
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap { namespace Attach {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapAttachBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::Attach::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapAttachBoolean() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryFormats/MemoryMap.h line 282
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap {
    const char* InsertFileMapMode(int64_t i) {
        switch (i) {
            case 0L: return "MAP_PRIVATE";
            case 1L: return "MAP_READWRITE";
            case 2L: return "MAP_RDONLY";
            default: return "";
        }
    }

    std::string InsertFileMapMode(int64_t i, const std::string &strip) {
        std::string s = InsertFileMapMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertFileMapMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapInsertFileMapMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapInsertFileMapMode() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryFormats/SRecord.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Syntax(int64_t i) {
        switch (i) {
            case 0L: return "SREC_MOTOROLA";
            case 1L: return "SREC_INTEL";
            case 2L: return "SREC_UNKNOWN_SYNTAX";
            default: return "";
        }
    }

    std::string Syntax(int64_t i, const std::string &strip) {
        std::string s = Syntax(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Syntax() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordSyntax(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Syntax(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Syntax::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordSyntax() {
        return stringify::Rose::BinaryAnalysis::SRecord::Syntax();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryFormats/SRecord.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "SREC_M_HEADER";
            case 1L: return "SREC_M_DATA16";
            case 2L: return "SREC_M_DATA24";
            case 3L: return "SREC_M_DATA32";
            case 4L: return "SREC_M_RESERVED";
            case 5L: return "SREC_M_COUNT16";
            case 6L: return "SREC_M_COUNT24";
            case 7L: return "SREC_M_START32";
            case 8L: return "SREC_M_START24";
            case 9L: return "SREC_M_START16";
            case 10L: return "SREC_I_DATA";
            case 11L: return "SREC_I_END";
            case 12L: return "SREC_I_EXTENDED_SA";
            case 13L: return "SREC_I_START_SA";
            case 14L: return "SREC_I_EXTENDED_LA";
            case 15L: return "SREC_I_START_LA";
            case 16L: return "SREC_UNKNOWN_TYPE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordType() {
        return stringify::Rose::BinaryAnalysis::SRecord::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryFormats/ByteOrder.h line 7
namespace stringify { namespace ByteOrder {
    const char* Endianness(int64_t i) {
        switch (i) {
            case 0L: return "ORDER_UNSPECIFIED";
            case 1L: return "ORDER_LSB";
            case 2L: return "ORDER_MSB";
            default: return "";
        }
    }

    std::string Endianness(int64_t i, const std::string &strip) {
        std::string s = Endianness(i);
        if (s.empty())
            s = "(ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Endianness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyByteOrderEndianness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ByteOrder::Endianness(i);
        if (retval.empty()) {
            retval = "(ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ByteOrder::Endianness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyByteOrderEndianness() {
        return stringify::ByteOrder::Endianness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 11
namespace stringify { namespace General_Language_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_access_modifier_public";
            case 2L: return "e_access_modifier_private";
            case 3L: return "e_storage_modifier_contiguous";
            case 4L: return "e_storage_modifier_external";
            case 5L: return "e_storage_modifier_static";
            case 6L: return "e_storage_modifier_location";
            case 7L: return "e_storage_modifier_jovial_def";
            case 8L: return "e_storage_modifier_jovial_ref";
            case 9L: return "e_type_modifier_list";
            case 10L: return "e_type_modifier_allocatable";
            case 11L: return "e_type_modifier_asynchronous";
            case 12L: return "e_type_modifier_const";
            case 13L: return "e_type_modifier_intent_in";
            case 14L: return "e_type_modifier_intent_out";
            case 15L: return "e_type_modifier_intent_inout";
            case 16L: return "e_type_modifier_intrinsic";
            case 17L: return "e_type_modifier_optional";
            case 18L: return "e_type_modifier_pointer";
            case 19L: return "e_type_modifier_protected";
            case 20L: return "e_type_modifier_round";
            case 21L: return "e_type_modifier_save";
            case 22L: return "e_type_modifier_target";
            case 23L: return "e_type_modifier_truncate";
            case 24L: return "e_type_modifier_value";
            case 25L: return "e_type_modifier_reference";
            case 26L: return "e_type_modifier_result";
            case 27L: return "e_type_modifier_volatile";
            case 28L: return "e_type_modifier_z";
            case 29L: return "e_function_modifier_list";
            case 30L: return "e_function_modifier_none";
            case 31L: return "e_function_modifier_elemental";
            case 32L: return "e_function_modifier_impure";
            case 33L: return "e_function_modifier_module";
            case 34L: return "e_function_modifier_pure";
            case 35L: return "e_function_modifier_recursive";
            case 36L: return "e_function_modifier_reentrant";
            case 37L: return "e_struct_modifier_list";
            case 38L: return "e_struct_item_modifier_list";
            case 39L: return "e_operator_assign";
            case 40L: return "e_operator_exponentiate";
            case 41L: return "e_operator_concatenate";
            case 42L: return "e_operator_add";
            case 43L: return "e_operator_subtract";
            case 44L: return "e_operator_mod";
            case 45L: return "e_operator_multiply";
            case 46L: return "e_operator_divide";
            case 47L: return "e_operator_and";
            case 48L: return "e_operator_or";
            case 49L: return "e_operator_xor";
            case 50L: return "e_operator_equiv";
            case 51L: return "e_operator_less_than";
            case 52L: return "e_operator_greater_than";
            case 53L: return "e_operator_less_than_or_equal";
            case 54L: return "e_operator_greater_than_or_equal";
            case 55L: return "e_operator_equality";
            case 56L: return "e_operator_not_equal";
            case 57L: return "e_operator_unary_plus";
            case 58L: return "e_operator_unary_minus";
            case 59L: return "e_operator_unary_not";
            case 60L: return "e_operator_unity";
            case 61L: return "e_literalExpression";
            case 62L: return "e_function_reference";
            case 63L: return "e_procedure_call";
            case 64L: return "e_argument_list";
            case 65L: return "e_argument_keyword";
            case 66L: return "e_variable_reference";
            case 67L: return "e_array_reference";
            case 68L: return "e_case_range";
            case 69L: return "e_case_selector";
            case 70L: return "e_array_shape";
            case 71L: return "e_explicit_shape";
            case 72L: return "e_assumed_or_implied_shape";
            case 73L: return "e_assumed_shape";
            case 74L: return "e_assumed_size";
            case 75L: return "e_array_subscripts";
            case 76L: return "e_array_index_triplet";
            case 77L: return "e_section_subscripts";
            case 78L: return "e_explicit_dimension";
            case 79L: return "e_star_dimension";
            case 80L: return "e_star_expression";
            case 81L: return "e_initializer";
            case 82L: return "e_struct_initializer";
            case 83L: return "e_switch_stmt";
            case 84L: return "e_end_switch_stmt";
            case 85L: return "e_case_option_stmt";
            case 86L: return "e_case_default_option_stmt";
            case 87L: return "e_end_proc_ref_stmt";
            case 88L: return "e_end_proc_def_stmt";
            case 89L: return "e_define_directive_stmt";
            case 90L: return "e_fortran_dimension_stmt";
            case 91L: return "e_fortran_import_stmt";
            case 92L: return "e_fortran_if_stmt";
            case 93L: return "e_fortran_if_then_stmt";
            case 94L: return "e_fortran_else_if_stmt";
            case 95L: return "e_fortran_else_stmt";
            case 96L: return "e_fortran_end_do_stmt";
            case 97L: return "e_fortran_do_concurrent_stmt";
            case 98L: return "e_fortran_concurrent_header";
            case 99L: return "e_fortran_concurrent_control";
            case 100L: return "e_fortran_concurrent_locality";
            case 101L: return "e_fortran_forall_stmt";
            case 102L: return "e_fortran_end_forall_stmt";
            case 103L: return "e_fortran_sync_all_stmt";
            case 104L: return "e_fortran_sync_images_stmt";
            case 105L: return "e_fortran_sync_memory_stmt";
            case 106L: return "e_fortran_sync_team_stmt";
            case 107L: return "e_fortran_lock_stmt";
            case 108L: return "e_fortran_unlock_stmt";
            case 109L: return "e_fortran_sync_stat_list";
            case 110L: return "e_fortran_sync_stat_stat";
            case 111L: return "e_fortran_sync_stat_errmsg";
            case 112L: return "e_fortran_stat_acquired_lock";
            case 113L: return "e_jovial_compool_stmt";
            case 114L: return "e_cuda_host";
            case 115L: return "e_cuda_device";
            case 116L: return "e_cuda_global_function";
            case 117L: return "e_cuda_grid_global";
            case 118L: return "e_cuda_global";
            case 119L: return "e_cuda_device_memory";
            case 120L: return "e_cuda_managed";
            case 121L: return "e_cuda_constant";
            case 122L: return "e_cuda_shared";
            case 123L: return "e_cuda_pinned";
            case 124L: return "e_cuda_texture";
            case 125L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(General_Language_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L
        };
        static const std::vector<int64_t> retval(values, values + 126);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyGeneral_Language_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::General_Language_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(General_Language_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "General_Language_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGeneral_Language_TranslationExpressionKind() {
        return stringify::General_Language_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/FASTNodes.h line 88
namespace stringify { namespace FAST { namespace TypeSpec {
    const char* TypeEnum(int64_t i) {
        switch (i) {
            case 0L: return "Unknown";
            case 1L: return "Void";
            case 2L: return "Integer";
            case 3L: return "Real";
            case 4L: return "Double";
            case 5L: return "Complex";
            case 6L: return "DoubleComplex";
            case 7L: return "Boolean";
            case 8L: return "Character";
            case 9L: return "Derived";
            default: return "";
        }
    }

    std::string TypeEnum(int64_t i, const std::string &strip) {
        std::string s = TypeEnum(i);
        if (s.empty())
            s = "(FAST::TypeSpec::TypeEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFAST_TypeSpecTypeEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FAST::TypeSpec::TypeEnum(i);
        if (retval.empty()) {
            retval = "(FAST::TypeSpec::TypeEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FAST::TypeSpec::TypeEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFAST_TypeSpecTypeEnum() {
        return stringify::FAST::TypeSpec::TypeEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/FASTNodes.h line 136
namespace stringify { namespace FAST { namespace AttrSpec {
    const char* AttrEnum(int64_t i) {
        switch (i) {
            case 0L: return "Unknown";
            case 1L: return "Public";
            case 2L: return "Private";
            case 3L: return "Allocatable";
            case 4L: return "Asynchronous";
            case 5L: return "Codimension";
            case 6L: return "Contiguous";
            case 7L: return "Dimension";
            case 8L: return "External";
            case 9L: return "IntentIn";
            case 10L: return "IntentOut";
            case 11L: return "IntentInOut";
            case 12L: return "Intent";
            case 13L: return "Intrinsic";
            case 14L: return "Bind";
            case 15L: return "Optional";
            case 16L: return "Parameter";
            case 17L: return "Pointer";
            case 18L: return "Protected";
            case 19L: return "Save";
            case 20L: return "Target";
            case 21L: return "Value";
            case 22L: return "Volatile";
            default: return "";
        }
    }

    std::string AttrEnum(int64_t i, const std::string &strip) {
        std::string s = AttrEnum(i);
        if (s.empty())
            s = "(FAST::AttrSpec::AttrEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AttrEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFAST_AttrSpecAttrEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FAST::AttrSpec::AttrEnum(i);
        if (retval.empty()) {
            retval = "(FAST::AttrSpec::AttrEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FAST::AttrSpec::AttrEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFAST_AttrSpecAttrEnum() {
        return stringify::FAST::AttrSpec::AttrEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/FASTNodes.h line 265
namespace stringify { namespace FAST { namespace UseStmt {
    const char* ModuleNature(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Intrinsic";
            case 2L: return "NonIntrinsic";
            default: return "";
        }
    }

    std::string ModuleNature(int64_t i, const std::string &strip) {
        std::string s = ModuleNature(i);
        if (s.empty())
            s = "(FAST::UseStmt::ModuleNature)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ModuleNature() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFAST_UseStmtModuleNature(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FAST::UseStmt::ModuleNature(i);
        if (retval.empty()) {
            retval = "(FAST::UseStmt::ModuleNature)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FAST::UseStmt::ModuleNature::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFAST_UseStmtModuleNature() {
        return stringify::FAST::UseStmt::ModuleNature();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/FASTNodes.h line 444
namespace stringify { namespace FAST { namespace PrefixSpec {
    const char* PrefixEnum(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Elemental";
            case 2L: return "Impure";
            case 3L: return "Module";
            case 4L: return "Pure";
            case 5L: return "Recursive";
            default: return "";
        }
    }

    std::string PrefixEnum(int64_t i, const std::string &strip) {
        std::string s = PrefixEnum(i);
        if (s.empty())
            s = "(FAST::PrefixSpec::PrefixEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PrefixEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFAST_PrefixSpecPrefixEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FAST::PrefixSpec::PrefixEnum(i);
        if (retval.empty()) {
            retval = "(FAST::PrefixSpec::PrefixEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FAST::PrefixSpec::PrefixEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFAST_PrefixSpecPrefixEnum() {
        return stringify::FAST::PrefixSpec::PrefixEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryLoader/BinaryLoader.h line 63
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* MappingContribution(int64_t i) {
        switch (i) {
            case 0L: return "CONTRIBUTE_NONE";
            case 1L: return "CONTRIBUTE_ADD";
            case 2L: return "CONTRIBUTE_SUB";
            default: return "";
        }
    }

    std::string MappingContribution(int64_t i, const std::string &strip) {
        std::string s = MappingContribution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MappingContribution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderMappingContribution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::MappingContribution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderMappingContribution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/BinaryLoader/BinaryLoader.h line 71
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* ConflictResolution(int64_t i) {
        switch (i) {
            case 0L: return "RESOLVE_THROW";
            case 1L: return "RESOLVE_OVERMAP";
            case 2L: return "RESOLVE_REMAP";
            case 3L: return "RESOLVE_REMAP_ABOVE";
            default: return "";
        }
    }

    std::string ConflictResolution(int64_t i, const std::string &strip) {
        std::string s = ConflictResolution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConflictResolution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderConflictResolution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::ConflictResolution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderConflictResolution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.h line 26
namespace stringify { namespace Ada_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_error";
            case 2L: return "e_identifier";
            case 3L: return "e_characterLiteral";
            case 4L: return "e_enumerationLiteral";
            case 5L: return "e_integerLiteral";
            case 6L: return "e_realLiteral";
            case 7L: return "e_stringLiteral";
            case 8L: return "e_selectedComponent";
            case 9L: return "e_notAnOperator";
            case 10L: return "e_andOperator";
            case 11L: return "e_orOperator";
            case 12L: return "e_xorOperator";
            case 13L: return "e_equalOperator";
            case 14L: return "e_notEqualOperator";
            case 15L: return "e_lessThanOperator";
            case 16L: return "e_lessThanOrEqualOperator";
            case 17L: return "e_greaterThanOperator";
            case 18L: return "e_greaterThanOrEqualOperator";
            case 19L: return "e_plusOperator";
            case 20L: return "e_minusOperator";
            case 21L: return "e_concatenateOperator";
            case 22L: return "e_unaryPlusOperator";
            case 23L: return "e_unaryMinusOperator";
            case 24L: return "e_multiplyOperator";
            case 25L: return "e_divideOperator";
            case 26L: return "e_modOperator";
            case 27L: return "e_remOperator";
            case 28L: return "e_exponentiateOperator";
            case 29L: return "e_absOperator";
            case 30L: return "e_notOperator";
            case 31L: return "e_functionCall";
            case 32L: return "e_typeConversion";
            case 33L: return "e_qualifiedExpression";
            case 34L: return "e_parameterAssociation";
            case 35L: return "e_genericAssociation";
            case 36L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Ada_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L
        };
        static const std::vector<int64_t> retval(values, values + 37);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAda_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Ada_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Ada_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Ada_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAda_ROSE_TranslationExpressionKind() {
        return stringify::Ada_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 7222
namespace stringify {
    const char* Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Definition";
            case 1L: return "A_Type_Definition";
            case 2L: return "A_Subtype_Indication";
            case 3L: return "A_Constraint";
            case 4L: return "A_Component_Definition";
            case 5L: return "A_Discrete_Subtype_Definition";
            case 6L: return "A_Discrete_Range";
            case 7L: return "An_Unknown_Discriminant_Part";
            case 8L: return "A_Known_Discriminant_Part";
            case 9L: return "A_Record_Definition";
            case 10L: return "A_Null_Record_Definition";
            case 11L: return "A_Null_Component";
            case 12L: return "A_Variant_Part";
            case 13L: return "A_Variant";
            case 14L: return "An_Others_Choice";
            case 15L: return "An_Access_Definition";
            case 16L: return "A_Private_Type_Definition";
            case 17L: return "A_Tagged_Private_Type_Definition";
            case 18L: return "A_Private_Extension_Definition";
            case 19L: return "A_Task_Definition";
            case 20L: return "A_Protected_Definition";
            case 21L: return "A_Formal_Type_Definition";
            case 22L: return "An_Aspect_Specification";
            default: return "";
        }
    }

    std::string Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = Definition_Kinds(i);
        if (s.empty())
            s = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefinition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefinition_Kinds() {
        return stringify::Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 7859
namespace stringify {
    const char* Path_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Path";
            case 1L: return "An_If_Path";
            case 2L: return "An_Elsif_Path";
            case 3L: return "An_Else_Path";
            case 4L: return "A_Case_Path";
            case 5L: return "A_Select_Path";
            case 6L: return "An_Or_Path";
            case 7L: return "A_Then_Abort_Path";
            case 8L: return "A_Case_Expression_Path";
            case 9L: return "An_If_Expression_Path";
            case 10L: return "An_Elsif_Expression_Path";
            case 11L: return "An_Else_Expression_Path";
            default: return "";
        }
    }

    std::string Path_Kinds(int64_t i, const std::string &strip) {
        std::string s = Path_Kinds(i);
        if (s.empty())
            s = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Path_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPath_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Path_Kinds(i);
        if (retval.empty()) {
            retval = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Path_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPath_Kinds() {
        return stringify::Path_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 9954
namespace stringify {
    const char* _Access_Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Definition";
            case 1L: return "An_Anonymous_Access_To_Variable";
            case 2L: return "An_Anonymous_Access_To_Constant";
            case 3L: return "An_Anonymous_Access_To_Procedure";
            case 4L: return "An_Anonymous_Access_To_Protected_Procedure";
            case 5L: return "An_Anonymous_Access_To_Function";
            case 6L: return "An_Anonymous_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Definition_Kinds(i);
        if (s.empty())
            s = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Definition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Definition_Kinds() {
        return stringify::_Access_Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 9992
namespace stringify {
    const char* _Formal_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Formal_Type_Definition";
            case 1L: return "A_Formal_Private_Type_Definition";
            case 2L: return "A_Formal_Tagged_Private_Type_Definition";
            case 3L: return "A_Formal_Derived_Type_Definition";
            case 4L: return "A_Formal_Discrete_Type_Definition";
            case 5L: return "A_Formal_Signed_Integer_Type_Definition";
            case 6L: return "A_Formal_Modular_Type_Definition";
            case 7L: return "A_Formal_Floating_Point_Definition";
            case 8L: return "A_Formal_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Formal_Decimal_Fixed_Point_Definition";
            case 10L: return "A_Formal_Interface_Type_Definition";
            case 11L: return "A_Formal_Unconstrained_Array_Definition";
            case 12L: return "A_Formal_Constrained_Array_Definition";
            case 13L: return "A_Formal_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Formal_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Formal_Type_Kinds(i);
        if (s.empty())
            s = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Formal_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Formal_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Formal_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Formal_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Formal_Type_Kinds() {
        return stringify::_Formal_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 10048
namespace stringify {
    const char* _Discrete_Range_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Discrete_Range";
            case 1L: return "A_Discrete_Subtype_Indication";
            case 2L: return "A_Discrete_Range_Attribute_Reference";
            case 3L: return "A_Discrete_Simple_Expression_Range";
            default: return "";
        }
    }

    std::string _Discrete_Range_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Discrete_Range_Kinds(i);
        if (s.empty())
            s = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Discrete_Range_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Discrete_Range_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Discrete_Range_Kinds(i);
        if (retval.empty()) {
            retval = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Discrete_Range_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Discrete_Range_Kinds() {
        return stringify::_Discrete_Range_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 10079
namespace stringify {
    const char* _Constraint_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Constraint";
            case 1L: return "A_Range_Attribute_Reference";
            case 2L: return "A_Simple_Expression_Range";
            case 3L: return "A_Digits_Constraint";
            case 4L: return "A_Delta_Constraint";
            case 5L: return "An_Index_Constraint";
            case 6L: return "A_Discriminant_Constraint";
            default: return "";
        }
    }

    std::string _Constraint_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Constraint_Kinds(i);
        if (s.empty())
            s = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Constraint_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Constraint_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Constraint_Kinds(i);
        if (retval.empty()) {
            retval = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Constraint_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Constraint_Kinds() {
        return stringify::_Constraint_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/Ada_to_ROSE_translation.C line 10116
namespace stringify {
    const char* _Representation_Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Representation_Clause";
            case 1L: return "An_Attribute_Definition_Clause";
            case 2L: return "An_Enumeration_Representation_Clause";
            case 3L: return "A_Record_Representation_Clause";
            case 4L: return "An_At_Clause";
            default: return "";
        }
    }

    std::string _Representation_Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Representation_Clause_Kinds(i);
        if (s.empty())
            s = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Representation_Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Representation_Clause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Representation_Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Representation_Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Representation_Clause_Kinds() {
        return stringify::_Representation_Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 47
namespace stringify {
    const char* Element_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Element";
            case 1L: return "A_Pragma";
            case 2L: return "A_Defining_Name";
            case 3L: return "A_Declaration";
            case 4L: return "A_Definition";
            case 5L: return "An_Expression";
            case 6L: return "An_Association";
            case 7L: return "A_Statement";
            case 8L: return "A_Path";
            case 9L: return "A_Clause";
            case 10L: return "An_Exception_Handler";
            default: return "";
        }
    }

    std::string Element_Kinds(int64_t i, const std::string &strip) {
        std::string s = Element_Kinds(i);
        if (s.empty())
            s = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Element_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}

namespace Rose {
    std::string stringifyElement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Element_Kinds(i);
        if (retval.empty()) {
            retval = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Element_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyElement_Kinds() {
        return stringify::Element_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 142
namespace stringify {
    const char* Operator_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Operator";
            case 1L: return "An_And_Operator";
            case 2L: return "An_Or_Operator";
            case 3L: return "An_Xor_Operator";
            case 4L: return "An_Equal_Operator";
            case 5L: return "A_Not_Equal_Operator";
            case 6L: return "A_Less_Than_Operator";
            case 7L: return "A_Less_Than_Or_Equal_Operator";
            case 8L: return "A_Greater_Than_Operator";
            case 9L: return "A_Greater_Than_Or_Equal_Operator";
            case 10L: return "A_Plus_Operator";
            case 11L: return "A_Minus_Operator";
            case 12L: return "A_Concatenate_Operator";
            case 13L: return "A_Unary_Plus_Operator";
            case 14L: return "A_Unary_Minus_Operator";
            case 15L: return "A_Multiply_Operator";
            case 16L: return "A_Divide_Operator";
            case 17L: return "A_Mod_Operator";
            case 18L: return "A_Rem_Operator";
            case 19L: return "An_Exponentiate_Operator";
            case 20L: return "An_Abs_Operator";
            case 21L: return "A_Not_Operator";
            default: return "";
        }
    }

    std::string Operator_Kinds(int64_t i, const std::string &strip) {
        std::string s = Operator_Kinds(i);
        if (s.empty())
            s = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOperator_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Operator_Kinds(i);
        if (retval.empty()) {
            retval = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Operator_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOperator_Kinds() {
        return stringify::Operator_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 172
namespace stringify {
    const char* Pragma_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Pragma";
            case 1L: return "An_All_Calls_Remote_Pragma";
            case 2L: return "An_Assert_Pragma";
            case 3L: return "An_Assertion_Policy_Pragma";
            case 4L: return "An_Asynchronous_Pragma";
            case 5L: return "An_Atomic_Pragma";
            case 6L: return "An_Atomic_Components_Pragma";
            case 7L: return "An_Attach_Handler_Pragma";
            case 8L: return "A_Controlled_Pragma";
            case 9L: return "A_Convention_Pragma";
            case 10L: return "A_CPU_Pragma";
            case 11L: return "A_Default_Storage_Pool_Pragma";
            case 12L: return "A_Detect_Blocking_Pragma";
            case 13L: return "A_Discard_Names_Pragma";
            case 14L: return "A_Dispatching_Domain_Pragma";
            case 15L: return "An_Elaborate_Pragma";
            case 16L: return "An_Elaborate_All_Pragma";
            case 17L: return "An_Elaborate_Body_Pragma";
            case 18L: return "An_Export_Pragma";
            case 19L: return "An_Independent_Pragma";
            case 20L: return "A_Independent_Components_Pragma";
            case 21L: return "An_Import_Pragma";
            case 22L: return "An_Inline_Pragma";
            case 23L: return "An_Inspection_Point_Pragma";
            case 24L: return "An_Interrupt_Handler_Pragma";
            case 25L: return "An_Interrupt_Priority_Pragma";
            case 26L: return "A_Linker_Options_Pragma";
            case 27L: return "A_List_Pragma";
            case 28L: return "A_Locking_Policy_Pragma";
            case 29L: return "A_No_Return_Pragma";
            case 30L: return "A_Normalize_Scalars_Pragma";
            case 31L: return "An_Optimize_Pragma";
            case 32L: return "A_Pack_Pragma";
            case 33L: return "A_Page_Pragma";
            case 34L: return "A_Partition_Elaboration_Policy_Pragma";
            case 35L: return "A_Preelaborable_Initialization_Pragma";
            case 36L: return "A_Preelaborate_Pragma";
            case 37L: return "A_Priority_Pragma";
            case 38L: return "A_Priority_Specific_Dispatching_Pragma";
            case 39L: return "A_Profile_Pragma";
            case 40L: return "A_Pure_Pragma";
            case 41L: return "A_Queuing_Policy_Pragma";
            case 42L: return "A_Relative_Deadline_Pragma";
            case 43L: return "A_Remote_Call_Interface_Pragma";
            case 44L: return "A_Remote_Types_Pragma";
            case 45L: return "A_Restrictions_Pragma";
            case 46L: return "A_Reviewable_Pragma";
            case 47L: return "A_Shared_Passive_Pragma";
            case 48L: return "A_Storage_Size_Pragma";
            case 49L: return "A_Suppress_Pragma";
            case 50L: return "A_Task_Dispatching_Policy_Pragma";
            case 51L: return "An_Unchecked_Union_Pragma";
            case 52L: return "An_Unsuppress_Pragma";
            case 53L: return "A_Volatile_Pragma";
            case 54L: return "A_Volatile_Components_Pragma";
            case 55L: return "An_Implementation_Defined_Pragma";
            default: return "";
        }
    }

    std::string Pragma_Kinds(int64_t i, const std::string &strip) {
        std::string s = Pragma_Kinds(i);
        if (s.empty())
            s = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Pragma_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L
        };
        static const std::vector<int64_t> retval(values, values + 56);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPragma_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Pragma_Kinds(i);
        if (retval.empty()) {
            retval = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Pragma_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPragma_Kinds() {
        return stringify::Pragma_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 247
namespace stringify {
    const char* Defining_Name_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Defining_Name";
            case 1L: return "A_Defining_Identifier";
            case 2L: return "A_Defining_Character_Literal";
            case 3L: return "A_Defining_Enumeration_Literal";
            case 4L: return "A_Defining_Operator_Symbol";
            case 5L: return "A_Defining_Expanded_Name";
            default: return "";
        }
    }

    std::string Defining_Name_Kinds(int64_t i, const std::string &strip) {
        std::string s = Defining_Name_Kinds(i);
        if (s.empty())
            s = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Defining_Name_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefining_Name_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Defining_Name_Kinds(i);
        if (retval.empty()) {
            retval = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Defining_Name_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefining_Name_Kinds() {
        return stringify::Defining_Name_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 288
namespace stringify {
    const char* Declaration_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration";
            case 1L: return "An_Ordinary_Type_Declaration";
            case 2L: return "A_Task_Type_Declaration";
            case 3L: return "A_Protected_Type_Declaration";
            case 4L: return "An_Incomplete_Type_Declaration";
            case 5L: return "A_Tagged_Incomplete_Type_Declaration";
            case 6L: return "A_Private_Type_Declaration";
            case 7L: return "A_Private_Extension_Declaration";
            case 8L: return "A_Subtype_Declaration";
            case 9L: return "A_Variable_Declaration";
            case 10L: return "A_Constant_Declaration";
            case 11L: return "A_Deferred_Constant_Declaration";
            case 12L: return "A_Single_Task_Declaration";
            case 13L: return "A_Single_Protected_Declaration";
            case 14L: return "An_Integer_Number_Declaration";
            case 15L: return "A_Real_Number_Declaration";
            case 16L: return "An_Enumeration_Literal_Specification";
            case 17L: return "A_Discriminant_Specification";
            case 18L: return "A_Component_Declaration";
            case 19L: return "A_Loop_Parameter_Specification";
            case 20L: return "A_Generalized_Iterator_Specification";
            case 21L: return "An_Element_Iterator_Specification";
            case 22L: return "A_Procedure_Declaration";
            case 23L: return "A_Function_Declaration";
            case 24L: return "A_Parameter_Specification";
            case 25L: return "A_Procedure_Body_Declaration";
            case 26L: return "A_Function_Body_Declaration";
            case 27L: return "A_Return_Variable_Specification";
            case 28L: return "A_Return_Constant_Specification";
            case 29L: return "A_Null_Procedure_Declaration";
            case 30L: return "An_Expression_Function_Declaration";
            case 31L: return "A_Package_Declaration";
            case 32L: return "A_Package_Body_Declaration";
            case 33L: return "An_Object_Renaming_Declaration";
            case 34L: return "An_Exception_Renaming_Declaration";
            case 35L: return "A_Package_Renaming_Declaration";
            case 36L: return "A_Procedure_Renaming_Declaration";
            case 37L: return "A_Function_Renaming_Declaration";
            case 38L: return "A_Generic_Package_Renaming_Declaration";
            case 39L: return "A_Generic_Procedure_Renaming_Declaration";
            case 40L: return "A_Generic_Function_Renaming_Declaration";
            case 41L: return "A_Task_Body_Declaration";
            case 42L: return "A_Protected_Body_Declaration";
            case 43L: return "An_Entry_Declaration";
            case 44L: return "An_Entry_Body_Declaration";
            case 45L: return "An_Entry_Index_Specification";
            case 46L: return "A_Procedure_Body_Stub";
            case 47L: return "A_Function_Body_Stub";
            case 48L: return "A_Package_Body_Stub";
            case 49L: return "A_Task_Body_Stub";
            case 50L: return "A_Protected_Body_Stub";
            case 51L: return "An_Exception_Declaration";
            case 52L: return "A_Choice_Parameter_Specification";
            case 53L: return "A_Generic_Procedure_Declaration";
            case 54L: return "A_Generic_Function_Declaration";
            case 55L: return "A_Generic_Package_Declaration";
            case 56L: return "A_Package_Instantiation";
            case 57L: return "A_Procedure_Instantiation";
            case 58L: return "A_Function_Instantiation";
            case 59L: return "A_Formal_Object_Declaration";
            case 60L: return "A_Formal_Type_Declaration";
            case 61L: return "A_Formal_Incomplete_Type_Declaration";
            case 62L: return "A_Formal_Procedure_Declaration";
            case 63L: return "A_Formal_Function_Declaration";
            case 64L: return "A_Formal_Package_Declaration";
            case 65L: return "A_Formal_Package_Declaration_With_Box";
            default: return "";
        }
    }

    std::string Declaration_Kinds(int64_t i, const std::string &strip) {
        std::string s = Declaration_Kinds(i);
        if (s.empty())
            s = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Kinds(i);
        if (retval.empty()) {
            retval = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Kinds() {
        return stringify::Declaration_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 392
namespace stringify {
    const char* Declaration_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration_Origin";
            case 1L: return "An_Explicit_Declaration";
            case 2L: return "An_Implicit_Predefined_Declaration";
            case 3L: return "An_Implicit_Inherited_Declaration";
            default: return "";
        }
    }

    std::string Declaration_Origins(int64_t i, const std::string &strip) {
        std::string s = Declaration_Origins(i);
        if (s.empty())
            s = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Origins(i);
        if (retval.empty()) {
            retval = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Origins() {
        return stringify::Declaration_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 408
namespace stringify {
    const char* Mode_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Mode";
            case 1L: return "A_Default_In_Mode";
            case 2L: return "An_In_Mode";
            case 3L: return "An_Out_Mode";
            case 4L: return "An_In_Out_Mode";
            default: return "";
        }
    }

    std::string Mode_Kinds(int64_t i, const std::string &strip) {
        std::string s = Mode_Kinds(i);
        if (s.empty())
            s = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyMode_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Mode_Kinds(i);
        if (retval.empty()) {
            retval = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Mode_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMode_Kinds() {
        return stringify::Mode_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 418
namespace stringify {
    const char* Subprogram_Default_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Default";
            case 1L: return "A_Name_Default";
            case 2L: return "A_Box_Default";
            case 3L: return "A_Null_Default";
            case 4L: return "A_Nil_Default";
            default: return "";
        }
    }

    std::string Subprogram_Default_Kinds(int64_t i, const std::string &strip) {
        std::string s = Subprogram_Default_Kinds(i);
        if (s.empty())
            s = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subprogram_Default_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifySubprogram_Default_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Subprogram_Default_Kinds(i);
        if (retval.empty()) {
            retval = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Subprogram_Default_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySubprogram_Default_Kinds() {
        return stringify::Subprogram_Default_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 836
namespace stringify {
    const char* _Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Type_Definition";
            case 1L: return "A_Derived_Type_Definition";
            case 2L: return "A_Derived_Record_Extension_Definition";
            case 3L: return "An_Enumeration_Type_Definition";
            case 4L: return "A_Signed_Integer_Type_Definition";
            case 5L: return "A_Modular_Type_Definition";
            case 6L: return "A_Root_Type_Definition";
            case 7L: return "A_Floating_Point_Definition";
            case 8L: return "An_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Decimal_Fixed_Point_Definition";
            case 10L: return "An_Unconstrained_Array_Definition";
            case 11L: return "A_Constrained_Array_Definition";
            case 12L: return "A_Record_Type_Definition";
            case 13L: return "A_Tagged_Record_Type_Definition";
            case 14L: return "An_Interface_Type_Definition";
            case 15L: return "An_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Type_Kinds(i);
        if (s.empty())
            s = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Type_Kinds() {
        return stringify::_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 870
namespace stringify {
    const char* _Interface_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Interface";
            case 1L: return "An_Ordinary_Interface";
            case 2L: return "A_Limited_Interface";
            case 3L: return "A_Task_Interface";
            case 4L: return "A_Protected_Interface";
            case 5L: return "A_Synchronized_Interface";
            default: return "";
        }
    }

    std::string _Interface_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Interface_Kinds(i);
        if (s.empty())
            s = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Interface_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Interface_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Interface_Kinds(i);
        if (retval.empty()) {
            retval = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Interface_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Interface_Kinds() {
        return stringify::_Interface_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 879
namespace stringify {
    const char* _Root_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Root_Type_Definition";
            case 1L: return "A_Root_Integer_Definition";
            case 2L: return "A_Root_Real_Definition";
            case 3L: return "A_Universal_Integer_Definition";
            case 4L: return "A_Universal_Real_Definition";
            case 5L: return "A_Universal_Fixed_Definition";
            default: return "";
        }
    }

    std::string _Root_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Root_Type_Kinds(i);
        if (s.empty())
            s = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Root_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Root_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Root_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Root_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Root_Type_Kinds() {
        return stringify::_Root_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 917
namespace stringify {
    const char* _Access_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Type_Definition";
            case 1L: return "A_Pool_Specific_Access_To_Variable";
            case 2L: return "An_Access_To_Variable";
            case 3L: return "An_Access_To_Constant";
            case 4L: return "An_Access_To_Procedure";
            case 5L: return "An_Access_To_Protected_Procedure";
            case 6L: return "An_Access_To_Function";
            case 7L: return "An_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Type_Kinds(i);
        if (s.empty())
            s = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Type_Kinds() {
        return stringify::_Access_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1244
namespace stringify {
    const char* Expression_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Expression";
            case 1L: return "A_Box_Expression";
            case 2L: return "An_Integer_Literal";
            case 3L: return "A_Real_Literal";
            case 4L: return "A_String_Literal";
            case 5L: return "An_Identifier";
            case 6L: return "An_Operator_Symbol";
            case 7L: return "A_Character_Literal";
            case 8L: return "An_Enumeration_Literal";
            case 9L: return "An_Explicit_Dereference";
            case 10L: return "A_Function_Call";
            case 11L: return "An_Indexed_Component";
            case 12L: return "A_Slice";
            case 13L: return "A_Selected_Component";
            case 14L: return "An_Attribute_Reference";
            case 15L: return "A_Record_Aggregate";
            case 16L: return "An_Extension_Aggregate";
            case 17L: return "A_Positional_Array_Aggregate";
            case 18L: return "A_Named_Array_Aggregate";
            case 19L: return "An_And_Then_Short_Circuit";
            case 20L: return "An_Or_Else_Short_Circuit";
            case 21L: return "An_In_Membership_Test";
            case 22L: return "A_Not_In_Membership_Test";
            case 23L: return "A_Null_Literal";
            case 24L: return "A_Parenthesized_Expression";
            case 25L: return "A_Raise_Expression";
            case 26L: return "A_Type_Conversion";
            case 27L: return "A_Qualified_Expression";
            case 28L: return "An_Allocation_From_Subtype";
            case 29L: return "An_Allocation_From_Qualified_Expression";
            case 30L: return "A_Case_Expression";
            case 31L: return "An_If_Expression";
            case 32L: return "A_For_All_Quantified_Expression";
            case 33L: return "A_For_Some_Quantified_Expression";
            default: return "";
        }
    }

    std::string Expression_Kinds(int64_t i, const std::string &strip) {
        std::string s = Expression_Kinds(i);
        if (s.empty())
            s = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Expression_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}

namespace Rose {
    std::string stringifyExpression_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Expression_Kinds(i);
        if (retval.empty()) {
            retval = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Expression_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyExpression_Kinds() {
        return stringify::Expression_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1289
namespace stringify {
    const char* Attribute_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Attribute";
            case 1L: return "An_Access_Attribute";
            case 2L: return "An_Address_Attribute";
            case 3L: return "An_Adjacent_Attribute";
            case 4L: return "An_Aft_Attribute";
            case 5L: return "An_Alignment_Attribute";
            case 6L: return "A_Base_Attribute";
            case 7L: return "A_Bit_Order_Attribute";
            case 8L: return "A_Body_Version_Attribute";
            case 9L: return "A_Callable_Attribute";
            case 10L: return "A_Caller_Attribute";
            case 11L: return "A_Ceiling_Attribute";
            case 12L: return "A_Class_Attribute";
            case 13L: return "A_Component_Size_Attribute";
            case 14L: return "A_Compose_Attribute";
            case 15L: return "A_Constrained_Attribute";
            case 16L: return "A_Copy_Sign_Attribute";
            case 17L: return "A_Count_Attribute";
            case 18L: return "A_Definite_Attribute";
            case 19L: return "A_Delta_Attribute";
            case 20L: return "A_Denorm_Attribute";
            case 21L: return "A_Digits_Attribute";
            case 22L: return "An_Exponent_Attribute";
            case 23L: return "An_External_Tag_Attribute";
            case 24L: return "A_First_Attribute";
            case 25L: return "A_First_Bit_Attribute";
            case 26L: return "A_Floor_Attribute";
            case 27L: return "A_Fore_Attribute";
            case 28L: return "A_Fraction_Attribute";
            case 29L: return "An_Identity_Attribute";
            case 30L: return "An_Image_Attribute";
            case 31L: return "An_Input_Attribute";
            case 32L: return "A_Last_Attribute";
            case 33L: return "A_Last_Bit_Attribute";
            case 34L: return "A_Leading_Part_Attribute";
            case 35L: return "A_Length_Attribute";
            case 36L: return "A_Machine_Attribute";
            case 37L: return "A_Machine_Emax_Attribute";
            case 38L: return "A_Machine_Emin_Attribute";
            case 39L: return "A_Machine_Mantissa_Attribute";
            case 40L: return "A_Machine_Overflows_Attribute";
            case 41L: return "A_Machine_Radix_Attribute";
            case 42L: return "A_Machine_Rounds_Attribute";
            case 43L: return "A_Max_Attribute";
            case 44L: return "A_Max_Size_In_Storage_Elements_Attribute";
            case 45L: return "A_Min_Attribute";
            case 46L: return "A_Model_Attribute";
            case 47L: return "A_Model_Emin_Attribute";
            case 48L: return "A_Model_Epsilon_Attribute";
            case 49L: return "A_Model_Mantissa_Attribute";
            case 50L: return "A_Model_Small_Attribute";
            case 51L: return "A_Modulus_Attribute";
            case 52L: return "An_Output_Attribute";
            case 53L: return "A_Partition_ID_Attribute";
            case 54L: return "A_Pos_Attribute";
            case 55L: return "A_Position_Attribute";
            case 56L: return "A_Pred_Attribute";
            case 57L: return "A_Range_Attribute";
            case 58L: return "A_Read_Attribute";
            case 59L: return "A_Remainder_Attribute";
            case 60L: return "A_Round_Attribute";
            case 61L: return "A_Rounding_Attribute";
            case 62L: return "A_Safe_First_Attribute";
            case 63L: return "A_Safe_Last_Attribute";
            case 64L: return "A_Scale_Attribute";
            case 65L: return "A_Scaling_Attribute";
            case 66L: return "A_Signed_Zeros_Attribute";
            case 67L: return "A_Size_Attribute";
            case 68L: return "A_Small_Attribute";
            case 69L: return "A_Storage_Pool_Attribute";
            case 70L: return "A_Storage_Size_Attribute";
            case 71L: return "A_Succ_Attribute";
            case 72L: return "A_Tag_Attribute";
            case 73L: return "A_Terminated_Attribute";
            case 74L: return "A_Truncation_Attribute";
            case 75L: return "An_Unbiased_Rounding_Attribute";
            case 76L: return "An_Unchecked_Access_Attribute";
            case 77L: return "A_Val_Attribute";
            case 78L: return "A_Valid_Attribute";
            case 79L: return "A_Value_Attribute";
            case 80L: return "A_Version_Attribute";
            case 81L: return "A_Wide_Image_Attribute";
            case 82L: return "A_Wide_Value_Attribute";
            case 83L: return "A_Wide_Width_Attribute";
            case 84L: return "A_Width_Attribute";
            case 85L: return "A_Write_Attribute";
            case 86L: return "A_Machine_Rounding_Attribute";
            case 87L: return "A_Mod_Attribute";
            case 88L: return "A_Priority_Attribute";
            case 89L: return "A_Stream_Size_Attribute";
            case 90L: return "A_Wide_Wide_Image_Attribute";
            case 91L: return "A_Wide_Wide_Value_Attribute";
            case 92L: return "A_Wide_Wide_Width_Attribute";
            case 93L: return "A_Max_Alignment_For_Allocation_Attribute";
            case 94L: return "An_Overlaps_Storage_Attribute";
            case 95L: return "An_Implementation_Defined_Attribute";
            case 96L: return "An_Unknown_Attribute";
            default: return "";
        }
    }

    std::string Attribute_Kinds(int64_t i, const std::string &strip) {
        std::string s = Attribute_Kinds(i);
        if (s.empty())
            s = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Attribute_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L
        };
        static const std::vector<int64_t> retval(values, values + 97);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAttribute_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Attribute_Kinds(i);
        if (retval.empty()) {
            retval = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Attribute_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAttribute_Kinds() {
        return stringify::Attribute_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1515
namespace stringify {
    const char* Association_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Association";
            case 1L: return "A_Pragma_Argument_Association";
            case 2L: return "A_Discriminant_Association";
            case 3L: return "A_Record_Component_Association";
            case 4L: return "An_Array_Component_Association";
            case 5L: return "A_Parameter_Association";
            case 6L: return "A_Generic_Association";
            default: return "";
        }
    }

    std::string Association_Kinds(int64_t i, const std::string &strip) {
        std::string s = Association_Kinds(i);
        if (s.empty())
            s = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Association_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociation_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Association_Kinds(i);
        if (retval.empty()) {
            retval = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Association_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociation_Kinds() {
        return stringify::Association_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1564
namespace stringify {
    const char* Statement_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Statement";
            case 1L: return "A_Null_Statement";
            case 2L: return "An_Assignment_Statement";
            case 3L: return "An_If_Statement";
            case 4L: return "A_Case_Statement";
            case 5L: return "A_Loop_Statement";
            case 6L: return "A_While_Loop_Statement";
            case 7L: return "A_For_Loop_Statement";
            case 8L: return "A_Block_Statement";
            case 9L: return "An_Exit_Statement";
            case 10L: return "A_Goto_Statement";
            case 11L: return "A_Procedure_Call_Statement";
            case 12L: return "A_Return_Statement";
            case 13L: return "An_Extended_Return_Statement";
            case 14L: return "An_Accept_Statement";
            case 15L: return "An_Entry_Call_Statement";
            case 16L: return "A_Requeue_Statement";
            case 17L: return "A_Requeue_Statement_With_Abort";
            case 18L: return "A_Delay_Until_Statement";
            case 19L: return "A_Delay_Relative_Statement";
            case 20L: return "A_Terminate_Alternative_Statement";
            case 21L: return "A_Selective_Accept_Statement";
            case 22L: return "A_Timed_Entry_Call_Statement";
            case 23L: return "A_Conditional_Entry_Call_Statement";
            case 24L: return "An_Asynchronous_Select_Statement";
            case 25L: return "An_Abort_Statement";
            case 26L: return "A_Raise_Statement";
            case 27L: return "A_Code_Statement";
            default: return "";
        }
    }

    std::string Statement_Kinds(int64_t i, const std::string &strip) {
        std::string s = Statement_Kinds(i);
        if (s.empty())
            s = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statement_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyStatement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Statement_Kinds(i);
        if (retval.empty()) {
            retval = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Statement_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStatement_Kinds() {
        return stringify::Statement_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1792
namespace stringify {
    const char* Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Clause";
            case 1L: return "A_Use_Package_Clause";
            case 2L: return "A_Use_Type_Clause";
            case 3L: return "A_Use_All_Type_Clause";
            case 4L: return "A_With_Clause";
            case 5L: return "A_Representation_Clause";
            case 6L: return "A_Component_Clause";
            default: return "";
        }
    }

    std::string Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = Clause_Kinds(i);
        if (s.empty())
            s = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyClause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClause_Kinds() {
        return stringify::Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1893
namespace stringify {
    const char* Enclosing_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_Enclosing";
            case 1L: return "Enclosing_Element";
            case 2L: return "Enclosing_Unit";
            default: return "";
        }
    }

    std::string Enclosing_Kinds(int64_t i, const std::string &strip) {
        std::string s = Enclosing_Kinds(i);
        if (s.empty())
            s = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Enclosing_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyEnclosing_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Enclosing_Kinds(i);
        if (retval.empty()) {
            retval = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Enclosing_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEnclosing_Kinds() {
        return stringify::Enclosing_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 1945
namespace stringify {
    const char* Unit_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Unit";
            case 1L: return "A_Procedure";
            case 2L: return "A_Function";
            case 3L: return "A_Package";
            case 4L: return "A_Generic_Procedure";
            case 5L: return "A_Generic_Function";
            case 6L: return "A_Generic_Package";
            case 7L: return "A_Procedure_Instance";
            case 8L: return "A_Function_Instance";
            case 9L: return "A_Package_Instance";
            case 10L: return "A_Procedure_Renaming";
            case 11L: return "A_Function_Renaming";
            case 12L: return "A_Package_Renaming";
            case 13L: return "A_Generic_Procedure_Renaming";
            case 14L: return "A_Generic_Function_Renaming";
            case 15L: return "A_Generic_Package_Renaming";
            case 16L: return "A_Procedure_Body";
            case 17L: return "A_Function_Body";
            case 18L: return "A_Package_Body";
            case 19L: return "A_Procedure_Body_Subunit";
            case 20L: return "A_Function_Body_Subunit";
            case 21L: return "A_Package_Body_Subunit";
            case 22L: return "A_Task_Body_Subunit";
            case 23L: return "A_Protected_Body_Subunit";
            case 24L: return "A_Nonexistent_Declaration";
            case 25L: return "A_Nonexistent_Body";
            case 26L: return "A_Configuration_Compilation";
            case 27L: return "An_Unknown_Unit";
            default: return "";
        }
    }

    std::string Unit_Kinds(int64_t i, const std::string &strip) {
        std::string s = Unit_Kinds(i);
        if (s.empty())
            s = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Kinds(i);
        if (retval.empty()) {
            retval = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Kinds() {
        return stringify::Unit_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 2012
namespace stringify {
    const char* Unit_Classes(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Class";
            case 1L: return "A_Public_Declaration";
            case 2L: return "A_Public_Body";
            case 3L: return "A_Public_Declaration_And_Body";
            case 4L: return "A_Private_Declaration";
            case 5L: return "A_Private_Body";
            case 6L: return "A_Separate_Body";
            default: return "";
        }
    }

    std::string Unit_Classes(int64_t i, const std::string &strip) {
        std::string s = Unit_Classes(i);
        if (s.empty())
            s = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Classes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Classes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Classes(i);
        if (retval.empty()) {
            retval = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Classes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Classes() {
        return stringify::Unit_Classes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/a_nodes.h line 2033
namespace stringify {
    const char* Unit_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Origin";
            case 1L: return "A_Predefined_Unit";
            case 2L: return "An_Implementation_Unit";
            case 3L: return "An_Application_Unit";
            default: return "";
        }
    }

    std::string Unit_Origins(int64_t i, const std::string &strip) {
        std::string s = Unit_Origins(i);
        if (s.empty())
            s = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Origins(i);
        if (retval.empty()) {
            retval = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Origins() {
        return stringify::Unit_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/Reference.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Reference {
    const char* Granularity(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "ADDRESS";
            case 2L: return "INSTRUCTION";
            case 3L: return "BASIC_BLOCK";
            case 4L: return "FUNCTION";
            default: return "";
        }
    }

    std::string Granularity(int64_t i, const std::string &strip) {
        std::string s = Granularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Granularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ReferenceGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Reference::Granularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ReferenceGranularity() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/Modules.h line 46
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace BasicBlockCallback {
    const char* Termination(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE_DISCOVERY";
            case 1L: return "TERMINATE_NOW";
            case 2L: return "TERMINATE_PRIOR";
            default: return "";
        }
    }

    std::string Termination(int64_t i, const std::string &strip) {
        std::string s = Termination(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Termination() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/DataFlow.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace DataFlow { namespace DfCfgVertex {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "BBLOCK";
            case 1L: return "FAKED_CALL";
            case 2L: return "FUNCRET";
            case 3L: return "INDET";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/Partitioner.h line 1460
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Partitioner { namespace MayReturnVertexInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "INIT";
            case 1L: return "CALCULATING";
            case 2L: return "FINISHED";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/ModulesElf.h line 73
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace ModulesElf { namespace FixUndefinedSymbols {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 22
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Precision {
    const char* Level(int64_t i) {
        switch (i) {
            case 0L: return "LOW";
            case 1L: return "HIGH";
            default: return "";
        }
    }

    std::string Level(int64_t i, const std::string &strip) {
        std::string s = Level(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Level() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PrecisionLevel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Precision::Level::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PrecisionLevel() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace AllowParallelEdges {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 39
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* VertexType(int64_t i) {
        switch (i) {
            case 0L: return "V_BASIC_BLOCK";
            case 1L: return "V_UNDISCOVERED";
            case 2L: return "V_INDETERMINATE";
            case 3L: return "V_NONEXISTING";
            case 4L: return "V_USER_DEFINED";
            default: return "";
        }
    }

    std::string VertexType(int64_t i, const std::string &strip) {
        std::string s = VertexType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VertexType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2VertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::VertexType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::VertexType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2VertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::VertexType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "E_NORMAL";
            case 1L: return "E_FUNCTION_CALL";
            case 2L: return "E_FUNCTION_RETURN";
            case 3L: return "E_CALL_RETURN";
            case 4L: return "E_FUNCTION_XFER";
            case 5L: return "E_USER_DEFINED";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2EdgeType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 74
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* Confidence(int64_t i) {
        switch (i) {
            case 0L: return "ASSUMED";
            case 1L: return "PROVED";
            default: return "";
        }
    }

    std::string Confidence(int64_t i, const std::string &strip) {
        std::string s = Confidence(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Confidence() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2Confidence(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Confidence(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Confidence::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2Confidence() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Confidence();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 80
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 178
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* MemoryDataAdjustment(int64_t i) {
        switch (i) {
            case 0L: return "DATA_IS_CONSTANT";
            case 1L: return "DATA_IS_INITIALIZED";
            case 2L: return "DATA_NO_CHANGE";
            default: return "";
        }
    }

    std::string MemoryDataAdjustment(int64_t i, const std::string &strip) {
        std::string s = MemoryDataAdjustment(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryDataAdjustment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/BasicTypes.h line 263
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* FunctionReturnAnalysis(int64_t i) {
        switch (i) {
            case 0L: return "MAYRETURN_DEFAULT_YES";
            case 1L: return "MAYRETURN_DEFAULT_NO";
            case 2L: return "MAYRETURN_ALWAYS_YES";
            case 3L: return "MAYRETURN_ALWAYS_NO";
            default: return "";
        }
    }

    std::string FunctionReturnAnalysis(int64_t i, const std::string &strip) {
        std::string s = FunctionReturnAnalysis(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReturnAnalysis() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/Function.h line 42
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Function {
    const char* Ownership(int64_t i) {
        switch (i) {
            case 0L: return "OWN_UNOWNED";
            case 1L: return "OWN_EXPLICIT";
            case 2L: return "OWN_PROVISIONAL";
            default: return "";
        }
    }

    std::string Ownership(int64_t i, const std::string &strip) {
        std::string s = Ownership(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ownership() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionOwnership(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Function::Ownership::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionOwnership() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Partitioner2/CfgPath.h line 388
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Inliner {
    const char* HowInline(int64_t i) {
        switch (i) {
            case 0L: return "INLINE_NONE";
            case 1L: return "INLINE_NORMAL";
            case 2L: return "INLINE_USER";
            default: return "";
        }
    }

    std::string HowInline(int64_t i, const std::string &strip) {
        std::string s = HowInline(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HowInline() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2InlinerHowInline(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2InlinerHowInline() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/csharpBuilder.h line 10
namespace stringify { namespace csharp_translator {
    const char* SeqKind(int64_t i) {
        switch (i) {
            case 2L: return "GLOBALSCOPESEQ";
            case 3L: return "CLASSMEMBERSEQ";
            case 4L: return "PARAMETERSEQ";
            case 5L: return "METHODBODYSEQ";
            case 6L: return "EXPRLISTSEQ";
            case 7L: return "IFSTMT";
            case 8L: return "FORSTMT";
            case 9L: return "WHILESTMT";
            default: return "";
        }
    }

    std::string SeqKind(int64_t i, const std::string &strip) {
        std::string s = SeqKind(i);
        if (s.empty())
            s = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SeqKind() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_csharp_translatorSeqKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::csharp_translator::SeqKind(i);
        if (retval.empty()) {
            retval = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "csharp_translator::SeqKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_csharp_translatorSeqKind() {
        return stringify::csharp_translator::SeqKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/ast2dot.hpp line 11
namespace stringify { namespace dot {
    const char* attr_set(int64_t i) {
        switch (i) {
            case 0L: return "simple";
            case 1L: return "types";
            case 3L: return "moretypes";
            case 4L: return "decllinks";
            case 5L: return "balanced";
            case 8L: return "symbols";
            case 16L: return "builtins";
            case 31L: return "full";
            default: return "";
        }
    }

    std::string attr_set(int64_t i, const std::string &strip) {
        std::string s = attr_set(i);
        if (s.empty())
            s = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attr_set() {
        static const int64_t values[] = {
            0L,
            1L,
            3L,
            4L,
            5L,
            8L,
            16L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_dot_attr_set(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::dot::attr_set(i);
        if (retval.empty()) {
            retval = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "dot::attr_set::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_dot_attr_set() {
        return stringify::dot::attr_set();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 91
namespace stringify {
    const char* a_diag_fill_in_kind(int64_t i) {
        switch (i) {
            case 0L: return "dfk_number";
            case 1L: return "dfk_position";
            case 2L: return "dfk_string";
            case 3L: return "dfk_symbol";
            case 4L: return "dfk_type";
            case 5L: return "dfk_last";
            default: return "";
        }
    }

    std::string a_diag_fill_in_kind(int64_t i, const std::string &strip) {
        std::string s = a_diag_fill_in_kind(i);
        if (s.empty())
            s = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diag_fill_in_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diag_fill_in_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diag_fill_in_kind(i);
        if (retval.empty()) {
            retval = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diag_fill_in_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diag_fill_in_kind() {
        return stringify::a_diag_fill_in_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 196
namespace stringify {
    const char* a_diagnostic_kind(int64_t i) {
        switch (i) {
            case 0L: return "dck_primary";
            case 1L: return "dck_sub_message";
            case 2L: return "dck_context";
            case 3L: return "dck_macro_context";
            default: return "";
        }
    }

    std::string a_diagnostic_kind(int64_t i, const std::string &strip) {
        std::string s = a_diagnostic_kind(i);
        if (s.empty())
            s = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diagnostic_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diagnostic_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diagnostic_kind(i);
        if (retval.empty()) {
            retval = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diagnostic_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diagnostic_kind() {
        return stringify::a_diagnostic_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/lexical.h line 1949
namespace stringify {
    const char* a_token_extra_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "teik_none";
            case 1L: return "teik_identifier";
            case 2L: return "teik_constant";
            case 3L: return "teik_pragma";
            case 4L: return "teik_pp_token";
            case 5L: return "teik_extracted_body";
            case 6L: return "teik_asm_string";
            case 7L: return "teik_insert_string";
            case 8L: return "teik_ud_lit";
            default: return "";
        }
    }

    std::string a_token_extra_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_token_extra_info_kind_tag(i);
        if (s.empty())
            s = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_token_extra_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_token_extra_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_token_extra_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_token_extra_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_token_extra_info_kind_tag() {
        return stringify::a_token_extra_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/pragma.h line 49
namespace stringify {
    const char* a_pragma_binding_kind(int64_t i) {
        switch (i) {
            case 0L: return "pbk_none";
            case 1L: return "pbk_next_construct";
            case 2L: return "pbk_next_token";
            case 3L: return "pbk_immediate";
            case 4L: return "pbk_other";
            case 5L: return "pbk_preproc_immediate";
            case 6L: return "pbk_last";
            default: return "";
        }
    }

    std::string a_pragma_binding_kind(int64_t i, const std::string &strip) {
        std::string s = a_pragma_binding_kind(i);
        if (s.empty())
            s = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_binding_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_binding_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_binding_kind(i);
        if (retval.empty()) {
            retval = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_binding_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_binding_kind() {
        return stringify::a_pragma_binding_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/cp_gen_be.c line 94
namespace stringify {
    const char* a_type_mode_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tmk_none";
            default: return "";
        }
    }

    std::string a_type_mode_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_mode_kind_tag(i);
        if (s.empty())
            s = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_mode_kind_tag() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_mode_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_mode_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_mode_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_mode_kind_tag() {
        return stringify::a_type_mode_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/host_envir.h line 2370
namespace stringify {
    const char* a_unicode_source_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "usk_none";
            case 1L: return "usk_utf8";
            case 2L: return "usk_utf16LE";
            case 3L: return "usk_utf16BE";
            default: return "";
        }
    }

    std::string a_unicode_source_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_unicode_source_kind_tag(i);
        if (s.empty())
            s = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_unicode_source_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_unicode_source_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_unicode_source_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_unicode_source_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_unicode_source_kind_tag() {
        return stringify::a_unicode_source_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/host_envir.h line 3754
namespace stringify {
    const char* a_predef_macro_mode(int64_t i) {
        switch (i) {
            case 0L: return "pmm_none";
            case 1L: return "pmm_gnu";
            case 2L: return "pmm_gcc";
            case 3L: return "pmm_gpp";
            case 4L: return "pmm_clang";
            case 5L: return "pmm_clang_c";
            case 6L: return "pmm_clang_cpp";
            case 7L: return "pmm_gnu_or_clang";
            case 8L: return "pmm_microsoft";
            case 9L: return "pmm_strict";
            case 10L: return "pmm_cpp";
            case 11L: return "pmm_all";
            case 12L: return "pmm_last";
            default: return "";
        }
    }

    std::string a_predef_macro_mode(int64_t i, const std::string &strip) {
        std::string s = a_predef_macro_mode(i);
        if (s.empty())
            s = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_predef_macro_mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_predef_macro_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_predef_macro_mode(i);
        if (retval.empty()) {
            retval = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_predef_macro_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_predef_macro_mode() {
        return stringify::a_predef_macro_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/expr.h line 87
namespace stringify {
    const char* an_init_component_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ick_expression";
            case 1L: return "ick_braced";
            case 2L: return "ick_designator";
            case 3L: return "ick_continued";
            default: return "";
        }
    }

    std::string an_init_component_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_component_kind_tag(i);
        if (s.empty())
            s = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_component_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_component_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_component_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_component_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_component_kind_tag() {
        return stringify::an_init_component_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/mem_manage.h line 407
namespace stringify {
    const char* a_function_number_tag(int64_t i) {
        switch (i) {
            case 0L: return "fn_null";
            case 1L: return "fn_hash_attribute_kind";
            case 2L: return "fn_compare_for_attr_corresp_checking_map";
            case 3L: return "fn_hash_source_string";
            case 4L: return "fn_compare_for_attr_name_map";
            case 5L: return "fn_compare_for_asm_name_map";
            case 6L: return "fn_hash_include_search_result";
            case 7L: return "fn_compare_include_search_result";
            case 8L: return "fn_hash_include_file_history";
            case 9L: return "fn_compare_include_file_history";
            case 10L: return "fn_hash_unique_file_id_for_table";
            case 11L: return "fn_compare_unique_file_id";
            case 12L: return "fn_hash_include_alias";
            case 13L: return "fn_compare_include_alias";
            case 14L: return "fn_hash_instantiation";
            case 15L: return "fn_compare_instantiation";
            case 16L: return "fn_hash_prop_or_event_accessor_header_lookup";
            case 17L: return "fn_compare_prop_or_event_accessor_header_lookup";
            case 18L: return "fn_hash_symbol_header_lookup_entry";
            case 19L: return "fn_compare_symbol_header_lookup_entry";
            case 20L: return "fn_record_arg_pragma";
            case 21L: return "fn_instantiation_pragma";
            case 22L: return "fn_pack_pragma";
            case 23L: return "fn_ident_pragma";
            case 24L: return "fn_ident_directive";
            case 25L: return "fn_once_pragma";
            case 26L: return "fn_hdrstop_or_no_pch_pragma";
            case 27L: return "fn_define_type_info_pragma";
            case 28L: return "fn_stdc_pragma";
            case 29L: return "fn_upc_pragma";
            case 30L: return "fn_redefine_extname_pragma";
            case 31L: return "fn_ldscope_pragma";
            case 32L: return "fn_gcc_pragma";
            case 33L: return "fn_diag_pragma";
            case 34L: return "fn_test_immediate_pragma";
            case 35L: return "fn_test_next_construct_pragma";
            case 36L: return "fn_db_opt_pragma";
            case 37L: return "fn_db_name_pragma";
            case 38L: return "fn_if_exists_pragma";
            case 39L: return "fn_push_macro_pragma";
            case 40L: return "fn_pop_macro_pragma";
            case 41L: return "fn_microsoft_start_map_region_pragma";
            case 42L: return "fn_microsoft_stop_map_region_pragma";
            case 43L: return "fn_setlocale_pragma";
            case 44L: return "fn_microsoft_comment_pragma";
            case 45L: return "fn_microsoft_conform_pragma";
            case 46L: return "fn_microsoft_include_alias_pragma";
            case 47L: return "fn_hash_unresolved_type_map_key";
            case 48L: return "fn_compare_for_unresolved_type_map";
            case 49L: return "fn_hash_void_pointer";
            case 50L: return "fn_compare_for_pointer_pair_map";
            case 51L: return "fn_compare_substituted_type_list_entry";
            case 52L: return "fn_hash_token_sequence_xref";
            case 53L: return "fn_compare_token_sequence_xref";
            case 54L: return "fn_last";
            default: return "";
        }
    }

    std::string a_function_number_tag(int64_t i, const std::string &strip) {
        std::string s = a_function_number_tag(i);
        if (s.empty())
            s = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_function_number_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_function_number_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_function_number_tag(i);
        if (retval.empty()) {
            retval = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_function_number_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_function_number_tag() {
        return stringify::a_function_number_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 1031
namespace stringify { namespace a_type_wrapper {
    const char* a_kind(int64_t i) {
        switch (i) {
            case 0L: return "twk_invalid";
            case 1L: return "twk_void";
            case 2L: return "twk_cxx_udt_return";
            case 3L: return "twk_copy_ctor";
            case 4L: return "twk_bool";
            case 5L: return "twk_char";
            case 6L: return "twk_signed_char";
            case 7L: return "twk_unsigned_char";
            case 8L: return "twk_short";
            case 9L: return "twk_unsigned_short";
            case 10L: return "twk_wchar_t";
            case 11L: return "twk_int";
            case 12L: return "twk_unsigned_int";
            case 13L: return "twk_long";
            case 14L: return "twk_unsigned_long";
            case 15L: return "twk_long_long";
            case 16L: return "twk_unsigned_long_long";
            case 17L: return "twk_float";
            case 18L: return "twk_double";
            case 19L: return "twk_long_double";
            case 20L: return "twk_class";
            case 21L: return "twk_array";
            case 22L: return "twk_indirection";
            case 23L: return "twk_function";
            default: return "";
        }
    }

    std::string a_kind(int64_t i, const std::string &strip) {
        std::string s = a_kind(i);
        if (s.empty())
            s = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_wrapper_a_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_wrapper::a_kind(i);
        if (retval.empty()) {
            retval = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_wrapper::a_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_wrapper_a_kind() {
        return stringify::a_type_wrapper::a_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 1292
namespace stringify { namespace a_class_type_wrapper {
    const char* a_class_kind(int64_t i) {
        switch (i) {
            case 0L: return "ck_invalid";
            case 1L: return "ck_unresolved";
            case 2L: return "ck_class";
            case 3L: return "ck_generic_parameter";
            default: return "";
        }
    }

    std::string a_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_class_kind(i);
        if (s.empty())
            s = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_class_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_class_type_wrapper_a_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_class_type_wrapper::a_class_kind(i);
        if (retval.empty()) {
            retval = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_class_type_wrapper::a_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_class_type_wrapper_a_class_kind() {
        return stringify::a_class_type_wrapper::a_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 1413
namespace stringify { namespace a_type_indirection {
    const char* an_indirection_kind(int64_t i) {
        switch (i) {
            case 0L: return "tik_invalid";
            case 1L: return "tik_pointer";
            case 2L: return "tik_interior_pointer";
            case 3L: return "tik_handle";
            case 4L: return "tik_reference";
            case 5L: return "tik_rvalue_reference";
            case 6L: return "tik_tracking_reference";
            case 7L: return "tik_tentative_byref";
            default: return "";
        }
    }

    std::string an_indirection_kind(int64_t i, const std::string &strip) {
        std::string s = an_indirection_kind(i);
        if (s.empty())
            s = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_indirection_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_indirection_an_indirection_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_indirection::an_indirection_kind(i);
        if (retval.empty()) {
            retval = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_indirection::an_indirection_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_indirection_an_indirection_kind() {
        return stringify::a_type_indirection::an_indirection_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 1565
namespace stringify { namespace an_array_type_wrapper {
    const char* an_array_kind(int64_t i) {
        switch (i) {
            case 0L: return "ak_invalid";
            case 1L: return "ak_array";
            case 2L: return "ak_param_array";
            case 3L: return "ak_write_only_array";
            default: return "";
        }
    }

    std::string an_array_kind(int64_t i, const std::string &strip) {
        std::string s = an_array_kind(i);
        if (s.empty())
            s = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_array_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_array_type_wrapper_an_array_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_array_type_wrapper::an_array_kind(i);
        if (retval.empty()) {
            retval = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_array_type_wrapper::an_array_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_array_type_wrapper_an_array_kind() {
        return stringify::an_array_type_wrapper::an_array_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 3806
namespace stringify { namespace an_accessibility {
    const char* access_kind(int64_t i) {
        switch (i) {
            case 0L: return "access_unknown";
            case 1L: return "access_none";
            case 2L: return "access_private";
            case 3L: return "access_imported_private";
            case 4L: return "access_private_as_friend";
            case 5L: return "access_family_and_assembly";
            case 6L: return "access_imported_family_and_assembly";
            case 7L: return "access_family_and_assembly_as_friend";
            case 8L: return "access_assembly";
            case 9L: return "access_imported_assembly";
            case 10L: return "access_assembly_as_friend";
            case 11L: return "access_family";
            case 12L: return "access_family_or_assembly";
            case 13L: return "access_family_or_assembly_as_friend";
            case 14L: return "access_public";
            default: return "";
        }
    }

    std::string access_kind(int64_t i, const std::string &strip) {
        std::string s = access_kind(i);
        if (s.empty())
            s = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_accessibility_access_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_accessibility::access_kind(i);
        if (retval.empty()) {
            retval = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_accessibility::access_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_accessibility_access_kind() {
        return stringify::an_accessibility::access_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.cpp line 3845
namespace stringify { namespace a_type_definition {
    const char* a_type_definition_kind(int64_t i) {
        switch (i) {
            case 0L: return "tdk_unknown";
            case 1L: return "tdk_ref_class";
            case 2L: return "tdk_interface_class";
            case 3L: return "tdk_value_class";
            case 4L: return "tdk_enum_class";
            case 5L: return "tdk_delegate";
            case 6L: return "tdk_native_class";
            case 7L: return "tdk_native_enum";
            default: return "";
        }
    }

    std::string a_type_definition_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_definition_kind(i);
        if (s.empty())
            s = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_definition_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_definition_a_type_definition_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_definition::a_type_definition_kind(i);
        if (retval.empty()) {
            retval = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_definition::a_type_definition_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_definition_a_type_definition_kind() {
        return stringify::a_type_definition::a_type_definition_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/builtin_defs.h line 22
namespace stringify {
    const char* a_builtin_function_type_index(int64_t i) {
        switch (i) {
            case 0L: return "bfti_000db6619e";
            case 1L: return "bfti_001e209a45";
            case 2L: return "bfti_003d6de10d";
            case 3L: return "bfti_003fa00724";
            case 4L: return "bfti_0056490ab6";
            case 5L: return "bfti_0063dc7557";
            case 6L: return "bfti_00a69d8b4b";
            case 7L: return "bfti_00cce8bfc5";
            case 8L: return "bfti_00d9b248c7";
            case 9L: return "bfti_00f5fef98c";
            case 10L: return "bfti_013bed6256";
            case 11L: return "bfti_018e095f15";
            case 12L: return "bfti_019980e3fc";
            case 13L: return "bfti_01a390af99";
            case 14L: return "bfti_01b5072cbd";
            case 15L: return "bfti_01ed60f438";
            case 16L: return "bfti_02075a7818";
            case 17L: return "bfti_021feda6a2";
            case 18L: return "bfti_0261491605";
            case 19L: return "bfti_02a7d41178";
            case 20L: return "bfti_02b5a15283";
            case 21L: return "bfti_02e6f23732";
            case 22L: return "bfti_03aa168638";
            case 23L: return "bfti_03d5cb95bf";
            case 24L: return "bfti_03ea8a6e53";
            case 25L: return "bfti_04022dca7a";
            case 26L: return "bfti_041f722932";
            case 27L: return "bfti_0438d503e1";
            case 28L: return "bfti_043f0f6bdd";
            case 29L: return "bfti_049f994f52";
            case 30L: return "bfti_04a02a19bd";
            case 31L: return "bfti_050f43759e";
            case 32L: return "bfti_053aad4f6b";
            case 33L: return "bfti_054ab132f8";
            case 34L: return "bfti_0553518b14";
            case 35L: return "bfti_05db792456";
            case 36L: return "bfti_05f212d199";
            case 37L: return "bfti_0635a955f7";
            case 38L: return "bfti_06786e9f2b";
            case 39L: return "bfti_069e99e161";
            case 40L: return "bfti_06c519c321";
            case 41L: return "bfti_06ee14db2f";
            case 42L: return "bfti_06f1e4b6db";
            case 43L: return "bfti_072a41f47f";
            case 44L: return "bfti_073f5e849d";
            case 45L: return "bfti_076d9dc90a";
            case 46L: return "bfti_076e140dd7";
            case 47L: return "bfti_07734d6839";
            case 48L: return "bfti_078c102556";
            case 49L: return "bfti_079010e56c";
            case 50L: return "bfti_0792fee631";
            case 51L: return "bfti_079f4de5a6";
            case 52L: return "bfti_07c96ecc2b";
            case 53L: return "bfti_07cec8b399";
            case 54L: return "bfti_08224e710e";
            case 55L: return "bfti_0829edf422";
            case 56L: return "bfti_083d2d8dcd";
            case 57L: return "bfti_08550e996a";
            case 58L: return "bfti_0878a3dbd1";
            case 59L: return "bfti_087be52f11";
            case 60L: return "bfti_088bc89552";
            case 61L: return "bfti_08aba71b16";
            case 62L: return "bfti_08d2223f23";
            case 63L: return "bfti_08d56cfd51";
            case 64L: return "bfti_08f83fcc74";
            case 65L: return "bfti_094a4a928e";
            case 66L: return "bfti_09629c2306";
            case 67L: return "bfti_09671bacac";
            case 68L: return "bfti_096a3b13bd";
            case 69L: return "bfti_0973c161e2";
            case 70L: return "bfti_0997187e9a";
            case 71L: return "bfti_09cc70d50c";
            case 72L: return "bfti_09fbe2b5e1";
            case 73L: return "bfti_0a19a2d5c0";
            case 74L: return "bfti_0a1fae4344";
            case 75L: return "bfti_0a2e9f10a4";
            case 76L: return "bfti_0a4a1950d1";
            case 77L: return "bfti_0ab459d8f9";
            case 78L: return "bfti_0ad0083bce";
            case 79L: return "bfti_0ae7c3c252";
            case 80L: return "bfti_0b144dbb6d";
            case 81L: return "bfti_0b1a7c543d";
            case 82L: return "bfti_0b493e41c9";
            case 83L: return "bfti_0b646cddc6";
            case 84L: return "bfti_0b667519de";
            case 85L: return "bfti_0b875308d0";
            case 86L: return "bfti_0bb7f15d41";
            case 87L: return "bfti_0bcb8b17b5";
            case 88L: return "bfti_0bce84f3ab";
            case 89L: return "bfti_0bd530539f";
            case 90L: return "bfti_0bdff635b8";
            case 91L: return "bfti_0c0e8645bc";
            case 92L: return "bfti_0c1ce1dbd8";
            case 93L: return "bfti_0c48dcecd8";
            case 94L: return "bfti_0cd91d57ab";
            case 95L: return "bfti_0ceb38c49d";
            case 96L: return "bfti_0d2af5ce76";
            case 97L: return "bfti_0d44f81ccc";
            case 98L: return "bfti_0d584dbeaa";
            case 99L: return "bfti_0d6f1fdfcb";
            case 100L: return "bfti_0d7ec2a155";
            case 101L: return "bfti_0d9a31fcc7";
            case 102L: return "bfti_0da2b2ac63";
            case 103L: return "bfti_0da3b4892e";
            case 104L: return "bfti_0dac31fc8d";
            case 105L: return "bfti_0ddee3dcb1";
            case 106L: return "bfti_0dfa3c8404";
            case 107L: return "bfti_0e3fefe412";
            case 108L: return "bfti_0e4fd898c7";
            case 109L: return "bfti_0e6a4e2beb";
            case 110L: return "bfti_0e7894567a";
            case 111L: return "bfti_0e89e8268b";
            case 112L: return "bfti_0e9b9d2319";
            case 113L: return "bfti_0eadfe1dba";
            case 114L: return "bfti_0ee8659d68";
            case 115L: return "bfti_0ee9cb5436";
            case 116L: return "bfti_0f097d6f7e";
            case 117L: return "bfti_0f2fd6445b";
            case 118L: return "bfti_0f3903a67e";
            case 119L: return "bfti_0f54e1c803";
            case 120L: return "bfti_0f61c53ab9";
            case 121L: return "bfti_0f9efae8ce";
            case 122L: return "bfti_0fa4f4bf2b";
            case 123L: return "bfti_0fb2ceae5f";
            case 124L: return "bfti_0fc006bdcc";
            case 125L: return "bfti_0fedb54ba6";
            case 126L: return "bfti_10275706e1";
            case 127L: return "bfti_1041c6a791";
            case 128L: return "bfti_106f9cad20";
            case 129L: return "bfti_10ac05c17e";
            case 130L: return "bfti_10deec183f";
            case 131L: return "bfti_10e2a64785";
            case 132L: return "bfti_110084a10b";
            case 133L: return "bfti_11a957515b";
            case 134L: return "bfti_11ab1a3a1f";
            case 135L: return "bfti_11bf806960";
            case 136L: return "bfti_11ef997505";
            case 137L: return "bfti_11f28b741a";
            case 138L: return "bfti_12489ae6ff";
            case 139L: return "bfti_12a19d76dc";
            case 140L: return "bfti_12e249d08f";
            case 141L: return "bfti_133b9a35bb";
            case 142L: return "bfti_1345213053";
            case 143L: return "bfti_135c501a56";
            case 144L: return "bfti_1363dd796e";
            case 145L: return "bfti_138d138eb0";
            case 146L: return "bfti_13cacdc41f";
            case 147L: return "bfti_13d1000887";
            case 148L: return "bfti_13d9a0dfac";
            case 149L: return "bfti_13f171890a";
            case 150L: return "bfti_1429007ea9";
            case 151L: return "bfti_144f9138f1";
            case 152L: return "bfti_14854d240b";
            case 153L: return "bfti_14970992c6";
            case 154L: return "bfti_14a0812d09";
            case 155L: return "bfti_14edb45f9a";
            case 156L: return "bfti_14f74930d4";
            case 157L: return "bfti_157092cbcc";
            case 158L: return "bfti_1579595730";
            case 159L: return "bfti_1594b1776b";
            case 160L: return "bfti_15b201edad";
            case 161L: return "bfti_15c82d0793";
            case 162L: return "bfti_15d5e0e930";
            case 163L: return "bfti_15fe1865b6";
            case 164L: return "bfti_16083eecf1";
            case 165L: return "bfti_16232d7f39";
            case 166L: return "bfti_1623a621a8";
            case 167L: return "bfti_164fee816a";
            case 168L: return "bfti_165e80e4d0";
            case 169L: return "bfti_166ba9bb06";
            case 170L: return "bfti_16835c8cb2";
            case 171L: return "bfti_16844cfcaa";
            case 172L: return "bfti_16c5c386dd";
            case 173L: return "bfti_16c5d1ee97";
            case 174L: return "bfti_16d2dd0c23";
            case 175L: return "bfti_16d896f164";
            case 176L: return "bfti_16e6ce0874";
            case 177L: return "bfti_172d4ded1c";
            case 178L: return "bfti_1746cd3964";
            case 179L: return "bfti_17655780d3";
            case 180L: return "bfti_177cb42b60";
            case 181L: return "bfti_17abda1ad3";
            case 182L: return "bfti_17fe3e6ec9";
            case 183L: return "bfti_1804314289";
            case 184L: return "bfti_180cd5420b";
            case 185L: return "bfti_181ccc9767";
            case 186L: return "bfti_183bb9fd6f";
            case 187L: return "bfti_183cc632bc";
            case 188L: return "bfti_1855e653cb";
            case 189L: return "bfti_1861131fba";
            case 190L: return "bfti_18ba52f8d5";
            case 191L: return "bfti_18d42eabcb";
            case 192L: return "bfti_18e2a741d3";
            case 193L: return "bfti_18e72fe806";
            case 194L: return "bfti_1902b04093";
            case 195L: return "bfti_19243598d1";
            case 196L: return "bfti_19372dee47";
            case 197L: return "bfti_19856b98b2";
            case 198L: return "bfti_19ac9c70e8";
            case 199L: return "bfti_1a03221fa2";
            case 200L: return "bfti_1a1ed1aeb3";
            case 201L: return "bfti_1a53f11758";
            case 202L: return "bfti_1a82453c56";
            case 203L: return "bfti_1aa81332d2";
            case 204L: return "bfti_1aa8f02153";
            case 205L: return "bfti_1aad43899a";
            case 206L: return "bfti_1af3646a6f";
            case 207L: return "bfti_1afd5d7557";
            case 208L: return "bfti_1b09479a2c";
            case 209L: return "bfti_1b36b7dd5d";
            case 210L: return "bfti_1b4c3772a3";
            case 211L: return "bfti_1b8490292a";
            case 212L: return "bfti_1b8b4142f0";
            case 213L: return "bfti_1bd10470e2";
            case 214L: return "bfti_1bd7c59031";
            case 215L: return "bfti_1c5d3c4cd6";
            case 216L: return "bfti_1c6b8b4074";
            case 217L: return "bfti_1c989dc11b";
            case 218L: return "bfti_1ca724dbdf";
            case 219L: return "bfti_1ccf5477ea";
            case 220L: return "bfti_1cdcc627f2";
            case 221L: return "bfti_1cf7409a55";
            case 222L: return "bfti_1d1d7d60fb";
            case 223L: return "bfti_1d4e5c82bc";
            case 224L: return "bfti_1d6e6627e3";
            case 225L: return "bfti_1dafa7d608";
            case 226L: return "bfti_1db66d695f";
            case 227L: return "bfti_1dc718c508";
            case 228L: return "bfti_1e17a03d28";
            case 229L: return "bfti_1e1aad424d";
            case 230L: return "bfti_1e1b3b7da0";
            case 231L: return "bfti_1e1daf59c4";
            case 232L: return "bfti_1e5188cc74";
            case 233L: return "bfti_1e72c68fe4";
            case 234L: return "bfti_1e7863e94a";
            case 235L: return "bfti_1e7ee3d778";
            case 236L: return "bfti_1e91885a56";
            case 237L: return "bfti_1e9c717db7";
            case 238L: return "bfti_1ea1135519";
            case 239L: return "bfti_1ed174492c";
            case 240L: return "bfti_1f119532c8";
            case 241L: return "bfti_1f545dde45";
            case 242L: return "bfti_1f5e04cb20";
            case 243L: return "bfti_1f5fbc696e";
            case 244L: return "bfti_1f6f079742";
            case 245L: return "bfti_1fe349f6d3";
            case 246L: return "bfti_202b5991f4";
            case 247L: return "bfti_2041624b53";
            case 248L: return "bfti_204ca5bac5";
            case 249L: return "bfti_2071e2464d";
            case 250L: return "bfti_20a5af4621";
            case 251L: return "bfti_20c87514ce";
            case 252L: return "bfti_20d4922265";
            case 253L: return "bfti_20db90a2f5";
            case 254L: return "bfti_21184779dc";
            case 255L: return "bfti_212b0b9eab";
            case 256L: return "bfti_212fc8185d";
            case 257L: return "bfti_2161a8acff";
            case 258L: return "bfti_217015e55d";
            case 259L: return "bfti_21aa5fec2d";
            case 260L: return "bfti_21aa7c5185";
            case 261L: return "bfti_21b6466dcf";
            case 262L: return "bfti_21e71befc5";
            case 263L: return "bfti_220cfa4d95";
            case 264L: return "bfti_22228caa6f";
            case 265L: return "bfti_222b95de68";
            case 266L: return "bfti_2238731621";
            case 267L: return "bfti_224444a7fd";
            case 268L: return "bfti_224d69c947";
            case 269L: return "bfti_226ae106f4";
            case 270L: return "bfti_22b228fcd9";
            case 271L: return "bfti_22fdc9ba40";
            case 272L: return "bfti_2309315d4d";
            case 273L: return "bfti_231195c162";
            case 274L: return "bfti_2342d8ed5d";
            case 275L: return "bfti_234978f903";
            case 276L: return "bfti_235ac0fe86";
            case 277L: return "bfti_235d6c3e2c";
            case 278L: return "bfti_23c0dca960";
            case 279L: return "bfti_23d48c14f7";
            case 280L: return "bfti_23ee1d49bd";
            case 281L: return "bfti_23f8b1cc1d";
            case 282L: return "bfti_240db23826";
            case 283L: return "bfti_24124c69a5";
            case 284L: return "bfti_2417476ffe";
            case 285L: return "bfti_2421c7878b";
            case 286L: return "bfti_242803315b";
            case 287L: return "bfti_244ed5fe2c";
            case 288L: return "bfti_24620a103e";
            case 289L: return "bfti_2478fe37ff";
            case 290L: return "bfti_247f8d5dee";
            case 291L: return "bfti_2498af02d8";
            case 292L: return "bfti_24a17495d6";
            case 293L: return "bfti_24b66da9c1";
            case 294L: return "bfti_24e889906c";
            case 295L: return "bfti_24f4753ab4";
            case 296L: return "bfti_2526a73369";
            case 297L: return "bfti_25272939f9";
            case 298L: return "bfti_2566557da0";
            case 299L: return "bfti_259a571579";
            case 300L: return "bfti_25b669ecaa";
            case 301L: return "bfti_25d14c1b7c";
            case 302L: return "bfti_25d623a33d";
            case 303L: return "bfti_25e8ab162e";
            case 304L: return "bfti_260558396a";
            case 305L: return "bfti_266990a8bb";
            case 306L: return "bfti_26cab0e481";
            case 307L: return "bfti_26cbc3eb59";
            case 308L: return "bfti_26d251ab8e";
            case 309L: return "bfti_26fcc50d0f";
            case 310L: return "bfti_2714b3ad29";
            case 311L: return "bfti_272295074f";
            case 312L: return "bfti_273c13de41";
            case 313L: return "bfti_27409c86f3";
            case 314L: return "bfti_2761d18f84";
            case 315L: return "bfti_277b297420";
            case 316L: return "bfti_27802a1e54";
            case 317L: return "bfti_278282b6d8";
            case 318L: return "bfti_27b4d59c87";
            case 319L: return "bfti_2817fc3990";
            case 320L: return "bfti_281e73f96d";
            case 321L: return "bfti_2820c907ec";
            case 322L: return "bfti_282b8bb919";
            case 323L: return "bfti_2832191c17";
            case 324L: return "bfti_2838f64533";
            case 325L: return "bfti_2880c3fb37";
            case 326L: return "bfti_28ac9e657f";
            case 327L: return "bfti_28afb5604b";
            case 328L: return "bfti_28e5df3f2d";
            case 329L: return "bfti_28f33d91de";
            case 330L: return "bfti_28f9dc7344";
            case 331L: return "bfti_290357eb1d";
            case 332L: return "bfti_297367ee56";
            case 333L: return "bfti_297ac95dc2";
            case 334L: return "bfti_29df303b2a";
            case 335L: return "bfti_29f1d32960";
            case 336L: return "bfti_2a0b6e540b";
            case 337L: return "bfti_2a1787a280";
            case 338L: return "bfti_2a7d61e66a";
            case 339L: return "bfti_2ab6fad262";
            case 340L: return "bfti_2abc32c8df";
            case 341L: return "bfti_2ad4106e0d";
            case 342L: return "bfti_2b087e7d18";
            case 343L: return "bfti_2b09870e84";
            case 344L: return "bfti_2b2a43cb09";
            case 345L: return "bfti_2b3f6c3302";
            case 346L: return "bfti_2b6c384072";
            case 347L: return "bfti_2b8f4eb0ca";
            case 348L: return "bfti_2bcc8a204b";
            case 349L: return "bfti_2bd9265718";
            case 350L: return "bfti_2c1300f922";
            case 351L: return "bfti_2c20414721";
            case 352L: return "bfti_2c5fc38c7b";
            case 353L: return "bfti_2c904955e6";
            case 354L: return "bfti_2c99316882";
            case 355L: return "bfti_2c9b734dbf";
            case 356L: return "bfti_2c9e0ab48f";
            case 357L: return "bfti_2ca344f3b8";
            case 358L: return "bfti_2cc508f1f7";
            case 359L: return "bfti_2cca3f2760";
            case 360L: return "bfti_2cd13b956a";
            case 361L: return "bfti_2ce9808990";
            case 362L: return "bfti_2cfc52d1ad";
            case 363L: return "bfti_2d0e87f00a";
            case 364L: return "bfti_2d4097d376";
            case 365L: return "bfti_2d493c24d7";
            case 366L: return "bfti_2d6ffd7c91";
            case 367L: return "bfti_2d7eb42a37";
            case 368L: return "bfti_2da1a95297";
            case 369L: return "bfti_2dbdc9ab22";
            case 370L: return "bfti_2de4fa95b7";
            case 371L: return "bfti_2e0abffd7b";
            case 372L: return "bfti_2e160ce4fc";
            case 373L: return "bfti_2e2cf8ce97";
            case 374L: return "bfti_2e7326905b";
            case 375L: return "bfti_2e77b0dad8";
            case 376L: return "bfti_2eb68153fb";
            case 377L: return "bfti_2ee41c62cf";
            case 378L: return "bfti_2f25d8b1b4";
            case 379L: return "bfti_2f26d8ab17";
            case 380L: return "bfti_2f2c340741";
            case 381L: return "bfti_2f3af666a6";
            case 382L: return "bfti_2f80c5a85b";
            case 383L: return "bfti_2f815c605e";
            case 384L: return "bfti_2f8f306fb1";
            case 385L: return "bfti_2fb59735b3";
            case 386L: return "bfti_2fc9b972de";
            case 387L: return "bfti_2fe793f356";
            case 388L: return "bfti_2ff7822286";
            case 389L: return "bfti_3065534615";
            case 390L: return "bfti_3077ebe9e0";
            case 391L: return "bfti_30afc18be7";
            case 392L: return "bfti_30d166a274";
            case 393L: return "bfti_30f8b7f7a5";
            case 394L: return "bfti_315ecf6dc3";
            case 395L: return "bfti_31644d2fb2";
            case 396L: return "bfti_318f92063d";
            case 397L: return "bfti_319eafd31d";
            case 398L: return "bfti_31d077a664";
            case 399L: return "bfti_32088d8163";
            case 400L: return "bfti_32136ef373";
            case 401L: return "bfti_322956ccf0";
            case 402L: return "bfti_3248e36e71";
            case 403L: return "bfti_3285875503";
            case 404L: return "bfti_3297c9cf8d";
            case 405L: return "bfti_32ab7102de";
            case 406L: return "bfti_32c3a3055f";
            case 407L: return "bfti_32c70784fc";
            case 408L: return "bfti_32f1e3b7da";
            case 409L: return "bfti_32f35d75ce";
            case 410L: return "bfti_32fd940ac7";
            case 411L: return "bfti_3329d4c20c";
            case 412L: return "bfti_33b09ff8e8";
            case 413L: return "bfti_33c7f0cd4c";
            case 414L: return "bfti_33cb510d37";
            case 415L: return "bfti_33f43e6d23";
            case 416L: return "bfti_33f4552478";
            case 417L: return "bfti_34327292b3";
            case 418L: return "bfti_344272427c";
            case 419L: return "bfti_3442f023a1";
            case 420L: return "bfti_34492eaf8c";
            case 421L: return "bfti_3468fb73ca";
            case 422L: return "bfti_3472aee82a";
            case 423L: return "bfti_3477445486";
            case 424L: return "bfti_34814e8652";
            case 425L: return "bfti_34a545e62d";
            case 426L: return "bfti_34a63c7ea4";
            case 427L: return "bfti_35311cafb8";
            case 428L: return "bfti_3585c2985e";
            case 429L: return "bfti_359ab02841";
            case 430L: return "bfti_35b3447b04";
            case 431L: return "bfti_35c69b7855";
            case 432L: return "bfti_35d4f7e96f";
            case 433L: return "bfti_35f2899b52";
            case 434L: return "bfti_35ff8de1a8";
            case 435L: return "bfti_361617e5d8";
            case 436L: return "bfti_3629449bd9";
            case 437L: return "bfti_363dec7adf";
            case 438L: return "bfti_36610ed3e3";
            case 439L: return "bfti_366b60a9ae";
            case 440L: return "bfti_36702b92bb";
            case 441L: return "bfti_3675b7642c";
            case 442L: return "bfti_36dd12046d";
            case 443L: return "bfti_36fc5336c4";
            case 444L: return "bfti_374a046371";
            case 445L: return "bfti_37501c21c3";
            case 446L: return "bfti_3771c33244";
            case 447L: return "bfti_377eab1137";
            case 448L: return "bfti_3798b2fc0c";
            case 449L: return "bfti_37b2dee55d";
            case 450L: return "bfti_37d8ed8ff2";
            case 451L: return "bfti_37f3160927";
            case 452L: return "bfti_387cc159a8";
            case 453L: return "bfti_388523c7c7";
            case 454L: return "bfti_388c1c59ae";
            case 455L: return "bfti_388c979dc2";
            case 456L: return "bfti_38f0e7ad6f";
            case 457L: return "bfti_3900d90676";
            case 458L: return "bfti_39516bd715";
            case 459L: return "bfti_395554f443";
            case 460L: return "bfti_3981d04884";
            case 461L: return "bfti_3991fc513c";
            case 462L: return "bfti_39b13e8b07";
            case 463L: return "bfti_39d283f70e";
            case 464L: return "bfti_39de673ebd";
            case 465L: return "bfti_39e4ecdfd9";
            case 466L: return "bfti_3a36ec7a93";
            case 467L: return "bfti_3a4518ce54";
            case 468L: return "bfti_3a5388b465";
            case 469L: return "bfti_3aa20e919e";
            case 470L: return "bfti_3abb0346ea";
            case 471L: return "bfti_3acb137cf2";
            case 472L: return "bfti_3ae136b830";
            case 473L: return "bfti_3c1345f125";
            case 474L: return "bfti_3c3cba7786";
            case 475L: return "bfti_3c4777897f";
            case 476L: return "bfti_3c643bfab6";
            case 477L: return "bfti_3c73745a2e";
            case 478L: return "bfti_3c95dd4ddf";
            case 479L: return "bfti_3ca5ad7d5f";
            case 480L: return "bfti_3ceee99c80";
            case 481L: return "bfti_3d27d748e8";
            case 482L: return "bfti_3d6b046bc9";
            case 483L: return "bfti_3d75148905";
            case 484L: return "bfti_3d94720c77";
            case 485L: return "bfti_3dcf5021c2";
            case 486L: return "bfti_3ddbc292a4";
            case 487L: return "bfti_3df37a15b3";
            case 488L: return "bfti_3e4e552e80";
            case 489L: return "bfti_3e5cc7cedf";
            case 490L: return "bfti_3e67bcdeb4";
            case 491L: return "bfti_3e71f41b7a";
            case 492L: return "bfti_3e8cd1e1d9";
            case 493L: return "bfti_3e8e103c62";
            case 494L: return "bfti_3e922cf548";
            case 495L: return "bfti_3e9282df2c";
            case 496L: return "bfti_3ea2f12fd2";
            case 497L: return "bfti_3eba34f35e";
            case 498L: return "bfti_3ed06857c3";
            case 499L: return "bfti_3eeb86a455";
            case 500L: return "bfti_3f324d93cd";
            case 501L: return "bfti_3f3402878e";
            case 502L: return "bfti_3f3db6ce76";
            case 503L: return "bfti_3f6b32d7bf";
            case 504L: return "bfti_3f8bcd7340";
            case 505L: return "bfti_3fc94965ed";
            case 506L: return "bfti_3fed034f7c";
            case 507L: return "bfti_3ff25f2d91";
            case 508L: return "bfti_3ff34ff33d";
            case 509L: return "bfti_3ffbfacfc3";
            case 510L: return "bfti_403582992a";
            case 511L: return "bfti_403da3b35d";
            case 512L: return "bfti_4040f84db6";
            case 513L: return "bfti_404e40353f";
            case 514L: return "bfti_40673eee8c";
            case 515L: return "bfti_406c4ea7b8";
            case 516L: return "bfti_40b7bd1bcb";
            case 517L: return "bfti_40f3baab83";
            case 518L: return "bfti_41081d5062";
            case 519L: return "bfti_412f071fcd";
            case 520L: return "bfti_41600a9f86";
            case 521L: return "bfti_41637b73d6";
            case 522L: return "bfti_417031a38a";
            case 523L: return "bfti_4170d01296";
            case 524L: return "bfti_417549c2e6";
            case 525L: return "bfti_417bedfde4";
            case 526L: return "bfti_41869691ac";
            case 527L: return "bfti_41b96e589f";
            case 528L: return "bfti_421fdb32b1";
            case 529L: return "bfti_423721d757";
            case 530L: return "bfti_426ef947ad";
            case 531L: return "bfti_427b820ade";
            case 532L: return "bfti_4284ce7dcf";
            case 533L: return "bfti_428e410b8a";
            case 534L: return "bfti_4295aa69ff";
            case 535L: return "bfti_42a2c403b7";
            case 536L: return "bfti_42bd796283";
            case 537L: return "bfti_4307049193";
            case 538L: return "bfti_4352a2daf7";
            case 539L: return "bfti_4364615e0d";
            case 540L: return "bfti_4373ab6d1b";
            case 541L: return "bfti_4373d64d40";
            case 542L: return "bfti_4378888800";
            case 543L: return "bfti_437ce74e1e";
            case 544L: return "bfti_43a0acf2a4";
            case 545L: return "bfti_43d3b793d2";
            case 546L: return "bfti_43faf6d454";
            case 547L: return "bfti_4403f83dae";
            case 548L: return "bfti_44110a9e5d";
            case 549L: return "bfti_444abf4183";
            case 550L: return "bfti_44596024fc";
            case 551L: return "bfti_44a2a2ae3b";
            case 552L: return "bfti_44dffe79e7";
            case 553L: return "bfti_44edf9602f";
            case 554L: return "bfti_45400bfcdc";
            case 555L: return "bfti_455973f3f6";
            case 556L: return "bfti_45638abfb1";
            case 557L: return "bfti_457426a792";
            case 558L: return "bfti_458a3f0142";
            case 559L: return "bfti_45908ace6e";
            case 560L: return "bfti_45e1492dcb";
            case 561L: return "bfti_4602dc1244";
            case 562L: return "bfti_46102dcf72";
            case 563L: return "bfti_463c502e30";
            case 564L: return "bfti_46659d9534";
            case 565L: return "bfti_46ae6ba4d6";
            case 566L: return "bfti_46d26eb3a8";
            case 567L: return "bfti_46d4fe894d";
            case 568L: return "bfti_474dc5fc8a";
            case 569L: return "bfti_4757a12fb1";
            case 570L: return "bfti_475fcf2c4e";
            case 571L: return "bfti_477d8c1396";
            case 572L: return "bfti_4785656737";
            case 573L: return "bfti_4799211e97";
            case 574L: return "bfti_47a8b5f3fd";
            case 575L: return "bfti_47b82ed471";
            case 576L: return "bfti_47cb13d7a9";
            case 577L: return "bfti_47d1984159";
            case 578L: return "bfti_47d8bd8d7a";
            case 579L: return "bfti_4884d3475a";
            case 580L: return "bfti_48bd2a9674";
            case 581L: return "bfti_48c3c00d6a";
            case 582L: return "bfti_48d603f662";
            case 583L: return "bfti_49000971f7";
            case 584L: return "bfti_4939bab4fa";
            case 585L: return "bfti_49660415ac";
            case 586L: return "bfti_4984a6814f";
            case 587L: return "bfti_49b36b6014";
            case 588L: return "bfti_49ccee4c1e";
            case 589L: return "bfti_49e90027eb";
            case 590L: return "bfti_49eb4a1432";
            case 591L: return "bfti_4a090a46a0";
            case 592L: return "bfti_4a78974318";
            case 593L: return "bfti_4a8732c1ae";
            case 594L: return "bfti_4aa69f6d86";
            case 595L: return "bfti_4ac6f38309";
            case 596L: return "bfti_4ae3ac6470";
            case 597L: return "bfti_4afcabad8a";
            case 598L: return "bfti_4b04fb1d35";
            case 599L: return "bfti_4b4582c555";
            case 600L: return "bfti_4b633d9cbc";
            case 601L: return "bfti_4b6b1c29aa";
            case 602L: return "bfti_4b85220956";
            case 603L: return "bfti_4b8db75463";
            case 604L: return "bfti_4ba076afbb";
            case 605L: return "bfti_4bb5fd52bc";
            case 606L: return "bfti_4be58825fa";
            case 607L: return "bfti_4bedc3b05c";
            case 608L: return "bfti_4bee96831e";
            case 609L: return "bfti_4c169845e4";
            case 610L: return "bfti_4c7a626b08";
            case 611L: return "bfti_4c9b8adf5c";
            case 612L: return "bfti_4cdf7ff37f";
            case 613L: return "bfti_4d08dfc9ca";
            case 614L: return "bfti_4d1a3308cb";
            case 615L: return "bfti_4d35cc6e38";
            case 616L: return "bfti_4d7ec1b5b6";
            case 617L: return "bfti_4d91193f49";
            case 618L: return "bfti_4da1bcf6df";
            case 619L: return "bfti_4dc7faec00";
            case 620L: return "bfti_4dce24c368";
            case 621L: return "bfti_4de463a752";
            case 622L: return "bfti_4df3447d7c";
            case 623L: return "bfti_4dfdcdd55d";
            case 624L: return "bfti_4e01e0dcb2";
            case 625L: return "bfti_4e253a0dca";
            case 626L: return "bfti_4e2738c91d";
            case 627L: return "bfti_4e2d025300";
            case 628L: return "bfti_4e30ed76e3";
            case 629L: return "bfti_4e514e8fcc";
            case 630L: return "bfti_4e53ff546b";
            case 631L: return "bfti_4e68df38f0";
            case 632L: return "bfti_4e77af121b";
            case 633L: return "bfti_4e81f85206";
            case 634L: return "bfti_4e98ee60b8";
            case 635L: return "bfti_4ebf1b6a81";
            case 636L: return "bfti_4ee908688c";
            case 637L: return "bfti_4ef071cab2";
            case 638L: return "bfti_4f06b662b7";
            case 639L: return "bfti_4f0dc3b304";
            case 640L: return "bfti_4f264094c7";
            case 641L: return "bfti_4f2b7708dc";
            case 642L: return "bfti_4f5ed5c11a";
            case 643L: return "bfti_4f6a73628d";
            case 644L: return "bfti_4f71abd9b9";
            case 645L: return "bfti_4f9da4f4e5";
            case 646L: return "bfti_4fa4e71e8a";
            case 647L: return "bfti_4faf560655";
            case 648L: return "bfti_4fc336fff2";
            case 649L: return "bfti_4fc9499d5e";
            case 650L: return "bfti_4ff92dc33a";
            case 651L: return "bfti_5036c0f447";
            case 652L: return "bfti_5048e2c4b3";
            case 653L: return "bfti_507160dbeb";
            case 654L: return "bfti_507badf080";
            case 655L: return "bfti_5094540cbb";
            case 656L: return "bfti_50bae3ce44";
            case 657L: return "bfti_50d43e3dd0";
            case 658L: return "bfti_50f7f6fb2a";
            case 659L: return "bfti_510b93e19a";
            case 660L: return "bfti_51473f9c3c";
            case 661L: return "bfti_5148cd2787";
            case 662L: return "bfti_5188944c45";
            case 663L: return "bfti_51bd8e1f07";
            case 664L: return "bfti_51ea5a07b3";
            case 665L: return "bfti_520ed58b15";
            case 666L: return "bfti_522fd4b577";
            case 667L: return "bfti_5235b0a01d";
            case 668L: return "bfti_52ac889299";
            case 669L: return "bfti_52b50b66c6";
            case 670L: return "bfti_52f04be5ae";
            case 671L: return "bfti_53209be2ab";
            case 672L: return "bfti_53464fcd8a";
            case 673L: return "bfti_5374aff85c";
            case 674L: return "bfti_53b024cffe";
            case 675L: return "bfti_53b033cc6e";
            case 676L: return "bfti_53b2719dff";
            case 677L: return "bfti_53c0e4f12e";
            case 678L: return "bfti_53e3eef58b";
            case 679L: return "bfti_54072d8762";
            case 680L: return "bfti_5412963e41";
            case 681L: return "bfti_54422d3191";
            case 682L: return "bfti_548c8f97c1";
            case 683L: return "bfti_5495a81987";
            case 684L: return "bfti_549c8f7452";
            case 685L: return "bfti_54ad3d7405";
            case 686L: return "bfti_54b0342cb8";
            case 687L: return "bfti_54d55504de";
            case 688L: return "bfti_54d639c341";
            case 689L: return "bfti_54ea68ef33";
            case 690L: return "bfti_54fb04ae11";
            case 691L: return "bfti_5510dd39df";
            case 692L: return "bfti_554d2db086";
            case 693L: return "bfti_556b745490";
            case 694L: return "bfti_55b9e35a19";
            case 695L: return "bfti_55d6ad988c";
            case 696L: return "bfti_55dc777bbe";
            case 697L: return "bfti_55dc7a75b6";
            case 698L: return "bfti_55e1d85c26";
            case 699L: return "bfti_55fa978734";
            case 700L: return "bfti_563408a166";
            case 701L: return "bfti_56490b90b8";
            case 702L: return "bfti_5650a84842";
            case 703L: return "bfti_566717f9aa";
            case 704L: return "bfti_566eb6f210";
            case 705L: return "bfti_5672c56d58";
            case 706L: return "bfti_56744b8225";
            case 707L: return "bfti_568ba34659";
            case 708L: return "bfti_568d43212b";
            case 709L: return "bfti_569d8ea359";
            case 710L: return "bfti_56d7dbf543";
            case 711L: return "bfti_56f84e68bd";
            case 712L: return "bfti_5752d33fef";
            case 713L: return "bfti_5756ce5be7";
            case 714L: return "bfti_576d87228e";
            case 715L: return "bfti_57bd7a3571";
            case 716L: return "bfti_57d21eda0d";
            case 717L: return "bfti_57d7d6afe6";
            case 718L: return "bfti_57df6de23d";
            case 719L: return "bfti_57e5f58e89";
            case 720L: return "bfti_57f14f0812";
            case 721L: return "bfti_57f3db37f0";
            case 722L: return "bfti_5829a92b79";
            case 723L: return "bfti_585274d3be";
            case 724L: return "bfti_58851e798f";
            case 725L: return "bfti_58b118f542";
            case 726L: return "bfti_58bccfb62e";
            case 727L: return "bfti_58c88381cb";
            case 728L: return "bfti_58fb50007d";
            case 729L: return "bfti_5917650572";
            case 730L: return "bfti_5922d2768b";
            case 731L: return "bfti_59848f7f99";
            case 732L: return "bfti_59a0cbfcfc";
            case 733L: return "bfti_59b0c6b3dc";
            case 734L: return "bfti_59eef96f39";
            case 735L: return "bfti_5a00c77bb3";
            case 736L: return "bfti_5a09702542";
            case 737L: return "bfti_5a1ee53b7e";
            case 738L: return "bfti_5a2c468a36";
            case 739L: return "bfti_5a663ff1fe";
            case 740L: return "bfti_5a66a83110";
            case 741L: return "bfti_5a8d417e14";
            case 742L: return "bfti_5aa1785ada";
            case 743L: return "bfti_5aaef128f8";
            case 744L: return "bfti_5ab407de35";
            case 745L: return "bfti_5ab415eb94";
            case 746L: return "bfti_5ad8b960b0";
            case 747L: return "bfti_5b0aa6e33f";
            case 748L: return "bfti_5b272ac382";
            case 749L: return "bfti_5b43ee1d9f";
            case 750L: return "bfti_5b54cb7b58";
            case 751L: return "bfti_5b64f01311";
            case 752L: return "bfti_5b6a01accc";
            case 753L: return "bfti_5bd162420f";
            case 754L: return "bfti_5beab249b9";
            case 755L: return "bfti_5bf1df01df";
            case 756L: return "bfti_5bf4274a7e";
            case 757L: return "bfti_5bfe209403";
            case 758L: return "bfti_5c0ef2135b";
            case 759L: return "bfti_5c3da66fbd";
            case 760L: return "bfti_5c6c72ff3e";
            case 761L: return "bfti_5cca26ddbf";
            case 762L: return "bfti_5cfc3b5b4c";
            case 763L: return "bfti_5d0ffbe003";
            case 764L: return "bfti_5d56089899";
            case 765L: return "bfti_5d65fd793c";
            case 766L: return "bfti_5daf90f8fb";
            case 767L: return "bfti_5dd2bf0fec";
            case 768L: return "bfti_5dffeb6de1";
            case 769L: return "bfti_5e1bd120c8";
            case 770L: return "bfti_5e2d8648dc";
            case 771L: return "bfti_5e32022ca0";
            case 772L: return "bfti_5e45be2598";
            case 773L: return "bfti_5e935510ab";
            case 774L: return "bfti_5ed293acf4";
            case 775L: return "bfti_5ee8e11dc8";
            case 776L: return "bfti_5f09e99a9b";
            case 777L: return "bfti_5f28546ef8";
            case 778L: return "bfti_5f2c578696";
            case 779L: return "bfti_5f33e1ee3f";
            case 780L: return "bfti_5f36a958b6";
            case 781L: return "bfti_6001b0602b";
            case 782L: return "bfti_6004795e19";
            case 783L: return "bfti_602d8b495f";
            case 784L: return "bfti_60308b2432";
            case 785L: return "bfti_60de612447";
            case 786L: return "bfti_611000e820";
            case 787L: return "bfti_6154b35a15";
            case 788L: return "bfti_6156ef68e2";
            case 789L: return "bfti_617a569928";
            case 790L: return "bfti_6185d55604";
            case 791L: return "bfti_61a3861bfb";
            case 792L: return "bfti_61b0bb3150";
            case 793L: return "bfti_61b7287efc";
            case 794L: return "bfti_61cfa1935a";
            case 795L: return "bfti_61fc71ca74";
            case 796L: return "bfti_6225c8441a";
            case 797L: return "bfti_626589aa1e";
            case 798L: return "bfti_62726d0377";
            case 799L: return "bfti_628aa1bb7b";
            case 800L: return "bfti_62afdd195f";
            case 801L: return "bfti_62bde0e3b2";
            case 802L: return "bfti_62d06fcc44";
            case 803L: return "bfti_62e6248dfb";
            case 804L: return "bfti_62fbff47e9";
            case 805L: return "bfti_6307f35cf6";
            case 806L: return "bfti_630a94c7fc";
            case 807L: return "bfti_63353c311d";
            case 808L: return "bfti_634d3e2463";
            case 809L: return "bfti_63bc224f4d";
            case 810L: return "bfti_63f94d0014";
            case 811L: return "bfti_63fa16e110";
            case 812L: return "bfti_6400341218";
            case 813L: return "bfti_6412de3a55";
            case 814L: return "bfti_642df1468c";
            case 815L: return "bfti_64338b297c";
            case 816L: return "bfti_643c64b54f";
            case 817L: return "bfti_646f236585";
            case 818L: return "bfti_647e07d40b";
            case 819L: return "bfti_648bd8e36d";
            case 820L: return "bfti_64e10c4b08";
            case 821L: return "bfti_64eb464466";
            case 822L: return "bfti_64f86da40e";
            case 823L: return "bfti_65363641c1";
            case 824L: return "bfti_65455c44b5";
            case 825L: return "bfti_658ed20145";
            case 826L: return "bfti_6596ba3751";
            case 827L: return "bfti_659920f694";
            case 828L: return "bfti_65cfa4cf9d";
            case 829L: return "bfti_65d50e9b22";
            case 830L: return "bfti_65dd9e9278";
            case 831L: return "bfti_65e7364f54";
            case 832L: return "bfti_664fdbbc45";
            case 833L: return "bfti_66613df1fb";
            case 834L: return "bfti_666d2df0db";
            case 835L: return "bfti_666ecb44ba";
            case 836L: return "bfti_66c1bdd41a";
            case 837L: return "bfti_66f75a06f7";
            case 838L: return "bfti_6711b35bde";
            case 839L: return "bfti_6727816bea";
            case 840L: return "bfti_672ad8cf38";
            case 841L: return "bfti_673d711aa8";
            case 842L: return "bfti_676fa16616";
            case 843L: return "bfti_678269df04";
            case 844L: return "bfti_678499d39c";
            case 845L: return "bfti_6788710305";
            case 846L: return "bfti_681676f263";
            case 847L: return "bfti_684ca27f5e";
            case 848L: return "bfti_6853828c1e";
            case 849L: return "bfti_6882d463f1";
            case 850L: return "bfti_68aa34da03";
            case 851L: return "bfti_68b900647a";
            case 852L: return "bfti_68c7ff3363";
            case 853L: return "bfti_692bd1692d";
            case 854L: return "bfti_696dfad892";
            case 855L: return "bfti_698a84e6e3";
            case 856L: return "bfti_6993792391";
            case 857L: return "bfti_69cfccc059";
            case 858L: return "bfti_69f1dc9a05";
            case 859L: return "bfti_6a3273b3c5";
            case 860L: return "bfti_6a5c596d54";
            case 861L: return "bfti_6a5eb80f2e";
            case 862L: return "bfti_6a6a898c31";
            case 863L: return "bfti_6a7366d080";
            case 864L: return "bfti_6a74f732b1";
            case 865L: return "bfti_6a7c077641";
            case 866L: return "bfti_6a8e1c26c8";
            case 867L: return "bfti_6aa5608d1a";
            case 868L: return "bfti_6ab0803ece";
            case 869L: return "bfti_6ac6754936";
            case 870L: return "bfti_6accf35747";
            case 871L: return "bfti_6b227023a4";
            case 872L: return "bfti_6b294172ca";
            case 873L: return "bfti_6b334bd7c4";
            case 874L: return "bfti_6b3be7d373";
            case 875L: return "bfti_6b411082d4";
            case 876L: return "bfti_6b4412ad13";
            case 877L: return "bfti_6b6d3d4711";
            case 878L: return "bfti_6b71de1a33";
            case 879L: return "bfti_6b74b5863c";
            case 880L: return "bfti_6b89e81494";
            case 881L: return "bfti_6b93ac8b16";
            case 882L: return "bfti_6bb0fe7a87";
            case 883L: return "bfti_6bb3b86a9e";
            case 884L: return "bfti_6bc51f00e4";
            case 885L: return "bfti_6bc86b6d7f";
            case 886L: return "bfti_6be124b729";
            case 887L: return "bfti_6be1585ac8";
            case 888L: return "bfti_6bfbdcf5df";
            case 889L: return "bfti_6bfd735dc1";
            case 890L: return "bfti_6c13141f62";
            case 891L: return "bfti_6c4f7d12ab";
            case 892L: return "bfti_6c5afbbc39";
            case 893L: return "bfti_6c6bfbb57b";
            case 894L: return "bfti_6c7c6ab40b";
            case 895L: return "bfti_6c8af6322c";
            case 896L: return "bfti_6ca238a1e9";
            case 897L: return "bfti_6cd43f7c21";
            case 898L: return "bfti_6cfbd87d48";
            case 899L: return "bfti_6d4fd0355b";
            case 900L: return "bfti_6d75f3ee99";
            case 901L: return "bfti_6dbb58adf2";
            case 902L: return "bfti_6e08b3c5a7";
            case 903L: return "bfti_6e0bcf23e9";
            case 904L: return "bfti_6e10f1bcd7";
            case 905L: return "bfti_6e17abbfa0";
            case 906L: return "bfti_6e1bcd41da";
            case 907L: return "bfti_6e3fa6b510";
            case 908L: return "bfti_6e5d48e096";
            case 909L: return "bfti_6e646ba9d4";
            case 910L: return "bfti_6e680051dd";
            case 911L: return "bfti_6e988b32e4";
            case 912L: return "bfti_6e99696f59";
            case 913L: return "bfti_6e9e02c373";
            case 914L: return "bfti_6edf78bf06";
            case 915L: return "bfti_6f1d85b9e5";
            case 916L: return "bfti_6f31963edd";
            case 917L: return "bfti_6f3e0dfa3d";
            case 918L: return "bfti_6fd2dd172c";
            case 919L: return "bfti_6fd7c1cd44";
            case 920L: return "bfti_702d78eb89";
            case 921L: return "bfti_7072b04016";
            case 922L: return "bfti_7089767499";
            case 923L: return "bfti_7090ed7c7c";
            case 924L: return "bfti_70920f81b3";
            case 925L: return "bfti_70b79f07b2";
            case 926L: return "bfti_70dfa4e2e5";
            case 927L: return "bfti_70e1c53177";
            case 928L: return "bfti_70f8d53332";
            case 929L: return "bfti_715714a07c";
            case 930L: return "bfti_717a714881";
            case 931L: return "bfti_717c9d662e";
            case 932L: return "bfti_7181266eeb";
            case 933L: return "bfti_71a5a931e6";
            case 934L: return "bfti_71f1d7aaba";
            case 935L: return "bfti_71fbe24941";
            case 936L: return "bfti_721164f9da";
            case 937L: return "bfti_7236860958";
            case 938L: return "bfti_7245bc68e3";
            case 939L: return "bfti_725a9a695a";
            case 940L: return "bfti_728b46bce7";
            case 941L: return "bfti_729206740d";
            case 942L: return "bfti_72bdc4b521";
            case 943L: return "bfti_72ca2bee94";
            case 944L: return "bfti_73062210d5";
            case 945L: return "bfti_732c687617";
            case 946L: return "bfti_735b9bce52";
            case 947L: return "bfti_7372bd6505";
            case 948L: return "bfti_73c071bc40";
            case 949L: return "bfti_73e4f09d59";
            case 950L: return "bfti_73e645533e";
            case 951L: return "bfti_73eece56e8";
            case 952L: return "bfti_73f984a044";
            case 953L: return "bfti_7411e2da0d";
            case 954L: return "bfti_741946d37b";
            case 955L: return "bfti_743606e7f3";
            case 956L: return "bfti_7439f6e74d";
            case 957L: return "bfti_743ba986ab";
            case 958L: return "bfti_74512b55a3";
            case 959L: return "bfti_747ab28a91";
            case 960L: return "bfti_747b19d04f";
            case 961L: return "bfti_748a0901f7";
            case 962L: return "bfti_748ea550d6";
            case 963L: return "bfti_74c6ba983f";
            case 964L: return "bfti_74d45d7226";
            case 965L: return "bfti_75032dae16";
            case 966L: return "bfti_753183cb90";
            case 967L: return "bfti_75506a9fbd";
            case 968L: return "bfti_7551897a7a";
            case 969L: return "bfti_756b26544d";
            case 970L: return "bfti_75714d6b13";
            case 971L: return "bfti_757b6a50ea";
            case 972L: return "bfti_758c664d2f";
            case 973L: return "bfti_759fc3ac3f";
            case 974L: return "bfti_75a90d6bb2";
            case 975L: return "bfti_75c7ddd248";
            case 976L: return "bfti_75cbe8aace";
            case 977L: return "bfti_761a592f26";
            case 978L: return "bfti_765808e277";
            case 979L: return "bfti_767a6c232a";
            case 980L: return "bfti_768a23be16";
            case 981L: return "bfti_76953745d1";
            case 982L: return "bfti_76a574762b";
            case 983L: return "bfti_76b90ffb57";
            case 984L: return "bfti_76fb86b28b";
            case 985L: return "bfti_7716adb227";
            case 986L: return "bfti_7734c25e8d";
            case 987L: return "bfti_773ad86447";
            case 988L: return "bfti_77978735fe";
            case 989L: return "bfti_779f1ece73";
            case 990L: return "bfti_77cbe5a02b";
            case 991L: return "bfti_780aab42df";
            case 992L: return "bfti_78496e62ca";
            case 993L: return "bfti_7869d6ad75";
            case 994L: return "bfti_78885ab579";
            case 995L: return "bfti_78947e7514";
            case 996L: return "bfti_78a3349585";
            case 997L: return "bfti_78c654566e";
            case 998L: return "bfti_78dc022076";
            case 999L: return "bfti_78eb0dec70";
            case 1000L: return "bfti_78f4bf7828";
            case 1001L: return "bfti_78faf1b713";
            case 1002L: return "bfti_790af77de7";
            case 1003L: return "bfti_791263ccb3";
            case 1004L: return "bfti_791c6b1993";
            case 1005L: return "bfti_792fc3e2af";
            case 1006L: return "bfti_79461406af";
            case 1007L: return "bfti_796ae22273";
            case 1008L: return "bfti_79b4878404";
            case 1009L: return "bfti_79bc89269f";
            case 1010L: return "bfti_79c80226a2";
            case 1011L: return "bfti_79c8f35835";
            case 1012L: return "bfti_79f56ee6aa";
            case 1013L: return "bfti_7a135cd2e3";
            case 1014L: return "bfti_7a5bb6640d";
            case 1015L: return "bfti_7a5d479dc9";
            case 1016L: return "bfti_7ae711cde9";
            case 1017L: return "bfti_7b077cb8e2";
            case 1018L: return "bfti_7b1302731d";
            case 1019L: return "bfti_7b1f73d02f";
            case 1020L: return "bfti_7b4593557f";
            case 1021L: return "bfti_7b7348433e";
            case 1022L: return "bfti_7b939ac3d7";
            case 1023L: return "bfti_7b9c6ee492";
            case 1024L: return "bfti_7bb7cbcbc4";
            case 1025L: return "bfti_7bcaaf9cdd";
            case 1026L: return "bfti_7c052fcc47";
            case 1027L: return "bfti_7c106b0ea5";
            case 1028L: return "bfti_7c12c4cc47";
            case 1029L: return "bfti_7c46a5e875";
            case 1030L: return "bfti_7c54706b23";
            case 1031L: return "bfti_7c7aad3878";
            case 1032L: return "bfti_7c8fa948d7";
            case 1033L: return "bfti_7c970c1edf";
            case 1034L: return "bfti_7c9879911c";
            case 1035L: return "bfti_7ca53d1ebb";
            case 1036L: return "bfti_7cbec3735a";
            case 1037L: return "bfti_7cc8f91f16";
            case 1038L: return "bfti_7ceaa3f156";
            case 1039L: return "bfti_7cf621f125";
            case 1040L: return "bfti_7d0aeab0d6";
            case 1041L: return "bfti_7d36b925a3";
            case 1042L: return "bfti_7d545a5ae9";
            case 1043L: return "bfti_7d6b5a3746";
            case 1044L: return "bfti_7d6ee203f1";
            case 1045L: return "bfti_7d8ab33925";
            case 1046L: return "bfti_7d953cd087";
            case 1047L: return "bfti_7dac1befb2";
            case 1048L: return "bfti_7de06301e8";
            case 1049L: return "bfti_7e1d5d238c";
            case 1050L: return "bfti_7e3d1faa0c";
            case 1051L: return "bfti_7e41646a22";
            case 1052L: return "bfti_7e4cb54b4f";
            case 1053L: return "bfti_7e4d9d1016";
            case 1054L: return "bfti_7e4f601f20";
            case 1055L: return "bfti_7e6f5df02c";
            case 1056L: return "bfti_7e75c36d49";
            case 1057L: return "bfti_7e8c304830";
            case 1058L: return "bfti_7e8df83414";
            case 1059L: return "bfti_7ea365444c";
            case 1060L: return "bfti_7eb2a471ca";
            case 1061L: return "bfti_7ec86b1335";
            case 1062L: return "bfti_7ecebe0382";
            case 1063L: return "bfti_7edd8a020f";
            case 1064L: return "bfti_7ee31bbb80";
            case 1065L: return "bfti_7ef2fcf593";
            case 1066L: return "bfti_7f0094cd11";
            case 1067L: return "bfti_7f16bee6b9";
            case 1068L: return "bfti_7f1eff7f58";
            case 1069L: return "bfti_7f4b55dad1";
            case 1070L: return "bfti_7f603a621e";
            case 1071L: return "bfti_7f815df06a";
            case 1072L: return "bfti_7f9a0d779d";
            case 1073L: return "bfti_7fa56021a9";
            case 1074L: return "bfti_7fc1d03eb9";
            case 1075L: return "bfti_7fcc43d717";
            case 1076L: return "bfti_7fceb30d1f";
            case 1077L: return "bfti_7fdd38def1";
            case 1078L: return "bfti_7ff203e31d";
            case 1079L: return "bfti_7ffbec0d8d";
            case 1080L: return "bfti_800ec5a23b";
            case 1081L: return "bfti_802b38c238";
            case 1082L: return "bfti_802b59ea3f";
            case 1083L: return "bfti_8090747d6d";
            case 1084L: return "bfti_8154db458a";
            case 1085L: return "bfti_8169f75e7c";
            case 1086L: return "bfti_817c32e01e";
            case 1087L: return "bfti_818b38abd3";
            case 1088L: return "bfti_818f007437";
            case 1089L: return "bfti_81acf5a82c";
            case 1090L: return "bfti_81f67702c9";
            case 1091L: return "bfti_81faad84e6";
            case 1092L: return "bfti_8246563c0c";
            case 1093L: return "bfti_8257e0c20e";
            case 1094L: return "bfti_826de42190";
            case 1095L: return "bfti_8275570935";
            case 1096L: return "bfti_828c59ce75";
            case 1097L: return "bfti_829f612161";
            case 1098L: return "bfti_82a6170b6e";
            case 1099L: return "bfti_832ad8fb99";
            case 1100L: return "bfti_8355bb71a3";
            case 1101L: return "bfti_8377428c99";
            case 1102L: return "bfti_838dd5feee";
            case 1103L: return "bfti_83a0321e57";
            case 1104L: return "bfti_83b8be0c44";
            case 1105L: return "bfti_83e28d4e33";
            case 1106L: return "bfti_83ee670f7d";
            case 1107L: return "bfti_83f948b132";
            case 1108L: return "bfti_84115dc2ba";
            case 1109L: return "bfti_84240b8163";
            case 1110L: return "bfti_842b316134";
            case 1111L: return "bfti_843090a24e";
            case 1112L: return "bfti_8440dda2ba";
            case 1113L: return "bfti_846a362da5";
            case 1114L: return "bfti_84746f3a70";
            case 1115L: return "bfti_84a4681591";
            case 1116L: return "bfti_84dfe4b1d9";
            case 1117L: return "bfti_84fedfd13f";
            case 1118L: return "bfti_851d974afd";
            case 1119L: return "bfti_853d7986ec";
            case 1120L: return "bfti_85790e53b6";
            case 1121L: return "bfti_859bbb8cb6";
            case 1122L: return "bfti_85c244bcaf";
            case 1123L: return "bfti_85d37f9103";
            case 1124L: return "bfti_85ff3417dc";
            case 1125L: return "bfti_8665dae4ba";
            case 1126L: return "bfti_8672bb54e3";
            case 1127L: return "bfti_8676f92db7";
            case 1128L: return "bfti_867f565c91";
            case 1129L: return "bfti_8697257f79";
            case 1130L: return "bfti_86c357ebda";
            case 1131L: return "bfti_86cef64642";
            case 1132L: return "bfti_8707a39e7b";
            case 1133L: return "bfti_870c26909d";
            case 1134L: return "bfti_87345842ab";
            case 1135L: return "bfti_879534b906";
            case 1136L: return "bfti_87980cec03";
            case 1137L: return "bfti_8802fe90eb";
            case 1138L: return "bfti_88065e0aa0";
            case 1139L: return "bfti_88293189c5";
            case 1140L: return "bfti_883f6adc56";
            case 1141L: return "bfti_88551720eb";
            case 1142L: return "bfti_8859e75d90";
            case 1143L: return "bfti_8860dc6b8d";
            case 1144L: return "bfti_888d66db7e";
            case 1145L: return "bfti_88b4a9e6de";
            case 1146L: return "bfti_88bbdd7354";
            case 1147L: return "bfti_8901e92b1e";
            case 1148L: return "bfti_893acb134f";
            case 1149L: return "bfti_8944855e7c";
            case 1150L: return "bfti_8962467c9c";
            case 1151L: return "bfti_89c63bd3e2";
            case 1152L: return "bfti_89cfe5ff4e";
            case 1153L: return "bfti_89dbfcdba9";
            case 1154L: return "bfti_89ebf08bd5";
            case 1155L: return "bfti_8a175f291c";
            case 1156L: return "bfti_8a1f027f51";
            case 1157L: return "bfti_8a263e5df0";
            case 1158L: return "bfti_8a2e144d0d";
            case 1159L: return "bfti_8a5ae09fc8";
            case 1160L: return "bfti_8a6bcb14b1";
            case 1161L: return "bfti_8a825b073d";
            case 1162L: return "bfti_8ab42c4d0a";
            case 1163L: return "bfti_8ac5e843d9";
            case 1164L: return "bfti_8ac61f4909";
            case 1165L: return "bfti_8ad0cfdc75";
            case 1166L: return "bfti_8afdebfd34";
            case 1167L: return "bfti_8b22e205f9";
            case 1168L: return "bfti_8b2a3f8317";
            case 1169L: return "bfti_8b448fc92d";
            case 1170L: return "bfti_8b58045a11";
            case 1171L: return "bfti_8b5d19d4e6";
            case 1172L: return "bfti_8b7a5eac03";
            case 1173L: return "bfti_8b9abc1b83";
            case 1174L: return "bfti_8babb34e2d";
            case 1175L: return "bfti_8bba56991b";
            case 1176L: return "bfti_8bbe7c0b61";
            case 1177L: return "bfti_8c1316c7e1";
            case 1178L: return "bfti_8c200dfdab";
            case 1179L: return "bfti_8c3fccadfc";
            case 1180L: return "bfti_8c75d580ec";
            case 1181L: return "bfti_8c814367d5";
            case 1182L: return "bfti_8c9cdd3ba6";
            case 1183L: return "bfti_8ca80b6f2c";
            case 1184L: return "bfti_8cc15f077a";
            case 1185L: return "bfti_8ce6b32c00";
            case 1186L: return "bfti_8ce82669a9";
            case 1187L: return "bfti_8cfa5fc13f";
            case 1188L: return "bfti_8d2425844c";
            case 1189L: return "bfti_8d2996e4ff";
            case 1190L: return "bfti_8d58be22c0";
            case 1191L: return "bfti_8d7f261b94";
            case 1192L: return "bfti_8d8570ffbe";
            case 1193L: return "bfti_8db8e8846a";
            case 1194L: return "bfti_8dd54a3602";
            case 1195L: return "bfti_8dd7a724c2";
            case 1196L: return "bfti_8dddf37754";
            case 1197L: return "bfti_8dfa7492c2";
            case 1198L: return "bfti_8e6ff73718";
            case 1199L: return "bfti_8e761642d3";
            case 1200L: return "bfti_8e78caf0b8";
            case 1201L: return "bfti_8e85aa8c80";
            case 1202L: return "bfti_8e88135b65";
            case 1203L: return "bfti_8ea56efd1c";
            case 1204L: return "bfti_8eb2a5206b";
            case 1205L: return "bfti_8eccfdc9c5";
            case 1206L: return "bfti_8ef094cc09";
            case 1207L: return "bfti_8f049409cf";
            case 1208L: return "bfti_8f0948a99c";
            case 1209L: return "bfti_8f3119796d";
            case 1210L: return "bfti_8f91001cfe";
            case 1211L: return "bfti_8f93358894";
            case 1212L: return "bfti_8f98b359fc";
            case 1213L: return "bfti_8fa819c5e0";
            case 1214L: return "bfti_8fb2adc19f";
            case 1215L: return "bfti_8fc07089c1";
            case 1216L: return "bfti_8fca868f46";
            case 1217L: return "bfti_8fcd162684";
            case 1218L: return "bfti_8fd81c449b";
            case 1219L: return "bfti_8fedea9993";
            case 1220L: return "bfti_90287907ae";
            case 1221L: return "bfti_903f2e8e42";
            case 1222L: return "bfti_908cc1b2c2";
            case 1223L: return "bfti_90a1b28862";
            case 1224L: return "bfti_90b4c59578";
            case 1225L: return "bfti_90b8b3556a";
            case 1226L: return "bfti_90c8fe242e";
            case 1227L: return "bfti_90cb165f50";
            case 1228L: return "bfti_90cd025cac";
            case 1229L: return "bfti_90e0db847d";
            case 1230L: return "bfti_90e0eed036";
            case 1231L: return "bfti_90e396f8f1";
            case 1232L: return "bfti_910bd70433";
            case 1233L: return "bfti_914777912e";
            case 1234L: return "bfti_914f5877d3";
            case 1235L: return "bfti_9186a98e0e";
            case 1236L: return "bfti_9191735c60";
            case 1237L: return "bfti_91f4c61dec";
            case 1238L: return "bfti_91fecf7a97";
            case 1239L: return "bfti_9212e386a9";
            case 1240L: return "bfti_9213386b58";
            case 1241L: return "bfti_9215b2afdc";
            case 1242L: return "bfti_922365f3e9";
            case 1243L: return "bfti_923cd52cf0";
            case 1244L: return "bfti_92697c92f0";
            case 1245L: return "bfti_9276a479f5";
            case 1246L: return "bfti_928f76d224";
            case 1247L: return "bfti_929367f132";
            case 1248L: return "bfti_92a8506d94";
            case 1249L: return "bfti_92b544b032";
            case 1250L: return "bfti_92e29c4ec3";
            case 1251L: return "bfti_92e8fb5cdf";
            case 1252L: return "bfti_92fac32ce7";
            case 1253L: return "bfti_9317465577";
            case 1254L: return "bfti_931d32cf99";
            case 1255L: return "bfti_932db00782";
            case 1256L: return "bfti_9335f317c0";
            case 1257L: return "bfti_934d603d27";
            case 1258L: return "bfti_93629b2c9a";
            case 1259L: return "bfti_936774a04e";
            case 1260L: return "bfti_9372915e3b";
            case 1261L: return "bfti_937a8aa664";
            case 1262L: return "bfti_937d8cf101";
            case 1263L: return "bfti_93b45aaff5";
            case 1264L: return "bfti_93f79ea781";
            case 1265L: return "bfti_93f7b61038";
            case 1266L: return "bfti_9428db02d4";
            case 1267L: return "bfti_942d3ce4c1";
            case 1268L: return "bfti_9459b060b0";
            case 1269L: return "bfti_9463e91674";
            case 1270L: return "bfti_94736eba2b";
            case 1271L: return "bfti_947a975f94";
            case 1272L: return "bfti_94f3b7f0c2";
            case 1273L: return "bfti_94fa74057d";
            case 1274L: return "bfti_9506a185f5";
            case 1275L: return "bfti_95155f3818";
            case 1276L: return "bfti_951f637c83";
            case 1277L: return "bfti_9527cc2b95";
            case 1278L: return "bfti_95509ca9f7";
            case 1279L: return "bfti_95625e988a";
            case 1280L: return "bfti_957e064fee";
            case 1281L: return "bfti_95841a910a";
            case 1282L: return "bfti_958d7936a2";
            case 1283L: return "bfti_95dc1d54bc";
            case 1284L: return "bfti_9643dd1241";
            case 1285L: return "bfti_9645f5f25e";
            case 1286L: return "bfti_9646648c78";
            case 1287L: return "bfti_966e5ea019";
            case 1288L: return "bfti_9670cc57a6";
            case 1289L: return "bfti_969e915b3e";
            case 1290L: return "bfti_96a23b3f1c";
            case 1291L: return "bfti_96d278b868";
            case 1292L: return "bfti_96d86a9418";
            case 1293L: return "bfti_96e46b2a48";
            case 1294L: return "bfti_97157e1a99";
            case 1295L: return "bfti_97223697d6";
            case 1296L: return "bfti_9750598bf2";
            case 1297L: return "bfti_975e62d841";
            case 1298L: return "bfti_9771186bad";
            case 1299L: return "bfti_977f627e4e";
            case 1300L: return "bfti_9780112df8";
            case 1301L: return "bfti_978f35adff";
            case 1302L: return "bfti_979dce71ed";
            case 1303L: return "bfti_97a228aaf7";
            case 1304L: return "bfti_97a77dc9dc";
            case 1305L: return "bfti_97c6334ab2";
            case 1306L: return "bfti_97d060587d";
            case 1307L: return "bfti_9817260056";
            case 1308L: return "bfti_98190337db";
            case 1309L: return "bfti_9822fb0c67";
            case 1310L: return "bfti_98232855aa";
            case 1311L: return "bfti_9826748757";
            case 1312L: return "bfti_985122aa14";
            case 1313L: return "bfti_9858c0595e";
            case 1314L: return "bfti_98697cd677";
            case 1315L: return "bfti_989a717567";
            case 1316L: return "bfti_98af3a9f55";
            case 1317L: return "bfti_98b2a2d1c7";
            case 1318L: return "bfti_98b7ebccb3";
            case 1319L: return "bfti_995ea30375";
            case 1320L: return "bfti_996e402141";
            case 1321L: return "bfti_999a34e85a";
            case 1322L: return "bfti_99d45a72e5";
            case 1323L: return "bfti_99d83c3201";
            case 1324L: return "bfti_9a14ae649e";
            case 1325L: return "bfti_9a25299429";
            case 1326L: return "bfti_9a2c6b0ab5";
            case 1327L: return "bfti_9a3665e8ec";
            case 1328L: return "bfti_9ac2950c02";
            case 1329L: return "bfti_9b027c8388";
            case 1330L: return "bfti_9b0ea52974";
            case 1331L: return "bfti_9b554b353e";
            case 1332L: return "bfti_9b5b3864d7";
            case 1333L: return "bfti_9b5c8f0dd4";
            case 1334L: return "bfti_9b6c293511";
            case 1335L: return "bfti_9b6c9961ca";
            case 1336L: return "bfti_9ba01e673a";
            case 1337L: return "bfti_9ba69135a2";
            case 1338L: return "bfti_9bc66e54c6";
            case 1339L: return "bfti_9be1126281";
            case 1340L: return "bfti_9c05874aa1";
            case 1341L: return "bfti_9c24c014fc";
            case 1342L: return "bfti_9c27f920d2";
            case 1343L: return "bfti_9c44510568";
            case 1344L: return "bfti_9ca6fdd901";
            case 1345L: return "bfti_9cb2fdb668";
            case 1346L: return "bfti_9cdb773d13";
            case 1347L: return "bfti_9ceab2593a";
            case 1348L: return "bfti_9d09a2749e";
            case 1349L: return "bfti_9d172ca88f";
            case 1350L: return "bfti_9d4a25fd11";
            case 1351L: return "bfti_9d4f5d2000";
            case 1352L: return "bfti_9d5d8c7bd5";
            case 1353L: return "bfti_9d88dad950";
            case 1354L: return "bfti_9db2980d40";
            case 1355L: return "bfti_9dcaca3832";
            case 1356L: return "bfti_9dd85b86b4";
            case 1357L: return "bfti_9de588181a";
            case 1358L: return "bfti_9de5f3219a";
            case 1359L: return "bfti_9e506ef4ce";
            case 1360L: return "bfti_9e68a45d49";
            case 1361L: return "bfti_9e8d557493";
            case 1362L: return "bfti_9ed912b678";
            case 1363L: return "bfti_9ed9764c12";
            case 1364L: return "bfti_9ee6bec364";
            case 1365L: return "bfti_9f066b0fd4";
            case 1366L: return "bfti_9f5e73aa28";
            case 1367L: return "bfti_9f781f2e39";
            case 1368L: return "bfti_9fe0a505bd";
            case 1369L: return "bfti_a087fe322e";
            case 1370L: return "bfti_a095ba66eb";
            case 1371L: return "bfti_a09b0703e5";
            case 1372L: return "bfti_a0ec6a4837";
            case 1373L: return "bfti_a114e3f6fd";
            case 1374L: return "bfti_a13b30e4f8";
            case 1375L: return "bfti_a18a45dfc7";
            case 1376L: return "bfti_a22e651be8";
            case 1377L: return "bfti_a2a588eb56";
            case 1378L: return "bfti_a2af9dda47";
            case 1379L: return "bfti_a2db2f77d6";
            case 1380L: return "bfti_a2dee1851d";
            case 1381L: return "bfti_a2dfb3b7f2";
            case 1382L: return "bfti_a301630ae9";
            case 1383L: return "bfti_a303677d17";
            case 1384L: return "bfti_a31a0bfab6";
            case 1385L: return "bfti_a320b5ba15";
            case 1386L: return "bfti_a3326a87e2";
            case 1387L: return "bfti_a349db3324";
            case 1388L: return "bfti_a391348047";
            case 1389L: return "bfti_a421c3755c";
            case 1390L: return "bfti_a4cc855666";
            case 1391L: return "bfti_a4d8f4fbce";
            case 1392L: return "bfti_a4e2625b44";
            case 1393L: return "bfti_a4e443f89a";
            case 1394L: return "bfti_a50500fb68";
            case 1395L: return "bfti_a513da5d94";
            case 1396L: return "bfti_a564a35e91";
            case 1397L: return "bfti_a576213dc5";
            case 1398L: return "bfti_a57cf152e5";
            case 1399L: return "bfti_a5e563f273";
            case 1400L: return "bfti_a60dd6abfc";
            case 1401L: return "bfti_a622b194a8";
            case 1402L: return "bfti_a6350825e4";
            case 1403L: return "bfti_a67d6a64e5";
            case 1404L: return "bfti_a68bee1010";
            case 1405L: return "bfti_a6a2e8bebd";
            case 1406L: return "bfti_a6bb7fd805";
            case 1407L: return "bfti_a6bc69ffdd";
            case 1408L: return "bfti_a6c9489aa5";
            case 1409L: return "bfti_a6d666c02a";
            case 1410L: return "bfti_a6e9f1d2e8";
            case 1411L: return "bfti_a7000984b7";
            case 1412L: return "bfti_a73910d0f1";
            case 1413L: return "bfti_a74c7064c4";
            case 1414L: return "bfti_a77f6f6a8d";
            case 1415L: return "bfti_a7b4b49d20";
            case 1416L: return "bfti_a7b9a561a6";
            case 1417L: return "bfti_a80d60191c";
            case 1418L: return "bfti_a832f7f2ab";
            case 1419L: return "bfti_a8839e3e10";
            case 1420L: return "bfti_a8bf2e34cf";
            case 1421L: return "bfti_a8dca33c0e";
            case 1422L: return "bfti_a931c261ce";
            case 1423L: return "bfti_a964a28eaf";
            case 1424L: return "bfti_a973125eab";
            case 1425L: return "bfti_a97df6728c";
            case 1426L: return "bfti_a98b196786";
            case 1427L: return "bfti_a99c03f5e2";
            case 1428L: return "bfti_a9ac3d2f90";
            case 1429L: return "bfti_a9ac565719";
            case 1430L: return "bfti_a9bbdd2f2a";
            case 1431L: return "bfti_aa0ecd0181";
            case 1432L: return "bfti_aa1551ff72";
            case 1433L: return "bfti_aa250a4d86";
            case 1434L: return "bfti_aa5c57371b";
            case 1435L: return "bfti_aa71e26b43";
            case 1436L: return "bfti_aa8f324063";
            case 1437L: return "bfti_aa9b69b48f";
            case 1438L: return "bfti_aa9c8f3492";
            case 1439L: return "bfti_aabc219878";
            case 1440L: return "bfti_aae661aa9e";
            case 1441L: return "bfti_aaf10250c1";
            case 1442L: return "bfti_ab2b023c48";
            case 1443L: return "bfti_ab83421b46";
            case 1444L: return "bfti_ab8f77493f";
            case 1445L: return "bfti_abcb9a4eba";
            case 1446L: return "bfti_abd707cfe7";
            case 1447L: return "bfti_abe3ec3b0e";
            case 1448L: return "bfti_ac32ae5925";
            case 1449L: return "bfti_ac5a891877";
            case 1450L: return "bfti_ac611a7665";
            case 1451L: return "bfti_ac65215cf6";
            case 1452L: return "bfti_ac8458a5b9";
            case 1453L: return "bfti_ac8621d692";
            case 1454L: return "bfti_ac9ee299f0";
            case 1455L: return "bfti_acb4ad318c";
            case 1456L: return "bfti_acbad091a4";
            case 1457L: return "bfti_ad7c16d446";
            case 1458L: return "bfti_ad7cb7d315";
            case 1459L: return "bfti_ad91e997c5";
            case 1460L: return "bfti_ada3f8b024";
            case 1461L: return "bfti_ada8ed44d5";
            case 1462L: return "bfti_adb78c3c8c";
            case 1463L: return "bfti_add6c40a2d";
            case 1464L: return "bfti_ae43d05fec";
            case 1465L: return "bfti_ae756ed007";
            case 1466L: return "bfti_aea98fb72f";
            case 1467L: return "bfti_aeb6b2560f";
            case 1468L: return "bfti_aeefc643d4";
            case 1469L: return "bfti_af1960020c";
            case 1470L: return "bfti_af37b6bc8e";
            case 1471L: return "bfti_af6827f9a7";
            case 1472L: return "bfti_af8c728dea";
            case 1473L: return "bfti_af8f05590f";
            case 1474L: return "bfti_afb77f928f";
            case 1475L: return "bfti_afb846b145";
            case 1476L: return "bfti_afbfbd170c";
            case 1477L: return "bfti_b01314301e";
            case 1478L: return "bfti_b03da5d6ea";
            case 1479L: return "bfti_b052bf6f17";
            case 1480L: return "bfti_b05d3152a5";
            case 1481L: return "bfti_b0a32ea7f6";
            case 1482L: return "bfti_b100a3b395";
            case 1483L: return "bfti_b13ad3fc7f";
            case 1484L: return "bfti_b13ea8f07b";
            case 1485L: return "bfti_b147103a23";
            case 1486L: return "bfti_b16b545bf5";
            case 1487L: return "bfti_b179c28184";
            case 1488L: return "bfti_b17ed5dcbb";
            case 1489L: return "bfti_b17f3f93d0";
            case 1490L: return "bfti_b1b2447001";
            case 1491L: return "bfti_b1b9be06e6";
            case 1492L: return "bfti_b1c1f02ee1";
            case 1493L: return "bfti_b1d92c4a5c";
            case 1494L: return "bfti_b23bd24559";
            case 1495L: return "bfti_b245f78b5a";
            case 1496L: return "bfti_b255bff837";
            case 1497L: return "bfti_b26f2b317e";
            case 1498L: return "bfti_b2c6c7a8c0";
            case 1499L: return "bfti_b2ca075328";
            case 1500L: return "bfti_b318412877";
            case 1501L: return "bfti_b32020f057";
            case 1502L: return "bfti_b320aba05b";
            case 1503L: return "bfti_b356bc9028";
            case 1504L: return "bfti_b3c1c9347a";
            case 1505L: return "bfti_b412716bc2";
            case 1506L: return "bfti_b4315995ad";
            case 1507L: return "bfti_b48192f5d3";
            case 1508L: return "bfti_b4984ec0ef";
            case 1509L: return "bfti_b4a3100cbc";
            case 1510L: return "bfti_b4a3e2be21";
            case 1511L: return "bfti_b4ac1fafe1";
            case 1512L: return "bfti_b4c5441a31";
            case 1513L: return "bfti_b4ee5ccba2";
            case 1514L: return "bfti_b50de25c37";
            case 1515L: return "bfti_b554c02ce2";
            case 1516L: return "bfti_b56bc815e5";
            case 1517L: return "bfti_b56f335e55";
            case 1518L: return "bfti_b591649efe";
            case 1519L: return "bfti_b5a2ee518b";
            case 1520L: return "bfti_b5a7112f46";
            case 1521L: return "bfti_b5af0d529f";
            case 1522L: return "bfti_b5c501764b";
            case 1523L: return "bfti_b5c8c0bbda";
            case 1524L: return "bfti_b5d02b5eb7";
            case 1525L: return "bfti_b5e7283042";
            case 1526L: return "bfti_b5ee15bd1a";
            case 1527L: return "bfti_b6245f4003";
            case 1528L: return "bfti_b63bbd445a";
            case 1529L: return "bfti_b6634d205c";
            case 1530L: return "bfti_b6e5c02d17";
            case 1531L: return "bfti_b6f5a0d7c1";
            case 1532L: return "bfti_b714be47eb";
            case 1533L: return "bfti_b78658f4e1";
            case 1534L: return "bfti_b79cb61f2e";
            case 1535L: return "bfti_b7df1437c7";
            case 1536L: return "bfti_b7e0638101";
            case 1537L: return "bfti_b7e40fe912";
            case 1538L: return "bfti_b809e5f64e";
            case 1539L: return "bfti_b819cd2277";
            case 1540L: return "bfti_b81ae9d571";
            case 1541L: return "bfti_b83c52ca18";
            case 1542L: return "bfti_b8546d8341";
            case 1543L: return "bfti_b860bd6059";
            case 1544L: return "bfti_b861cd456c";
            case 1545L: return "bfti_b86b8ed237";
            case 1546L: return "bfti_b87a129aa0";
            case 1547L: return "bfti_b8b65349d2";
            case 1548L: return "bfti_b8dec5f274";
            case 1549L: return "bfti_b8fb3c39ef";
            case 1550L: return "bfti_b91a7e7347";
            case 1551L: return "bfti_b921391022";
            case 1552L: return "bfti_b950d05de8";
            case 1553L: return "bfti_b9beb23acb";
            case 1554L: return "bfti_b9fe771df3";
            case 1555L: return "bfti_ba4f0f6d28";
            case 1556L: return "bfti_baa2656971";
            case 1557L: return "bfti_baab380765";
            case 1558L: return "bfti_baf28ede80";
            case 1559L: return "bfti_baf3b2dfcf";
            case 1560L: return "bfti_baf82fd146";
            case 1561L: return "bfti_bb16e940b2";
            case 1562L: return "bfti_bb29e28c23";
            case 1563L: return "bfti_bb2e076aa5";
            case 1564L: return "bfti_bb315dbb21";
            case 1565L: return "bfti_bb351775e5";
            case 1566L: return "bfti_bb487b2a53";
            case 1567L: return "bfti_bb523499cd";
            case 1568L: return "bfti_bb5997c548";
            case 1569L: return "bfti_bb6ed2ce2e";
            case 1570L: return "bfti_bb7829c5b9";
            case 1571L: return "bfti_bbc5d4c040";
            case 1572L: return "bfti_bbd4d841c4";
            case 1573L: return "bfti_bbe5e95ac5";
            case 1574L: return "bfti_bbf2ffcd1c";
            case 1575L: return "bfti_bbfb1332fc";
            case 1576L: return "bfti_bc51497c04";
            case 1577L: return "bfti_bc8d46fb1a";
            case 1578L: return "bfti_bca2424fdb";
            case 1579L: return "bfti_bca4101e33";
            case 1580L: return "bfti_bcab3ce0f1";
            case 1581L: return "bfti_bcb322c85e";
            case 1582L: return "bfti_bcb92d7395";
            case 1583L: return "bfti_bce767038d";
            case 1584L: return "bfti_bcfb9b3225";
            case 1585L: return "bfti_bd1558b62f";
            case 1586L: return "bfti_bd1d3d9c37";
            case 1587L: return "bfti_bd2ab5c502";
            case 1588L: return "bfti_bd32056632";
            case 1589L: return "bfti_bd4ceb4932";
            case 1590L: return "bfti_bd621682b6";
            case 1591L: return "bfti_bd8c77ba6b";
            case 1592L: return "bfti_bd9819dc18";
            case 1593L: return "bfti_bdc1956832";
            case 1594L: return "bfti_bdcd8083e4";
            case 1595L: return "bfti_bdd2b92448";
            case 1596L: return "bfti_bdebe478f1";
            case 1597L: return "bfti_bdec379159";
            case 1598L: return "bfti_be596be481";
            case 1599L: return "bfti_be5b4fa6c2";
            case 1600L: return "bfti_be861bb9a5";
            case 1601L: return "bfti_be9f8a325d";
            case 1602L: return "bfti_bf0d377f9d";
            case 1603L: return "bfti_bf1ce0b344";
            case 1604L: return "bfti_bf4fd453ea";
            case 1605L: return "bfti_bf7138da88";
            case 1606L: return "bfti_bf925784db";
            case 1607L: return "bfti_bf93e91c21";
            case 1608L: return "bfti_bfa8b8f089";
            case 1609L: return "bfti_bffe5089a8";
            case 1610L: return "bfti_c00738ccbc";
            case 1611L: return "bfti_c046c3de04";
            case 1612L: return "bfti_c06a217627";
            case 1613L: return "bfti_c07b55824b";
            case 1614L: return "bfti_c0ad293ee9";
            case 1615L: return "bfti_c0b9a64723";
            case 1616L: return "bfti_c0bf68e2cd";
            case 1617L: return "bfti_c1462f7be1";
            case 1618L: return "bfti_c1a8628bd2";
            case 1619L: return "bfti_c1ad3876b0";
            case 1620L: return "bfti_c1bff6ca19";
            case 1621L: return "bfti_c1c10f6aa6";
            case 1622L: return "bfti_c1d6e8432a";
            case 1623L: return "bfti_c1efdbc200";
            case 1624L: return "bfti_c2009fd9ab";
            case 1625L: return "bfti_c223500f6d";
            case 1626L: return "bfti_c2340d1d37";
            case 1627L: return "bfti_c24e344492";
            case 1628L: return "bfti_c29041c36e";
            case 1629L: return "bfti_c2c14da164";
            case 1630L: return "bfti_c2e3d90748";
            case 1631L: return "bfti_c32fc88bd0";
            case 1632L: return "bfti_c338109c5f";
            case 1633L: return "bfti_c3392e25ed";
            case 1634L: return "bfti_c346bd1fcf";
            case 1635L: return "bfti_c374f16abb";
            case 1636L: return "bfti_c38303da51";
            case 1637L: return "bfti_c39b9d298e";
            case 1638L: return "bfti_c3b6b58f93";
            case 1639L: return "bfti_c3f0bd713a";
            case 1640L: return "bfti_c40c7a3275";
            case 1641L: return "bfti_c4268824f4";
            case 1642L: return "bfti_c4297fc795";
            case 1643L: return "bfti_c4405dc80c";
            case 1644L: return "bfti_c4504ef4c4";
            case 1645L: return "bfti_c4529931c7";
            case 1646L: return "bfti_c453e83cd1";
            case 1647L: return "bfti_c4683b629f";
            case 1648L: return "bfti_c496889b3a";
            case 1649L: return "bfti_c49f1724b4";
            case 1650L: return "bfti_c4b6487e95";
            case 1651L: return "bfti_c4b9ba9800";
            case 1652L: return "bfti_c4de4e68f2";
            case 1653L: return "bfti_c4ebf1ddc4";
            case 1654L: return "bfti_c4f5fad99a";
            case 1655L: return "bfti_c4f7dcaba1";
            case 1656L: return "bfti_c532468eae";
            case 1657L: return "bfti_c54d9bc801";
            case 1658L: return "bfti_c55ce00b27";
            case 1659L: return "bfti_c56e0926eb";
            case 1660L: return "bfti_c58134e999";
            case 1661L: return "bfti_c5e144957a";
            case 1662L: return "bfti_c5e2c98b4b";
            case 1663L: return "bfti_c5ed5c3921";
            case 1664L: return "bfti_c608d1e9fe";
            case 1665L: return "bfti_c640f31d68";
            case 1666L: return "bfti_c659e7568e";
            case 1667L: return "bfti_c689a0ffc4";
            case 1668L: return "bfti_c697583e6b";
            case 1669L: return "bfti_c6b60f984e";
            case 1670L: return "bfti_c6dd9b460c";
            case 1671L: return "bfti_c6ff840450";
            case 1672L: return "bfti_c707207fe7";
            case 1673L: return "bfti_c738da4d9e";
            case 1674L: return "bfti_c76a3e75e0";
            case 1675L: return "bfti_c7792ddeb7";
            case 1676L: return "bfti_c7989b2e00";
            case 1677L: return "bfti_c7ab251502";
            case 1678L: return "bfti_c7b0779a73";
            case 1679L: return "bfti_c7b9951cea";
            case 1680L: return "bfti_c7c395da0f";
            case 1681L: return "bfti_c7df608793";
            case 1682L: return "bfti_c8136316b5";
            case 1683L: return "bfti_c833811d37";
            case 1684L: return "bfti_c83455426e";
            case 1685L: return "bfti_c86aa80f14";
            case 1686L: return "bfti_c8846b59d3";
            case 1687L: return "bfti_c8a2ddf896";
            case 1688L: return "bfti_c8cfe57591";
            case 1689L: return "bfti_c8d8accf5f";
            case 1690L: return "bfti_c8ebf7c9dd";
            case 1691L: return "bfti_c8ecfe09e8";
            case 1692L: return "bfti_c922566151";
            case 1693L: return "bfti_c92453a0a7";
            case 1694L: return "bfti_c9630d09dc";
            case 1695L: return "bfti_c96c630c47";
            case 1696L: return "bfti_c96e076b7e";
            case 1697L: return "bfti_c97258b9ee";
            case 1698L: return "bfti_c98236df38";
            case 1699L: return "bfti_c9b4b2d405";
            case 1700L: return "bfti_c9d8d1fc87";
            case 1701L: return "bfti_ca1c9559d7";
            case 1702L: return "bfti_ca58a2a76f";
            case 1703L: return "bfti_ca82943ec4";
            case 1704L: return "bfti_cae4f0d655";
            case 1705L: return "bfti_cb08d9acdd";
            case 1706L: return "bfti_cb9f72e7da";
            case 1707L: return "bfti_cba2107c00";
            case 1708L: return "bfti_cbc277c523";
            case 1709L: return "bfti_cbd3e996ec";
            case 1710L: return "bfti_cbd9894a96";
            case 1711L: return "bfti_cbe3c97219";
            case 1712L: return "bfti_cc0b0f1337";
            case 1713L: return "bfti_cc5fb7ed79";
            case 1714L: return "bfti_cc6bc683af";
            case 1715L: return "bfti_cc98505991";
            case 1716L: return "bfti_ccb370f3b2";
            case 1717L: return "bfti_ccc273dcf6";
            case 1718L: return "bfti_cce576adeb";
            case 1719L: return "bfti_cd67dcc966";
            case 1720L: return "bfti_cd9d6e69ac";
            case 1721L: return "bfti_cdb3ae5237";
            case 1722L: return "bfti_cdb44d631c";
            case 1723L: return "bfti_cdb64f8594";
            case 1724L: return "bfti_cdc173fd55";
            case 1725L: return "bfti_cdd2355e00";
            case 1726L: return "bfti_ce0804814a";
            case 1727L: return "bfti_ce27cb807f";
            case 1728L: return "bfti_ce64a83900";
            case 1729L: return "bfti_ceab1b8cd5";
            case 1730L: return "bfti_cec05a888a";
            case 1731L: return "bfti_cec909ed39";
            case 1732L: return "bfti_ced0dc715b";
            case 1733L: return "bfti_cedc14d25c";
            case 1734L: return "bfti_cf1272f225";
            case 1735L: return "bfti_cf22057832";
            case 1736L: return "bfti_cf467abd62";
            case 1737L: return "bfti_cfd0be8b3c";
            case 1738L: return "bfti_cfd4683658";
            case 1739L: return "bfti_cfee8e1f3a";
            case 1740L: return "bfti_d01b2ed9f0";
            case 1741L: return "bfti_d03f5672de";
            case 1742L: return "bfti_d073fda265";
            case 1743L: return "bfti_d09216e200";
            case 1744L: return "bfti_d09a1e33d9";
            case 1745L: return "bfti_d09e01a8e5";
            case 1746L: return "bfti_d0f14e168d";
            case 1747L: return "bfti_d0fa8fe4ce";
            case 1748L: return "bfti_d0fdbdb40d";
            case 1749L: return "bfti_d10aafd5a3";
            case 1750L: return "bfti_d10e6d91c1";
            case 1751L: return "bfti_d1539785fc";
            case 1752L: return "bfti_d155030d64";
            case 1753L: return "bfti_d156b6898a";
            case 1754L: return "bfti_d18b29ea35";
            case 1755L: return "bfti_d18f0cc527";
            case 1756L: return "bfti_d195fa1e38";
            case 1757L: return "bfti_d1bf93f85a";
            case 1758L: return "bfti_d206537496";
            case 1759L: return "bfti_d215731d67";
            case 1760L: return "bfti_d2469ffa77";
            case 1761L: return "bfti_d275e5d4e6";
            case 1762L: return "bfti_d28bcd8da9";
            case 1763L: return "bfti_d29eca8d67";
            case 1764L: return "bfti_d2e074961c";
            case 1765L: return "bfti_d2f9401152";
            case 1766L: return "bfti_d30110d3fb";
            case 1767L: return "bfti_d35d7b8e13";
            case 1768L: return "bfti_d39659f2ab";
            case 1769L: return "bfti_d3c0217805";
            case 1770L: return "bfti_d3e3c773d9";
            case 1771L: return "bfti_d3f623646c";
            case 1772L: return "bfti_d3ff668cbf";
            case 1773L: return "bfti_d410ba086b";
            case 1774L: return "bfti_d45473f6de";
            case 1775L: return "bfti_d45eea814d";
            case 1776L: return "bfti_d494954117";
            case 1777L: return "bfti_d4a2038c67";
            case 1778L: return "bfti_d4a876c514";
            case 1779L: return "bfti_d4c9ce383a";
            case 1780L: return "bfti_d4e8d2026f";
            case 1781L: return "bfti_d4ef95ae10";
            case 1782L: return "bfti_d518665079";
            case 1783L: return "bfti_d51bcf4fe6";
            case 1784L: return "bfti_d5317f6a19";
            case 1785L: return "bfti_d54836d3d4";
            case 1786L: return "bfti_d573552715";
            case 1787L: return "bfti_d58ee2f5ff";
            case 1788L: return "bfti_d5954c2bbd";
            case 1789L: return "bfti_d59de47a45";
            case 1790L: return "bfti_d5e0afcb65";
            case 1791L: return "bfti_d5e96f9474";
            case 1792L: return "bfti_d60608391d";
            case 1793L: return "bfti_d617cfd87c";
            case 1794L: return "bfti_d66dbb3d53";
            case 1795L: return "bfti_d688d49c70";
            case 1796L: return "bfti_d6cf059146";
            case 1797L: return "bfti_d6eaa3bded";
            case 1798L: return "bfti_d764410123";
            case 1799L: return "bfti_d769be6c4b";
            case 1800L: return "bfti_d7f5582c63";
            case 1801L: return "bfti_d81d222b15";
            case 1802L: return "bfti_d88f511064";
            case 1803L: return "bfti_d91239a169";
            case 1804L: return "bfti_d9629cde9c";
            case 1805L: return "bfti_d98fac9738";
            case 1806L: return "bfti_d9a22ef3b7";
            case 1807L: return "bfti_d9af0bc253";
            case 1808L: return "bfti_da0c05bdea";
            case 1809L: return "bfti_da2ae06c81";
            case 1810L: return "bfti_da479757b6";
            case 1811L: return "bfti_da509d69d8";
            case 1812L: return "bfti_da6f63fa25";
            case 1813L: return "bfti_da7aeece0f";
            case 1814L: return "bfti_daa9a51b8f";
            case 1815L: return "bfti_dac269456c";
            case 1816L: return "bfti_dafb9f78bc";
            case 1817L: return "bfti_db1484c146";
            case 1818L: return "bfti_db1e578566";
            case 1819L: return "bfti_db3e8bcf93";
            case 1820L: return "bfti_db4a4eba52";
            case 1821L: return "bfti_db7b4183db";
            case 1822L: return "bfti_db81816ecd";
            case 1823L: return "bfti_db932471d7";
            case 1824L: return "bfti_dbac1e5ee4";
            case 1825L: return "bfti_dc01001a53";
            case 1826L: return "bfti_dc55d8e45c";
            case 1827L: return "bfti_dcbf0c9924";
            case 1828L: return "bfti_dcda675c5e";
            case 1829L: return "bfti_dd0544598a";
            case 1830L: return "bfti_dd0edf0911";
            case 1831L: return "bfti_dd1dccfad5";
            case 1832L: return "bfti_dd5c34f83a";
            case 1833L: return "bfti_dd925c690b";
            case 1834L: return "bfti_dda79210d5";
            case 1835L: return "bfti_ddaef1085b";
            case 1836L: return "bfti_ddbaa69943";
            case 1837L: return "bfti_dde2d2df2e";
            case 1838L: return "bfti_dde9c31aab";
            case 1839L: return "bfti_ddeaddad2a";
            case 1840L: return "bfti_de121de5f9";
            case 1841L: return "bfti_de39384a90";
            case 1842L: return "bfti_de4ada85b6";
            case 1843L: return "bfti_de4bc29402";
            case 1844L: return "bfti_de826caa72";
            case 1845L: return "bfti_de8ba52df3";
            case 1846L: return "bfti_debe442f2e";
            case 1847L: return "bfti_dec1ea95c7";
            case 1848L: return "bfti_decd0bd8c4";
            case 1849L: return "bfti_ded1e53cc0";
            case 1850L: return "bfti_dee8d7ed9e";
            case 1851L: return "bfti_def576084b";
            case 1852L: return "bfti_defb063cfb";
            case 1853L: return "bfti_df04730baf";
            case 1854L: return "bfti_df047ee4cb";
            case 1855L: return "bfti_df120f4412";
            case 1856L: return "bfti_df4d8f86e5";
            case 1857L: return "bfti_df502df456";
            case 1858L: return "bfti_df7afde2a6";
            case 1859L: return "bfti_dfb5b095d4";
            case 1860L: return "bfti_dfffb43f8a";
            case 1861L: return "bfti_e0036e3da2";
            case 1862L: return "bfti_e02d34d7fe";
            case 1863L: return "bfti_e0376efc04";
            case 1864L: return "bfti_e04dbe1ed1";
            case 1865L: return "bfti_e0724b2ea7";
            case 1866L: return "bfti_e094af64d6";
            case 1867L: return "bfti_e0d03ab848";
            case 1868L: return "bfti_e0db2a4a53";
            case 1869L: return "bfti_e0e377c1bd";
            case 1870L: return "bfti_e1066b5ec4";
            case 1871L: return "bfti_e11fbc319c";
            case 1872L: return "bfti_e150a4d6a7";
            case 1873L: return "bfti_e173c3bdad";
            case 1874L: return "bfti_e1b9eda92e";
            case 1875L: return "bfti_e1be22c277";
            case 1876L: return "bfti_e1c0492848";
            case 1877L: return "bfti_e1e58145da";
            case 1878L: return "bfti_e1f0e8999f";
            case 1879L: return "bfti_e1fb5e1fe8";
            case 1880L: return "bfti_e21b2ece9e";
            case 1881L: return "bfti_e23bf60b57";
            case 1882L: return "bfti_e256fbb843";
            case 1883L: return "bfti_e27df2d830";
            case 1884L: return "bfti_e29e8c76f5";
            case 1885L: return "bfti_e2bf034f20";
            case 1886L: return "bfti_e2dcbe343e";
            case 1887L: return "bfti_e2dd9e2e56";
            case 1888L: return "bfti_e2e4d7865c";
            case 1889L: return "bfti_e307270b1f";
            case 1890L: return "bfti_e3075b9388";
            case 1891L: return "bfti_e326673aec";
            case 1892L: return "bfti_e330738694";
            case 1893L: return "bfti_e3394256ac";
            case 1894L: return "bfti_e3a2e4983e";
            case 1895L: return "bfti_e3ae10b090";
            case 1896L: return "bfti_e402efe3af";
            case 1897L: return "bfti_e42963e8e2";
            case 1898L: return "bfti_e46136fb52";
            case 1899L: return "bfti_e467e41671";
            case 1900L: return "bfti_e4c2962623";
            case 1901L: return "bfti_e4fc7a1cc8";
            case 1902L: return "bfti_e51a9102f6";
            case 1903L: return "bfti_e53440bad4";
            case 1904L: return "bfti_e5d921181f";
            case 1905L: return "bfti_e6103617cb";
            case 1906L: return "bfti_e62982b650";
            case 1907L: return "bfti_e6470ea292";
            case 1908L: return "bfti_e658c32910";
            case 1909L: return "bfti_e68a5c2caf";
            case 1910L: return "bfti_e69d6edd95";
            case 1911L: return "bfti_e6c6ba8e25";
            case 1912L: return "bfti_e6dae0b968";
            case 1913L: return "bfti_e6df4483d3";
            case 1914L: return "bfti_e7110292a4";
            case 1915L: return "bfti_e7223491ae";
            case 1916L: return "bfti_e72b870587";
            case 1917L: return "bfti_e72d0bc0dd";
            case 1918L: return "bfti_e7498b0c2a";
            case 1919L: return "bfti_e784cbea37";
            case 1920L: return "bfti_e7bf8df06e";
            case 1921L: return "bfti_e7ea306c2e";
            case 1922L: return "bfti_e80fc1d2a3";
            case 1923L: return "bfti_e81ba5a612";
            case 1924L: return "bfti_e82e20a540";
            case 1925L: return "bfti_e8341b76ec";
            case 1926L: return "bfti_e8378314e4";
            case 1927L: return "bfti_e8395d327b";
            case 1928L: return "bfti_e86032bd75";
            case 1929L: return "bfti_e86f5fc5bc";
            case 1930L: return "bfti_e89a02e09f";
            case 1931L: return "bfti_e8abb52925";
            case 1932L: return "bfti_e8d8539733";
            case 1933L: return "bfti_e944e016ac";
            case 1934L: return "bfti_e94efe43f7";
            case 1935L: return "bfti_e9940d4b68";
            case 1936L: return "bfti_e996f47390";
            case 1937L: return "bfti_e9fdf9e610";
            case 1938L: return "bfti_ea186403d9";
            case 1939L: return "bfti_ea18a9682b";
            case 1940L: return "bfti_ea3d7c0b91";
            case 1941L: return "bfti_ea44be3ef1";
            case 1942L: return "bfti_ea531035ce";
            case 1943L: return "bfti_eac41a89c8";
            case 1944L: return "bfti_eaeabc9957";
            case 1945L: return "bfti_eaf552bbd5";
            case 1946L: return "bfti_eb0f764104";
            case 1947L: return "bfti_eb249ec982";
            case 1948L: return "bfti_eb712f0bdb";
            case 1949L: return "bfti_eb774769c9";
            case 1950L: return "bfti_eb800a3ed7";
            case 1951L: return "bfti_eb991ad3f8";
            case 1952L: return "bfti_eba6079ecb";
            case 1953L: return "bfti_eba8fe603d";
            case 1954L: return "bfti_ebcb25d721";
            case 1955L: return "bfti_ebe12987ea";
            case 1956L: return "bfti_ec1c4fc343";
            case 1957L: return "bfti_ec3991cdb3";
            case 1958L: return "bfti_ec4e93048b";
            case 1959L: return "bfti_ec510b378a";
            case 1960L: return "bfti_ec8294af72";
            case 1961L: return "bfti_ec9eaa6cc9";
            case 1962L: return "bfti_ecbf7c3952";
            case 1963L: return "bfti_ecc1777e00";
            case 1964L: return "bfti_ecd989c159";
            case 1965L: return "bfti_ed1f9fee39";
            case 1966L: return "bfti_ed2a28af9f";
            case 1967L: return "bfti_ed6b7fc650";
            case 1968L: return "bfti_ed83f24fc9";
            case 1969L: return "bfti_edb0d22177";
            case 1970L: return "bfti_ee07931288";
            case 1971L: return "bfti_ee0e12d5d8";
            case 1972L: return "bfti_ee4e80e92e";
            case 1973L: return "bfti_ee9498a725";
            case 1974L: return "bfti_eebb362371";
            case 1975L: return "bfti_ef0879a007";
            case 1976L: return "bfti_ef45e5427a";
            case 1977L: return "bfti_ef69064538";
            case 1978L: return "bfti_ef6b16135c";
            case 1979L: return "bfti_ef9c2a2588";
            case 1980L: return "bfti_efc83f14da";
            case 1981L: return "bfti_efefccb61e";
            case 1982L: return "bfti_f00037c220";
            case 1983L: return "bfti_f0005979bc";
            case 1984L: return "bfti_f004038852";
            case 1985L: return "bfti_f04bca1267";
            case 1986L: return "bfti_f098fd319a";
            case 1987L: return "bfti_f0cc077772";
            case 1988L: return "bfti_f0e48fbf1d";
            case 1989L: return "bfti_f0e7a08dc6";
            case 1990L: return "bfti_f11709c0ca";
            case 1991L: return "bfti_f16def1781";
            case 1992L: return "bfti_f175fa97ba";
            case 1993L: return "bfti_f17bd906f1";
            case 1994L: return "bfti_f1ae98068c";
            case 1995L: return "bfti_f1ec082751";
            case 1996L: return "bfti_f23cd7545e";
            case 1997L: return "bfti_f2e82fe7eb";
            case 1998L: return "bfti_f2f30c1868";
            case 1999L: return "bfti_f31078c017";
            case 2000L: return "bfti_f31fa9d57d";
            case 2001L: return "bfti_f328af8e55";
            case 2002L: return "bfti_f349b86ad0";
            case 2003L: return "bfti_f3625a753e";
            case 2004L: return "bfti_f36a819e53";
            case 2005L: return "bfti_f388485362";
            case 2006L: return "bfti_f3a9c0ffa8";
            case 2007L: return "bfti_f3b7558a14";
            case 2008L: return "bfti_f3c4691d8b";
            case 2009L: return "bfti_f3c8d4357c";
            case 2010L: return "bfti_f3dc909b34";
            case 2011L: return "bfti_f3fe702729";
            case 2012L: return "bfti_f41a7e5346";
            case 2013L: return "bfti_f42ad892e3";
            case 2014L: return "bfti_f47907394b";
            case 2015L: return "bfti_f48e738432";
            case 2016L: return "bfti_f4ab981150";
            case 2017L: return "bfti_f4b8e269fd";
            case 2018L: return "bfti_f4cf58d722";
            case 2019L: return "bfti_f4d5595ade";
            case 2020L: return "bfti_f4efa1f3e0";
            case 2021L: return "bfti_f522976c00";
            case 2022L: return "bfti_f546d4cc7d";
            case 2023L: return "bfti_f5a37604a0";
            case 2024L: return "bfti_f5cfb4b36d";
            case 2025L: return "bfti_f6139a5b1c";
            case 2026L: return "bfti_f619988375";
            case 2027L: return "bfti_f667f7472c";
            case 2028L: return "bfti_f675857266";
            case 2029L: return "bfti_f68345ce77";
            case 2030L: return "bfti_f68f94e898";
            case 2031L: return "bfti_f6b167f49c";
            case 2032L: return "bfti_f6e13c6253";
            case 2033L: return "bfti_f6f6715eae";
            case 2034L: return "bfti_f701d29bf6";
            case 2035L: return "bfti_f7096e66b8";
            case 2036L: return "bfti_f7469c46ee";
            case 2037L: return "bfti_f7541e2606";
            case 2038L: return "bfti_f7a9dd4858";
            case 2039L: return "bfti_f7b5c01d95";
            case 2040L: return "bfti_f7bce644c8";
            case 2041L: return "bfti_f7e06f26f2";
            case 2042L: return "bfti_f7e85347c6";
            case 2043L: return "bfti_f7fa335e50";
            case 2044L: return "bfti_f80defb21e";
            case 2045L: return "bfti_f81185710d";
            case 2046L: return "bfti_f825c51446";
            case 2047L: return "bfti_f84b461ec8";
            case 2048L: return "bfti_f8b96e2714";
            case 2049L: return "bfti_f8bcc4fb0c";
            case 2050L: return "bfti_f8e01da3da";
            case 2051L: return "bfti_f8e4c00692";
            case 2052L: return "bfti_f8e6203699";
            case 2053L: return "bfti_f8ed161325";
            case 2054L: return "bfti_f8fcfa7f69";
            case 2055L: return "bfti_f906837692";
            case 2056L: return "bfti_f90ca5d33f";
            case 2057L: return "bfti_f9520da84b";
            case 2058L: return "bfti_f970022bc4";
            case 2059L: return "bfti_f9837438ff";
            case 2060L: return "bfti_f986b2d5ce";
            case 2061L: return "bfti_f98fef8652";
            case 2062L: return "bfti_f99710fc1d";
            case 2063L: return "bfti_f9b0b4e9b6";
            case 2064L: return "bfti_f9cc71ca3b";
            case 2065L: return "bfti_f9e54aadd6";
            case 2066L: return "bfti_f9f39af3ae";
            case 2067L: return "bfti_f9f6640629";
            case 2068L: return "bfti_fa64ad19f0";
            case 2069L: return "bfti_fa6659b90b";
            case 2070L: return "bfti_fa6e4f625e";
            case 2071L: return "bfti_fabc3d4a4f";
            case 2072L: return "bfti_fac1365817";
            case 2073L: return "bfti_fafc65e875";
            case 2074L: return "bfti_fb39ee2ab0";
            case 2075L: return "bfti_fb3b241720";
            case 2076L: return "bfti_fb4e42ae06";
            case 2077L: return "bfti_fb5ad52db3";
            case 2078L: return "bfti_fb602dd132";
            case 2079L: return "bfti_fb60ac0bc9";
            case 2080L: return "bfti_fb85c61cbb";
            case 2081L: return "bfti_fbc6154444";
            case 2082L: return "bfti_fbf1af9eea";
            case 2083L: return "bfti_fc0bd128f4";
            case 2084L: return "bfti_fc24ed5436";
            case 2085L: return "bfti_fc2a05412b";
            case 2086L: return "bfti_fc3c52a0fb";
            case 2087L: return "bfti_fc4bb5e11c";
            case 2088L: return "bfti_fc75304bbc";
            case 2089L: return "bfti_fc839f5c89";
            case 2090L: return "bfti_fc86f4b82a";
            case 2091L: return "bfti_fd30bc8201";
            case 2092L: return "bfti_fd44bab025";
            case 2093L: return "bfti_fd5562a3ff";
            case 2094L: return "bfti_fd5aaa6f87";
            case 2095L: return "bfti_fdb89a20cb";
            case 2096L: return "bfti_fdc8662281";
            case 2097L: return "bfti_fdd6928843";
            case 2098L: return "bfti_fdd7a5e331";
            case 2099L: return "bfti_fdd7f1e60f";
            case 2100L: return "bfti_fdeb8449f8";
            case 2101L: return "bfti_fdec4e1bd1";
            case 2102L: return "bfti_fe18d6e969";
            case 2103L: return "bfti_fe1db9286a";
            case 2104L: return "bfti_fe95eb849c";
            case 2105L: return "bfti_fea59671c2";
            case 2106L: return "bfti_feb8bcf217";
            case 2107L: return "bfti_fec957fd30";
            case 2108L: return "bfti_fece9e70ec";
            case 2109L: return "bfti_fedc099f48";
            case 2110L: return "bfti_feeac38fe4";
            case 2111L: return "bfti_ff12d56947";
            case 2112L: return "bfti_ff3d9cb127";
            case 2113L: return "bfti_ff7e5ae566";
            case 2114L: return "bfti_ff8d0d91d9";
            case 2115L: return "bfti_ff9d63b71f";
            case 2116L: return "bfti_ff9d993979";
            case 2117L: return "bfti_ff9dfa626a";
            case 2118L: return "bfti_ffc841e027";
            case 2119L: return "bfti_ffe16e5df8";
            case 2120L: return "bfti_ffe4addc6d";
            case 2121L: return "bfti_last";
            default: return "";
        }
    }

    std::string a_builtin_function_type_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_type_index(i);
        if (s.empty())
            s = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_type_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L
        };
        static const std::vector<int64_t> retval(values, values + 2122);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_type_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_type_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_type_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_type_index() {
        return stringify::a_builtin_function_type_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/builtin_defs.h line 4277
namespace stringify {
    const char* a_builtin_function_condition_index(int64_t i) {
        switch (i) {
            case 0L: return "bfci_00f7898ac1";
            case 1L: return "bfci_023c888429";
            case 2L: return "bfci_02af039f89";
            case 3L: return "bfci_03cc0a7dc4";
            case 4L: return "bfci_05f1854379";
            case 5L: return "bfci_06f5a8045f";
            case 6L: return "bfci_07fddcd316";
            case 7L: return "bfci_08b3aa4129";
            case 8L: return "bfci_0904b91f4a";
            case 9L: return "bfci_0a94310b00";
            case 10L: return "bfci_0ad6a55c34";
            case 11L: return "bfci_0bb687c5e4";
            case 12L: return "bfci_0db4983715";
            case 13L: return "bfci_0dfb27eb98";
            case 14L: return "bfci_0e2c11caa7";
            case 15L: return "bfci_0f0fdd84b4";
            case 16L: return "bfci_0f450964bb";
            case 17L: return "bfci_0f65c04b32";
            case 18L: return "bfci_0fbbca9837";
            case 19L: return "bfci_122d7c153b";
            case 20L: return "bfci_128232cc7f";
            case 21L: return "bfci_14f926a96f";
            case 22L: return "bfci_1584883a5c";
            case 23L: return "bfci_1639e4d87e";
            case 24L: return "bfci_166c46465e";
            case 25L: return "bfci_16e0f137b7";
            case 26L: return "bfci_18105219d6";
            case 27L: return "bfci_189110168a";
            case 28L: return "bfci_1a45864a1b";
            case 29L: return "bfci_1ad6a4407a";
            case 30L: return "bfci_1b20405271";
            case 31L: return "bfci_1b22e07cde";
            case 32L: return "bfci_1cf925f27f";
            case 33L: return "bfci_208bf41966";
            case 34L: return "bfci_24d7b6c650";
            case 35L: return "bfci_251bba9b08";
            case 36L: return "bfci_28d016cf40";
            case 37L: return "bfci_2b141f30ec";
            case 38L: return "bfci_2b6a6ccbfd";
            case 39L: return "bfci_2b83d5c086";
            case 40L: return "bfci_2bdc9b7c53";
            case 41L: return "bfci_2e3d8a2d64";
            case 42L: return "bfci_2eda4ca466";
            case 43L: return "bfci_2ee82dc3d0";
            case 44L: return "bfci_30a8f841d0";
            case 45L: return "bfci_3184ecb0eb";
            case 46L: return "bfci_32163ae6f8";
            case 47L: return "bfci_3325a27549";
            case 48L: return "bfci_33d2cd07a4";
            case 49L: return "bfci_360945a0aa";
            case 50L: return "bfci_3658d5daaf";
            case 51L: return "bfci_37096f0c56";
            case 52L: return "bfci_38b3fa5b0c";
            case 53L: return "bfci_3949302733";
            case 54L: return "bfci_396f29aaa8";
            case 55L: return "bfci_39931913b1";
            case 56L: return "bfci_3ad620d37f";
            case 57L: return "bfci_3b4d939364";
            case 58L: return "bfci_3c62e28266";
            case 59L: return "bfci_3d7e578457";
            case 60L: return "bfci_3f8db3aebf";
            case 61L: return "bfci_405b7f8d43";
            case 62L: return "bfci_406d0b7d5c";
            case 63L: return "bfci_41fe137935";
            case 64L: return "bfci_4283c97174";
            case 65L: return "bfci_432a5a4741";
            case 66L: return "bfci_43401f0c3e";
            case 67L: return "bfci_45b1e2f4fa";
            case 68L: return "bfci_49263981c7";
            case 69L: return "bfci_49bce16100";
            case 70L: return "bfci_4abb53d66f";
            case 71L: return "bfci_4b9fc82931";
            case 72L: return "bfci_4bfa966855";
            case 73L: return "bfci_4c073e3d32";
            case 74L: return "bfci_4c0ef4cb09";
            case 75L: return "bfci_4c453628b7";
            case 76L: return "bfci_4de20c655a";
            case 77L: return "bfci_4e1252c20f";
            case 78L: return "bfci_4e63ca8caf";
            case 79L: return "bfci_502ffc9ecc";
            case 80L: return "bfci_508053f403";
            case 81L: return "bfci_513a431293";
            case 82L: return "bfci_520a754f09";
            case 83L: return "bfci_522a7362cf";
            case 84L: return "bfci_5440a29628";
            case 85L: return "bfci_54826858f8";
            case 86L: return "bfci_54a29ecd4b";
            case 87L: return "bfci_54df111b0b";
            case 88L: return "bfci_55c72c9da6";
            case 89L: return "bfci_56682e3d8c";
            case 90L: return "bfci_5774453750";
            case 91L: return "bfci_577b2906b3";
            case 92L: return "bfci_57ae73720e";
            case 93L: return "bfci_57e928b997";
            case 94L: return "bfci_59aa2e490d";
            case 95L: return "bfci_5a36eb321d";
            case 96L: return "bfci_5adee730bd";
            case 97L: return "bfci_5bf906970b";
            case 98L: return "bfci_5d2530522e";
            case 99L: return "bfci_5e4b26a750";
            case 100L: return "bfci_5ebf9a8708";
            case 101L: return "bfci_5feba30d04";
            case 102L: return "bfci_60dac71855";
            case 103L: return "bfci_6233187660";
            case 104L: return "bfci_62c10382ca";
            case 105L: return "bfci_62f5b90514";
            case 106L: return "bfci_634ad11953";
            case 107L: return "bfci_6462b43199";
            case 108L: return "bfci_651e3687bb";
            case 109L: return "bfci_6697624632";
            case 110L: return "bfci_670852f41a";
            case 111L: return "bfci_67fecca1dd";
            case 112L: return "bfci_6824786031";
            case 113L: return "bfci_69d4f189e6";
            case 114L: return "bfci_6a4e73b1f7";
            case 115L: return "bfci_6a8da69fa1";
            case 116L: return "bfci_6c559f46f1";
            case 117L: return "bfci_6ccda99e01";
            case 118L: return "bfci_6e8695f6e1";
            case 119L: return "bfci_6edf5a16fc";
            case 120L: return "bfci_713af109f0";
            case 121L: return "bfci_715cee0f46";
            case 122L: return "bfci_7292666ab4";
            case 123L: return "bfci_74877ae309";
            case 124L: return "bfci_74973482fa";
            case 125L: return "bfci_752da8b1fe";
            case 126L: return "bfci_779f906272";
            case 127L: return "bfci_77e865c6a2";
            case 128L: return "bfci_783b1bcf11";
            case 129L: return "bfci_78b62bf4fc";
            case 130L: return "bfci_79815881ff";
            case 131L: return "bfci_7bff338720";
            case 132L: return "bfci_7de2ca1029";
            case 133L: return "bfci_819b663547";
            case 134L: return "bfci_819dfc40c9";
            case 135L: return "bfci_81f7ddea30";
            case 136L: return "bfci_822510f655";
            case 137L: return "bfci_828d52a9f4";
            case 138L: return "bfci_829d78317c";
            case 139L: return "bfci_84bc60bb46";
            case 140L: return "bfci_8534e84a97";
            case 141L: return "bfci_858b2c1758";
            case 142L: return "bfci_85c0226b73";
            case 143L: return "bfci_863b97bf5d";
            case 144L: return "bfci_87c8ad8477";
            case 145L: return "bfci_89741dc6ad";
            case 146L: return "bfci_8ad4effd96";
            case 147L: return "bfci_8d3cda1dc3";
            case 148L: return "bfci_8f30ba5abe";
            case 149L: return "bfci_8fc6b9a779";
            case 150L: return "bfci_915c9bd439";
            case 151L: return "bfci_92436a153d";
            case 152L: return "bfci_9377bbcfa7";
            case 153L: return "bfci_94fe778681";
            case 154L: return "bfci_94fe8631f9";
            case 155L: return "bfci_9502adfe46";
            case 156L: return "bfci_958934928d";
            case 157L: return "bfci_959812e8be";
            case 158L: return "bfci_95deeaeb59";
            case 159L: return "bfci_95ef0a52d2";
            case 160L: return "bfci_9602b2a587";
            case 161L: return "bfci_97cd2838f9";
            case 162L: return "bfci_99788cf313";
            case 163L: return "bfci_99cfd45cc2";
            case 164L: return "bfci_99d7e22373";
            case 165L: return "bfci_99f247e3d3";
            case 166L: return "bfci_9a6fa67179";
            case 167L: return "bfci_9a8f27778b";
            case 168L: return "bfci_9b42c213be";
            case 169L: return "bfci_9b8dca96ed";
            case 170L: return "bfci_9c3f64c544";
            case 171L: return "bfci_9cb3f2de6d";
            case 172L: return "bfci_9e3f2d008e";
            case 173L: return "bfci_9ed43877aa";
            case 174L: return "bfci_9fc024b9d1";
            case 175L: return "bfci_a11751e8c7";
            case 176L: return "bfci_a1ea1d44f4";
            case 177L: return "bfci_a201931f77";
            case 178L: return "bfci_a2cc09eead";
            case 179L: return "bfci_a33b49d4c4";
            case 180L: return "bfci_a4537c68bd";
            case 181L: return "bfci_a4fe5f2994";
            case 182L: return "bfci_a53fd2bb41";
            case 183L: return "bfci_a64b37e87e";
            case 184L: return "bfci_a7330460b7";
            case 185L: return "bfci_a781bfe8c7";
            case 186L: return "bfci_a7e9ce229c";
            case 187L: return "bfci_a82603eeaa";
            case 188L: return "bfci_a86ccbad83";
            case 189L: return "bfci_a90062d397";
            case 190L: return "bfci_a9c6b361c8";
            case 191L: return "bfci_ab11f6964c";
            case 192L: return "bfci_ab51cb3c48";
            case 193L: return "bfci_ab65adfe0e";
            case 194L: return "bfci_ad3825c933";
            case 195L: return "bfci_adc63abe75";
            case 196L: return "bfci_adef37cffd";
            case 197L: return "bfci_af2178e4b7";
            case 198L: return "bfci_af556fac96";
            case 199L: return "bfci_b03ddf20b3";
            case 200L: return "bfci_b10b51ded7";
            case 201L: return "bfci_b1cec7092e";
            case 202L: return "bfci_b22d4facff";
            case 203L: return "bfci_b26f2cfb08";
            case 204L: return "bfci_b455251d81";
            case 205L: return "bfci_b4aa481bef";
            case 206L: return "bfci_b51a2bbe85";
            case 207L: return "bfci_b539c6f0a8";
            case 208L: return "bfci_b57a37d661";
            case 209L: return "bfci_b686ebed1a";
            case 210L: return "bfci_b73c4f16e5";
            case 211L: return "bfci_b813592eb0";
            case 212L: return "bfci_b90efe4b7e";
            case 213L: return "bfci_ba50c01cb5";
            case 214L: return "bfci_bad392549e";
            case 215L: return "bfci_bb902b1b0f";
            case 216L: return "bfci_bc534c5473";
            case 217L: return "bfci_bc6ed4867a";
            case 218L: return "bfci_bd0ab013c9";
            case 219L: return "bfci_c0cfdaf944";
            case 220L: return "bfci_c382276e7f";
            case 221L: return "bfci_c3a192d6c1";
            case 222L: return "bfci_c427d326a4";
            case 223L: return "bfci_c5fa5926f2";
            case 224L: return "bfci_c643c030aa";
            case 225L: return "bfci_c69f9a4f8b";
            case 226L: return "bfci_c6feacf333";
            case 227L: return "bfci_c786ccfb66";
            case 228L: return "bfci_c798f5e9ea";
            case 229L: return "bfci_c8e6be958a";
            case 230L: return "bfci_c9f1aecdc8";
            case 231L: return "bfci_ca711666f3";
            case 232L: return "bfci_cdae3e4632";
            case 233L: return "bfci_ce2a96ed38";
            case 234L: return "bfci_cec983dfe6";
            case 235L: return "bfci_cee21c23e8";
            case 236L: return "bfci_cfd49bdf86";
            case 237L: return "bfci_d23485c2ea";
            case 238L: return "bfci_d24f7b9365";
            case 239L: return "bfci_d2abb762b9";
            case 240L: return "bfci_d35abe7739";
            case 241L: return "bfci_d76d02e310";
            case 242L: return "bfci_d81a3b371a";
            case 243L: return "bfci_dacb367fda";
            case 244L: return "bfci_db0aa07e4d";
            case 245L: return "bfci_dc3e7aaf4d";
            case 246L: return "bfci_de9d5193d7";
            case 247L: return "bfci_e030436e93";
            case 248L: return "bfci_e153c0eaa5";
            case 249L: return "bfci_e155f0607a";
            case 250L: return "bfci_e2a99c7094";
            case 251L: return "bfci_e374bf567b";
            case 252L: return "bfci_e64364acdb";
            case 253L: return "bfci_e6b4e03721";
            case 254L: return "bfci_e73f511266";
            case 255L: return "bfci_e796ae2ac5";
            case 256L: return "bfci_e7ab46e012";
            case 257L: return "bfci_e91242a7aa";
            case 258L: return "bfci_eba83ed205";
            case 259L: return "bfci_ec7c3ecaa2";
            case 260L: return "bfci_ed67fabb51";
            case 261L: return "bfci_ed7b044a3b";
            case 262L: return "bfci_edb114e3c7";
            case 263L: return "bfci_ee665fd40d";
            case 264L: return "bfci_ef0582593d";
            case 265L: return "bfci_eff010683a";
            case 266L: return "bfci_f023265b7b";
            case 267L: return "bfci_f02e002361";
            case 268L: return "bfci_f1a07309fd";
            case 269L: return "bfci_f1bcd01647";
            case 270L: return "bfci_f347f14cec";
            case 271L: return "bfci_f38d5e9172";
            case 272L: return "bfci_f3f5ce09c8";
            case 273L: return "bfci_f40ffd293a";
            case 274L: return "bfci_f4471a96d1";
            case 275L: return "bfci_f6c14e39e6";
            case 276L: return "bfci_f7d440e3c6";
            case 277L: return "bfci_f8fb60295c";
            case 278L: return "bfci_fa0252ddf6";
            case 279L: return "bfci_fbb6119505";
            case 280L: return "bfci_fbeac09b3b";
            case 281L: return "bfci_fbf29a145f";
            case 282L: return "bfci_fcf334be72";
            case 283L: return "bfci_fe170151e2";
            case 284L: return "bfci_ff337d6933";
            case 285L: return "bfci_ffd4a0cf4a";
            case 286L: return "bfci_last";
            default: return "";
        }
    }

    std::string a_builtin_function_condition_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_condition_index(i);
        if (s.empty())
            s = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_condition_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L
        };
        static const std::vector<int64_t> retval(values, values + 287);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_condition_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_condition_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_condition_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_condition_index() {
        return stringify::a_builtin_function_condition_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/builtin_defs.h line 4862
namespace stringify {
    const char* a_builtin_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bfk_none";
            case 1L: return "bfk_FILE";
            case 2L: return "bfk_FUNCTION";
            case 3L: return "bfk_GOMP_atomic_end";
            case 4L: return "bfk_GOMP_atomic_start";
            case 5L: return "bfk_GOMP_barrier";
            case 6L: return "bfk_GOMP_barrier_cancel";
            case 7L: return "bfk_GOMP_cancel";
            case 8L: return "bfk_GOMP_cancellation_point";
            case 9L: return "bfk_GOMP_critical_end";
            case 10L: return "bfk_GOMP_critical_name_end";
            case 11L: return "bfk_GOMP_critical_name_start";
            case 12L: return "bfk_GOMP_critical_start";
            case 13L: return "bfk_GOMP_loop_dynamic_next";
            case 14L: return "bfk_GOMP_loop_dynamic_start";
            case 15L: return "bfk_GOMP_loop_end";
            case 16L: return "bfk_GOMP_loop_end_cancel";
            case 17L: return "bfk_GOMP_loop_end_nowait";
            case 18L: return "bfk_GOMP_loop_guided_next";
            case 19L: return "bfk_GOMP_loop_guided_start";
            case 20L: return "bfk_GOMP_loop_ordered_dynamic_next";
            case 21L: return "bfk_GOMP_loop_ordered_dynamic_start";
            case 22L: return "bfk_GOMP_loop_ordered_guided_next";
            case 23L: return "bfk_GOMP_loop_ordered_guided_start";
            case 24L: return "bfk_GOMP_loop_ordered_runtime_next";
            case 25L: return "bfk_GOMP_loop_ordered_runtime_start";
            case 26L: return "bfk_GOMP_loop_ordered_static_next";
            case 27L: return "bfk_GOMP_loop_ordered_static_start";
            case 28L: return "bfk_GOMP_loop_runtime_next";
            case 29L: return "bfk_GOMP_loop_runtime_start";
            case 30L: return "bfk_GOMP_loop_static_next";
            case 31L: return "bfk_GOMP_loop_static_start";
            case 32L: return "bfk_GOMP_loop_ull_dynamic_next";
            case 33L: return "bfk_GOMP_loop_ull_dynamic_start";
            case 34L: return "bfk_GOMP_loop_ull_guided_next";
            case 35L: return "bfk_GOMP_loop_ull_guided_start";
            case 36L: return "bfk_GOMP_loop_ull_ordered_dynamic_next";
            case 37L: return "bfk_GOMP_loop_ull_ordered_dynamic_start";
            case 38L: return "bfk_GOMP_loop_ull_ordered_guided_next";
            case 39L: return "bfk_GOMP_loop_ull_ordered_guided_start";
            case 40L: return "bfk_GOMP_loop_ull_ordered_runtime_next";
            case 41L: return "bfk_GOMP_loop_ull_ordered_runtime_start";
            case 42L: return "bfk_GOMP_loop_ull_ordered_static_next";
            case 43L: return "bfk_GOMP_loop_ull_ordered_static_start";
            case 44L: return "bfk_GOMP_loop_ull_runtime_next";
            case 45L: return "bfk_GOMP_loop_ull_runtime_start";
            case 46L: return "bfk_GOMP_loop_ull_static_next";
            case 47L: return "bfk_GOMP_loop_ull_static_start";
            case 48L: return "bfk_GOMP_ordered_end";
            case 49L: return "bfk_GOMP_ordered_start";
            case 50L: return "bfk_GOMP_parallel";
            case 51L: return "bfk_GOMP_parallel_end";
            case 52L: return "bfk_GOMP_parallel_loop_dynamic";
            case 53L: return "bfk_GOMP_parallel_loop_dynamic_start";
            case 54L: return "bfk_GOMP_parallel_loop_guided";
            case 55L: return "bfk_GOMP_parallel_loop_guided_start";
            case 56L: return "bfk_GOMP_parallel_loop_runtime";
            case 57L: return "bfk_GOMP_parallel_loop_runtime_start";
            case 58L: return "bfk_GOMP_parallel_loop_static";
            case 59L: return "bfk_GOMP_parallel_loop_static_start";
            case 60L: return "bfk_GOMP_parallel_sections";
            case 61L: return "bfk_GOMP_parallel_sections_start";
            case 62L: return "bfk_GOMP_parallel_start";
            case 63L: return "bfk_GOMP_sections_end";
            case 64L: return "bfk_GOMP_sections_end_cancel";
            case 65L: return "bfk_GOMP_sections_end_nowait";
            case 66L: return "bfk_GOMP_sections_next";
            case 67L: return "bfk_GOMP_sections_start";
            case 68L: return "bfk_GOMP_single_copy_end";
            case 69L: return "bfk_GOMP_single_copy_start";
            case 70L: return "bfk_GOMP_single_start";
            case 71L: return "bfk_GOMP_target";
            case 72L: return "bfk_GOMP_target_data";
            case 73L: return "bfk_GOMP_target_end_data";
            case 74L: return "bfk_GOMP_target_update";
            case 75L: return "bfk_GOMP_task";
            case 76L: return "bfk_GOMP_taskgroup_end";
            case 77L: return "bfk_GOMP_taskgroup_start";
            case 78L: return "bfk_GOMP_taskwait";
            case 79L: return "bfk_GOMP_taskyield";
            case 80L: return "bfk_GOMP_teams";
            case 81L: return "bfk_LINE";
            case 82L: return "bfk__Block_object_assign";
            case 83L: return "bfk__Block_object_dispose";
            case 84L: return "bfk__Exit";
            case 85L: return "bfk___CFStringMakeConstantString";
            case 86L: return "bfk___NSStringMakeConstantString";
            case 87L: return "bfk___annotation";
            case 88L: return "bfk___bnd_chk_ptr_bounds";
            case 89L: return "bfk___bnd_chk_ptr_lbounds";
            case 90L: return "bfk___bnd_chk_ptr_ubounds";
            case 91L: return "bfk___bnd_copy_ptr_bounds";
            case 92L: return "bfk___bnd_get_ptr_lbound";
            case 93L: return "bfk___bnd_get_ptr_ubound";
            case 94L: return "bfk___bnd_init_ptr_bounds";
            case 95L: return "bfk___bnd_narrow_ptr_bounds";
            case 96L: return "bfk___bnd_null_ptr_bounds";
            case 97L: return "bfk___bnd_set_ptr_bounds";
            case 98L: return "bfk___bnd_store_ptr_bounds";
            case 99L: return "bfk___c11_atomic_compare_exchange_strong";
            case 100L: return "bfk___c11_atomic_compare_exchange_weak";
            case 101L: return "bfk___c11_atomic_exchange";
            case 102L: return "bfk___c11_atomic_fetch_add";
            case 103L: return "bfk___c11_atomic_fetch_and";
            case 104L: return "bfk___c11_atomic_fetch_or";
            case 105L: return "bfk___c11_atomic_fetch_sub";
            case 106L: return "bfk___c11_atomic_fetch_xor";
            case 107L: return "bfk___c11_atomic_init";
            case 108L: return "bfk___c11_atomic_is_lock_free";
            case 109L: return "bfk___c11_atomic_load";
            case 110L: return "bfk___c11_atomic_signal_fence";
            case 111L: return "bfk___c11_atomic_store";
            case 112L: return "bfk___c11_atomic_thread_fence";
            case 113L: return "bfk___chkp_bndldx";
            case 114L: return "bfk___clear_cache";
            case 115L: return "bfk___cospi";
            case 116L: return "bfk___cospif";
            case 117L: return "bfk___cxa_call_unexpected";
            case 118L: return "bfk___cyg_profile_func_enter";
            case 119L: return "bfk___cyg_profile_func_exit";
            case 120L: return "bfk___debugbreak";
            case 121L: return "bfk___divdc3";
            case 122L: return "bfk___divsc3";
            case 123L: return "bfk___divxc3";
            case 124L: return "bfk___exp10";
            case 125L: return "bfk___exp10f";
            case 126L: return "bfk___finite";
            case 127L: return "bfk___finitef";
            case 128L: return "bfk___finitel";
            case 129L: return "bfk___fprintf_chk";
            case 130L: return "bfk___get_unsafe_stack_ptr";
            case 131L: return "bfk___get_unsafe_stack_start";
            case 132L: return "bfk___memccpy_chk";
            case 133L: return "bfk___memcpy_chk";
            case 134L: return "bfk___memmove_chk";
            case 135L: return "bfk___mempcpy_chk";
            case 136L: return "bfk___memset_chk";
            case 137L: return "bfk___muldc3";
            case 138L: return "bfk___mulsc3";
            case 139L: return "bfk___mulxc3";
            case 140L: return "bfk___opencl_atomic_compare_exchange_strong";
            case 141L: return "bfk___opencl_atomic_compare_exchange_weak";
            case 142L: return "bfk___opencl_atomic_exchange";
            case 143L: return "bfk___opencl_atomic_fetch_add";
            case 144L: return "bfk___opencl_atomic_fetch_and";
            case 145L: return "bfk___opencl_atomic_fetch_max";
            case 146L: return "bfk___opencl_atomic_fetch_min";
            case 147L: return "bfk___opencl_atomic_fetch_or";
            case 148L: return "bfk___opencl_atomic_fetch_sub";
            case 149L: return "bfk___opencl_atomic_fetch_xor";
            case 150L: return "bfk___opencl_atomic_init";
            case 151L: return "bfk___opencl_atomic_load";
            case 152L: return "bfk___opencl_atomic_store";
            case 153L: return "bfk___printf_chk";
            case 154L: return "bfk___rdtsc";
            case 155L: return "bfk___sinpi";
            case 156L: return "bfk___sinpif";
            case 157L: return "bfk___snprintf_chk";
            case 158L: return "bfk___sprintf_chk";
            case 159L: return "bfk___stpcpy_chk";
            case 160L: return "bfk___stpncpy_chk";
            case 161L: return "bfk___strcat_chk";
            case 162L: return "bfk___strcpy_chk";
            case 163L: return "bfk___strlcat_chk";
            case 164L: return "bfk___strlcpy_chk";
            case 165L: return "bfk___strncat_chk";
            case 166L: return "bfk___strncpy_chk";
            case 167L: return "bfk___tanpi";
            case 168L: return "bfk___tanpif";
            case 169L: return "bfk___vfprintf_chk";
            case 170L: return "bfk___vprintf_chk";
            case 171L: return "bfk___vsnprintf_chk";
            case 172L: return "bfk___vsprintf_chk";
            case 173L: return "bfk___xray_customevent";
            case 174L: return "bfk__exit";
            case 175L: return "bfk__mm_clflush";
            case 176L: return "bfk__mm_getcsr";
            case 177L: return "bfk__mm_lfence";
            case 178L: return "bfk__mm_mfence";
            case 179L: return "bfk__mm_pause";
            case 180L: return "bfk__mm_prefetch";
            case 181L: return "bfk__mm_setcsr";
            case 182L: return "bfk__mm_sfence";
            case 183L: return "bfk_abort";
            case 184L: return "bfk_abs";
            case 185L: return "bfk_acc_on_device";
            case 186L: return "bfk_acos";
            case 187L: return "bfk_acosf";
            case 188L: return "bfk_acosh";
            case 189L: return "bfk_acoshf";
            case 190L: return "bfk_acoshl";
            case 191L: return "bfk_acosl";
            case 192L: return "bfk_add_overflow";
            case 193L: return "bfk_add_overflow_p";
            case 194L: return "bfk_addc";
            case 195L: return "bfk_addcb";
            case 196L: return "bfk_addcl";
            case 197L: return "bfk_addcll";
            case 198L: return "bfk_addcs";
            case 199L: return "bfk_addressof";
            case 200L: return "bfk_adjust_descriptor";
            case 201L: return "bfk_adjust_trampoline";
            case 202L: return "bfk_aggregate_incoming_address";
            case 203L: return "bfk_aligned_alloc";
            case 204L: return "bfk_alloca";
            case 205L: return "bfk_alloca_with_align";
            case 206L: return "bfk_alloca_with_align_and_max";
            case 207L: return "bfk_annotation";
            case 208L: return "bfk_apply";
            case 209L: return "bfk_apply_args";
            case 210L: return "bfk_args_info";
            case 211L: return "bfk_asin";
            case 212L: return "bfk_asinf";
            case 213L: return "bfk_asinh";
            case 214L: return "bfk_asinhf";
            case 215L: return "bfk_asinhl";
            case 216L: return "bfk_asinl";
            case 217L: return "bfk_assume";
            case 218L: return "bfk_assume_aligned";
            case 219L: return "bfk_atan";
            case 220L: return "bfk_atan2";
            case 221L: return "bfk_atan2f";
            case 222L: return "bfk_atan2l";
            case 223L: return "bfk_atanf";
            case 224L: return "bfk_atanh";
            case 225L: return "bfk_atanhf";
            case 226L: return "bfk_atanhl";
            case 227L: return "bfk_atanl";
            case 228L: return "bfk_atomic_add_fetch";
            case 229L: return "bfk_atomic_add_fetch_1";
            case 230L: return "bfk_atomic_add_fetch_16";
            case 231L: return "bfk_atomic_add_fetch_2";
            case 232L: return "bfk_atomic_add_fetch_4";
            case 233L: return "bfk_atomic_add_fetch_8";
            case 234L: return "bfk_atomic_always_lock_free";
            case 235L: return "bfk_atomic_and_fetch";
            case 236L: return "bfk_atomic_and_fetch_1";
            case 237L: return "bfk_atomic_and_fetch_16";
            case 238L: return "bfk_atomic_and_fetch_2";
            case 239L: return "bfk_atomic_and_fetch_4";
            case 240L: return "bfk_atomic_and_fetch_8";
            case 241L: return "bfk_atomic_clear";
            case 242L: return "bfk_atomic_compare_exchange";
            case 243L: return "bfk_atomic_compare_exchange_1";
            case 244L: return "bfk_atomic_compare_exchange_16";
            case 245L: return "bfk_atomic_compare_exchange_2";
            case 246L: return "bfk_atomic_compare_exchange_4";
            case 247L: return "bfk_atomic_compare_exchange_8";
            case 248L: return "bfk_atomic_compare_exchange_n";
            case 249L: return "bfk_atomic_exchange";
            case 250L: return "bfk_atomic_exchange_1";
            case 251L: return "bfk_atomic_exchange_16";
            case 252L: return "bfk_atomic_exchange_2";
            case 253L: return "bfk_atomic_exchange_4";
            case 254L: return "bfk_atomic_exchange_8";
            case 255L: return "bfk_atomic_exchange_n";
            case 256L: return "bfk_atomic_feraiseexcept";
            case 257L: return "bfk_atomic_fetch_add";
            case 258L: return "bfk_atomic_fetch_add_1";
            case 259L: return "bfk_atomic_fetch_add_16";
            case 260L: return "bfk_atomic_fetch_add_2";
            case 261L: return "bfk_atomic_fetch_add_4";
            case 262L: return "bfk_atomic_fetch_add_8";
            case 263L: return "bfk_atomic_fetch_and";
            case 264L: return "bfk_atomic_fetch_and_1";
            case 265L: return "bfk_atomic_fetch_and_16";
            case 266L: return "bfk_atomic_fetch_and_2";
            case 267L: return "bfk_atomic_fetch_and_4";
            case 268L: return "bfk_atomic_fetch_and_8";
            case 269L: return "bfk_atomic_fetch_nand";
            case 270L: return "bfk_atomic_fetch_nand_1";
            case 271L: return "bfk_atomic_fetch_nand_16";
            case 272L: return "bfk_atomic_fetch_nand_2";
            case 273L: return "bfk_atomic_fetch_nand_4";
            case 274L: return "bfk_atomic_fetch_nand_8";
            case 275L: return "bfk_atomic_fetch_or";
            case 276L: return "bfk_atomic_fetch_or_1";
            case 277L: return "bfk_atomic_fetch_or_16";
            case 278L: return "bfk_atomic_fetch_or_2";
            case 279L: return "bfk_atomic_fetch_or_4";
            case 280L: return "bfk_atomic_fetch_or_8";
            case 281L: return "bfk_atomic_fetch_sub";
            case 282L: return "bfk_atomic_fetch_sub_1";
            case 283L: return "bfk_atomic_fetch_sub_16";
            case 284L: return "bfk_atomic_fetch_sub_2";
            case 285L: return "bfk_atomic_fetch_sub_4";
            case 286L: return "bfk_atomic_fetch_sub_8";
            case 287L: return "bfk_atomic_fetch_xor";
            case 288L: return "bfk_atomic_fetch_xor_1";
            case 289L: return "bfk_atomic_fetch_xor_16";
            case 290L: return "bfk_atomic_fetch_xor_2";
            case 291L: return "bfk_atomic_fetch_xor_4";
            case 292L: return "bfk_atomic_fetch_xor_8";
            case 293L: return "bfk_atomic_is_lock_free";
            case 294L: return "bfk_atomic_load";
            case 295L: return "bfk_atomic_load_1";
            case 296L: return "bfk_atomic_load_16";
            case 297L: return "bfk_atomic_load_2";
            case 298L: return "bfk_atomic_load_4";
            case 299L: return "bfk_atomic_load_8";
            case 300L: return "bfk_atomic_load_n";
            case 301L: return "bfk_atomic_nand_fetch";
            case 302L: return "bfk_atomic_nand_fetch_1";
            case 303L: return "bfk_atomic_nand_fetch_16";
            case 304L: return "bfk_atomic_nand_fetch_2";
            case 305L: return "bfk_atomic_nand_fetch_4";
            case 306L: return "bfk_atomic_nand_fetch_8";
            case 307L: return "bfk_atomic_or_fetch";
            case 308L: return "bfk_atomic_or_fetch_1";
            case 309L: return "bfk_atomic_or_fetch_16";
            case 310L: return "bfk_atomic_or_fetch_2";
            case 311L: return "bfk_atomic_or_fetch_4";
            case 312L: return "bfk_atomic_or_fetch_8";
            case 313L: return "bfk_atomic_signal_fence";
            case 314L: return "bfk_atomic_store";
            case 315L: return "bfk_atomic_store_1";
            case 316L: return "bfk_atomic_store_16";
            case 317L: return "bfk_atomic_store_2";
            case 318L: return "bfk_atomic_store_4";
            case 319L: return "bfk_atomic_store_8";
            case 320L: return "bfk_atomic_store_n";
            case 321L: return "bfk_atomic_sub_fetch";
            case 322L: return "bfk_atomic_sub_fetch_1";
            case 323L: return "bfk_atomic_sub_fetch_16";
            case 324L: return "bfk_atomic_sub_fetch_2";
            case 325L: return "bfk_atomic_sub_fetch_4";
            case 326L: return "bfk_atomic_sub_fetch_8";
            case 327L: return "bfk_atomic_test_and_set";
            case 328L: return "bfk_atomic_thread_fence";
            case 329L: return "bfk_atomic_xor_fetch";
            case 330L: return "bfk_atomic_xor_fetch_1";
            case 331L: return "bfk_atomic_xor_fetch_16";
            case 332L: return "bfk_atomic_xor_fetch_2";
            case 333L: return "bfk_atomic_xor_fetch_4";
            case 334L: return "bfk_atomic_xor_fetch_8";
            case 335L: return "bfk_bcmp";
            case 336L: return "bfk_bcopy";
            case 337L: return "bfk_bitreverse16";
            case 338L: return "bfk_bitreverse32";
            case 339L: return "bfk_bitreverse64";
            case 340L: return "bfk_bitreverse8";
            case 341L: return "bfk_bswap16";
            case 342L: return "bfk_bswap32";
            case 343L: return "bfk_bswap64";
            case 344L: return "bfk_bzero";
            case 345L: return "bfk_cabs";
            case 346L: return "bfk_cabsf";
            case 347L: return "bfk_cabsl";
            case 348L: return "bfk_cacos";
            case 349L: return "bfk_cacosf";
            case 350L: return "bfk_cacosh";
            case 351L: return "bfk_cacoshf";
            case 352L: return "bfk_cacoshl";
            case 353L: return "bfk_cacosl";
            case 354L: return "bfk_call_with_static_chain";
            case 355L: return "bfk_calloc";
            case 356L: return "bfk_canonicalize";
            case 357L: return "bfk_canonicalizef";
            case 358L: return "bfk_canonicalizel";
            case 359L: return "bfk_carg";
            case 360L: return "bfk_cargf";
            case 361L: return "bfk_cargl";
            case 362L: return "bfk_casin";
            case 363L: return "bfk_casinf";
            case 364L: return "bfk_casinh";
            case 365L: return "bfk_casinhf";
            case 366L: return "bfk_casinhl";
            case 367L: return "bfk_casinl";
            case 368L: return "bfk_catan";
            case 369L: return "bfk_catanf";
            case 370L: return "bfk_catanh";
            case 371L: return "bfk_catanhf";
            case 372L: return "bfk_catanhl";
            case 373L: return "bfk_catanl";
            case 374L: return "bfk_cbrt";
            case 375L: return "bfk_cbrtf";
            case 376L: return "bfk_cbrtl";
            case 377L: return "bfk_ccos";
            case 378L: return "bfk_ccosf";
            case 379L: return "bfk_ccosh";
            case 380L: return "bfk_ccoshf";
            case 381L: return "bfk_ccoshl";
            case 382L: return "bfk_ccosl";
            case 383L: return "bfk_ceil";
            case 384L: return "bfk_ceilf";
            case 385L: return "bfk_ceilf32";
            case 386L: return "bfk_ceilf32x";
            case 387L: return "bfk_ceilf64";
            case 388L: return "bfk_ceilf64x";
            case 389L: return "bfk_ceill";
            case 390L: return "bfk_cexp";
            case 391L: return "bfk_cexpf";
            case 392L: return "bfk_cexpi";
            case 393L: return "bfk_cexpif";
            case 394L: return "bfk_cexpil";
            case 395L: return "bfk_cexpl";
            case 396L: return "bfk_char_memchr";
            case 397L: return "bfk_chkp_memcpy_nobnd";
            case 398L: return "bfk_chkp_memcpy_nobnd_nochk";
            case 399L: return "bfk_chkp_memcpy_nochk";
            case 400L: return "bfk_chkp_memmove_nobnd";
            case 401L: return "bfk_chkp_memmove_nobnd_nochk";
            case 402L: return "bfk_chkp_memmove_nochk";
            case 403L: return "bfk_chkp_mempcpy_nobnd";
            case 404L: return "bfk_chkp_mempcpy_nobnd_nochk";
            case 405L: return "bfk_chkp_mempcpy_nochk";
            case 406L: return "bfk_chkp_memset_nobnd";
            case 407L: return "bfk_chkp_memset_nobnd_nochk";
            case 408L: return "bfk_chkp_memset_nochk";
            case 409L: return "bfk_cimag";
            case 410L: return "bfk_cimagf";
            case 411L: return "bfk_cimagl";
            case 412L: return "bfk_classify_type";
            case 413L: return "bfk_clog";
            case 414L: return "bfk_clog10";
            case 415L: return "bfk_clog10f";
            case 416L: return "bfk_clog10l";
            case 417L: return "bfk_clogf";
            case 418L: return "bfk_clogl";
            case 419L: return "bfk_clrsb";
            case 420L: return "bfk_clrsbimax";
            case 421L: return "bfk_clrsbl";
            case 422L: return "bfk_clrsbll";
            case 423L: return "bfk_clz";
            case 424L: return "bfk_clzimax";
            case 425L: return "bfk_clzl";
            case 426L: return "bfk_clzll";
            case 427L: return "bfk_clzs";
            case 428L: return "bfk_conj";
            case 429L: return "bfk_conjf";
            case 430L: return "bfk_conjl";
            case 431L: return "bfk_constant_p";
            case 432L: return "bfk_convertvector";
            case 433L: return "bfk_copysign";
            case 434L: return "bfk_copysignf";
            case 435L: return "bfk_copysignf32";
            case 436L: return "bfk_copysignf32x";
            case 437L: return "bfk_copysignf64";
            case 438L: return "bfk_copysignf64x";
            case 439L: return "bfk_copysignl";
            case 440L: return "bfk_coro_alloc";
            case 441L: return "bfk_coro_begin";
            case 442L: return "bfk_coro_destroy";
            case 443L: return "bfk_coro_done";
            case 444L: return "bfk_coro_end";
            case 445L: return "bfk_coro_frame";
            case 446L: return "bfk_coro_free";
            case 447L: return "bfk_coro_id";
            case 448L: return "bfk_coro_param";
            case 449L: return "bfk_coro_promise";
            case 450L: return "bfk_coro_resume";
            case 451L: return "bfk_coro_size";
            case 452L: return "bfk_coro_suspend";
            case 453L: return "bfk_cos";
            case 454L: return "bfk_cosf";
            case 455L: return "bfk_cosh";
            case 456L: return "bfk_coshf";
            case 457L: return "bfk_coshl";
            case 458L: return "bfk_cosl";
            case 459L: return "bfk_cpow";
            case 460L: return "bfk_cpowf";
            case 461L: return "bfk_cpowl";
            case 462L: return "bfk_cproj";
            case 463L: return "bfk_cprojf";
            case 464L: return "bfk_cprojl";
            case 465L: return "bfk_cpu_init";
            case 466L: return "bfk_cpu_is";
            case 467L: return "bfk_cpu_supports";
            case 468L: return "bfk_creal";
            case 469L: return "bfk_crealf";
            case 470L: return "bfk_creall";
            case 471L: return "bfk_csin";
            case 472L: return "bfk_csinf";
            case 473L: return "bfk_csinh";
            case 474L: return "bfk_csinhf";
            case 475L: return "bfk_csinhl";
            case 476L: return "bfk_csinl";
            case 477L: return "bfk_csqrt";
            case 478L: return "bfk_csqrtf";
            case 479L: return "bfk_csqrtl";
            case 480L: return "bfk_ctan";
            case 481L: return "bfk_ctanf";
            case 482L: return "bfk_ctanh";
            case 483L: return "bfk_ctanhf";
            case 484L: return "bfk_ctanhl";
            case 485L: return "bfk_ctanl";
            case 486L: return "bfk_ctz";
            case 487L: return "bfk_ctzimax";
            case 488L: return "bfk_ctzl";
            case 489L: return "bfk_ctzll";
            case 490L: return "bfk_ctzs";
            case 491L: return "bfk_dcgettext";
            case 492L: return "bfk_debugtrap";
            case 493L: return "bfk_dgettext";
            case 494L: return "bfk_drem";
            case 495L: return "bfk_dremf";
            case 496L: return "bfk_dreml";
            case 497L: return "bfk_dwarf_cfa";
            case 498L: return "bfk_dwarf_fp_regnum";
            case 499L: return "bfk_dwarf_sp_column";
            case 500L: return "bfk_eh_copy_values";
            case 501L: return "bfk_eh_filter";
            case 502L: return "bfk_eh_pointer";
            case 503L: return "bfk_eh_return";
            case 504L: return "bfk_eh_return_data_regno";
            case 505L: return "bfk_erf";
            case 506L: return "bfk_erfc";
            case 507L: return "bfk_erfcf";
            case 508L: return "bfk_erfcl";
            case 509L: return "bfk_erff";
            case 510L: return "bfk_erfl";
            case 511L: return "bfk_execl";
            case 512L: return "bfk_execle";
            case 513L: return "bfk_execlp";
            case 514L: return "bfk_execv";
            case 515L: return "bfk_execve";
            case 516L: return "bfk_execvp";
            case 517L: return "bfk_exit";
            case 518L: return "bfk_exp";
            case 519L: return "bfk_exp10";
            case 520L: return "bfk_exp10f";
            case 521L: return "bfk_exp10l";
            case 522L: return "bfk_exp2";
            case 523L: return "bfk_exp2f";
            case 524L: return "bfk_exp2l";
            case 525L: return "bfk_expect";
            case 526L: return "bfk_expf";
            case 527L: return "bfk_expl";
            case 528L: return "bfk_expm1";
            case 529L: return "bfk_expm1f";
            case 530L: return "bfk_expm1l";
            case 531L: return "bfk_extend_pointer";
            case 532L: return "bfk_extract_return_addr";
            case 533L: return "bfk_fabs";
            case 534L: return "bfk_fabsf";
            case 535L: return "bfk_fabsf32";
            case 536L: return "bfk_fabsf32x";
            case 537L: return "bfk_fabsf64";
            case 538L: return "bfk_fabsf64x";
            case 539L: return "bfk_fabsl";
            case 540L: return "bfk_fdim";
            case 541L: return "bfk_fdimf";
            case 542L: return "bfk_fdiml";
            case 543L: return "bfk_feclearexcept";
            case 544L: return "bfk_fegetenv";
            case 545L: return "bfk_fegetexceptflag";
            case 546L: return "bfk_fegetround";
            case 547L: return "bfk_feholdexcept";
            case 548L: return "bfk_feraiseexcept";
            case 549L: return "bfk_fesetenv";
            case 550L: return "bfk_fesetexceptflag";
            case 551L: return "bfk_fesetround";
            case 552L: return "bfk_fetestexcept";
            case 553L: return "bfk_feupdateenv";
            case 554L: return "bfk_ffs";
            case 555L: return "bfk_ffsimax";
            case 556L: return "bfk_ffsl";
            case 557L: return "bfk_ffsll";
            case 558L: return "bfk_finite";
            case 559L: return "bfk_finitef";
            case 560L: return "bfk_finitel";
            case 561L: return "bfk_floor";
            case 562L: return "bfk_floorf";
            case 563L: return "bfk_floorf32";
            case 564L: return "bfk_floorf32x";
            case 565L: return "bfk_floorf64";
            case 566L: return "bfk_floorf64x";
            case 567L: return "bfk_floorl";
            case 568L: return "bfk_flt_rounds";
            case 569L: return "bfk_fma";
            case 570L: return "bfk_fmaf";
            case 571L: return "bfk_fmaf32";
            case 572L: return "bfk_fmaf32x";
            case 573L: return "bfk_fmaf64";
            case 574L: return "bfk_fmaf64x";
            case 575L: return "bfk_fmal";
            case 576L: return "bfk_fmax";
            case 577L: return "bfk_fmaxf";
            case 578L: return "bfk_fmaxf32";
            case 579L: return "bfk_fmaxf32x";
            case 580L: return "bfk_fmaxf64";
            case 581L: return "bfk_fmaxf64x";
            case 582L: return "bfk_fmaxl";
            case 583L: return "bfk_fmin";
            case 584L: return "bfk_fminf";
            case 585L: return "bfk_fminf32";
            case 586L: return "bfk_fminf32x";
            case 587L: return "bfk_fminf64";
            case 588L: return "bfk_fminf64x";
            case 589L: return "bfk_fminl";
            case 590L: return "bfk_fmod";
            case 591L: return "bfk_fmodf";
            case 592L: return "bfk_fmodl";
            case 593L: return "bfk_fork";
            case 594L: return "bfk_fpclassify";
            case 595L: return "bfk_fprintf";
            case 596L: return "bfk_fprintf_unlocked";
            case 597L: return "bfk_fputc";
            case 598L: return "bfk_fputc_unlocked";
            case 599L: return "bfk_fputs";
            case 600L: return "bfk_fputs_unlocked";
            case 601L: return "bfk_frame_address";
            case 602L: return "bfk_free";
            case 603L: return "bfk_frexp";
            case 604L: return "bfk_frexpf";
            case 605L: return "bfk_frexpl";
            case 606L: return "bfk_frob_return_addr";
            case 607L: return "bfk_fscanf";
            case 608L: return "bfk_fwrite";
            case 609L: return "bfk_fwrite_unlocked";
            case 610L: return "bfk_gamma";
            case 611L: return "bfk_gamma_r";
            case 612L: return "bfk_gammaf";
            case 613L: return "bfk_gammaf_r";
            case 614L: return "bfk_gammal";
            case 615L: return "bfk_gammal_r";
            case 616L: return "bfk_gettext";
            case 617L: return "bfk_huge_val";
            case 618L: return "bfk_huge_valf";
            case 619L: return "bfk_huge_valf32";
            case 620L: return "bfk_huge_valf32x";
            case 621L: return "bfk_huge_valf64";
            case 622L: return "bfk_huge_valf64x";
            case 623L: return "bfk_huge_vall";
            case 624L: return "bfk_hypot";
            case 625L: return "bfk_hypotf";
            case 626L: return "bfk_hypotl";
            case 627L: return "bfk_ia32_4fmaddps";
            case 628L: return "bfk_ia32_4fmaddps_mask";
            case 629L: return "bfk_ia32_4fmaddss";
            case 630L: return "bfk_ia32_4fmaddss_mask";
            case 631L: return "bfk_ia32_4fnmaddps";
            case 632L: return "bfk_ia32_4fnmaddps_mask";
            case 633L: return "bfk_ia32_4fnmaddss";
            case 634L: return "bfk_ia32_4fnmaddss_mask";
            case 635L: return "bfk_ia32_addcarry_u32";
            case 636L: return "bfk_ia32_addcarry_u64";
            case 637L: return "bfk_ia32_addcarryx_u32";
            case 638L: return "bfk_ia32_addcarryx_u64";
            case 639L: return "bfk_ia32_addpd";
            case 640L: return "bfk_ia32_addpd128_mask";
            case 641L: return "bfk_ia32_addpd256";
            case 642L: return "bfk_ia32_addpd256_mask";
            case 643L: return "bfk_ia32_addpd512_mask";
            case 644L: return "bfk_ia32_addps";
            case 645L: return "bfk_ia32_addps128_mask";
            case 646L: return "bfk_ia32_addps256";
            case 647L: return "bfk_ia32_addps256_mask";
            case 648L: return "bfk_ia32_addps512_mask";
            case 649L: return "bfk_ia32_addsd";
            case 650L: return "bfk_ia32_addsd_mask_round";
            case 651L: return "bfk_ia32_addsd_round";
            case 652L: return "bfk_ia32_addsd_round_mask";
            case 653L: return "bfk_ia32_addss";
            case 654L: return "bfk_ia32_addss_mask_round";
            case 655L: return "bfk_ia32_addss_round";
            case 656L: return "bfk_ia32_addss_round_mask";
            case 657L: return "bfk_ia32_addsubpd";
            case 658L: return "bfk_ia32_addsubpd256";
            case 659L: return "bfk_ia32_addsubps";
            case 660L: return "bfk_ia32_addsubps256";
            case 661L: return "bfk_ia32_aesdec128";
            case 662L: return "bfk_ia32_aesdec256";
            case 663L: return "bfk_ia32_aesdec512";
            case 664L: return "bfk_ia32_aesdeclast128";
            case 665L: return "bfk_ia32_aesdeclast256";
            case 666L: return "bfk_ia32_aesdeclast512";
            case 667L: return "bfk_ia32_aesenc128";
            case 668L: return "bfk_ia32_aesenc256";
            case 669L: return "bfk_ia32_aesenc512";
            case 670L: return "bfk_ia32_aesenclast128";
            case 671L: return "bfk_ia32_aesenclast256";
            case 672L: return "bfk_ia32_aesenclast512";
            case 673L: return "bfk_ia32_aesimc128";
            case 674L: return "bfk_ia32_aeskeygenassist128";
            case 675L: return "bfk_ia32_alignd128_mask";
            case 676L: return "bfk_ia32_alignd256_mask";
            case 677L: return "bfk_ia32_alignd512_mask";
            case 678L: return "bfk_ia32_alignq128_mask";
            case 679L: return "bfk_ia32_alignq256_mask";
            case 680L: return "bfk_ia32_alignq512_mask";
            case 681L: return "bfk_ia32_andnotsi256";
            case 682L: return "bfk_ia32_andnpd";
            case 683L: return "bfk_ia32_andnpd128_mask";
            case 684L: return "bfk_ia32_andnpd256";
            case 685L: return "bfk_ia32_andnpd256_mask";
            case 686L: return "bfk_ia32_andnpd512_mask";
            case 687L: return "bfk_ia32_andnps";
            case 688L: return "bfk_ia32_andnps128_mask";
            case 689L: return "bfk_ia32_andnps256";
            case 690L: return "bfk_ia32_andnps256_mask";
            case 691L: return "bfk_ia32_andnps512_mask";
            case 692L: return "bfk_ia32_andpd";
            case 693L: return "bfk_ia32_andpd128_mask";
            case 694L: return "bfk_ia32_andpd256";
            case 695L: return "bfk_ia32_andpd256_mask";
            case 696L: return "bfk_ia32_andpd512_mask";
            case 697L: return "bfk_ia32_andps";
            case 698L: return "bfk_ia32_andps128_mask";
            case 699L: return "bfk_ia32_andps256";
            case 700L: return "bfk_ia32_andps256_mask";
            case 701L: return "bfk_ia32_andps512_mask";
            case 702L: return "bfk_ia32_andsi256";
            case 703L: return "bfk_ia32_bextr_u32";
            case 704L: return "bfk_ia32_bextr_u64";
            case 705L: return "bfk_ia32_bextri_u32";
            case 706L: return "bfk_ia32_bextri_u64";
            case 707L: return "bfk_ia32_blendmb_128_mask";
            case 708L: return "bfk_ia32_blendmb_256_mask";
            case 709L: return "bfk_ia32_blendmb_512_mask";
            case 710L: return "bfk_ia32_blendmd_128_mask";
            case 711L: return "bfk_ia32_blendmd_256_mask";
            case 712L: return "bfk_ia32_blendmd_512_mask";
            case 713L: return "bfk_ia32_blendmpd_128_mask";
            case 714L: return "bfk_ia32_blendmpd_256_mask";
            case 715L: return "bfk_ia32_blendmpd_512_mask";
            case 716L: return "bfk_ia32_blendmps_128_mask";
            case 717L: return "bfk_ia32_blendmps_256_mask";
            case 718L: return "bfk_ia32_blendmps_512_mask";
            case 719L: return "bfk_ia32_blendmq_128_mask";
            case 720L: return "bfk_ia32_blendmq_256_mask";
            case 721L: return "bfk_ia32_blendmq_512_mask";
            case 722L: return "bfk_ia32_blendmw_128_mask";
            case 723L: return "bfk_ia32_blendmw_256_mask";
            case 724L: return "bfk_ia32_blendmw_512_mask";
            case 725L: return "bfk_ia32_blendpd";
            case 726L: return "bfk_ia32_blendpd256";
            case 727L: return "bfk_ia32_blendps";
            case 728L: return "bfk_ia32_blendps256";
            case 729L: return "bfk_ia32_blendvpd";
            case 730L: return "bfk_ia32_blendvpd256";
            case 731L: return "bfk_ia32_blendvps";
            case 732L: return "bfk_ia32_blendvps256";
            case 733L: return "bfk_ia32_broadcastf32x2_256_mask";
            case 734L: return "bfk_ia32_broadcastf32x2_512_mask";
            case 735L: return "bfk_ia32_broadcastf32x4_256_mask";
            case 736L: return "bfk_ia32_broadcastf32x4_512";
            case 737L: return "bfk_ia32_broadcastf32x8_512_mask";
            case 738L: return "bfk_ia32_broadcastf64x2_256_mask";
            case 739L: return "bfk_ia32_broadcastf64x2_512_mask";
            case 740L: return "bfk_ia32_broadcastf64x4_512";
            case 741L: return "bfk_ia32_broadcasti32x2_128_mask";
            case 742L: return "bfk_ia32_broadcasti32x2_256_mask";
            case 743L: return "bfk_ia32_broadcasti32x2_512_mask";
            case 744L: return "bfk_ia32_broadcasti32x4_256_mask";
            case 745L: return "bfk_ia32_broadcasti32x4_512";
            case 746L: return "bfk_ia32_broadcasti32x8_512_mask";
            case 747L: return "bfk_ia32_broadcasti64x2_256_mask";
            case 748L: return "bfk_ia32_broadcasti64x2_512_mask";
            case 749L: return "bfk_ia32_broadcasti64x4_512";
            case 750L: return "bfk_ia32_broadcastmb128";
            case 751L: return "bfk_ia32_broadcastmb256";
            case 752L: return "bfk_ia32_broadcastmb512";
            case 753L: return "bfk_ia32_broadcastmw128";
            case 754L: return "bfk_ia32_broadcastmw256";
            case 755L: return "bfk_ia32_broadcastmw512";
            case 756L: return "bfk_ia32_broadcastsd256_mask";
            case 757L: return "bfk_ia32_broadcastsd512";
            case 758L: return "bfk_ia32_broadcastss128_mask";
            case 759L: return "bfk_ia32_broadcastss256_mask";
            case 760L: return "bfk_ia32_broadcastss512";
            case 761L: return "bfk_ia32_bsrdi";
            case 762L: return "bfk_ia32_bsrsi";
            case 763L: return "bfk_ia32_bzhi_di";
            case 764L: return "bfk_ia32_bzhi_si";
            case 765L: return "bfk_ia32_ceilpd";
            case 766L: return "bfk_ia32_ceilpd256";
            case 767L: return "bfk_ia32_ceilpd512";
            case 768L: return "bfk_ia32_ceilpd_vec_pack_sfix";
            case 769L: return "bfk_ia32_ceilpd_vec_pack_sfix256";
            case 770L: return "bfk_ia32_ceilpd_vec_pack_sfix512";
            case 771L: return "bfk_ia32_ceilps";
            case 772L: return "bfk_ia32_ceilps256";
            case 773L: return "bfk_ia32_ceilps512";
            case 774L: return "bfk_ia32_ceilps_sfix";
            case 775L: return "bfk_ia32_ceilps_sfix256";
            case 776L: return "bfk_ia32_ceilps_sfix512";
            case 777L: return "bfk_ia32_clflush";
            case 778L: return "bfk_ia32_clflushopt";
            case 779L: return "bfk_ia32_clrssbsy";
            case 780L: return "bfk_ia32_clwb";
            case 781L: return "bfk_ia32_clzero";
            case 782L: return "bfk_ia32_cmpb128_mask";
            case 783L: return "bfk_ia32_cmpb256_mask";
            case 784L: return "bfk_ia32_cmpb512_mask";
            case 785L: return "bfk_ia32_cmpd128_mask";
            case 786L: return "bfk_ia32_cmpd256_mask";
            case 787L: return "bfk_ia32_cmpd512_mask";
            case 788L: return "bfk_ia32_cmpeqpd";
            case 789L: return "bfk_ia32_cmpeqps";
            case 790L: return "bfk_ia32_cmpeqsd";
            case 791L: return "bfk_ia32_cmpeqss";
            case 792L: return "bfk_ia32_cmpgepd";
            case 793L: return "bfk_ia32_cmpgeps";
            case 794L: return "bfk_ia32_cmpgtpd";
            case 795L: return "bfk_ia32_cmpgtps";
            case 796L: return "bfk_ia32_cmplepd";
            case 797L: return "bfk_ia32_cmpleps";
            case 798L: return "bfk_ia32_cmplesd";
            case 799L: return "bfk_ia32_cmpless";
            case 800L: return "bfk_ia32_cmpltpd";
            case 801L: return "bfk_ia32_cmpltps";
            case 802L: return "bfk_ia32_cmpltsd";
            case 803L: return "bfk_ia32_cmpltss";
            case 804L: return "bfk_ia32_cmpneqpd";
            case 805L: return "bfk_ia32_cmpneqps";
            case 806L: return "bfk_ia32_cmpneqsd";
            case 807L: return "bfk_ia32_cmpneqss";
            case 808L: return "bfk_ia32_cmpngepd";
            case 809L: return "bfk_ia32_cmpngeps";
            case 810L: return "bfk_ia32_cmpngess";
            case 811L: return "bfk_ia32_cmpngtpd";
            case 812L: return "bfk_ia32_cmpngtps";
            case 813L: return "bfk_ia32_cmpngtss";
            case 814L: return "bfk_ia32_cmpnlepd";
            case 815L: return "bfk_ia32_cmpnleps";
            case 816L: return "bfk_ia32_cmpnlesd";
            case 817L: return "bfk_ia32_cmpnless";
            case 818L: return "bfk_ia32_cmpnltpd";
            case 819L: return "bfk_ia32_cmpnltps";
            case 820L: return "bfk_ia32_cmpnltsd";
            case 821L: return "bfk_ia32_cmpnltss";
            case 822L: return "bfk_ia32_cmpordpd";
            case 823L: return "bfk_ia32_cmpordps";
            case 824L: return "bfk_ia32_cmpordsd";
            case 825L: return "bfk_ia32_cmpordss";
            case 826L: return "bfk_ia32_cmppd";
            case 827L: return "bfk_ia32_cmppd128_mask";
            case 828L: return "bfk_ia32_cmppd256";
            case 829L: return "bfk_ia32_cmppd256_mask";
            case 830L: return "bfk_ia32_cmppd512_mask";
            case 831L: return "bfk_ia32_cmpps";
            case 832L: return "bfk_ia32_cmpps128_mask";
            case 833L: return "bfk_ia32_cmpps256";
            case 834L: return "bfk_ia32_cmpps256_mask";
            case 835L: return "bfk_ia32_cmpps512_mask";
            case 836L: return "bfk_ia32_cmpq128_mask";
            case 837L: return "bfk_ia32_cmpq256_mask";
            case 838L: return "bfk_ia32_cmpq512_mask";
            case 839L: return "bfk_ia32_cmpsd";
            case 840L: return "bfk_ia32_cmpsd_mask";
            case 841L: return "bfk_ia32_cmpss";
            case 842L: return "bfk_ia32_cmpss_mask";
            case 843L: return "bfk_ia32_cmpunordpd";
            case 844L: return "bfk_ia32_cmpunordps";
            case 845L: return "bfk_ia32_cmpunordsd";
            case 846L: return "bfk_ia32_cmpunordss";
            case 847L: return "bfk_ia32_cmpw128_mask";
            case 848L: return "bfk_ia32_cmpw256_mask";
            case 849L: return "bfk_ia32_cmpw512_mask";
            case 850L: return "bfk_ia32_comeqpd";
            case 851L: return "bfk_ia32_comeqps";
            case 852L: return "bfk_ia32_comeqsd";
            case 853L: return "bfk_ia32_comeqss";
            case 854L: return "bfk_ia32_comfalsepd";
            case 855L: return "bfk_ia32_comfalseps";
            case 856L: return "bfk_ia32_comfalsesd";
            case 857L: return "bfk_ia32_comfalsess";
            case 858L: return "bfk_ia32_comgepd";
            case 859L: return "bfk_ia32_comgeps";
            case 860L: return "bfk_ia32_comgesd";
            case 861L: return "bfk_ia32_comgess";
            case 862L: return "bfk_ia32_comgtpd";
            case 863L: return "bfk_ia32_comgtps";
            case 864L: return "bfk_ia32_comgtsd";
            case 865L: return "bfk_ia32_comgtss";
            case 866L: return "bfk_ia32_comieq";
            case 867L: return "bfk_ia32_comige";
            case 868L: return "bfk_ia32_comigt";
            case 869L: return "bfk_ia32_comile";
            case 870L: return "bfk_ia32_comilt";
            case 871L: return "bfk_ia32_comineq";
            case 872L: return "bfk_ia32_comisdeq";
            case 873L: return "bfk_ia32_comisdge";
            case 874L: return "bfk_ia32_comisdgt";
            case 875L: return "bfk_ia32_comisdle";
            case 876L: return "bfk_ia32_comisdlt";
            case 877L: return "bfk_ia32_comisdneq";
            case 878L: return "bfk_ia32_comlepd";
            case 879L: return "bfk_ia32_comleps";
            case 880L: return "bfk_ia32_comlesd";
            case 881L: return "bfk_ia32_comless";
            case 882L: return "bfk_ia32_comltpd";
            case 883L: return "bfk_ia32_comltps";
            case 884L: return "bfk_ia32_comltsd";
            case 885L: return "bfk_ia32_comltss";
            case 886L: return "bfk_ia32_comnepd";
            case 887L: return "bfk_ia32_comneps";
            case 888L: return "bfk_ia32_comnesd";
            case 889L: return "bfk_ia32_comness";
            case 890L: return "bfk_ia32_comordpd";
            case 891L: return "bfk_ia32_comordps";
            case 892L: return "bfk_ia32_comordsd";
            case 893L: return "bfk_ia32_comordss";
            case 894L: return "bfk_ia32_compressdf128_mask";
            case 895L: return "bfk_ia32_compressdf256_mask";
            case 896L: return "bfk_ia32_compressdf512_mask";
            case 897L: return "bfk_ia32_compressdi128_mask";
            case 898L: return "bfk_ia32_compressdi256_mask";
            case 899L: return "bfk_ia32_compressdi512_mask";
            case 900L: return "bfk_ia32_compresshi128_mask";
            case 901L: return "bfk_ia32_compresshi256_mask";
            case 902L: return "bfk_ia32_compresshi512_mask";
            case 903L: return "bfk_ia32_compressqi128_mask";
            case 904L: return "bfk_ia32_compressqi256_mask";
            case 905L: return "bfk_ia32_compressqi512_mask";
            case 906L: return "bfk_ia32_compresssf128_mask";
            case 907L: return "bfk_ia32_compresssf256_mask";
            case 908L: return "bfk_ia32_compresssf512_mask";
            case 909L: return "bfk_ia32_compresssi128_mask";
            case 910L: return "bfk_ia32_compresssi256_mask";
            case 911L: return "bfk_ia32_compresssi512_mask";
            case 912L: return "bfk_ia32_compressstoredf128_mask";
            case 913L: return "bfk_ia32_compressstoredf256_mask";
            case 914L: return "bfk_ia32_compressstoredf512_mask";
            case 915L: return "bfk_ia32_compressstoredi128_mask";
            case 916L: return "bfk_ia32_compressstoredi256_mask";
            case 917L: return "bfk_ia32_compressstoredi512_mask";
            case 918L: return "bfk_ia32_compressstorehi128_mask";
            case 919L: return "bfk_ia32_compressstorehi256_mask";
            case 920L: return "bfk_ia32_compressstorehi512_mask";
            case 921L: return "bfk_ia32_compressstoreqi128_mask";
            case 922L: return "bfk_ia32_compressstoreqi256_mask";
            case 923L: return "bfk_ia32_compressstoreqi512_mask";
            case 924L: return "bfk_ia32_compressstoresf128_mask";
            case 925L: return "bfk_ia32_compressstoresf256_mask";
            case 926L: return "bfk_ia32_compressstoresf512_mask";
            case 927L: return "bfk_ia32_compressstoresi128_mask";
            case 928L: return "bfk_ia32_compressstoresi256_mask";
            case 929L: return "bfk_ia32_compressstoresi512_mask";
            case 930L: return "bfk_ia32_compressstoreuhi128_mask";
            case 931L: return "bfk_ia32_compressstoreuhi256_mask";
            case 932L: return "bfk_ia32_compressstoreuhi512_mask";
            case 933L: return "bfk_ia32_compressstoreuqi128_mask";
            case 934L: return "bfk_ia32_compressstoreuqi256_mask";
            case 935L: return "bfk_ia32_compressstoreuqi512_mask";
            case 936L: return "bfk_ia32_comtruepd";
            case 937L: return "bfk_ia32_comtrueps";
            case 938L: return "bfk_ia32_comtruesd";
            case 939L: return "bfk_ia32_comtruess";
            case 940L: return "bfk_ia32_comueqpd";
            case 941L: return "bfk_ia32_comueqps";
            case 942L: return "bfk_ia32_comueqsd";
            case 943L: return "bfk_ia32_comueqss";
            case 944L: return "bfk_ia32_comunepd";
            case 945L: return "bfk_ia32_comuneps";
            case 946L: return "bfk_ia32_comunesd";
            case 947L: return "bfk_ia32_comuness";
            case 948L: return "bfk_ia32_comunordpd";
            case 949L: return "bfk_ia32_comunordps";
            case 950L: return "bfk_ia32_comunordsd";
            case 951L: return "bfk_ia32_comunordss";
            case 952L: return "bfk_ia32_copysignpd";
            case 953L: return "bfk_ia32_copysignpd256";
            case 954L: return "bfk_ia32_copysignpd512";
            case 955L: return "bfk_ia32_copysignps";
            case 956L: return "bfk_ia32_copysignps256";
            case 957L: return "bfk_ia32_copysignps512";
            case 958L: return "bfk_ia32_crc32di";
            case 959L: return "bfk_ia32_crc32hi";
            case 960L: return "bfk_ia32_crc32qi";
            case 961L: return "bfk_ia32_crc32si";
            case 962L: return "bfk_ia32_cvtb2mask128";
            case 963L: return "bfk_ia32_cvtb2mask256";
            case 964L: return "bfk_ia32_cvtb2mask512";
            case 965L: return "bfk_ia32_cvtd2mask128";
            case 966L: return "bfk_ia32_cvtd2mask256";
            case 967L: return "bfk_ia32_cvtd2mask512";
            case 968L: return "bfk_ia32_cvtdq2pd";
            case 969L: return "bfk_ia32_cvtdq2pd128_mask";
            case 970L: return "bfk_ia32_cvtdq2pd256";
            case 971L: return "bfk_ia32_cvtdq2pd256_mask";
            case 972L: return "bfk_ia32_cvtdq2pd512_mask";
            case 973L: return "bfk_ia32_cvtdq2ps";
            case 974L: return "bfk_ia32_cvtdq2ps128_mask";
            case 975L: return "bfk_ia32_cvtdq2ps256";
            case 976L: return "bfk_ia32_cvtdq2ps256_mask";
            case 977L: return "bfk_ia32_cvtdq2ps512_mask";
            case 978L: return "bfk_ia32_cvtmask2b128";
            case 979L: return "bfk_ia32_cvtmask2b256";
            case 980L: return "bfk_ia32_cvtmask2b512";
            case 981L: return "bfk_ia32_cvtmask2d128";
            case 982L: return "bfk_ia32_cvtmask2d256";
            case 983L: return "bfk_ia32_cvtmask2d512";
            case 984L: return "bfk_ia32_cvtmask2q128";
            case 985L: return "bfk_ia32_cvtmask2q256";
            case 986L: return "bfk_ia32_cvtmask2q512";
            case 987L: return "bfk_ia32_cvtmask2w128";
            case 988L: return "bfk_ia32_cvtmask2w256";
            case 989L: return "bfk_ia32_cvtmask2w512";
            case 990L: return "bfk_ia32_cvtpd2dq";
            case 991L: return "bfk_ia32_cvtpd2dq128_mask";
            case 992L: return "bfk_ia32_cvtpd2dq256";
            case 993L: return "bfk_ia32_cvtpd2dq256_mask";
            case 994L: return "bfk_ia32_cvtpd2dq512_mask";
            case 995L: return "bfk_ia32_cvtpd2pi";
            case 996L: return "bfk_ia32_cvtpd2ps";
            case 997L: return "bfk_ia32_cvtpd2ps256";
            case 998L: return "bfk_ia32_cvtpd2ps256_mask";
            case 999L: return "bfk_ia32_cvtpd2ps512_mask";
            case 1000L: return "bfk_ia32_cvtpd2ps_mask";
            case 1001L: return "bfk_ia32_cvtpd2qq128_mask";
            case 1002L: return "bfk_ia32_cvtpd2qq256_mask";
            case 1003L: return "bfk_ia32_cvtpd2qq512_mask";
            case 1004L: return "bfk_ia32_cvtpd2udq128_mask";
            case 1005L: return "bfk_ia32_cvtpd2udq256_mask";
            case 1006L: return "bfk_ia32_cvtpd2udq512_mask";
            case 1007L: return "bfk_ia32_cvtpd2uqq128_mask";
            case 1008L: return "bfk_ia32_cvtpd2uqq256_mask";
            case 1009L: return "bfk_ia32_cvtpd2uqq512_mask";
            case 1010L: return "bfk_ia32_cvtpi2pd";
            case 1011L: return "bfk_ia32_cvtpi2ps";
            case 1012L: return "bfk_ia32_cvtps2dq";
            case 1013L: return "bfk_ia32_cvtps2dq128_mask";
            case 1014L: return "bfk_ia32_cvtps2dq256";
            case 1015L: return "bfk_ia32_cvtps2dq256_mask";
            case 1016L: return "bfk_ia32_cvtps2dq512";
            case 1017L: return "bfk_ia32_cvtps2dq512_mask";
            case 1018L: return "bfk_ia32_cvtps2pd";
            case 1019L: return "bfk_ia32_cvtps2pd128_mask";
            case 1020L: return "bfk_ia32_cvtps2pd256";
            case 1021L: return "bfk_ia32_cvtps2pd256_mask";
            case 1022L: return "bfk_ia32_cvtps2pd512_mask";
            case 1023L: return "bfk_ia32_cvtps2pi";
            case 1024L: return "bfk_ia32_cvtps2qq128_mask";
            case 1025L: return "bfk_ia32_cvtps2qq256_mask";
            case 1026L: return "bfk_ia32_cvtps2qq512_mask";
            case 1027L: return "bfk_ia32_cvtps2udq128_mask";
            case 1028L: return "bfk_ia32_cvtps2udq256_mask";
            case 1029L: return "bfk_ia32_cvtps2udq512_mask";
            case 1030L: return "bfk_ia32_cvtps2uqq128_mask";
            case 1031L: return "bfk_ia32_cvtps2uqq256_mask";
            case 1032L: return "bfk_ia32_cvtps2uqq512_mask";
            case 1033L: return "bfk_ia32_cvtq2mask128";
            case 1034L: return "bfk_ia32_cvtq2mask256";
            case 1035L: return "bfk_ia32_cvtq2mask512";
            case 1036L: return "bfk_ia32_cvtqq2pd128_mask";
            case 1037L: return "bfk_ia32_cvtqq2pd256_mask";
            case 1038L: return "bfk_ia32_cvtqq2pd512_mask";
            case 1039L: return "bfk_ia32_cvtqq2ps128_mask";
            case 1040L: return "bfk_ia32_cvtqq2ps256_mask";
            case 1041L: return "bfk_ia32_cvtqq2ps512_mask";
            case 1042L: return "bfk_ia32_cvtsd2si";
            case 1043L: return "bfk_ia32_cvtsd2si64";
            case 1044L: return "bfk_ia32_cvtsd2ss";
            case 1045L: return "bfk_ia32_cvtsd2ss_round";
            case 1046L: return "bfk_ia32_cvtsd2ss_round_mask";
            case 1047L: return "bfk_ia32_cvtsi2sd";
            case 1048L: return "bfk_ia32_cvtsi2sd64";
            case 1049L: return "bfk_ia32_cvtsi2ss";
            case 1050L: return "bfk_ia32_cvtsi2ss32";
            case 1051L: return "bfk_ia32_cvtsi2ss64";
            case 1052L: return "bfk_ia32_cvtsi642sd";
            case 1053L: return "bfk_ia32_cvtsi642ss";
            case 1054L: return "bfk_ia32_cvtss2sd";
            case 1055L: return "bfk_ia32_cvtss2sd_round";
            case 1056L: return "bfk_ia32_cvtss2sd_round_mask";
            case 1057L: return "bfk_ia32_cvtss2si";
            case 1058L: return "bfk_ia32_cvtss2si64";
            case 1059L: return "bfk_ia32_cvttpd2dq";
            case 1060L: return "bfk_ia32_cvttpd2dq128_mask";
            case 1061L: return "bfk_ia32_cvttpd2dq256";
            case 1062L: return "bfk_ia32_cvttpd2dq256_mask";
            case 1063L: return "bfk_ia32_cvttpd2dq512_mask";
            case 1064L: return "bfk_ia32_cvttpd2pi";
            case 1065L: return "bfk_ia32_cvttpd2qq128_mask";
            case 1066L: return "bfk_ia32_cvttpd2qq256_mask";
            case 1067L: return "bfk_ia32_cvttpd2qq512_mask";
            case 1068L: return "bfk_ia32_cvttpd2udq128_mask";
            case 1069L: return "bfk_ia32_cvttpd2udq256_mask";
            case 1070L: return "bfk_ia32_cvttpd2udq512_mask";
            case 1071L: return "bfk_ia32_cvttpd2uqq128_mask";
            case 1072L: return "bfk_ia32_cvttpd2uqq256_mask";
            case 1073L: return "bfk_ia32_cvttpd2uqq512_mask";
            case 1074L: return "bfk_ia32_cvttps2dq";
            case 1075L: return "bfk_ia32_cvttps2dq128_mask";
            case 1076L: return "bfk_ia32_cvttps2dq256";
            case 1077L: return "bfk_ia32_cvttps2dq256_mask";
            case 1078L: return "bfk_ia32_cvttps2dq512_mask";
            case 1079L: return "bfk_ia32_cvttps2pi";
            case 1080L: return "bfk_ia32_cvttps2qq128_mask";
            case 1081L: return "bfk_ia32_cvttps2qq256_mask";
            case 1082L: return "bfk_ia32_cvttps2qq512_mask";
            case 1083L: return "bfk_ia32_cvttps2udq128_mask";
            case 1084L: return "bfk_ia32_cvttps2udq256_mask";
            case 1085L: return "bfk_ia32_cvttps2udq512_mask";
            case 1086L: return "bfk_ia32_cvttps2uqq128_mask";
            case 1087L: return "bfk_ia32_cvttps2uqq256_mask";
            case 1088L: return "bfk_ia32_cvttps2uqq512_mask";
            case 1089L: return "bfk_ia32_cvttsd2si";
            case 1090L: return "bfk_ia32_cvttsd2si64";
            case 1091L: return "bfk_ia32_cvttss2si";
            case 1092L: return "bfk_ia32_cvttss2si64";
            case 1093L: return "bfk_ia32_cvtudq2pd128_mask";
            case 1094L: return "bfk_ia32_cvtudq2pd256_mask";
            case 1095L: return "bfk_ia32_cvtudq2pd512_mask";
            case 1096L: return "bfk_ia32_cvtudq2ps";
            case 1097L: return "bfk_ia32_cvtudq2ps128_mask";
            case 1098L: return "bfk_ia32_cvtudq2ps256_mask";
            case 1099L: return "bfk_ia32_cvtudq2ps512_mask";
            case 1100L: return "bfk_ia32_cvtuqq2pd128_mask";
            case 1101L: return "bfk_ia32_cvtuqq2pd256_mask";
            case 1102L: return "bfk_ia32_cvtuqq2pd512_mask";
            case 1103L: return "bfk_ia32_cvtuqq2ps128_mask";
            case 1104L: return "bfk_ia32_cvtuqq2ps256_mask";
            case 1105L: return "bfk_ia32_cvtuqq2ps512_mask";
            case 1106L: return "bfk_ia32_cvtusi2sd32";
            case 1107L: return "bfk_ia32_cvtusi2sd64";
            case 1108L: return "bfk_ia32_cvtusi2ss32";
            case 1109L: return "bfk_ia32_cvtusi2ss64";
            case 1110L: return "bfk_ia32_cvtw2mask128";
            case 1111L: return "bfk_ia32_cvtw2mask256";
            case 1112L: return "bfk_ia32_cvtw2mask512";
            case 1113L: return "bfk_ia32_dbpsadbw128_mask";
            case 1114L: return "bfk_ia32_dbpsadbw256_mask";
            case 1115L: return "bfk_ia32_dbpsadbw512_mask";
            case 1116L: return "bfk_ia32_directstoreu_u32";
            case 1117L: return "bfk_ia32_directstoreu_u64";
            case 1118L: return "bfk_ia32_divpd";
            case 1119L: return "bfk_ia32_divpd256";
            case 1120L: return "bfk_ia32_divpd256_mask";
            case 1121L: return "bfk_ia32_divpd512_mask";
            case 1122L: return "bfk_ia32_divpd_mask";
            case 1123L: return "bfk_ia32_divps";
            case 1124L: return "bfk_ia32_divps256";
            case 1125L: return "bfk_ia32_divps256_mask";
            case 1126L: return "bfk_ia32_divps512_mask";
            case 1127L: return "bfk_ia32_divps_mask";
            case 1128L: return "bfk_ia32_divsd";
            case 1129L: return "bfk_ia32_divsd_mask_round";
            case 1130L: return "bfk_ia32_divsd_round";
            case 1131L: return "bfk_ia32_divsd_round_mask";
            case 1132L: return "bfk_ia32_divss";
            case 1133L: return "bfk_ia32_divss_mask_round";
            case 1134L: return "bfk_ia32_divss_round";
            case 1135L: return "bfk_ia32_divss_round_mask";
            case 1136L: return "bfk_ia32_dppd";
            case 1137L: return "bfk_ia32_dpps";
            case 1138L: return "bfk_ia32_dpps256";
            case 1139L: return "bfk_ia32_emms";
            case 1140L: return "bfk_ia32_exp2pd_mask";
            case 1141L: return "bfk_ia32_exp2ps";
            case 1142L: return "bfk_ia32_exp2ps_mask";
            case 1143L: return "bfk_ia32_expanddf128_mask";
            case 1144L: return "bfk_ia32_expanddf128_maskz";
            case 1145L: return "bfk_ia32_expanddf256_mask";
            case 1146L: return "bfk_ia32_expanddf256_maskz";
            case 1147L: return "bfk_ia32_expanddf512_mask";
            case 1148L: return "bfk_ia32_expanddf512_maskz";
            case 1149L: return "bfk_ia32_expanddi128_mask";
            case 1150L: return "bfk_ia32_expanddi128_maskz";
            case 1151L: return "bfk_ia32_expanddi256_mask";
            case 1152L: return "bfk_ia32_expanddi256_maskz";
            case 1153L: return "bfk_ia32_expanddi512_mask";
            case 1154L: return "bfk_ia32_expanddi512_maskz";
            case 1155L: return "bfk_ia32_expandhi128_mask";
            case 1156L: return "bfk_ia32_expandhi128_maskz";
            case 1157L: return "bfk_ia32_expandhi256_mask";
            case 1158L: return "bfk_ia32_expandhi256_maskz";
            case 1159L: return "bfk_ia32_expandhi512_mask";
            case 1160L: return "bfk_ia32_expandhi512_maskz";
            case 1161L: return "bfk_ia32_expandloaddf128_mask";
            case 1162L: return "bfk_ia32_expandloaddf128_maskz";
            case 1163L: return "bfk_ia32_expandloaddf256_mask";
            case 1164L: return "bfk_ia32_expandloaddf256_maskz";
            case 1165L: return "bfk_ia32_expandloaddf512_mask";
            case 1166L: return "bfk_ia32_expandloaddf512_maskz";
            case 1167L: return "bfk_ia32_expandloaddi128_mask";
            case 1168L: return "bfk_ia32_expandloaddi128_maskz";
            case 1169L: return "bfk_ia32_expandloaddi256_mask";
            case 1170L: return "bfk_ia32_expandloaddi256_maskz";
            case 1171L: return "bfk_ia32_expandloaddi512_mask";
            case 1172L: return "bfk_ia32_expandloaddi512_maskz";
            case 1173L: return "bfk_ia32_expandloadhi128_mask";
            case 1174L: return "bfk_ia32_expandloadhi128_maskz";
            case 1175L: return "bfk_ia32_expandloadhi256_mask";
            case 1176L: return "bfk_ia32_expandloadhi256_maskz";
            case 1177L: return "bfk_ia32_expandloadhi512_mask";
            case 1178L: return "bfk_ia32_expandloadhi512_maskz";
            case 1179L: return "bfk_ia32_expandloadqi128_mask";
            case 1180L: return "bfk_ia32_expandloadqi128_maskz";
            case 1181L: return "bfk_ia32_expandloadqi256_mask";
            case 1182L: return "bfk_ia32_expandloadqi256_maskz";
            case 1183L: return "bfk_ia32_expandloadqi512_mask";
            case 1184L: return "bfk_ia32_expandloadqi512_maskz";
            case 1185L: return "bfk_ia32_expandloadsf128_mask";
            case 1186L: return "bfk_ia32_expandloadsf128_maskz";
            case 1187L: return "bfk_ia32_expandloadsf256_mask";
            case 1188L: return "bfk_ia32_expandloadsf256_maskz";
            case 1189L: return "bfk_ia32_expandloadsf512_mask";
            case 1190L: return "bfk_ia32_expandloadsf512_maskz";
            case 1191L: return "bfk_ia32_expandloadsi128_mask";
            case 1192L: return "bfk_ia32_expandloadsi128_maskz";
            case 1193L: return "bfk_ia32_expandloadsi256_mask";
            case 1194L: return "bfk_ia32_expandloadsi256_maskz";
            case 1195L: return "bfk_ia32_expandloadsi512_mask";
            case 1196L: return "bfk_ia32_expandloadsi512_maskz";
            case 1197L: return "bfk_ia32_expandqi128_mask";
            case 1198L: return "bfk_ia32_expandqi128_maskz";
            case 1199L: return "bfk_ia32_expandqi256_mask";
            case 1200L: return "bfk_ia32_expandqi256_maskz";
            case 1201L: return "bfk_ia32_expandqi512_mask";
            case 1202L: return "bfk_ia32_expandqi512_maskz";
            case 1203L: return "bfk_ia32_expandsf128_mask";
            case 1204L: return "bfk_ia32_expandsf128_maskz";
            case 1205L: return "bfk_ia32_expandsf256_mask";
            case 1206L: return "bfk_ia32_expandsf256_maskz";
            case 1207L: return "bfk_ia32_expandsf512_mask";
            case 1208L: return "bfk_ia32_expandsf512_maskz";
            case 1209L: return "bfk_ia32_expandsi128_mask";
            case 1210L: return "bfk_ia32_expandsi128_maskz";
            case 1211L: return "bfk_ia32_expandsi256_mask";
            case 1212L: return "bfk_ia32_expandsi256_maskz";
            case 1213L: return "bfk_ia32_expandsi512_mask";
            case 1214L: return "bfk_ia32_expandsi512_maskz";
            case 1215L: return "bfk_ia32_extract128i256";
            case 1216L: return "bfk_ia32_extractf32x4_256_mask";
            case 1217L: return "bfk_ia32_extractf32x4_mask";
            case 1218L: return "bfk_ia32_extractf32x8_mask";
            case 1219L: return "bfk_ia32_extractf64x2_256_mask";
            case 1220L: return "bfk_ia32_extractf64x2_512_mask";
            case 1221L: return "bfk_ia32_extractf64x4_mask";
            case 1222L: return "bfk_ia32_extracti32x4_256_mask";
            case 1223L: return "bfk_ia32_extracti32x4_mask";
            case 1224L: return "bfk_ia32_extracti32x8_mask";
            case 1225L: return "bfk_ia32_extracti64x2_256_mask";
            case 1226L: return "bfk_ia32_extracti64x2_512_mask";
            case 1227L: return "bfk_ia32_extracti64x4_mask";
            case 1228L: return "bfk_ia32_extrq";
            case 1229L: return "bfk_ia32_extrqi";
            case 1230L: return "bfk_ia32_femms";
            case 1231L: return "bfk_ia32_fixupimmpd128_mask";
            case 1232L: return "bfk_ia32_fixupimmpd128_maskz";
            case 1233L: return "bfk_ia32_fixupimmpd256_mask";
            case 1234L: return "bfk_ia32_fixupimmpd256_maskz";
            case 1235L: return "bfk_ia32_fixupimmpd512_mask";
            case 1236L: return "bfk_ia32_fixupimmpd512_maskz";
            case 1237L: return "bfk_ia32_fixupimmps128_mask";
            case 1238L: return "bfk_ia32_fixupimmps128_maskz";
            case 1239L: return "bfk_ia32_fixupimmps256_mask";
            case 1240L: return "bfk_ia32_fixupimmps256_maskz";
            case 1241L: return "bfk_ia32_fixupimmps512_mask";
            case 1242L: return "bfk_ia32_fixupimmps512_maskz";
            case 1243L: return "bfk_ia32_fixupimmsd_mask";
            case 1244L: return "bfk_ia32_fixupimmsd_maskz";
            case 1245L: return "bfk_ia32_fixupimmss_mask";
            case 1246L: return "bfk_ia32_fixupimmss_maskz";
            case 1247L: return "bfk_ia32_fldenv";
            case 1248L: return "bfk_ia32_floorpd";
            case 1249L: return "bfk_ia32_floorpd256";
            case 1250L: return "bfk_ia32_floorpd512";
            case 1251L: return "bfk_ia32_floorpd_vec_pack_sfix";
            case 1252L: return "bfk_ia32_floorpd_vec_pack_sfix256";
            case 1253L: return "bfk_ia32_floorpd_vec_pack_sfix512";
            case 1254L: return "bfk_ia32_floorps";
            case 1255L: return "bfk_ia32_floorps256";
            case 1256L: return "bfk_ia32_floorps512";
            case 1257L: return "bfk_ia32_floorps_sfix";
            case 1258L: return "bfk_ia32_floorps_sfix256";
            case 1259L: return "bfk_ia32_floorps_sfix512";
            case 1260L: return "bfk_ia32_fmaddpd";
            case 1261L: return "bfk_ia32_fmaddps";
            case 1262L: return "bfk_ia32_fmaddsd";
            case 1263L: return "bfk_ia32_fmaddss";
            case 1264L: return "bfk_ia32_fmsubpd";
            case 1265L: return "bfk_ia32_fmsubps";
            case 1266L: return "bfk_ia32_fmsubsd";
            case 1267L: return "bfk_ia32_fmsubss";
            case 1268L: return "bfk_ia32_fnclex";
            case 1269L: return "bfk_ia32_fnmaddpd";
            case 1270L: return "bfk_ia32_fnmaddps";
            case 1271L: return "bfk_ia32_fnmaddsd";
            case 1272L: return "bfk_ia32_fnmaddss";
            case 1273L: return "bfk_ia32_fnmsubpd";
            case 1274L: return "bfk_ia32_fnmsubps";
            case 1275L: return "bfk_ia32_fnmsubsd";
            case 1276L: return "bfk_ia32_fnmsubss";
            case 1277L: return "bfk_ia32_fnstenv";
            case 1278L: return "bfk_ia32_fnstsw";
            case 1279L: return "bfk_ia32_fpclasspd128_mask";
            case 1280L: return "bfk_ia32_fpclasspd256_mask";
            case 1281L: return "bfk_ia32_fpclasspd512_mask";
            case 1282L: return "bfk_ia32_fpclassps128_mask";
            case 1283L: return "bfk_ia32_fpclassps256_mask";
            case 1284L: return "bfk_ia32_fpclassps512_mask";
            case 1285L: return "bfk_ia32_fpclasssd";
            case 1286L: return "bfk_ia32_fpclasssd_mask";
            case 1287L: return "bfk_ia32_fpclassss";
            case 1288L: return "bfk_ia32_fpclassss_mask";
            case 1289L: return "bfk_ia32_frczpd";
            case 1290L: return "bfk_ia32_frczps";
            case 1291L: return "bfk_ia32_frczsd";
            case 1292L: return "bfk_ia32_frczss";
            case 1293L: return "bfk_ia32_fxrstor";
            case 1294L: return "bfk_ia32_fxrstor64";
            case 1295L: return "bfk_ia32_fxsave";
            case 1296L: return "bfk_ia32_fxsave64";
            case 1297L: return "bfk_ia32_gather3altdiv8sf";
            case 1298L: return "bfk_ia32_gather3altdiv8si";
            case 1299L: return "bfk_ia32_gather3altsiv4df";
            case 1300L: return "bfk_ia32_gather3altsiv4di";
            case 1301L: return "bfk_ia32_gather3div2df";
            case 1302L: return "bfk_ia32_gather3div2di";
            case 1303L: return "bfk_ia32_gather3div4df";
            case 1304L: return "bfk_ia32_gather3div4di";
            case 1305L: return "bfk_ia32_gather3div4sf";
            case 1306L: return "bfk_ia32_gather3div4si";
            case 1307L: return "bfk_ia32_gather3div8sf";
            case 1308L: return "bfk_ia32_gather3div8si";
            case 1309L: return "bfk_ia32_gather3siv2df";
            case 1310L: return "bfk_ia32_gather3siv2di";
            case 1311L: return "bfk_ia32_gather3siv4df";
            case 1312L: return "bfk_ia32_gather3siv4di";
            case 1313L: return "bfk_ia32_gather3siv4sf";
            case 1314L: return "bfk_ia32_gather3siv4si";
            case 1315L: return "bfk_ia32_gather3siv8sf";
            case 1316L: return "bfk_ia32_gather3siv8si";
            case 1317L: return "bfk_ia32_gatheraltdiv4sf256";
            case 1318L: return "bfk_ia32_gatheraltdiv4si256";
            case 1319L: return "bfk_ia32_gatheraltdiv8sf";
            case 1320L: return "bfk_ia32_gatheraltdiv8si";
            case 1321L: return "bfk_ia32_gatheraltsiv4df";
            case 1322L: return "bfk_ia32_gatheraltsiv4di";
            case 1323L: return "bfk_ia32_gatheraltsiv8df";
            case 1324L: return "bfk_ia32_gatheraltsiv8di";
            case 1325L: return "bfk_ia32_gatherd_d";
            case 1326L: return "bfk_ia32_gatherd_d256";
            case 1327L: return "bfk_ia32_gatherd_pd";
            case 1328L: return "bfk_ia32_gatherd_pd256";
            case 1329L: return "bfk_ia32_gatherd_ps";
            case 1330L: return "bfk_ia32_gatherd_ps256";
            case 1331L: return "bfk_ia32_gatherd_q";
            case 1332L: return "bfk_ia32_gatherd_q256";
            case 1333L: return "bfk_ia32_gatherdiv16sf";
            case 1334L: return "bfk_ia32_gatherdiv16si";
            case 1335L: return "bfk_ia32_gatherdiv2df";
            case 1336L: return "bfk_ia32_gatherdiv2di";
            case 1337L: return "bfk_ia32_gatherdiv4df";
            case 1338L: return "bfk_ia32_gatherdiv4di";
            case 1339L: return "bfk_ia32_gatherdiv4sf";
            case 1340L: return "bfk_ia32_gatherdiv4sf256";
            case 1341L: return "bfk_ia32_gatherdiv4si";
            case 1342L: return "bfk_ia32_gatherdiv4si256";
            case 1343L: return "bfk_ia32_gatherdiv8df";
            case 1344L: return "bfk_ia32_gatherdiv8di";
            case 1345L: return "bfk_ia32_gatherpfdpd";
            case 1346L: return "bfk_ia32_gatherpfdps";
            case 1347L: return "bfk_ia32_gatherpfqpd";
            case 1348L: return "bfk_ia32_gatherpfqps";
            case 1349L: return "bfk_ia32_gatherq_d";
            case 1350L: return "bfk_ia32_gatherq_d256";
            case 1351L: return "bfk_ia32_gatherq_pd";
            case 1352L: return "bfk_ia32_gatherq_pd256";
            case 1353L: return "bfk_ia32_gatherq_ps";
            case 1354L: return "bfk_ia32_gatherq_ps256";
            case 1355L: return "bfk_ia32_gatherq_q";
            case 1356L: return "bfk_ia32_gatherq_q256";
            case 1357L: return "bfk_ia32_gathersiv16sf";
            case 1358L: return "bfk_ia32_gathersiv16si";
            case 1359L: return "bfk_ia32_gathersiv2df";
            case 1360L: return "bfk_ia32_gathersiv2di";
            case 1361L: return "bfk_ia32_gathersiv4df";
            case 1362L: return "bfk_ia32_gathersiv4di";
            case 1363L: return "bfk_ia32_gathersiv4sf";
            case 1364L: return "bfk_ia32_gathersiv4si";
            case 1365L: return "bfk_ia32_gathersiv8df";
            case 1366L: return "bfk_ia32_gathersiv8di";
            case 1367L: return "bfk_ia32_gathersiv8sf";
            case 1368L: return "bfk_ia32_gathersiv8si";
            case 1369L: return "bfk_ia32_getexppd128_mask";
            case 1370L: return "bfk_ia32_getexppd256_mask";
            case 1371L: return "bfk_ia32_getexppd512_mask";
            case 1372L: return "bfk_ia32_getexpps128_mask";
            case 1373L: return "bfk_ia32_getexpps256_mask";
            case 1374L: return "bfk_ia32_getexpps512_mask";
            case 1375L: return "bfk_ia32_getexpsd128_round";
            case 1376L: return "bfk_ia32_getexpsd128_round_mask";
            case 1377L: return "bfk_ia32_getexpsd_mask_round";
            case 1378L: return "bfk_ia32_getexpss128_round";
            case 1379L: return "bfk_ia32_getexpss128_round_mask";
            case 1380L: return "bfk_ia32_getexpss_mask_round";
            case 1381L: return "bfk_ia32_getmantpd128_mask";
            case 1382L: return "bfk_ia32_getmantpd256_mask";
            case 1383L: return "bfk_ia32_getmantpd512_mask";
            case 1384L: return "bfk_ia32_getmantps128_mask";
            case 1385L: return "bfk_ia32_getmantps256_mask";
            case 1386L: return "bfk_ia32_getmantps512_mask";
            case 1387L: return "bfk_ia32_getmantsd_mask_round";
            case 1388L: return "bfk_ia32_getmantsd_round";
            case 1389L: return "bfk_ia32_getmantsd_round_mask";
            case 1390L: return "bfk_ia32_getmantss_mask_round";
            case 1391L: return "bfk_ia32_getmantss_round";
            case 1392L: return "bfk_ia32_getmantss_round_mask";
            case 1393L: return "bfk_ia32_haddpd";
            case 1394L: return "bfk_ia32_haddpd256";
            case 1395L: return "bfk_ia32_haddps";
            case 1396L: return "bfk_ia32_haddps256";
            case 1397L: return "bfk_ia32_hsubpd";
            case 1398L: return "bfk_ia32_hsubpd256";
            case 1399L: return "bfk_ia32_hsubps";
            case 1400L: return "bfk_ia32_hsubps256";
            case 1401L: return "bfk_ia32_incsspd";
            case 1402L: return "bfk_ia32_incsspq";
            case 1403L: return "bfk_ia32_insert128i256";
            case 1404L: return "bfk_ia32_insertf32x4_256_mask";
            case 1405L: return "bfk_ia32_insertf32x4_mask";
            case 1406L: return "bfk_ia32_insertf32x8_mask";
            case 1407L: return "bfk_ia32_insertf64x2_256_mask";
            case 1408L: return "bfk_ia32_insertf64x2_512_mask";
            case 1409L: return "bfk_ia32_insertf64x4_mask";
            case 1410L: return "bfk_ia32_inserti32x4_256_mask";
            case 1411L: return "bfk_ia32_inserti32x4_mask";
            case 1412L: return "bfk_ia32_inserti32x8_mask";
            case 1413L: return "bfk_ia32_inserti64x2_256_mask";
            case 1414L: return "bfk_ia32_inserti64x2_512_mask";
            case 1415L: return "bfk_ia32_inserti64x4_mask";
            case 1416L: return "bfk_ia32_insertps128";
            case 1417L: return "bfk_ia32_insertq";
            case 1418L: return "bfk_ia32_insertqi";
            case 1419L: return "bfk_ia32_kadddi";
            case 1420L: return "bfk_ia32_kaddhi";
            case 1421L: return "bfk_ia32_kaddqi";
            case 1422L: return "bfk_ia32_kaddsi";
            case 1423L: return "bfk_ia32_kanddi";
            case 1424L: return "bfk_ia32_kandhi";
            case 1425L: return "bfk_ia32_kandndi";
            case 1426L: return "bfk_ia32_kandnhi";
            case 1427L: return "bfk_ia32_kandnqi";
            case 1428L: return "bfk_ia32_kandnsi";
            case 1429L: return "bfk_ia32_kandqi";
            case 1430L: return "bfk_ia32_kandsi";
            case 1431L: return "bfk_ia32_kmov16";
            case 1432L: return "bfk_ia32_kmovb";
            case 1433L: return "bfk_ia32_kmovd";
            case 1434L: return "bfk_ia32_kmovq";
            case 1435L: return "bfk_ia32_kmovw";
            case 1436L: return "bfk_ia32_knotdi";
            case 1437L: return "bfk_ia32_knothi";
            case 1438L: return "bfk_ia32_knotqi";
            case 1439L: return "bfk_ia32_knotsi";
            case 1440L: return "bfk_ia32_kordi";
            case 1441L: return "bfk_ia32_korhi";
            case 1442L: return "bfk_ia32_korqi";
            case 1443L: return "bfk_ia32_korsi";
            case 1444L: return "bfk_ia32_kortestcdi";
            case 1445L: return "bfk_ia32_kortestchi";
            case 1446L: return "bfk_ia32_kortestcqi";
            case 1447L: return "bfk_ia32_kortestcsi";
            case 1448L: return "bfk_ia32_kortestzdi";
            case 1449L: return "bfk_ia32_kortestzhi";
            case 1450L: return "bfk_ia32_kortestzqi";
            case 1451L: return "bfk_ia32_kortestzsi";
            case 1452L: return "bfk_ia32_kshiftlidi";
            case 1453L: return "bfk_ia32_kshiftlihi";
            case 1454L: return "bfk_ia32_kshiftliqi";
            case 1455L: return "bfk_ia32_kshiftlisi";
            case 1456L: return "bfk_ia32_kshiftridi";
            case 1457L: return "bfk_ia32_kshiftrihi";
            case 1458L: return "bfk_ia32_kshiftriqi";
            case 1459L: return "bfk_ia32_kshiftrisi";
            case 1460L: return "bfk_ia32_ktestcdi";
            case 1461L: return "bfk_ia32_ktestchi";
            case 1462L: return "bfk_ia32_ktestcqi";
            case 1463L: return "bfk_ia32_ktestcsi";
            case 1464L: return "bfk_ia32_ktestzdi";
            case 1465L: return "bfk_ia32_ktestzhi";
            case 1466L: return "bfk_ia32_ktestzqi";
            case 1467L: return "bfk_ia32_ktestzsi";
            case 1468L: return "bfk_ia32_kunpckdi";
            case 1469L: return "bfk_ia32_kunpckhi";
            case 1470L: return "bfk_ia32_kunpcksi";
            case 1471L: return "bfk_ia32_kxnordi";
            case 1472L: return "bfk_ia32_kxnorhi";
            case 1473L: return "bfk_ia32_kxnorqi";
            case 1474L: return "bfk_ia32_kxnorsi";
            case 1475L: return "bfk_ia32_kxordi";
            case 1476L: return "bfk_ia32_kxorhi";
            case 1477L: return "bfk_ia32_kxorqi";
            case 1478L: return "bfk_ia32_kxorsi";
            case 1479L: return "bfk_ia32_lddqu";
            case 1480L: return "bfk_ia32_lddqu256";
            case 1481L: return "bfk_ia32_ldmxcsr";
            case 1482L: return "bfk_ia32_lfence";
            case 1483L: return "bfk_ia32_llwpcb";
            case 1484L: return "bfk_ia32_loadapd128_mask";
            case 1485L: return "bfk_ia32_loadapd256_mask";
            case 1486L: return "bfk_ia32_loadapd512_mask";
            case 1487L: return "bfk_ia32_loadaps";
            case 1488L: return "bfk_ia32_loadaps128_mask";
            case 1489L: return "bfk_ia32_loadaps256_mask";
            case 1490L: return "bfk_ia32_loadaps512_mask";
            case 1491L: return "bfk_ia32_loadddup";
            case 1492L: return "bfk_ia32_loaddqu";
            case 1493L: return "bfk_ia32_loaddqu256";
            case 1494L: return "bfk_ia32_loaddqudi128_mask";
            case 1495L: return "bfk_ia32_loaddqudi256_mask";
            case 1496L: return "bfk_ia32_loaddqudi512_mask";
            case 1497L: return "bfk_ia32_loaddquhi128_mask";
            case 1498L: return "bfk_ia32_loaddquhi256_mask";
            case 1499L: return "bfk_ia32_loaddquhi512_mask";
            case 1500L: return "bfk_ia32_loaddquqi128_mask";
            case 1501L: return "bfk_ia32_loaddquqi256_mask";
            case 1502L: return "bfk_ia32_loaddquqi512_mask";
            case 1503L: return "bfk_ia32_loaddqusi128_mask";
            case 1504L: return "bfk_ia32_loaddqusi256_mask";
            case 1505L: return "bfk_ia32_loaddqusi512_mask";
            case 1506L: return "bfk_ia32_loadhpd";
            case 1507L: return "bfk_ia32_loadhps";
            case 1508L: return "bfk_ia32_loadlpd";
            case 1509L: return "bfk_ia32_loadlps";
            case 1510L: return "bfk_ia32_loadsd128_mask";
            case 1511L: return "bfk_ia32_loadss";
            case 1512L: return "bfk_ia32_loadss128_mask";
            case 1513L: return "bfk_ia32_loadupd";
            case 1514L: return "bfk_ia32_loadupd128_mask";
            case 1515L: return "bfk_ia32_loadupd256";
            case 1516L: return "bfk_ia32_loadupd256_mask";
            case 1517L: return "bfk_ia32_loadupd512_mask";
            case 1518L: return "bfk_ia32_loadups";
            case 1519L: return "bfk_ia32_loadups128_mask";
            case 1520L: return "bfk_ia32_loadups256";
            case 1521L: return "bfk_ia32_loadups256_mask";
            case 1522L: return "bfk_ia32_loadups512_mask";
            case 1523L: return "bfk_ia32_lwpins32";
            case 1524L: return "bfk_ia32_lwpins64";
            case 1525L: return "bfk_ia32_lwpval32";
            case 1526L: return "bfk_ia32_lwpval64";
            case 1527L: return "bfk_ia32_lzcnt_u16";
            case 1528L: return "bfk_ia32_lzcnt_u32";
            case 1529L: return "bfk_ia32_lzcnt_u64";
            case 1530L: return "bfk_ia32_maskloadd";
            case 1531L: return "bfk_ia32_maskloadd256";
            case 1532L: return "bfk_ia32_maskloadpd";
            case 1533L: return "bfk_ia32_maskloadpd256";
            case 1534L: return "bfk_ia32_maskloadps";
            case 1535L: return "bfk_ia32_maskloadps256";
            case 1536L: return "bfk_ia32_maskloadq";
            case 1537L: return "bfk_ia32_maskloadq256";
            case 1538L: return "bfk_ia32_maskmovdqu";
            case 1539L: return "bfk_ia32_maskmovq";
            case 1540L: return "bfk_ia32_maskstored";
            case 1541L: return "bfk_ia32_maskstored256";
            case 1542L: return "bfk_ia32_maskstorepd";
            case 1543L: return "bfk_ia32_maskstorepd256";
            case 1544L: return "bfk_ia32_maskstoreps";
            case 1545L: return "bfk_ia32_maskstoreps256";
            case 1546L: return "bfk_ia32_maskstoreq";
            case 1547L: return "bfk_ia32_maskstoreq256";
            case 1548L: return "bfk_ia32_maxpd";
            case 1549L: return "bfk_ia32_maxpd256";
            case 1550L: return "bfk_ia32_maxpd256_mask";
            case 1551L: return "bfk_ia32_maxpd512_mask";
            case 1552L: return "bfk_ia32_maxpd_mask";
            case 1553L: return "bfk_ia32_maxps";
            case 1554L: return "bfk_ia32_maxps256";
            case 1555L: return "bfk_ia32_maxps256_mask";
            case 1556L: return "bfk_ia32_maxps512_mask";
            case 1557L: return "bfk_ia32_maxps_mask";
            case 1558L: return "bfk_ia32_maxsd";
            case 1559L: return "bfk_ia32_maxsd_mask_round";
            case 1560L: return "bfk_ia32_maxsd_round";
            case 1561L: return "bfk_ia32_maxsd_round_mask";
            case 1562L: return "bfk_ia32_maxss";
            case 1563L: return "bfk_ia32_maxss_mask_round";
            case 1564L: return "bfk_ia32_maxss_round";
            case 1565L: return "bfk_ia32_maxss_round_mask";
            case 1566L: return "bfk_ia32_mfence";
            case 1567L: return "bfk_ia32_minpd";
            case 1568L: return "bfk_ia32_minpd256";
            case 1569L: return "bfk_ia32_minpd256_mask";
            case 1570L: return "bfk_ia32_minpd512_mask";
            case 1571L: return "bfk_ia32_minpd_mask";
            case 1572L: return "bfk_ia32_minps";
            case 1573L: return "bfk_ia32_minps256";
            case 1574L: return "bfk_ia32_minps256_mask";
            case 1575L: return "bfk_ia32_minps512_mask";
            case 1576L: return "bfk_ia32_minps_mask";
            case 1577L: return "bfk_ia32_minsd";
            case 1578L: return "bfk_ia32_minsd_mask_round";
            case 1579L: return "bfk_ia32_minsd_round";
            case 1580L: return "bfk_ia32_minsd_round_mask";
            case 1581L: return "bfk_ia32_minss";
            case 1582L: return "bfk_ia32_minss_mask_round";
            case 1583L: return "bfk_ia32_minss_round";
            case 1584L: return "bfk_ia32_minss_round_mask";
            case 1585L: return "bfk_ia32_monitor";
            case 1586L: return "bfk_ia32_monitorx";
            case 1587L: return "bfk_ia32_movapd128_mask";
            case 1588L: return "bfk_ia32_movapd256_mask";
            case 1589L: return "bfk_ia32_movapd512_mask";
            case 1590L: return "bfk_ia32_movaps128_mask";
            case 1591L: return "bfk_ia32_movaps256_mask";
            case 1592L: return "bfk_ia32_movaps512_mask";
            case 1593L: return "bfk_ia32_movddup";
            case 1594L: return "bfk_ia32_movddup128_mask";
            case 1595L: return "bfk_ia32_movddup256";
            case 1596L: return "bfk_ia32_movddup256_mask";
            case 1597L: return "bfk_ia32_movddup512_mask";
            case 1598L: return "bfk_ia32_movdir64b";
            case 1599L: return "bfk_ia32_movdqa32_128_mask";
            case 1600L: return "bfk_ia32_movdqa32_256_mask";
            case 1601L: return "bfk_ia32_movdqa32_512_mask";
            case 1602L: return "bfk_ia32_movdqa32load128_mask";
            case 1603L: return "bfk_ia32_movdqa32load256_mask";
            case 1604L: return "bfk_ia32_movdqa32load512_mask";
            case 1605L: return "bfk_ia32_movdqa32store128_mask";
            case 1606L: return "bfk_ia32_movdqa32store256_mask";
            case 1607L: return "bfk_ia32_movdqa32store512_mask";
            case 1608L: return "bfk_ia32_movdqa64_128_mask";
            case 1609L: return "bfk_ia32_movdqa64_256_mask";
            case 1610L: return "bfk_ia32_movdqa64_512_mask";
            case 1611L: return "bfk_ia32_movdqa64load128_mask";
            case 1612L: return "bfk_ia32_movdqa64load256_mask";
            case 1613L: return "bfk_ia32_movdqa64load512_mask";
            case 1614L: return "bfk_ia32_movdqa64store128_mask";
            case 1615L: return "bfk_ia32_movdqa64store256_mask";
            case 1616L: return "bfk_ia32_movdqa64store512_mask";
            case 1617L: return "bfk_ia32_movdquhi128_mask";
            case 1618L: return "bfk_ia32_movdquhi256_mask";
            case 1619L: return "bfk_ia32_movdquhi512_mask";
            case 1620L: return "bfk_ia32_movdquqi128_mask";
            case 1621L: return "bfk_ia32_movdquqi256_mask";
            case 1622L: return "bfk_ia32_movdquqi512_mask";
            case 1623L: return "bfk_ia32_movhlps";
            case 1624L: return "bfk_ia32_movlhps";
            case 1625L: return "bfk_ia32_movmskpd";
            case 1626L: return "bfk_ia32_movmskpd256";
            case 1627L: return "bfk_ia32_movmskps";
            case 1628L: return "bfk_ia32_movmskps256";
            case 1629L: return "bfk_ia32_movntdq";
            case 1630L: return "bfk_ia32_movntdq256";
            case 1631L: return "bfk_ia32_movntdq512";
            case 1632L: return "bfk_ia32_movntdqa";
            case 1633L: return "bfk_ia32_movntdqa256";
            case 1634L: return "bfk_ia32_movntdqa512";
            case 1635L: return "bfk_ia32_movnti";
            case 1636L: return "bfk_ia32_movnti64";
            case 1637L: return "bfk_ia32_movntpd";
            case 1638L: return "bfk_ia32_movntpd256";
            case 1639L: return "bfk_ia32_movntpd512";
            case 1640L: return "bfk_ia32_movntps";
            case 1641L: return "bfk_ia32_movntps256";
            case 1642L: return "bfk_ia32_movntps512";
            case 1643L: return "bfk_ia32_movntq";
            case 1644L: return "bfk_ia32_movntsd";
            case 1645L: return "bfk_ia32_movntss";
            case 1646L: return "bfk_ia32_movq128";
            case 1647L: return "bfk_ia32_movsd";
            case 1648L: return "bfk_ia32_movshdup";
            case 1649L: return "bfk_ia32_movshdup128_mask";
            case 1650L: return "bfk_ia32_movshdup256";
            case 1651L: return "bfk_ia32_movshdup256_mask";
            case 1652L: return "bfk_ia32_movshdup512_mask";
            case 1653L: return "bfk_ia32_movsldup";
            case 1654L: return "bfk_ia32_movsldup128_mask";
            case 1655L: return "bfk_ia32_movsldup256";
            case 1656L: return "bfk_ia32_movsldup256_mask";
            case 1657L: return "bfk_ia32_movsldup512_mask";
            case 1658L: return "bfk_ia32_movss";
            case 1659L: return "bfk_ia32_mpsadbw128";
            case 1660L: return "bfk_ia32_mpsadbw256";
            case 1661L: return "bfk_ia32_mulpd";
            case 1662L: return "bfk_ia32_mulpd256";
            case 1663L: return "bfk_ia32_mulpd256_mask";
            case 1664L: return "bfk_ia32_mulpd512_mask";
            case 1665L: return "bfk_ia32_mulpd_mask";
            case 1666L: return "bfk_ia32_mulps";
            case 1667L: return "bfk_ia32_mulps256";
            case 1668L: return "bfk_ia32_mulps256_mask";
            case 1669L: return "bfk_ia32_mulps512_mask";
            case 1670L: return "bfk_ia32_mulps_mask";
            case 1671L: return "bfk_ia32_mulsd";
            case 1672L: return "bfk_ia32_mulsd_mask_round";
            case 1673L: return "bfk_ia32_mulsd_round";
            case 1674L: return "bfk_ia32_mulsd_round_mask";
            case 1675L: return "bfk_ia32_mulss";
            case 1676L: return "bfk_ia32_mulss_mask_round";
            case 1677L: return "bfk_ia32_mulss_round";
            case 1678L: return "bfk_ia32_mulss_round_mask";
            case 1679L: return "bfk_ia32_mwait";
            case 1680L: return "bfk_ia32_mwaitx";
            case 1681L: return "bfk_ia32_orpd";
            case 1682L: return "bfk_ia32_orpd128_mask";
            case 1683L: return "bfk_ia32_orpd256";
            case 1684L: return "bfk_ia32_orpd256_mask";
            case 1685L: return "bfk_ia32_orpd512_mask";
            case 1686L: return "bfk_ia32_orps";
            case 1687L: return "bfk_ia32_orps128_mask";
            case 1688L: return "bfk_ia32_orps256";
            case 1689L: return "bfk_ia32_orps256_mask";
            case 1690L: return "bfk_ia32_orps512_mask";
            case 1691L: return "bfk_ia32_pabsb";
            case 1692L: return "bfk_ia32_pabsb128";
            case 1693L: return "bfk_ia32_pabsb128_mask";
            case 1694L: return "bfk_ia32_pabsb256";
            case 1695L: return "bfk_ia32_pabsb256_mask";
            case 1696L: return "bfk_ia32_pabsb512_mask";
            case 1697L: return "bfk_ia32_pabsd";
            case 1698L: return "bfk_ia32_pabsd128";
            case 1699L: return "bfk_ia32_pabsd128_mask";
            case 1700L: return "bfk_ia32_pabsd256";
            case 1701L: return "bfk_ia32_pabsd256_mask";
            case 1702L: return "bfk_ia32_pabsd512_mask";
            case 1703L: return "bfk_ia32_pabsq128_mask";
            case 1704L: return "bfk_ia32_pabsq256_mask";
            case 1705L: return "bfk_ia32_pabsq512_mask";
            case 1706L: return "bfk_ia32_pabsw";
            case 1707L: return "bfk_ia32_pabsw128";
            case 1708L: return "bfk_ia32_pabsw128_mask";
            case 1709L: return "bfk_ia32_pabsw256";
            case 1710L: return "bfk_ia32_pabsw256_mask";
            case 1711L: return "bfk_ia32_pabsw512_mask";
            case 1712L: return "bfk_ia32_packssdw";
            case 1713L: return "bfk_ia32_packssdw128";
            case 1714L: return "bfk_ia32_packssdw128_mask";
            case 1715L: return "bfk_ia32_packssdw256";
            case 1716L: return "bfk_ia32_packssdw256_mask";
            case 1717L: return "bfk_ia32_packssdw512";
            case 1718L: return "bfk_ia32_packssdw512_mask";
            case 1719L: return "bfk_ia32_packsswb";
            case 1720L: return "bfk_ia32_packsswb128";
            case 1721L: return "bfk_ia32_packsswb128_mask";
            case 1722L: return "bfk_ia32_packsswb256";
            case 1723L: return "bfk_ia32_packsswb256_mask";
            case 1724L: return "bfk_ia32_packsswb512";
            case 1725L: return "bfk_ia32_packsswb512_mask";
            case 1726L: return "bfk_ia32_packusdw128";
            case 1727L: return "bfk_ia32_packusdw128_mask";
            case 1728L: return "bfk_ia32_packusdw256";
            case 1729L: return "bfk_ia32_packusdw256_mask";
            case 1730L: return "bfk_ia32_packusdw512";
            case 1731L: return "bfk_ia32_packusdw512_mask";
            case 1732L: return "bfk_ia32_packuswb";
            case 1733L: return "bfk_ia32_packuswb128";
            case 1734L: return "bfk_ia32_packuswb128_mask";
            case 1735L: return "bfk_ia32_packuswb256";
            case 1736L: return "bfk_ia32_packuswb256_mask";
            case 1737L: return "bfk_ia32_packuswb512";
            case 1738L: return "bfk_ia32_packuswb512_mask";
            case 1739L: return "bfk_ia32_paddb";
            case 1740L: return "bfk_ia32_paddb128";
            case 1741L: return "bfk_ia32_paddb128_mask";
            case 1742L: return "bfk_ia32_paddb256";
            case 1743L: return "bfk_ia32_paddb256_mask";
            case 1744L: return "bfk_ia32_paddb512_mask";
            case 1745L: return "bfk_ia32_paddd";
            case 1746L: return "bfk_ia32_paddd128";
            case 1747L: return "bfk_ia32_paddd128_mask";
            case 1748L: return "bfk_ia32_paddd256";
            case 1749L: return "bfk_ia32_paddd256_mask";
            case 1750L: return "bfk_ia32_paddd512_mask";
            case 1751L: return "bfk_ia32_paddq";
            case 1752L: return "bfk_ia32_paddq128";
            case 1753L: return "bfk_ia32_paddq128_mask";
            case 1754L: return "bfk_ia32_paddq256";
            case 1755L: return "bfk_ia32_paddq256_mask";
            case 1756L: return "bfk_ia32_paddq512_mask";
            case 1757L: return "bfk_ia32_paddsb";
            case 1758L: return "bfk_ia32_paddsb128";
            case 1759L: return "bfk_ia32_paddsb128_mask";
            case 1760L: return "bfk_ia32_paddsb256";
            case 1761L: return "bfk_ia32_paddsb256_mask";
            case 1762L: return "bfk_ia32_paddsb512_mask";
            case 1763L: return "bfk_ia32_paddsw";
            case 1764L: return "bfk_ia32_paddsw128";
            case 1765L: return "bfk_ia32_paddsw128_mask";
            case 1766L: return "bfk_ia32_paddsw256";
            case 1767L: return "bfk_ia32_paddsw256_mask";
            case 1768L: return "bfk_ia32_paddsw512_mask";
            case 1769L: return "bfk_ia32_paddusb";
            case 1770L: return "bfk_ia32_paddusb128";
            case 1771L: return "bfk_ia32_paddusb128_mask";
            case 1772L: return "bfk_ia32_paddusb256";
            case 1773L: return "bfk_ia32_paddusb256_mask";
            case 1774L: return "bfk_ia32_paddusb512_mask";
            case 1775L: return "bfk_ia32_paddusw";
            case 1776L: return "bfk_ia32_paddusw128";
            case 1777L: return "bfk_ia32_paddusw128_mask";
            case 1778L: return "bfk_ia32_paddusw256";
            case 1779L: return "bfk_ia32_paddusw256_mask";
            case 1780L: return "bfk_ia32_paddusw512_mask";
            case 1781L: return "bfk_ia32_paddw";
            case 1782L: return "bfk_ia32_paddw128";
            case 1783L: return "bfk_ia32_paddw128_mask";
            case 1784L: return "bfk_ia32_paddw256";
            case 1785L: return "bfk_ia32_paddw256_mask";
            case 1786L: return "bfk_ia32_paddw512_mask";
            case 1787L: return "bfk_ia32_palignr";
            case 1788L: return "bfk_ia32_palignr128";
            case 1789L: return "bfk_ia32_palignr128_mask";
            case 1790L: return "bfk_ia32_palignr256";
            case 1791L: return "bfk_ia32_palignr256_mask";
            case 1792L: return "bfk_ia32_palignr512";
            case 1793L: return "bfk_ia32_palignr512_mask";
            case 1794L: return "bfk_ia32_pand";
            case 1795L: return "bfk_ia32_pand128";
            case 1796L: return "bfk_ia32_pandd128_mask";
            case 1797L: return "bfk_ia32_pandd256_mask";
            case 1798L: return "bfk_ia32_pandd512_mask";
            case 1799L: return "bfk_ia32_pandn";
            case 1800L: return "bfk_ia32_pandn128";
            case 1801L: return "bfk_ia32_pandnd128_mask";
            case 1802L: return "bfk_ia32_pandnd256_mask";
            case 1803L: return "bfk_ia32_pandnd512_mask";
            case 1804L: return "bfk_ia32_pandnq128_mask";
            case 1805L: return "bfk_ia32_pandnq256_mask";
            case 1806L: return "bfk_ia32_pandnq512_mask";
            case 1807L: return "bfk_ia32_pandq128_mask";
            case 1808L: return "bfk_ia32_pandq256_mask";
            case 1809L: return "bfk_ia32_pandq512_mask";
            case 1810L: return "bfk_ia32_pause";
            case 1811L: return "bfk_ia32_pavgb";
            case 1812L: return "bfk_ia32_pavgb128";
            case 1813L: return "bfk_ia32_pavgb128_mask";
            case 1814L: return "bfk_ia32_pavgb256";
            case 1815L: return "bfk_ia32_pavgb256_mask";
            case 1816L: return "bfk_ia32_pavgb512_mask";
            case 1817L: return "bfk_ia32_pavgusb";
            case 1818L: return "bfk_ia32_pavgw";
            case 1819L: return "bfk_ia32_pavgw128";
            case 1820L: return "bfk_ia32_pavgw128_mask";
            case 1821L: return "bfk_ia32_pavgw256";
            case 1822L: return "bfk_ia32_pavgw256_mask";
            case 1823L: return "bfk_ia32_pavgw512_mask";
            case 1824L: return "bfk_ia32_pblendd128";
            case 1825L: return "bfk_ia32_pblendd256";
            case 1826L: return "bfk_ia32_pblendvb128";
            case 1827L: return "bfk_ia32_pblendvb256";
            case 1828L: return "bfk_ia32_pblendw128";
            case 1829L: return "bfk_ia32_pblendw256";
            case 1830L: return "bfk_ia32_pbroadcastb128";
            case 1831L: return "bfk_ia32_pbroadcastb128_gpr_mask";
            case 1832L: return "bfk_ia32_pbroadcastb128_mask";
            case 1833L: return "bfk_ia32_pbroadcastb256";
            case 1834L: return "bfk_ia32_pbroadcastb256_gpr_mask";
            case 1835L: return "bfk_ia32_pbroadcastb256_mask";
            case 1836L: return "bfk_ia32_pbroadcastb512_gpr_mask";
            case 1837L: return "bfk_ia32_pbroadcastb512_mask";
            case 1838L: return "bfk_ia32_pbroadcastd128";
            case 1839L: return "bfk_ia32_pbroadcastd128_gpr_mask";
            case 1840L: return "bfk_ia32_pbroadcastd128_mask";
            case 1841L: return "bfk_ia32_pbroadcastd256";
            case 1842L: return "bfk_ia32_pbroadcastd256_gpr_mask";
            case 1843L: return "bfk_ia32_pbroadcastd256_mask";
            case 1844L: return "bfk_ia32_pbroadcastd512";
            case 1845L: return "bfk_ia32_pbroadcastd512_gpr_mask";
            case 1846L: return "bfk_ia32_pbroadcastq128";
            case 1847L: return "bfk_ia32_pbroadcastq128_gpr_mask";
            case 1848L: return "bfk_ia32_pbroadcastq128_mask";
            case 1849L: return "bfk_ia32_pbroadcastq256";
            case 1850L: return "bfk_ia32_pbroadcastq256_gpr_mask";
            case 1851L: return "bfk_ia32_pbroadcastq256_mask";
            case 1852L: return "bfk_ia32_pbroadcastq512";
            case 1853L: return "bfk_ia32_pbroadcastq512_gpr_mask";
            case 1854L: return "bfk_ia32_pbroadcastq512_mem_mask";
            case 1855L: return "bfk_ia32_pbroadcastw128";
            case 1856L: return "bfk_ia32_pbroadcastw128_gpr_mask";
            case 1857L: return "bfk_ia32_pbroadcastw128_mask";
            case 1858L: return "bfk_ia32_pbroadcastw256";
            case 1859L: return "bfk_ia32_pbroadcastw256_gpr_mask";
            case 1860L: return "bfk_ia32_pbroadcastw256_mask";
            case 1861L: return "bfk_ia32_pbroadcastw512_gpr_mask";
            case 1862L: return "bfk_ia32_pbroadcastw512_mask";
            case 1863L: return "bfk_ia32_pclmulqdq128";
            case 1864L: return "bfk_ia32_pclmulqdq256";
            case 1865L: return "bfk_ia32_pclmulqdq512";
            case 1866L: return "bfk_ia32_pcmov";
            case 1867L: return "bfk_ia32_pcmov_v16qi";
            case 1868L: return "bfk_ia32_pcmov_v2df";
            case 1869L: return "bfk_ia32_pcmov_v2di";
            case 1870L: return "bfk_ia32_pcmov_v4sf";
            case 1871L: return "bfk_ia32_pcmov_v4si";
            case 1872L: return "bfk_ia32_pcmov_v8hi";
            case 1873L: return "bfk_ia32_pcmpeqb";
            case 1874L: return "bfk_ia32_pcmpeqb128";
            case 1875L: return "bfk_ia32_pcmpeqb128_mask";
            case 1876L: return "bfk_ia32_pcmpeqb256";
            case 1877L: return "bfk_ia32_pcmpeqb256_mask";
            case 1878L: return "bfk_ia32_pcmpeqb512_mask";
            case 1879L: return "bfk_ia32_pcmpeqd";
            case 1880L: return "bfk_ia32_pcmpeqd128";
            case 1881L: return "bfk_ia32_pcmpeqd128_mask";
            case 1882L: return "bfk_ia32_pcmpeqd256";
            case 1883L: return "bfk_ia32_pcmpeqd256_mask";
            case 1884L: return "bfk_ia32_pcmpeqd512_mask";
            case 1885L: return "bfk_ia32_pcmpeqq";
            case 1886L: return "bfk_ia32_pcmpeqq128_mask";
            case 1887L: return "bfk_ia32_pcmpeqq256";
            case 1888L: return "bfk_ia32_pcmpeqq256_mask";
            case 1889L: return "bfk_ia32_pcmpeqq512_mask";
            case 1890L: return "bfk_ia32_pcmpeqw";
            case 1891L: return "bfk_ia32_pcmpeqw128";
            case 1892L: return "bfk_ia32_pcmpeqw128_mask";
            case 1893L: return "bfk_ia32_pcmpeqw256";
            case 1894L: return "bfk_ia32_pcmpeqw256_mask";
            case 1895L: return "bfk_ia32_pcmpeqw512_mask";
            case 1896L: return "bfk_ia32_pcmpestri128";
            case 1897L: return "bfk_ia32_pcmpestria128";
            case 1898L: return "bfk_ia32_pcmpestric128";
            case 1899L: return "bfk_ia32_pcmpestrio128";
            case 1900L: return "bfk_ia32_pcmpestris128";
            case 1901L: return "bfk_ia32_pcmpestriz128";
            case 1902L: return "bfk_ia32_pcmpestrm128";
            case 1903L: return "bfk_ia32_pcmpgtb";
            case 1904L: return "bfk_ia32_pcmpgtb128";
            case 1905L: return "bfk_ia32_pcmpgtb128_mask";
            case 1906L: return "bfk_ia32_pcmpgtb256";
            case 1907L: return "bfk_ia32_pcmpgtb256_mask";
            case 1908L: return "bfk_ia32_pcmpgtb512_mask";
            case 1909L: return "bfk_ia32_pcmpgtd";
            case 1910L: return "bfk_ia32_pcmpgtd128";
            case 1911L: return "bfk_ia32_pcmpgtd128_mask";
            case 1912L: return "bfk_ia32_pcmpgtd256";
            case 1913L: return "bfk_ia32_pcmpgtd256_mask";
            case 1914L: return "bfk_ia32_pcmpgtd512_mask";
            case 1915L: return "bfk_ia32_pcmpgtq";
            case 1916L: return "bfk_ia32_pcmpgtq128_mask";
            case 1917L: return "bfk_ia32_pcmpgtq256";
            case 1918L: return "bfk_ia32_pcmpgtq256_mask";
            case 1919L: return "bfk_ia32_pcmpgtq512_mask";
            case 1920L: return "bfk_ia32_pcmpgtw";
            case 1921L: return "bfk_ia32_pcmpgtw128";
            case 1922L: return "bfk_ia32_pcmpgtw128_mask";
            case 1923L: return "bfk_ia32_pcmpgtw256";
            case 1924L: return "bfk_ia32_pcmpgtw256_mask";
            case 1925L: return "bfk_ia32_pcmpgtw512_mask";
            case 1926L: return "bfk_ia32_pcmpistri128";
            case 1927L: return "bfk_ia32_pcmpistria128";
            case 1928L: return "bfk_ia32_pcmpistric128";
            case 1929L: return "bfk_ia32_pcmpistrio128";
            case 1930L: return "bfk_ia32_pcmpistris128";
            case 1931L: return "bfk_ia32_pcmpistriz128";
            case 1932L: return "bfk_ia32_pcmpistrm128";
            case 1933L: return "bfk_ia32_pcomeqb";
            case 1934L: return "bfk_ia32_pcomeqd";
            case 1935L: return "bfk_ia32_pcomeqq";
            case 1936L: return "bfk_ia32_pcomequb";
            case 1937L: return "bfk_ia32_pcomequd";
            case 1938L: return "bfk_ia32_pcomequq";
            case 1939L: return "bfk_ia32_pcomequw";
            case 1940L: return "bfk_ia32_pcomeqw";
            case 1941L: return "bfk_ia32_pcomfalseb";
            case 1942L: return "bfk_ia32_pcomfalsed";
            case 1943L: return "bfk_ia32_pcomfalseq";
            case 1944L: return "bfk_ia32_pcomfalseub";
            case 1945L: return "bfk_ia32_pcomfalseud";
            case 1946L: return "bfk_ia32_pcomfalseuq";
            case 1947L: return "bfk_ia32_pcomfalseuw";
            case 1948L: return "bfk_ia32_pcomfalsew";
            case 1949L: return "bfk_ia32_pcomgeb";
            case 1950L: return "bfk_ia32_pcomged";
            case 1951L: return "bfk_ia32_pcomgeq";
            case 1952L: return "bfk_ia32_pcomgeub";
            case 1953L: return "bfk_ia32_pcomgeud";
            case 1954L: return "bfk_ia32_pcomgeuq";
            case 1955L: return "bfk_ia32_pcomgeuw";
            case 1956L: return "bfk_ia32_pcomgew";
            case 1957L: return "bfk_ia32_pcomgtb";
            case 1958L: return "bfk_ia32_pcomgtd";
            case 1959L: return "bfk_ia32_pcomgtq";
            case 1960L: return "bfk_ia32_pcomgtub";
            case 1961L: return "bfk_ia32_pcomgtud";
            case 1962L: return "bfk_ia32_pcomgtuq";
            case 1963L: return "bfk_ia32_pcomgtuw";
            case 1964L: return "bfk_ia32_pcomgtw";
            case 1965L: return "bfk_ia32_pcomleb";
            case 1966L: return "bfk_ia32_pcomled";
            case 1967L: return "bfk_ia32_pcomleq";
            case 1968L: return "bfk_ia32_pcomleub";
            case 1969L: return "bfk_ia32_pcomleud";
            case 1970L: return "bfk_ia32_pcomleuq";
            case 1971L: return "bfk_ia32_pcomleuw";
            case 1972L: return "bfk_ia32_pcomlew";
            case 1973L: return "bfk_ia32_pcomltb";
            case 1974L: return "bfk_ia32_pcomltd";
            case 1975L: return "bfk_ia32_pcomltq";
            case 1976L: return "bfk_ia32_pcomltub";
            case 1977L: return "bfk_ia32_pcomltud";
            case 1978L: return "bfk_ia32_pcomltuq";
            case 1979L: return "bfk_ia32_pcomltuw";
            case 1980L: return "bfk_ia32_pcomltw";
            case 1981L: return "bfk_ia32_pcommit";
            case 1982L: return "bfk_ia32_pcomneb";
            case 1983L: return "bfk_ia32_pcomned";
            case 1984L: return "bfk_ia32_pcomneq";
            case 1985L: return "bfk_ia32_pcomneub";
            case 1986L: return "bfk_ia32_pcomneud";
            case 1987L: return "bfk_ia32_pcomneuq";
            case 1988L: return "bfk_ia32_pcomneuw";
            case 1989L: return "bfk_ia32_pcomnew";
            case 1990L: return "bfk_ia32_pcomtrueb";
            case 1991L: return "bfk_ia32_pcomtrued";
            case 1992L: return "bfk_ia32_pcomtrueq";
            case 1993L: return "bfk_ia32_pcomtrueub";
            case 1994L: return "bfk_ia32_pcomtrueud";
            case 1995L: return "bfk_ia32_pcomtrueuq";
            case 1996L: return "bfk_ia32_pcomtrueuw";
            case 1997L: return "bfk_ia32_pcomtruew";
            case 1998L: return "bfk_ia32_pd256_pd";
            case 1999L: return "bfk_ia32_pd512_256pd";
            case 2000L: return "bfk_ia32_pd512_pd";
            case 2001L: return "bfk_ia32_pd_pd256";
            case 2002L: return "bfk_ia32_pdep_di";
            case 2003L: return "bfk_ia32_pdep_si";
            case 2004L: return "bfk_ia32_permdf256";
            case 2005L: return "bfk_ia32_permdf256_mask";
            case 2006L: return "bfk_ia32_permdf512_mask";
            case 2007L: return "bfk_ia32_permdi256";
            case 2008L: return "bfk_ia32_permdi256_mask";
            case 2009L: return "bfk_ia32_permdi512_mask";
            case 2010L: return "bfk_ia32_permpd";
            case 2011L: return "bfk_ia32_permps";
            case 2012L: return "bfk_ia32_permti256";
            case 2013L: return "bfk_ia32_permvardf256_mask";
            case 2014L: return "bfk_ia32_permvardf512_mask";
            case 2015L: return "bfk_ia32_permvardi256_mask";
            case 2016L: return "bfk_ia32_permvardi512_mask";
            case 2017L: return "bfk_ia32_permvarhi128_mask";
            case 2018L: return "bfk_ia32_permvarhi256_mask";
            case 2019L: return "bfk_ia32_permvarhi512_mask";
            case 2020L: return "bfk_ia32_permvarqi128_mask";
            case 2021L: return "bfk_ia32_permvarqi256_mask";
            case 2022L: return "bfk_ia32_permvarqi512_mask";
            case 2023L: return "bfk_ia32_permvarsf256";
            case 2024L: return "bfk_ia32_permvarsf256_mask";
            case 2025L: return "bfk_ia32_permvarsf512_mask";
            case 2026L: return "bfk_ia32_permvarsi256";
            case 2027L: return "bfk_ia32_permvarsi256_mask";
            case 2028L: return "bfk_ia32_permvarsi512_mask";
            case 2029L: return "bfk_ia32_pext_di";
            case 2030L: return "bfk_ia32_pext_si";
            case 2031L: return "bfk_ia32_pextrw";
            case 2032L: return "bfk_ia32_pf2id";
            case 2033L: return "bfk_ia32_pf2iw";
            case 2034L: return "bfk_ia32_pfacc";
            case 2035L: return "bfk_ia32_pfadd";
            case 2036L: return "bfk_ia32_pfcmpeq";
            case 2037L: return "bfk_ia32_pfcmpge";
            case 2038L: return "bfk_ia32_pfcmpgt";
            case 2039L: return "bfk_ia32_pfmax";
            case 2040L: return "bfk_ia32_pfmin";
            case 2041L: return "bfk_ia32_pfmul";
            case 2042L: return "bfk_ia32_pfnacc";
            case 2043L: return "bfk_ia32_pfpnacc";
            case 2044L: return "bfk_ia32_pfrcp";
            case 2045L: return "bfk_ia32_pfrcpit1";
            case 2046L: return "bfk_ia32_pfrcpit2";
            case 2047L: return "bfk_ia32_pfrsqit1";
            case 2048L: return "bfk_ia32_pfrsqrt";
            case 2049L: return "bfk_ia32_pfrsqrtit1";
            case 2050L: return "bfk_ia32_pfsub";
            case 2051L: return "bfk_ia32_pfsubr";
            case 2052L: return "bfk_ia32_phaddbd";
            case 2053L: return "bfk_ia32_phaddbq";
            case 2054L: return "bfk_ia32_phaddbw";
            case 2055L: return "bfk_ia32_phaddd";
            case 2056L: return "bfk_ia32_phaddd128";
            case 2057L: return "bfk_ia32_phaddd256";
            case 2058L: return "bfk_ia32_phadddq";
            case 2059L: return "bfk_ia32_phaddsw";
            case 2060L: return "bfk_ia32_phaddsw128";
            case 2061L: return "bfk_ia32_phaddsw256";
            case 2062L: return "bfk_ia32_phaddubd";
            case 2063L: return "bfk_ia32_phaddubq";
            case 2064L: return "bfk_ia32_phaddubw";
            case 2065L: return "bfk_ia32_phaddudq";
            case 2066L: return "bfk_ia32_phadduwd";
            case 2067L: return "bfk_ia32_phadduwq";
            case 2068L: return "bfk_ia32_phaddw";
            case 2069L: return "bfk_ia32_phaddw128";
            case 2070L: return "bfk_ia32_phaddw256";
            case 2071L: return "bfk_ia32_phaddwd";
            case 2072L: return "bfk_ia32_phaddwq";
            case 2073L: return "bfk_ia32_phminposuw128";
            case 2074L: return "bfk_ia32_phsubbw";
            case 2075L: return "bfk_ia32_phsubd";
            case 2076L: return "bfk_ia32_phsubd128";
            case 2077L: return "bfk_ia32_phsubd256";
            case 2078L: return "bfk_ia32_phsubdq";
            case 2079L: return "bfk_ia32_phsubsw";
            case 2080L: return "bfk_ia32_phsubsw128";
            case 2081L: return "bfk_ia32_phsubsw256";
            case 2082L: return "bfk_ia32_phsubw";
            case 2083L: return "bfk_ia32_phsubw128";
            case 2084L: return "bfk_ia32_phsubw256";
            case 2085L: return "bfk_ia32_phsubwd";
            case 2086L: return "bfk_ia32_pi2fd";
            case 2087L: return "bfk_ia32_pi2fw";
            case 2088L: return "bfk_ia32_pinsrw";
            case 2089L: return "bfk_ia32_pmacsdd";
            case 2090L: return "bfk_ia32_pmacsdqh";
            case 2091L: return "bfk_ia32_pmacsdql";
            case 2092L: return "bfk_ia32_pmacssdd";
            case 2093L: return "bfk_ia32_pmacssdqh";
            case 2094L: return "bfk_ia32_pmacssdql";
            case 2095L: return "bfk_ia32_pmacsswd";
            case 2096L: return "bfk_ia32_pmacssww";
            case 2097L: return "bfk_ia32_pmacswd";
            case 2098L: return "bfk_ia32_pmacsww";
            case 2099L: return "bfk_ia32_pmadcsswd";
            case 2100L: return "bfk_ia32_pmadcswd";
            case 2101L: return "bfk_ia32_pmaddubsw";
            case 2102L: return "bfk_ia32_pmaddubsw128";
            case 2103L: return "bfk_ia32_pmaddubsw128_mask";
            case 2104L: return "bfk_ia32_pmaddubsw256";
            case 2105L: return "bfk_ia32_pmaddubsw256_mask";
            case 2106L: return "bfk_ia32_pmaddubsw512_mask";
            case 2107L: return "bfk_ia32_pmaddwd";
            case 2108L: return "bfk_ia32_pmaddwd128";
            case 2109L: return "bfk_ia32_pmaddwd128_mask";
            case 2110L: return "bfk_ia32_pmaddwd256";
            case 2111L: return "bfk_ia32_pmaddwd256_mask";
            case 2112L: return "bfk_ia32_pmaddwd512_mask";
            case 2113L: return "bfk_ia32_pmaxsb128";
            case 2114L: return "bfk_ia32_pmaxsb128_mask";
            case 2115L: return "bfk_ia32_pmaxsb256";
            case 2116L: return "bfk_ia32_pmaxsb256_mask";
            case 2117L: return "bfk_ia32_pmaxsb512_mask";
            case 2118L: return "bfk_ia32_pmaxsd128";
            case 2119L: return "bfk_ia32_pmaxsd128_mask";
            case 2120L: return "bfk_ia32_pmaxsd256";
            case 2121L: return "bfk_ia32_pmaxsd256_mask";
            case 2122L: return "bfk_ia32_pmaxsd512_mask";
            case 2123L: return "bfk_ia32_pmaxsq128_mask";
            case 2124L: return "bfk_ia32_pmaxsq256_mask";
            case 2125L: return "bfk_ia32_pmaxsq512_mask";
            case 2126L: return "bfk_ia32_pmaxsw";
            case 2127L: return "bfk_ia32_pmaxsw128";
            case 2128L: return "bfk_ia32_pmaxsw128_mask";
            case 2129L: return "bfk_ia32_pmaxsw256";
            case 2130L: return "bfk_ia32_pmaxsw256_mask";
            case 2131L: return "bfk_ia32_pmaxsw512_mask";
            case 2132L: return "bfk_ia32_pmaxub";
            case 2133L: return "bfk_ia32_pmaxub128";
            case 2134L: return "bfk_ia32_pmaxub128_mask";
            case 2135L: return "bfk_ia32_pmaxub256";
            case 2136L: return "bfk_ia32_pmaxub256_mask";
            case 2137L: return "bfk_ia32_pmaxub512_mask";
            case 2138L: return "bfk_ia32_pmaxud128";
            case 2139L: return "bfk_ia32_pmaxud128_mask";
            case 2140L: return "bfk_ia32_pmaxud256";
            case 2141L: return "bfk_ia32_pmaxud256_mask";
            case 2142L: return "bfk_ia32_pmaxud512_mask";
            case 2143L: return "bfk_ia32_pmaxuq128_mask";
            case 2144L: return "bfk_ia32_pmaxuq256_mask";
            case 2145L: return "bfk_ia32_pmaxuq512_mask";
            case 2146L: return "bfk_ia32_pmaxuw128";
            case 2147L: return "bfk_ia32_pmaxuw128_mask";
            case 2148L: return "bfk_ia32_pmaxuw256";
            case 2149L: return "bfk_ia32_pmaxuw256_mask";
            case 2150L: return "bfk_ia32_pmaxuw512_mask";
            case 2151L: return "bfk_ia32_pminsb128";
            case 2152L: return "bfk_ia32_pminsb128_mask";
            case 2153L: return "bfk_ia32_pminsb256";
            case 2154L: return "bfk_ia32_pminsb256_mask";
            case 2155L: return "bfk_ia32_pminsb512_mask";
            case 2156L: return "bfk_ia32_pminsd128";
            case 2157L: return "bfk_ia32_pminsd128_mask";
            case 2158L: return "bfk_ia32_pminsd256";
            case 2159L: return "bfk_ia32_pminsd256_mask";
            case 2160L: return "bfk_ia32_pminsd512_mask";
            case 2161L: return "bfk_ia32_pminsq128_mask";
            case 2162L: return "bfk_ia32_pminsq256_mask";
            case 2163L: return "bfk_ia32_pminsq512_mask";
            case 2164L: return "bfk_ia32_pminsw";
            case 2165L: return "bfk_ia32_pminsw128";
            case 2166L: return "bfk_ia32_pminsw128_mask";
            case 2167L: return "bfk_ia32_pminsw256";
            case 2168L: return "bfk_ia32_pminsw256_mask";
            case 2169L: return "bfk_ia32_pminsw512_mask";
            case 2170L: return "bfk_ia32_pminub";
            case 2171L: return "bfk_ia32_pminub128";
            case 2172L: return "bfk_ia32_pminub128_mask";
            case 2173L: return "bfk_ia32_pminub256";
            case 2174L: return "bfk_ia32_pminub256_mask";
            case 2175L: return "bfk_ia32_pminub512_mask";
            case 2176L: return "bfk_ia32_pminud128";
            case 2177L: return "bfk_ia32_pminud128_mask";
            case 2178L: return "bfk_ia32_pminud256";
            case 2179L: return "bfk_ia32_pminud256_mask";
            case 2180L: return "bfk_ia32_pminud512_mask";
            case 2181L: return "bfk_ia32_pminuq128_mask";
            case 2182L: return "bfk_ia32_pminuq256_mask";
            case 2183L: return "bfk_ia32_pminuq512_mask";
            case 2184L: return "bfk_ia32_pminuw128";
            case 2185L: return "bfk_ia32_pminuw128_mask";
            case 2186L: return "bfk_ia32_pminuw256";
            case 2187L: return "bfk_ia32_pminuw256_mask";
            case 2188L: return "bfk_ia32_pminuw512_mask";
            case 2189L: return "bfk_ia32_pmovdb128_mask";
            case 2190L: return "bfk_ia32_pmovdb128mem_mask";
            case 2191L: return "bfk_ia32_pmovdb256_mask";
            case 2192L: return "bfk_ia32_pmovdb256mem_mask";
            case 2193L: return "bfk_ia32_pmovdb512_mask";
            case 2194L: return "bfk_ia32_pmovdb512mem_mask";
            case 2195L: return "bfk_ia32_pmovdw128_mask";
            case 2196L: return "bfk_ia32_pmovdw128mem_mask";
            case 2197L: return "bfk_ia32_pmovdw256_mask";
            case 2198L: return "bfk_ia32_pmovdw256mem_mask";
            case 2199L: return "bfk_ia32_pmovdw512_mask";
            case 2200L: return "bfk_ia32_pmovdw512mem_mask";
            case 2201L: return "bfk_ia32_pmovmskb";
            case 2202L: return "bfk_ia32_pmovmskb128";
            case 2203L: return "bfk_ia32_pmovmskb256";
            case 2204L: return "bfk_ia32_pmovqb128_mask";
            case 2205L: return "bfk_ia32_pmovqb128mem_mask";
            case 2206L: return "bfk_ia32_pmovqb256_mask";
            case 2207L: return "bfk_ia32_pmovqb256mem_mask";
            case 2208L: return "bfk_ia32_pmovqb512_mask";
            case 2209L: return "bfk_ia32_pmovqb512mem_mask";
            case 2210L: return "bfk_ia32_pmovqd128_mask";
            case 2211L: return "bfk_ia32_pmovqd128mem_mask";
            case 2212L: return "bfk_ia32_pmovqd256_mask";
            case 2213L: return "bfk_ia32_pmovqd256mem_mask";
            case 2214L: return "bfk_ia32_pmovqd512_mask";
            case 2215L: return "bfk_ia32_pmovqd512mem_mask";
            case 2216L: return "bfk_ia32_pmovqw128_mask";
            case 2217L: return "bfk_ia32_pmovqw128mem_mask";
            case 2218L: return "bfk_ia32_pmovqw256_mask";
            case 2219L: return "bfk_ia32_pmovqw256mem_mask";
            case 2220L: return "bfk_ia32_pmovqw512_mask";
            case 2221L: return "bfk_ia32_pmovqw512mem_mask";
            case 2222L: return "bfk_ia32_pmovsdb128_mask";
            case 2223L: return "bfk_ia32_pmovsdb128mem_mask";
            case 2224L: return "bfk_ia32_pmovsdb256_mask";
            case 2225L: return "bfk_ia32_pmovsdb256mem_mask";
            case 2226L: return "bfk_ia32_pmovsdb512_mask";
            case 2227L: return "bfk_ia32_pmovsdb512mem_mask";
            case 2228L: return "bfk_ia32_pmovsdw128_mask";
            case 2229L: return "bfk_ia32_pmovsdw128mem_mask";
            case 2230L: return "bfk_ia32_pmovsdw256_mask";
            case 2231L: return "bfk_ia32_pmovsdw256mem_mask";
            case 2232L: return "bfk_ia32_pmovsdw512_mask";
            case 2233L: return "bfk_ia32_pmovsdw512mem_mask";
            case 2234L: return "bfk_ia32_pmovsqb128_mask";
            case 2235L: return "bfk_ia32_pmovsqb128mem_mask";
            case 2236L: return "bfk_ia32_pmovsqb256_mask";
            case 2237L: return "bfk_ia32_pmovsqb256mem_mask";
            case 2238L: return "bfk_ia32_pmovsqb512_mask";
            case 2239L: return "bfk_ia32_pmovsqb512mem_mask";
            case 2240L: return "bfk_ia32_pmovsqd128_mask";
            case 2241L: return "bfk_ia32_pmovsqd128mem_mask";
            case 2242L: return "bfk_ia32_pmovsqd256_mask";
            case 2243L: return "bfk_ia32_pmovsqd256mem_mask";
            case 2244L: return "bfk_ia32_pmovsqd512_mask";
            case 2245L: return "bfk_ia32_pmovsqd512mem_mask";
            case 2246L: return "bfk_ia32_pmovsqw128_mask";
            case 2247L: return "bfk_ia32_pmovsqw128mem_mask";
            case 2248L: return "bfk_ia32_pmovsqw256_mask";
            case 2249L: return "bfk_ia32_pmovsqw256mem_mask";
            case 2250L: return "bfk_ia32_pmovsqw512_mask";
            case 2251L: return "bfk_ia32_pmovsqw512mem_mask";
            case 2252L: return "bfk_ia32_pmovswb128_mask";
            case 2253L: return "bfk_ia32_pmovswb128mem_mask";
            case 2254L: return "bfk_ia32_pmovswb256_mask";
            case 2255L: return "bfk_ia32_pmovswb256mem_mask";
            case 2256L: return "bfk_ia32_pmovswb512_mask";
            case 2257L: return "bfk_ia32_pmovswb512mem_mask";
            case 2258L: return "bfk_ia32_pmovsxbd128";
            case 2259L: return "bfk_ia32_pmovsxbd128_mask";
            case 2260L: return "bfk_ia32_pmovsxbd256";
            case 2261L: return "bfk_ia32_pmovsxbd256_mask";
            case 2262L: return "bfk_ia32_pmovsxbd512_mask";
            case 2263L: return "bfk_ia32_pmovsxbq128";
            case 2264L: return "bfk_ia32_pmovsxbq128_mask";
            case 2265L: return "bfk_ia32_pmovsxbq256";
            case 2266L: return "bfk_ia32_pmovsxbq256_mask";
            case 2267L: return "bfk_ia32_pmovsxbq512_mask";
            case 2268L: return "bfk_ia32_pmovsxbw128";
            case 2269L: return "bfk_ia32_pmovsxbw128_mask";
            case 2270L: return "bfk_ia32_pmovsxbw256";
            case 2271L: return "bfk_ia32_pmovsxbw256_mask";
            case 2272L: return "bfk_ia32_pmovsxbw512_mask";
            case 2273L: return "bfk_ia32_pmovsxdq128";
            case 2274L: return "bfk_ia32_pmovsxdq128_mask";
            case 2275L: return "bfk_ia32_pmovsxdq256";
            case 2276L: return "bfk_ia32_pmovsxdq256_mask";
            case 2277L: return "bfk_ia32_pmovsxdq512_mask";
            case 2278L: return "bfk_ia32_pmovsxwd128";
            case 2279L: return "bfk_ia32_pmovsxwd128_mask";
            case 2280L: return "bfk_ia32_pmovsxwd256";
            case 2281L: return "bfk_ia32_pmovsxwd256_mask";
            case 2282L: return "bfk_ia32_pmovsxwd512_mask";
            case 2283L: return "bfk_ia32_pmovsxwq128";
            case 2284L: return "bfk_ia32_pmovsxwq128_mask";
            case 2285L: return "bfk_ia32_pmovsxwq256";
            case 2286L: return "bfk_ia32_pmovsxwq256_mask";
            case 2287L: return "bfk_ia32_pmovsxwq512_mask";
            case 2288L: return "bfk_ia32_pmovusdb128_mask";
            case 2289L: return "bfk_ia32_pmovusdb128mem_mask";
            case 2290L: return "bfk_ia32_pmovusdb256_mask";
            case 2291L: return "bfk_ia32_pmovusdb256mem_mask";
            case 2292L: return "bfk_ia32_pmovusdb512_mask";
            case 2293L: return "bfk_ia32_pmovusdb512mem_mask";
            case 2294L: return "bfk_ia32_pmovusdw128_mask";
            case 2295L: return "bfk_ia32_pmovusdw128mem_mask";
            case 2296L: return "bfk_ia32_pmovusdw256_mask";
            case 2297L: return "bfk_ia32_pmovusdw256mem_mask";
            case 2298L: return "bfk_ia32_pmovusdw512_mask";
            case 2299L: return "bfk_ia32_pmovusdw512mem_mask";
            case 2300L: return "bfk_ia32_pmovusqb128_mask";
            case 2301L: return "bfk_ia32_pmovusqb128mem_mask";
            case 2302L: return "bfk_ia32_pmovusqb256_mask";
            case 2303L: return "bfk_ia32_pmovusqb256mem_mask";
            case 2304L: return "bfk_ia32_pmovusqb512_mask";
            case 2305L: return "bfk_ia32_pmovusqb512mem_mask";
            case 2306L: return "bfk_ia32_pmovusqd128_mask";
            case 2307L: return "bfk_ia32_pmovusqd128mem_mask";
            case 2308L: return "bfk_ia32_pmovusqd256_mask";
            case 2309L: return "bfk_ia32_pmovusqd256mem_mask";
            case 2310L: return "bfk_ia32_pmovusqd512_mask";
            case 2311L: return "bfk_ia32_pmovusqd512mem_mask";
            case 2312L: return "bfk_ia32_pmovusqw128_mask";
            case 2313L: return "bfk_ia32_pmovusqw128mem_mask";
            case 2314L: return "bfk_ia32_pmovusqw256_mask";
            case 2315L: return "bfk_ia32_pmovusqw256mem_mask";
            case 2316L: return "bfk_ia32_pmovusqw512_mask";
            case 2317L: return "bfk_ia32_pmovusqw512mem_mask";
            case 2318L: return "bfk_ia32_pmovuswb128_mask";
            case 2319L: return "bfk_ia32_pmovuswb128mem_mask";
            case 2320L: return "bfk_ia32_pmovuswb256_mask";
            case 2321L: return "bfk_ia32_pmovuswb256mem_mask";
            case 2322L: return "bfk_ia32_pmovuswb512_mask";
            case 2323L: return "bfk_ia32_pmovuswb512mem_mask";
            case 2324L: return "bfk_ia32_pmovwb128_mask";
            case 2325L: return "bfk_ia32_pmovwb128mem_mask";
            case 2326L: return "bfk_ia32_pmovwb256_mask";
            case 2327L: return "bfk_ia32_pmovwb256mem_mask";
            case 2328L: return "bfk_ia32_pmovwb512_mask";
            case 2329L: return "bfk_ia32_pmovwb512mem_mask";
            case 2330L: return "bfk_ia32_pmovzxbd128";
            case 2331L: return "bfk_ia32_pmovzxbd128_mask";
            case 2332L: return "bfk_ia32_pmovzxbd256";
            case 2333L: return "bfk_ia32_pmovzxbd256_mask";
            case 2334L: return "bfk_ia32_pmovzxbd512_mask";
            case 2335L: return "bfk_ia32_pmovzxbq128";
            case 2336L: return "bfk_ia32_pmovzxbq128_mask";
            case 2337L: return "bfk_ia32_pmovzxbq256";
            case 2338L: return "bfk_ia32_pmovzxbq256_mask";
            case 2339L: return "bfk_ia32_pmovzxbq512_mask";
            case 2340L: return "bfk_ia32_pmovzxbw128";
            case 2341L: return "bfk_ia32_pmovzxbw128_mask";
            case 2342L: return "bfk_ia32_pmovzxbw256";
            case 2343L: return "bfk_ia32_pmovzxbw256_mask";
            case 2344L: return "bfk_ia32_pmovzxbw512_mask";
            case 2345L: return "bfk_ia32_pmovzxdq128";
            case 2346L: return "bfk_ia32_pmovzxdq128_mask";
            case 2347L: return "bfk_ia32_pmovzxdq256";
            case 2348L: return "bfk_ia32_pmovzxdq256_mask";
            case 2349L: return "bfk_ia32_pmovzxdq512_mask";
            case 2350L: return "bfk_ia32_pmovzxwd128";
            case 2351L: return "bfk_ia32_pmovzxwd128_mask";
            case 2352L: return "bfk_ia32_pmovzxwd256";
            case 2353L: return "bfk_ia32_pmovzxwd256_mask";
            case 2354L: return "bfk_ia32_pmovzxwd512_mask";
            case 2355L: return "bfk_ia32_pmovzxwq128";
            case 2356L: return "bfk_ia32_pmovzxwq128_mask";
            case 2357L: return "bfk_ia32_pmovzxwq256";
            case 2358L: return "bfk_ia32_pmovzxwq256_mask";
            case 2359L: return "bfk_ia32_pmovzxwq512_mask";
            case 2360L: return "bfk_ia32_pmuldq128";
            case 2361L: return "bfk_ia32_pmuldq128_mask";
            case 2362L: return "bfk_ia32_pmuldq256";
            case 2363L: return "bfk_ia32_pmuldq256_mask";
            case 2364L: return "bfk_ia32_pmuldq512";
            case 2365L: return "bfk_ia32_pmuldq512_mask";
            case 2366L: return "bfk_ia32_pmulhrsw";
            case 2367L: return "bfk_ia32_pmulhrsw128";
            case 2368L: return "bfk_ia32_pmulhrsw128_mask";
            case 2369L: return "bfk_ia32_pmulhrsw256";
            case 2370L: return "bfk_ia32_pmulhrsw256_mask";
            case 2371L: return "bfk_ia32_pmulhrsw512_mask";
            case 2372L: return "bfk_ia32_pmulhrw";
            case 2373L: return "bfk_ia32_pmulhuw";
            case 2374L: return "bfk_ia32_pmulhuw128";
            case 2375L: return "bfk_ia32_pmulhuw128_mask";
            case 2376L: return "bfk_ia32_pmulhuw256";
            case 2377L: return "bfk_ia32_pmulhuw256_mask";
            case 2378L: return "bfk_ia32_pmulhuw512_mask";
            case 2379L: return "bfk_ia32_pmulhw";
            case 2380L: return "bfk_ia32_pmulhw128";
            case 2381L: return "bfk_ia32_pmulhw128_mask";
            case 2382L: return "bfk_ia32_pmulhw256";
            case 2383L: return "bfk_ia32_pmulhw256_mask";
            case 2384L: return "bfk_ia32_pmulhw512_mask";
            case 2385L: return "bfk_ia32_pmulld128";
            case 2386L: return "bfk_ia32_pmulld128_mask";
            case 2387L: return "bfk_ia32_pmulld256";
            case 2388L: return "bfk_ia32_pmulld256_mask";
            case 2389L: return "bfk_ia32_pmulld512_mask";
            case 2390L: return "bfk_ia32_pmullq128_mask";
            case 2391L: return "bfk_ia32_pmullq256_mask";
            case 2392L: return "bfk_ia32_pmullq512_mask";
            case 2393L: return "bfk_ia32_pmullw";
            case 2394L: return "bfk_ia32_pmullw128";
            case 2395L: return "bfk_ia32_pmullw128_mask";
            case 2396L: return "bfk_ia32_pmullw256";
            case 2397L: return "bfk_ia32_pmullw256_mask";
            case 2398L: return "bfk_ia32_pmullw512_mask";
            case 2399L: return "bfk_ia32_pmuludq";
            case 2400L: return "bfk_ia32_pmuludq128";
            case 2401L: return "bfk_ia32_pmuludq128_mask";
            case 2402L: return "bfk_ia32_pmuludq256";
            case 2403L: return "bfk_ia32_pmuludq256_mask";
            case 2404L: return "bfk_ia32_pmuludq512";
            case 2405L: return "bfk_ia32_pmuludq512_mask";
            case 2406L: return "bfk_ia32_por";
            case 2407L: return "bfk_ia32_por128";
            case 2408L: return "bfk_ia32_por256";
            case 2409L: return "bfk_ia32_pord128_mask";
            case 2410L: return "bfk_ia32_pord256_mask";
            case 2411L: return "bfk_ia32_pord512_mask";
            case 2412L: return "bfk_ia32_porq128_mask";
            case 2413L: return "bfk_ia32_porq256_mask";
            case 2414L: return "bfk_ia32_porq512_mask";
            case 2415L: return "bfk_ia32_pperm";
            case 2416L: return "bfk_ia32_prold128_mask";
            case 2417L: return "bfk_ia32_prold256_mask";
            case 2418L: return "bfk_ia32_prold512_mask";
            case 2419L: return "bfk_ia32_prolq128_mask";
            case 2420L: return "bfk_ia32_prolq256_mask";
            case 2421L: return "bfk_ia32_prolq512_mask";
            case 2422L: return "bfk_ia32_prolvd128_mask";
            case 2423L: return "bfk_ia32_prolvd256_mask";
            case 2424L: return "bfk_ia32_prolvd512_mask";
            case 2425L: return "bfk_ia32_prolvq128_mask";
            case 2426L: return "bfk_ia32_prolvq256_mask";
            case 2427L: return "bfk_ia32_prolvq512_mask";
            case 2428L: return "bfk_ia32_prord128_mask";
            case 2429L: return "bfk_ia32_prord256_mask";
            case 2430L: return "bfk_ia32_prord512_mask";
            case 2431L: return "bfk_ia32_prorq128_mask";
            case 2432L: return "bfk_ia32_prorq256_mask";
            case 2433L: return "bfk_ia32_prorq512_mask";
            case 2434L: return "bfk_ia32_prorvd128_mask";
            case 2435L: return "bfk_ia32_prorvd256_mask";
            case 2436L: return "bfk_ia32_prorvd512_mask";
            case 2437L: return "bfk_ia32_prorvq128_mask";
            case 2438L: return "bfk_ia32_prorvq256_mask";
            case 2439L: return "bfk_ia32_prorvq512_mask";
            case 2440L: return "bfk_ia32_protb";
            case 2441L: return "bfk_ia32_protd";
            case 2442L: return "bfk_ia32_protq";
            case 2443L: return "bfk_ia32_protw";
            case 2444L: return "bfk_ia32_ps256_ps";
            case 2445L: return "bfk_ia32_ps512_256ps";
            case 2446L: return "bfk_ia32_ps512_ps";
            case 2447L: return "bfk_ia32_ps_ps256";
            case 2448L: return "bfk_ia32_psadbw";
            case 2449L: return "bfk_ia32_psadbw128";
            case 2450L: return "bfk_ia32_psadbw256";
            case 2451L: return "bfk_ia32_psadbw512";
            case 2452L: return "bfk_ia32_pshab";
            case 2453L: return "bfk_ia32_pshad";
            case 2454L: return "bfk_ia32_pshaq";
            case 2455L: return "bfk_ia32_pshaw";
            case 2456L: return "bfk_ia32_pshlb";
            case 2457L: return "bfk_ia32_pshld";
            case 2458L: return "bfk_ia32_pshlq";
            case 2459L: return "bfk_ia32_pshlw";
            case 2460L: return "bfk_ia32_pshufb";
            case 2461L: return "bfk_ia32_pshufb128";
            case 2462L: return "bfk_ia32_pshufb128_mask";
            case 2463L: return "bfk_ia32_pshufb256";
            case 2464L: return "bfk_ia32_pshufb256_mask";
            case 2465L: return "bfk_ia32_pshufb512";
            case 2466L: return "bfk_ia32_pshufb512_mask";
            case 2467L: return "bfk_ia32_pshufd";
            case 2468L: return "bfk_ia32_pshufd128_mask";
            case 2469L: return "bfk_ia32_pshufd256";
            case 2470L: return "bfk_ia32_pshufd256_mask";
            case 2471L: return "bfk_ia32_pshufd512_mask";
            case 2472L: return "bfk_ia32_pshufhw";
            case 2473L: return "bfk_ia32_pshufhw128_mask";
            case 2474L: return "bfk_ia32_pshufhw256";
            case 2475L: return "bfk_ia32_pshufhw256_mask";
            case 2476L: return "bfk_ia32_pshufhw512_mask";
            case 2477L: return "bfk_ia32_pshuflw";
            case 2478L: return "bfk_ia32_pshuflw128_mask";
            case 2479L: return "bfk_ia32_pshuflw256";
            case 2480L: return "bfk_ia32_pshuflw256_mask";
            case 2481L: return "bfk_ia32_pshuflw512_mask";
            case 2482L: return "bfk_ia32_pshufw";
            case 2483L: return "bfk_ia32_psignb";
            case 2484L: return "bfk_ia32_psignb128";
            case 2485L: return "bfk_ia32_psignb256";
            case 2486L: return "bfk_ia32_psignd";
            case 2487L: return "bfk_ia32_psignd128";
            case 2488L: return "bfk_ia32_psignd256";
            case 2489L: return "bfk_ia32_psignw";
            case 2490L: return "bfk_ia32_psignw128";
            case 2491L: return "bfk_ia32_psignw256";
            case 2492L: return "bfk_ia32_pslld";
            case 2493L: return "bfk_ia32_pslld128";
            case 2494L: return "bfk_ia32_pslld128_mask";
            case 2495L: return "bfk_ia32_pslld256";
            case 2496L: return "bfk_ia32_pslld256_mask";
            case 2497L: return "bfk_ia32_pslld512";
            case 2498L: return "bfk_ia32_pslld512_mask";
            case 2499L: return "bfk_ia32_pslldi";
            case 2500L: return "bfk_ia32_pslldi128";
            case 2501L: return "bfk_ia32_pslldi128_mask";
            case 2502L: return "bfk_ia32_pslldi256";
            case 2503L: return "bfk_ia32_pslldi256_mask";
            case 2504L: return "bfk_ia32_pslldi512";
            case 2505L: return "bfk_ia32_pslldi512_mask";
            case 2506L: return "bfk_ia32_pslldq512";
            case 2507L: return "bfk_ia32_pslldqi128";
            case 2508L: return "bfk_ia32_pslldqi256";
            case 2509L: return "bfk_ia32_psllq";
            case 2510L: return "bfk_ia32_psllq128";
            case 2511L: return "bfk_ia32_psllq128_mask";
            case 2512L: return "bfk_ia32_psllq256";
            case 2513L: return "bfk_ia32_psllq256_mask";
            case 2514L: return "bfk_ia32_psllq512";
            case 2515L: return "bfk_ia32_psllq512_mask";
            case 2516L: return "bfk_ia32_psllqi";
            case 2517L: return "bfk_ia32_psllqi128";
            case 2518L: return "bfk_ia32_psllqi128_mask";
            case 2519L: return "bfk_ia32_psllqi256";
            case 2520L: return "bfk_ia32_psllqi256_mask";
            case 2521L: return "bfk_ia32_psllqi512";
            case 2522L: return "bfk_ia32_psllqi512_mask";
            case 2523L: return "bfk_ia32_psllv16hi";
            case 2524L: return "bfk_ia32_psllv16hi_mask";
            case 2525L: return "bfk_ia32_psllv16si";
            case 2526L: return "bfk_ia32_psllv16si_mask";
            case 2527L: return "bfk_ia32_psllv2di";
            case 2528L: return "bfk_ia32_psllv2di_mask";
            case 2529L: return "bfk_ia32_psllv32hi";
            case 2530L: return "bfk_ia32_psllv32hi_mask";
            case 2531L: return "bfk_ia32_psllv4di";
            case 2532L: return "bfk_ia32_psllv4di_mask";
            case 2533L: return "bfk_ia32_psllv4si";
            case 2534L: return "bfk_ia32_psllv4si_mask";
            case 2535L: return "bfk_ia32_psllv8di";
            case 2536L: return "bfk_ia32_psllv8di_mask";
            case 2537L: return "bfk_ia32_psllv8hi";
            case 2538L: return "bfk_ia32_psllv8hi_mask";
            case 2539L: return "bfk_ia32_psllv8si";
            case 2540L: return "bfk_ia32_psllv8si_mask";
            case 2541L: return "bfk_ia32_psllw";
            case 2542L: return "bfk_ia32_psllw128";
            case 2543L: return "bfk_ia32_psllw128_mask";
            case 2544L: return "bfk_ia32_psllw256";
            case 2545L: return "bfk_ia32_psllw256_mask";
            case 2546L: return "bfk_ia32_psllw512";
            case 2547L: return "bfk_ia32_psllw512_mask";
            case 2548L: return "bfk_ia32_psllwi";
            case 2549L: return "bfk_ia32_psllwi128";
            case 2550L: return "bfk_ia32_psllwi128_mask";
            case 2551L: return "bfk_ia32_psllwi256";
            case 2552L: return "bfk_ia32_psllwi256_mask";
            case 2553L: return "bfk_ia32_psllwi512";
            case 2554L: return "bfk_ia32_psllwi512_mask";
            case 2555L: return "bfk_ia32_psrad";
            case 2556L: return "bfk_ia32_psrad128";
            case 2557L: return "bfk_ia32_psrad128_mask";
            case 2558L: return "bfk_ia32_psrad256";
            case 2559L: return "bfk_ia32_psrad256_mask";
            case 2560L: return "bfk_ia32_psrad512";
            case 2561L: return "bfk_ia32_psrad512_mask";
            case 2562L: return "bfk_ia32_psradi";
            case 2563L: return "bfk_ia32_psradi128";
            case 2564L: return "bfk_ia32_psradi128_mask";
            case 2565L: return "bfk_ia32_psradi256";
            case 2566L: return "bfk_ia32_psradi256_mask";
            case 2567L: return "bfk_ia32_psradi512";
            case 2568L: return "bfk_ia32_psradi512_mask";
            case 2569L: return "bfk_ia32_psraq128";
            case 2570L: return "bfk_ia32_psraq128_mask";
            case 2571L: return "bfk_ia32_psraq256";
            case 2572L: return "bfk_ia32_psraq256_mask";
            case 2573L: return "bfk_ia32_psraq512";
            case 2574L: return "bfk_ia32_psraq512_mask";
            case 2575L: return "bfk_ia32_psraqi128";
            case 2576L: return "bfk_ia32_psraqi128_mask";
            case 2577L: return "bfk_ia32_psraqi256";
            case 2578L: return "bfk_ia32_psraqi256_mask";
            case 2579L: return "bfk_ia32_psraqi512";
            case 2580L: return "bfk_ia32_psraqi512_mask";
            case 2581L: return "bfk_ia32_psrav16hi";
            case 2582L: return "bfk_ia32_psrav16hi_mask";
            case 2583L: return "bfk_ia32_psrav16si";
            case 2584L: return "bfk_ia32_psrav16si_mask";
            case 2585L: return "bfk_ia32_psrav32hi";
            case 2586L: return "bfk_ia32_psrav32hi_mask";
            case 2587L: return "bfk_ia32_psrav4si";
            case 2588L: return "bfk_ia32_psrav4si_mask";
            case 2589L: return "bfk_ia32_psrav8di";
            case 2590L: return "bfk_ia32_psrav8di_mask";
            case 2591L: return "bfk_ia32_psrav8hi";
            case 2592L: return "bfk_ia32_psrav8hi_mask";
            case 2593L: return "bfk_ia32_psrav8si";
            case 2594L: return "bfk_ia32_psrav8si_mask";
            case 2595L: return "bfk_ia32_psravq128";
            case 2596L: return "bfk_ia32_psravq128_mask";
            case 2597L: return "bfk_ia32_psravq256";
            case 2598L: return "bfk_ia32_psravq256_mask";
            case 2599L: return "bfk_ia32_psraw";
            case 2600L: return "bfk_ia32_psraw128";
            case 2601L: return "bfk_ia32_psraw128_mask";
            case 2602L: return "bfk_ia32_psraw256";
            case 2603L: return "bfk_ia32_psraw256_mask";
            case 2604L: return "bfk_ia32_psraw512";
            case 2605L: return "bfk_ia32_psraw512_mask";
            case 2606L: return "bfk_ia32_psrawi";
            case 2607L: return "bfk_ia32_psrawi128";
            case 2608L: return "bfk_ia32_psrawi128_mask";
            case 2609L: return "bfk_ia32_psrawi256";
            case 2610L: return "bfk_ia32_psrawi256_mask";
            case 2611L: return "bfk_ia32_psrawi512";
            case 2612L: return "bfk_ia32_psrawi512_mask";
            case 2613L: return "bfk_ia32_psrld";
            case 2614L: return "bfk_ia32_psrld128";
            case 2615L: return "bfk_ia32_psrld128_mask";
            case 2616L: return "bfk_ia32_psrld256";
            case 2617L: return "bfk_ia32_psrld256_mask";
            case 2618L: return "bfk_ia32_psrld512";
            case 2619L: return "bfk_ia32_psrld512_mask";
            case 2620L: return "bfk_ia32_psrldi";
            case 2621L: return "bfk_ia32_psrldi128";
            case 2622L: return "bfk_ia32_psrldi128_mask";
            case 2623L: return "bfk_ia32_psrldi256";
            case 2624L: return "bfk_ia32_psrldi256_mask";
            case 2625L: return "bfk_ia32_psrldi512";
            case 2626L: return "bfk_ia32_psrldi512_mask";
            case 2627L: return "bfk_ia32_psrldq512";
            case 2628L: return "bfk_ia32_psrldqi128";
            case 2629L: return "bfk_ia32_psrldqi256";
            case 2630L: return "bfk_ia32_psrlq";
            case 2631L: return "bfk_ia32_psrlq128";
            case 2632L: return "bfk_ia32_psrlq128_mask";
            case 2633L: return "bfk_ia32_psrlq256";
            case 2634L: return "bfk_ia32_psrlq256_mask";
            case 2635L: return "bfk_ia32_psrlq512";
            case 2636L: return "bfk_ia32_psrlq512_mask";
            case 2637L: return "bfk_ia32_psrlqi";
            case 2638L: return "bfk_ia32_psrlqi128";
            case 2639L: return "bfk_ia32_psrlqi128_mask";
            case 2640L: return "bfk_ia32_psrlqi256";
            case 2641L: return "bfk_ia32_psrlqi256_mask";
            case 2642L: return "bfk_ia32_psrlqi512";
            case 2643L: return "bfk_ia32_psrlqi512_mask";
            case 2644L: return "bfk_ia32_psrlv16hi";
            case 2645L: return "bfk_ia32_psrlv16hi_mask";
            case 2646L: return "bfk_ia32_psrlv16si";
            case 2647L: return "bfk_ia32_psrlv16si_mask";
            case 2648L: return "bfk_ia32_psrlv2di";
            case 2649L: return "bfk_ia32_psrlv2di_mask";
            case 2650L: return "bfk_ia32_psrlv32hi";
            case 2651L: return "bfk_ia32_psrlv32hi_mask";
            case 2652L: return "bfk_ia32_psrlv4di";
            case 2653L: return "bfk_ia32_psrlv4di_mask";
            case 2654L: return "bfk_ia32_psrlv4si";
            case 2655L: return "bfk_ia32_psrlv4si_mask";
            case 2656L: return "bfk_ia32_psrlv8di";
            case 2657L: return "bfk_ia32_psrlv8di_mask";
            case 2658L: return "bfk_ia32_psrlv8hi";
            case 2659L: return "bfk_ia32_psrlv8hi_mask";
            case 2660L: return "bfk_ia32_psrlv8si";
            case 2661L: return "bfk_ia32_psrlv8si_mask";
            case 2662L: return "bfk_ia32_psrlw";
            case 2663L: return "bfk_ia32_psrlw128";
            case 2664L: return "bfk_ia32_psrlw128_mask";
            case 2665L: return "bfk_ia32_psrlw256";
            case 2666L: return "bfk_ia32_psrlw256_mask";
            case 2667L: return "bfk_ia32_psrlw512";
            case 2668L: return "bfk_ia32_psrlw512_mask";
            case 2669L: return "bfk_ia32_psrlwi";
            case 2670L: return "bfk_ia32_psrlwi128";
            case 2671L: return "bfk_ia32_psrlwi128_mask";
            case 2672L: return "bfk_ia32_psrlwi256";
            case 2673L: return "bfk_ia32_psrlwi256_mask";
            case 2674L: return "bfk_ia32_psrlwi512";
            case 2675L: return "bfk_ia32_psrlwi512_mask";
            case 2676L: return "bfk_ia32_psubb";
            case 2677L: return "bfk_ia32_psubb128";
            case 2678L: return "bfk_ia32_psubb128_mask";
            case 2679L: return "bfk_ia32_psubb256";
            case 2680L: return "bfk_ia32_psubb256_mask";
            case 2681L: return "bfk_ia32_psubb512_mask";
            case 2682L: return "bfk_ia32_psubd";
            case 2683L: return "bfk_ia32_psubd128";
            case 2684L: return "bfk_ia32_psubd128_mask";
            case 2685L: return "bfk_ia32_psubd256";
            case 2686L: return "bfk_ia32_psubd256_mask";
            case 2687L: return "bfk_ia32_psubd512_mask";
            case 2688L: return "bfk_ia32_psubq";
            case 2689L: return "bfk_ia32_psubq128";
            case 2690L: return "bfk_ia32_psubq128_mask";
            case 2691L: return "bfk_ia32_psubq256";
            case 2692L: return "bfk_ia32_psubq256_mask";
            case 2693L: return "bfk_ia32_psubq512_mask";
            case 2694L: return "bfk_ia32_psubsb";
            case 2695L: return "bfk_ia32_psubsb128";
            case 2696L: return "bfk_ia32_psubsb128_mask";
            case 2697L: return "bfk_ia32_psubsb256";
            case 2698L: return "bfk_ia32_psubsb256_mask";
            case 2699L: return "bfk_ia32_psubsb512_mask";
            case 2700L: return "bfk_ia32_psubsw";
            case 2701L: return "bfk_ia32_psubsw128";
            case 2702L: return "bfk_ia32_psubsw128_mask";
            case 2703L: return "bfk_ia32_psubsw256";
            case 2704L: return "bfk_ia32_psubsw256_mask";
            case 2705L: return "bfk_ia32_psubsw512_mask";
            case 2706L: return "bfk_ia32_psubusb";
            case 2707L: return "bfk_ia32_psubusb128";
            case 2708L: return "bfk_ia32_psubusb128_mask";
            case 2709L: return "bfk_ia32_psubusb256";
            case 2710L: return "bfk_ia32_psubusb256_mask";
            case 2711L: return "bfk_ia32_psubusb512_mask";
            case 2712L: return "bfk_ia32_psubusw";
            case 2713L: return "bfk_ia32_psubusw128";
            case 2714L: return "bfk_ia32_psubusw128_mask";
            case 2715L: return "bfk_ia32_psubusw256";
            case 2716L: return "bfk_ia32_psubusw256_mask";
            case 2717L: return "bfk_ia32_psubusw512_mask";
            case 2718L: return "bfk_ia32_psubw";
            case 2719L: return "bfk_ia32_psubw128";
            case 2720L: return "bfk_ia32_psubw128_mask";
            case 2721L: return "bfk_ia32_psubw256";
            case 2722L: return "bfk_ia32_psubw256_mask";
            case 2723L: return "bfk_ia32_psubw512_mask";
            case 2724L: return "bfk_ia32_pswapdsf";
            case 2725L: return "bfk_ia32_pswapdsi";
            case 2726L: return "bfk_ia32_pternlogd128_mask";
            case 2727L: return "bfk_ia32_pternlogd128_maskz";
            case 2728L: return "bfk_ia32_pternlogd256_mask";
            case 2729L: return "bfk_ia32_pternlogd256_maskz";
            case 2730L: return "bfk_ia32_pternlogd512_mask";
            case 2731L: return "bfk_ia32_pternlogd512_maskz";
            case 2732L: return "bfk_ia32_pternlogq128_mask";
            case 2733L: return "bfk_ia32_pternlogq128_maskz";
            case 2734L: return "bfk_ia32_pternlogq256_mask";
            case 2735L: return "bfk_ia32_pternlogq256_maskz";
            case 2736L: return "bfk_ia32_pternlogq512_mask";
            case 2737L: return "bfk_ia32_pternlogq512_maskz";
            case 2738L: return "bfk_ia32_ptestc128";
            case 2739L: return "bfk_ia32_ptestc256";
            case 2740L: return "bfk_ia32_ptestmb128";
            case 2741L: return "bfk_ia32_ptestmb256";
            case 2742L: return "bfk_ia32_ptestmb512";
            case 2743L: return "bfk_ia32_ptestmd128";
            case 2744L: return "bfk_ia32_ptestmd256";
            case 2745L: return "bfk_ia32_ptestmd512";
            case 2746L: return "bfk_ia32_ptestmq128";
            case 2747L: return "bfk_ia32_ptestmq256";
            case 2748L: return "bfk_ia32_ptestmq512";
            case 2749L: return "bfk_ia32_ptestmw128";
            case 2750L: return "bfk_ia32_ptestmw256";
            case 2751L: return "bfk_ia32_ptestmw512";
            case 2752L: return "bfk_ia32_ptestnmb128";
            case 2753L: return "bfk_ia32_ptestnmb256";
            case 2754L: return "bfk_ia32_ptestnmb512";
            case 2755L: return "bfk_ia32_ptestnmd128";
            case 2756L: return "bfk_ia32_ptestnmd256";
            case 2757L: return "bfk_ia32_ptestnmd512";
            case 2758L: return "bfk_ia32_ptestnmq128";
            case 2759L: return "bfk_ia32_ptestnmq256";
            case 2760L: return "bfk_ia32_ptestnmq512";
            case 2761L: return "bfk_ia32_ptestnmw128";
            case 2762L: return "bfk_ia32_ptestnmw256";
            case 2763L: return "bfk_ia32_ptestnmw512";
            case 2764L: return "bfk_ia32_ptestnzc128";
            case 2765L: return "bfk_ia32_ptestnzc256";
            case 2766L: return "bfk_ia32_ptestz128";
            case 2767L: return "bfk_ia32_ptestz256";
            case 2768L: return "bfk_ia32_punpckhbw";
            case 2769L: return "bfk_ia32_punpckhbw128";
            case 2770L: return "bfk_ia32_punpckhbw128_mask";
            case 2771L: return "bfk_ia32_punpckhbw256";
            case 2772L: return "bfk_ia32_punpckhbw256_mask";
            case 2773L: return "bfk_ia32_punpckhbw512_mask";
            case 2774L: return "bfk_ia32_punpckhdq";
            case 2775L: return "bfk_ia32_punpckhdq128";
            case 2776L: return "bfk_ia32_punpckhdq128_mask";
            case 2777L: return "bfk_ia32_punpckhdq256";
            case 2778L: return "bfk_ia32_punpckhdq256_mask";
            case 2779L: return "bfk_ia32_punpckhdq512_mask";
            case 2780L: return "bfk_ia32_punpckhqdq128";
            case 2781L: return "bfk_ia32_punpckhqdq128_mask";
            case 2782L: return "bfk_ia32_punpckhqdq256";
            case 2783L: return "bfk_ia32_punpckhqdq256_mask";
            case 2784L: return "bfk_ia32_punpckhqdq512_mask";
            case 2785L: return "bfk_ia32_punpckhwd";
            case 2786L: return "bfk_ia32_punpckhwd128";
            case 2787L: return "bfk_ia32_punpckhwd128_mask";
            case 2788L: return "bfk_ia32_punpckhwd256";
            case 2789L: return "bfk_ia32_punpckhwd256_mask";
            case 2790L: return "bfk_ia32_punpckhwd512_mask";
            case 2791L: return "bfk_ia32_punpcklbw";
            case 2792L: return "bfk_ia32_punpcklbw128";
            case 2793L: return "bfk_ia32_punpcklbw128_mask";
            case 2794L: return "bfk_ia32_punpcklbw256";
            case 2795L: return "bfk_ia32_punpcklbw256_mask";
            case 2796L: return "bfk_ia32_punpcklbw512_mask";
            case 2797L: return "bfk_ia32_punpckldq";
            case 2798L: return "bfk_ia32_punpckldq128";
            case 2799L: return "bfk_ia32_punpckldq128_mask";
            case 2800L: return "bfk_ia32_punpckldq256";
            case 2801L: return "bfk_ia32_punpckldq256_mask";
            case 2802L: return "bfk_ia32_punpckldq512_mask";
            case 2803L: return "bfk_ia32_punpcklqdq128";
            case 2804L: return "bfk_ia32_punpcklqdq128_mask";
            case 2805L: return "bfk_ia32_punpcklqdq256";
            case 2806L: return "bfk_ia32_punpcklqdq256_mask";
            case 2807L: return "bfk_ia32_punpcklqdq512_mask";
            case 2808L: return "bfk_ia32_punpcklwd";
            case 2809L: return "bfk_ia32_punpcklwd128";
            case 2810L: return "bfk_ia32_punpcklwd128_mask";
            case 2811L: return "bfk_ia32_punpcklwd256";
            case 2812L: return "bfk_ia32_punpcklwd256_mask";
            case 2813L: return "bfk_ia32_punpcklwd512_mask";
            case 2814L: return "bfk_ia32_pxor";
            case 2815L: return "bfk_ia32_pxor128";
            case 2816L: return "bfk_ia32_pxor256";
            case 2817L: return "bfk_ia32_pxord128_mask";
            case 2818L: return "bfk_ia32_pxord256_mask";
            case 2819L: return "bfk_ia32_pxord512_mask";
            case 2820L: return "bfk_ia32_pxorq128_mask";
            case 2821L: return "bfk_ia32_pxorq256_mask";
            case 2822L: return "bfk_ia32_pxorq512_mask";
            case 2823L: return "bfk_ia32_rangepd128_mask";
            case 2824L: return "bfk_ia32_rangepd256_mask";
            case 2825L: return "bfk_ia32_rangepd512_mask";
            case 2826L: return "bfk_ia32_rangeps128_mask";
            case 2827L: return "bfk_ia32_rangeps256_mask";
            case 2828L: return "bfk_ia32_rangeps512_mask";
            case 2829L: return "bfk_ia32_rangesd128_mask_round";
            case 2830L: return "bfk_ia32_rangesd128_round";
            case 2831L: return "bfk_ia32_rangesd128_round_mask";
            case 2832L: return "bfk_ia32_rangess128_mask_round";
            case 2833L: return "bfk_ia32_rangess128_round";
            case 2834L: return "bfk_ia32_rangess128_round_mask";
            case 2835L: return "bfk_ia32_rcp14pd128_mask";
            case 2836L: return "bfk_ia32_rcp14pd256_mask";
            case 2837L: return "bfk_ia32_rcp14pd512_mask";
            case 2838L: return "bfk_ia32_rcp14ps128_mask";
            case 2839L: return "bfk_ia32_rcp14ps256_mask";
            case 2840L: return "bfk_ia32_rcp14ps512_mask";
            case 2841L: return "bfk_ia32_rcp14sd";
            case 2842L: return "bfk_ia32_rcp14sd_mask";
            case 2843L: return "bfk_ia32_rcp14ss";
            case 2844L: return "bfk_ia32_rcp14ss_mask";
            case 2845L: return "bfk_ia32_rcp28pd_mask";
            case 2846L: return "bfk_ia32_rcp28ps_mask";
            case 2847L: return "bfk_ia32_rcp28sd_mask";
            case 2848L: return "bfk_ia32_rcp28sd_round";
            case 2849L: return "bfk_ia32_rcp28sd_round_mask";
            case 2850L: return "bfk_ia32_rcp28ss_mask";
            case 2851L: return "bfk_ia32_rcp28ss_round";
            case 2852L: return "bfk_ia32_rcp28ss_round_mask";
            case 2853L: return "bfk_ia32_rcpps";
            case 2854L: return "bfk_ia32_rcpps256";
            case 2855L: return "bfk_ia32_rcpss";
            case 2856L: return "bfk_ia32_rdfsbase32";
            case 2857L: return "bfk_ia32_rdfsbase64";
            case 2858L: return "bfk_ia32_rdgsbase32";
            case 2859L: return "bfk_ia32_rdgsbase64";
            case 2860L: return "bfk_ia32_rdpid";
            case 2861L: return "bfk_ia32_rdpkru";
            case 2862L: return "bfk_ia32_rdpmc";
            case 2863L: return "bfk_ia32_rdrand16_step";
            case 2864L: return "bfk_ia32_rdrand32_step";
            case 2865L: return "bfk_ia32_rdrand64_step";
            case 2866L: return "bfk_ia32_rdseed16_step";
            case 2867L: return "bfk_ia32_rdseed32_step";
            case 2868L: return "bfk_ia32_rdseed64_step";
            case 2869L: return "bfk_ia32_rdseed_di_step";
            case 2870L: return "bfk_ia32_rdseed_hi_step";
            case 2871L: return "bfk_ia32_rdseed_si_step";
            case 2872L: return "bfk_ia32_rdsspd";
            case 2873L: return "bfk_ia32_rdsspq";
            case 2874L: return "bfk_ia32_rdtsc";
            case 2875L: return "bfk_ia32_rdtscp";
            case 2876L: return "bfk_ia32_readeflags_u32";
            case 2877L: return "bfk_ia32_readeflags_u64";
            case 2878L: return "bfk_ia32_reducepd128_mask";
            case 2879L: return "bfk_ia32_reducepd256_mask";
            case 2880L: return "bfk_ia32_reducepd512_mask";
            case 2881L: return "bfk_ia32_reduceps128_mask";
            case 2882L: return "bfk_ia32_reduceps256_mask";
            case 2883L: return "bfk_ia32_reduceps512_mask";
            case 2884L: return "bfk_ia32_reducesd";
            case 2885L: return "bfk_ia32_reducesd_mask";
            case 2886L: return "bfk_ia32_reducess";
            case 2887L: return "bfk_ia32_reducess_mask";
            case 2888L: return "bfk_ia32_rintpd";
            case 2889L: return "bfk_ia32_rintpd256";
            case 2890L: return "bfk_ia32_rintps";
            case 2891L: return "bfk_ia32_rintps256";
            case 2892L: return "bfk_ia32_rndscalepd_128_mask";
            case 2893L: return "bfk_ia32_rndscalepd_256_mask";
            case 2894L: return "bfk_ia32_rndscalepd_mask";
            case 2895L: return "bfk_ia32_rndscaleps_128_mask";
            case 2896L: return "bfk_ia32_rndscaleps_256_mask";
            case 2897L: return "bfk_ia32_rndscaleps_mask";
            case 2898L: return "bfk_ia32_rndscalesd_round";
            case 2899L: return "bfk_ia32_rndscalesd_round_mask";
            case 2900L: return "bfk_ia32_rndscaless_round";
            case 2901L: return "bfk_ia32_rndscaless_round_mask";
            case 2902L: return "bfk_ia32_rolhi";
            case 2903L: return "bfk_ia32_rolqi";
            case 2904L: return "bfk_ia32_rorhi";
            case 2905L: return "bfk_ia32_rorqi";
            case 2906L: return "bfk_ia32_roundpd";
            case 2907L: return "bfk_ia32_roundpd256";
            case 2908L: return "bfk_ia32_roundpd_az";
            case 2909L: return "bfk_ia32_roundpd_az256";
            case 2910L: return "bfk_ia32_roundpd_az_vec_pack_sfix";
            case 2911L: return "bfk_ia32_roundpd_az_vec_pack_sfix256";
            case 2912L: return "bfk_ia32_roundpd_az_vec_pack_sfix512";
            case 2913L: return "bfk_ia32_roundps";
            case 2914L: return "bfk_ia32_roundps256";
            case 2915L: return "bfk_ia32_roundps_az";
            case 2916L: return "bfk_ia32_roundps_az256";
            case 2917L: return "bfk_ia32_roundps_az_sfix";
            case 2918L: return "bfk_ia32_roundps_az_sfix256";
            case 2919L: return "bfk_ia32_roundps_az_sfix512";
            case 2920L: return "bfk_ia32_roundsd";
            case 2921L: return "bfk_ia32_roundss";
            case 2922L: return "bfk_ia32_rsqrt14pd128_mask";
            case 2923L: return "bfk_ia32_rsqrt14pd256_mask";
            case 2924L: return "bfk_ia32_rsqrt14pd512_mask";
            case 2925L: return "bfk_ia32_rsqrt14ps128_mask";
            case 2926L: return "bfk_ia32_rsqrt14ps256_mask";
            case 2927L: return "bfk_ia32_rsqrt14ps512_mask";
            case 2928L: return "bfk_ia32_rsqrt14sd";
            case 2929L: return "bfk_ia32_rsqrt14sd_mask";
            case 2930L: return "bfk_ia32_rsqrt14ss";
            case 2931L: return "bfk_ia32_rsqrt14ss_mask";
            case 2932L: return "bfk_ia32_rsqrt28pd_mask";
            case 2933L: return "bfk_ia32_rsqrt28ps_mask";
            case 2934L: return "bfk_ia32_rsqrt28sd_mask";
            case 2935L: return "bfk_ia32_rsqrt28sd_round";
            case 2936L: return "bfk_ia32_rsqrt28sd_round_mask";
            case 2937L: return "bfk_ia32_rsqrt28ss_mask";
            case 2938L: return "bfk_ia32_rsqrt28ss_round";
            case 2939L: return "bfk_ia32_rsqrt28ss_round_mask";
            case 2940L: return "bfk_ia32_rsqrtf";
            case 2941L: return "bfk_ia32_rsqrtps";
            case 2942L: return "bfk_ia32_rsqrtps256";
            case 2943L: return "bfk_ia32_rsqrtps_nr";
            case 2944L: return "bfk_ia32_rsqrtps_nr256";
            case 2945L: return "bfk_ia32_rsqrtss";
            case 2946L: return "bfk_ia32_rstorssp";
            case 2947L: return "bfk_ia32_saveprevssp";
            case 2948L: return "bfk_ia32_sbb_u32";
            case 2949L: return "bfk_ia32_sbb_u64";
            case 2950L: return "bfk_ia32_scalefpd128_mask";
            case 2951L: return "bfk_ia32_scalefpd256_mask";
            case 2952L: return "bfk_ia32_scalefpd512_mask";
            case 2953L: return "bfk_ia32_scalefps128_mask";
            case 2954L: return "bfk_ia32_scalefps256_mask";
            case 2955L: return "bfk_ia32_scalefps512_mask";
            case 2956L: return "bfk_ia32_scalefsd_mask_round";
            case 2957L: return "bfk_ia32_scalefsd_round";
            case 2958L: return "bfk_ia32_scalefsd_round_mask";
            case 2959L: return "bfk_ia32_scalefss_mask_round";
            case 2960L: return "bfk_ia32_scalefss_round";
            case 2961L: return "bfk_ia32_scalefss_round_mask";
            case 2962L: return "bfk_ia32_scatteraltdiv8sf";
            case 2963L: return "bfk_ia32_scatteraltdiv8si";
            case 2964L: return "bfk_ia32_scatteraltsiv8df";
            case 2965L: return "bfk_ia32_scatteraltsiv8di";
            case 2966L: return "bfk_ia32_scatterdiv16sf";
            case 2967L: return "bfk_ia32_scatterdiv16si";
            case 2968L: return "bfk_ia32_scatterdiv2df";
            case 2969L: return "bfk_ia32_scatterdiv2di";
            case 2970L: return "bfk_ia32_scatterdiv4df";
            case 2971L: return "bfk_ia32_scatterdiv4di";
            case 2972L: return "bfk_ia32_scatterdiv4sf";
            case 2973L: return "bfk_ia32_scatterdiv4si";
            case 2974L: return "bfk_ia32_scatterdiv8df";
            case 2975L: return "bfk_ia32_scatterdiv8di";
            case 2976L: return "bfk_ia32_scatterdiv8sf";
            case 2977L: return "bfk_ia32_scatterdiv8si";
            case 2978L: return "bfk_ia32_scatterpfdpd";
            case 2979L: return "bfk_ia32_scatterpfdps";
            case 2980L: return "bfk_ia32_scatterpfqpd";
            case 2981L: return "bfk_ia32_scatterpfqps";
            case 2982L: return "bfk_ia32_scattersiv16sf";
            case 2983L: return "bfk_ia32_scattersiv16si";
            case 2984L: return "bfk_ia32_scattersiv2df";
            case 2985L: return "bfk_ia32_scattersiv2di";
            case 2986L: return "bfk_ia32_scattersiv4df";
            case 2987L: return "bfk_ia32_scattersiv4di";
            case 2988L: return "bfk_ia32_scattersiv4sf";
            case 2989L: return "bfk_ia32_scattersiv4si";
            case 2990L: return "bfk_ia32_scattersiv8df";
            case 2991L: return "bfk_ia32_scattersiv8di";
            case 2992L: return "bfk_ia32_scattersiv8sf";
            case 2993L: return "bfk_ia32_scattersiv8si";
            case 2994L: return "bfk_ia32_selectb_128";
            case 2995L: return "bfk_ia32_selectb_256";
            case 2996L: return "bfk_ia32_selectb_512";
            case 2997L: return "bfk_ia32_selectd_128";
            case 2998L: return "bfk_ia32_selectd_256";
            case 2999L: return "bfk_ia32_selectd_512";
            case 3000L: return "bfk_ia32_selectpd_128";
            case 3001L: return "bfk_ia32_selectpd_256";
            case 3002L: return "bfk_ia32_selectpd_512";
            case 3003L: return "bfk_ia32_selectps_128";
            case 3004L: return "bfk_ia32_selectps_256";
            case 3005L: return "bfk_ia32_selectps_512";
            case 3006L: return "bfk_ia32_selectq_128";
            case 3007L: return "bfk_ia32_selectq_256";
            case 3008L: return "bfk_ia32_selectq_512";
            case 3009L: return "bfk_ia32_selectw_128";
            case 3010L: return "bfk_ia32_selectw_256";
            case 3011L: return "bfk_ia32_selectw_512";
            case 3012L: return "bfk_ia32_setssbsy";
            case 3013L: return "bfk_ia32_sfence";
            case 3014L: return "bfk_ia32_sha1msg1";
            case 3015L: return "bfk_ia32_sha1msg2";
            case 3016L: return "bfk_ia32_sha1nexte";
            case 3017L: return "bfk_ia32_sha1rnds4";
            case 3018L: return "bfk_ia32_sha256msg1";
            case 3019L: return "bfk_ia32_sha256msg2";
            case 3020L: return "bfk_ia32_sha256rnds2";
            case 3021L: return "bfk_ia32_shuf_f32x4_256_mask";
            case 3022L: return "bfk_ia32_shuf_f32x4_mask";
            case 3023L: return "bfk_ia32_shuf_f64x2_256_mask";
            case 3024L: return "bfk_ia32_shuf_f64x2_mask";
            case 3025L: return "bfk_ia32_shuf_i32x4_256_mask";
            case 3026L: return "bfk_ia32_shuf_i32x4_mask";
            case 3027L: return "bfk_ia32_shuf_i64x2_256_mask";
            case 3028L: return "bfk_ia32_shuf_i64x2_mask";
            case 3029L: return "bfk_ia32_shufpd";
            case 3030L: return "bfk_ia32_shufpd128_mask";
            case 3031L: return "bfk_ia32_shufpd256";
            case 3032L: return "bfk_ia32_shufpd256_mask";
            case 3033L: return "bfk_ia32_shufpd512_mask";
            case 3034L: return "bfk_ia32_shufps";
            case 3035L: return "bfk_ia32_shufps128_mask";
            case 3036L: return "bfk_ia32_shufps256";
            case 3037L: return "bfk_ia32_shufps256_mask";
            case 3038L: return "bfk_ia32_shufps512_mask";
            case 3039L: return "bfk_ia32_si256_si";
            case 3040L: return "bfk_ia32_si512_256si";
            case 3041L: return "bfk_ia32_si512_si";
            case 3042L: return "bfk_ia32_si_si256";
            case 3043L: return "bfk_ia32_slwpcb";
            case 3044L: return "bfk_ia32_sqrtpd";
            case 3045L: return "bfk_ia32_sqrtpd128_mask";
            case 3046L: return "bfk_ia32_sqrtpd256";
            case 3047L: return "bfk_ia32_sqrtpd256_mask";
            case 3048L: return "bfk_ia32_sqrtpd512";
            case 3049L: return "bfk_ia32_sqrtpd512_mask";
            case 3050L: return "bfk_ia32_sqrtps";
            case 3051L: return "bfk_ia32_sqrtps128_mask";
            case 3052L: return "bfk_ia32_sqrtps256";
            case 3053L: return "bfk_ia32_sqrtps256_mask";
            case 3054L: return "bfk_ia32_sqrtps512";
            case 3055L: return "bfk_ia32_sqrtps512_mask";
            case 3056L: return "bfk_ia32_sqrtps_nr";
            case 3057L: return "bfk_ia32_sqrtps_nr256";
            case 3058L: return "bfk_ia32_sqrtsd";
            case 3059L: return "bfk_ia32_sqrtsd_mask_round";
            case 3060L: return "bfk_ia32_sqrtsd_round";
            case 3061L: return "bfk_ia32_sqrtsd_round_mask";
            case 3062L: return "bfk_ia32_sqrtss";
            case 3063L: return "bfk_ia32_sqrtss_mask_round";
            case 3064L: return "bfk_ia32_sqrtss_round";
            case 3065L: return "bfk_ia32_sqrtss_round_mask";
            case 3066L: return "bfk_ia32_stmxcsr";
            case 3067L: return "bfk_ia32_storeapd128_mask";
            case 3068L: return "bfk_ia32_storeapd256_mask";
            case 3069L: return "bfk_ia32_storeapd512_mask";
            case 3070L: return "bfk_ia32_storeaps";
            case 3071L: return "bfk_ia32_storeaps128_mask";
            case 3072L: return "bfk_ia32_storeaps256_mask";
            case 3073L: return "bfk_ia32_storeaps512_mask";
            case 3074L: return "bfk_ia32_storedqu";
            case 3075L: return "bfk_ia32_storedqu256";
            case 3076L: return "bfk_ia32_storedqudi128_mask";
            case 3077L: return "bfk_ia32_storedqudi256_mask";
            case 3078L: return "bfk_ia32_storedqudi512_mask";
            case 3079L: return "bfk_ia32_storedquhi128_mask";
            case 3080L: return "bfk_ia32_storedquhi256_mask";
            case 3081L: return "bfk_ia32_storedquhi512_mask";
            case 3082L: return "bfk_ia32_storedquqi128_mask";
            case 3083L: return "bfk_ia32_storedquqi256_mask";
            case 3084L: return "bfk_ia32_storedquqi512_mask";
            case 3085L: return "bfk_ia32_storedqusi128_mask";
            case 3086L: return "bfk_ia32_storedqusi256_mask";
            case 3087L: return "bfk_ia32_storedqusi512_mask";
            case 3088L: return "bfk_ia32_storehps";
            case 3089L: return "bfk_ia32_storelps";
            case 3090L: return "bfk_ia32_storesd128_mask";
            case 3091L: return "bfk_ia32_storess";
            case 3092L: return "bfk_ia32_storess128_mask";
            case 3093L: return "bfk_ia32_storeupd";
            case 3094L: return "bfk_ia32_storeupd128_mask";
            case 3095L: return "bfk_ia32_storeupd256";
            case 3096L: return "bfk_ia32_storeupd256_mask";
            case 3097L: return "bfk_ia32_storeupd512_mask";
            case 3098L: return "bfk_ia32_storeups";
            case 3099L: return "bfk_ia32_storeups128_mask";
            case 3100L: return "bfk_ia32_storeups256";
            case 3101L: return "bfk_ia32_storeups256_mask";
            case 3102L: return "bfk_ia32_storeups512_mask";
            case 3103L: return "bfk_ia32_subborrow_u32";
            case 3104L: return "bfk_ia32_subborrow_u64";
            case 3105L: return "bfk_ia32_subpd";
            case 3106L: return "bfk_ia32_subpd128_mask";
            case 3107L: return "bfk_ia32_subpd256";
            case 3108L: return "bfk_ia32_subpd256_mask";
            case 3109L: return "bfk_ia32_subpd512_mask";
            case 3110L: return "bfk_ia32_subps";
            case 3111L: return "bfk_ia32_subps128_mask";
            case 3112L: return "bfk_ia32_subps256";
            case 3113L: return "bfk_ia32_subps256_mask";
            case 3114L: return "bfk_ia32_subps512_mask";
            case 3115L: return "bfk_ia32_subsd";
            case 3116L: return "bfk_ia32_subsd_mask_round";
            case 3117L: return "bfk_ia32_subsd_round";
            case 3118L: return "bfk_ia32_subsd_round_mask";
            case 3119L: return "bfk_ia32_subss";
            case 3120L: return "bfk_ia32_subss_mask_round";
            case 3121L: return "bfk_ia32_subss_round";
            case 3122L: return "bfk_ia32_subss_round_mask";
            case 3123L: return "bfk_ia32_truncpd";
            case 3124L: return "bfk_ia32_truncpd256";
            case 3125L: return "bfk_ia32_truncpd512";
            case 3126L: return "bfk_ia32_truncps";
            case 3127L: return "bfk_ia32_truncps256";
            case 3128L: return "bfk_ia32_truncps512";
            case 3129L: return "bfk_ia32_tzcnt_u16";
            case 3130L: return "bfk_ia32_tzcnt_u32";
            case 3131L: return "bfk_ia32_tzcnt_u64";
            case 3132L: return "bfk_ia32_ucmpb128_mask";
            case 3133L: return "bfk_ia32_ucmpb256_mask";
            case 3134L: return "bfk_ia32_ucmpb512_mask";
            case 3135L: return "bfk_ia32_ucmpd128_mask";
            case 3136L: return "bfk_ia32_ucmpd256_mask";
            case 3137L: return "bfk_ia32_ucmpd512_mask";
            case 3138L: return "bfk_ia32_ucmpq128_mask";
            case 3139L: return "bfk_ia32_ucmpq256_mask";
            case 3140L: return "bfk_ia32_ucmpq512_mask";
            case 3141L: return "bfk_ia32_ucmpw128_mask";
            case 3142L: return "bfk_ia32_ucmpw256_mask";
            case 3143L: return "bfk_ia32_ucmpw512_mask";
            case 3144L: return "bfk_ia32_ucomieq";
            case 3145L: return "bfk_ia32_ucomige";
            case 3146L: return "bfk_ia32_ucomigt";
            case 3147L: return "bfk_ia32_ucomile";
            case 3148L: return "bfk_ia32_ucomilt";
            case 3149L: return "bfk_ia32_ucomineq";
            case 3150L: return "bfk_ia32_ucomisdeq";
            case 3151L: return "bfk_ia32_ucomisdge";
            case 3152L: return "bfk_ia32_ucomisdgt";
            case 3153L: return "bfk_ia32_ucomisdle";
            case 3154L: return "bfk_ia32_ucomisdlt";
            case 3155L: return "bfk_ia32_ucomisdneq";
            case 3156L: return "bfk_ia32_undef128";
            case 3157L: return "bfk_ia32_undef256";
            case 3158L: return "bfk_ia32_undef512";
            case 3159L: return "bfk_ia32_unpckhpd";
            case 3160L: return "bfk_ia32_unpckhpd128_mask";
            case 3161L: return "bfk_ia32_unpckhpd256";
            case 3162L: return "bfk_ia32_unpckhpd256_mask";
            case 3163L: return "bfk_ia32_unpckhpd512_mask";
            case 3164L: return "bfk_ia32_unpckhps";
            case 3165L: return "bfk_ia32_unpckhps128_mask";
            case 3166L: return "bfk_ia32_unpckhps256";
            case 3167L: return "bfk_ia32_unpckhps256_mask";
            case 3168L: return "bfk_ia32_unpckhps512_mask";
            case 3169L: return "bfk_ia32_unpcklpd";
            case 3170L: return "bfk_ia32_unpcklpd128_mask";
            case 3171L: return "bfk_ia32_unpcklpd256";
            case 3172L: return "bfk_ia32_unpcklpd256_mask";
            case 3173L: return "bfk_ia32_unpcklpd512_mask";
            case 3174L: return "bfk_ia32_unpcklps";
            case 3175L: return "bfk_ia32_unpcklps128_mask";
            case 3176L: return "bfk_ia32_unpcklps256";
            case 3177L: return "bfk_ia32_unpcklps256_mask";
            case 3178L: return "bfk_ia32_unpcklps512_mask";
            case 3179L: return "bfk_ia32_vaesdec_v16qi";
            case 3180L: return "bfk_ia32_vaesdec_v32qi";
            case 3181L: return "bfk_ia32_vaesdec_v64qi";
            case 3182L: return "bfk_ia32_vaesdeclast_v16qi";
            case 3183L: return "bfk_ia32_vaesdeclast_v32qi";
            case 3184L: return "bfk_ia32_vaesdeclast_v64qi";
            case 3185L: return "bfk_ia32_vaesenc_v16qi";
            case 3186L: return "bfk_ia32_vaesenc_v32qi";
            case 3187L: return "bfk_ia32_vaesenc_v64qi";
            case 3188L: return "bfk_ia32_vaesenclast_v16qi";
            case 3189L: return "bfk_ia32_vaesenclast_v32qi";
            case 3190L: return "bfk_ia32_vaesenclast_v64qi";
            case 3191L: return "bfk_ia32_vbroadcastf128_pd256";
            case 3192L: return "bfk_ia32_vbroadcastf128_ps256";
            case 3193L: return "bfk_ia32_vbroadcastsd256";
            case 3194L: return "bfk_ia32_vbroadcastsd_pd256";
            case 3195L: return "bfk_ia32_vbroadcastsi256";
            case 3196L: return "bfk_ia32_vbroadcastss";
            case 3197L: return "bfk_ia32_vbroadcastss256";
            case 3198L: return "bfk_ia32_vbroadcastss_ps";
            case 3199L: return "bfk_ia32_vbroadcastss_ps256";
            case 3200L: return "bfk_ia32_vcomisd";
            case 3201L: return "bfk_ia32_vcomiss";
            case 3202L: return "bfk_ia32_vcvtph2ps";
            case 3203L: return "bfk_ia32_vcvtph2ps256";
            case 3204L: return "bfk_ia32_vcvtph2ps256_mask";
            case 3205L: return "bfk_ia32_vcvtph2ps512";
            case 3206L: return "bfk_ia32_vcvtph2ps512_mask";
            case 3207L: return "bfk_ia32_vcvtph2ps_mask";
            case 3208L: return "bfk_ia32_vcvtps2ph";
            case 3209L: return "bfk_ia32_vcvtps2ph256";
            case 3210L: return "bfk_ia32_vcvtps2ph256_mask";
            case 3211L: return "bfk_ia32_vcvtps2ph512";
            case 3212L: return "bfk_ia32_vcvtps2ph512_mask";
            case 3213L: return "bfk_ia32_vcvtps2ph_mask";
            case 3214L: return "bfk_ia32_vcvtsd2si32";
            case 3215L: return "bfk_ia32_vcvtsd2si64";
            case 3216L: return "bfk_ia32_vcvtsd2usi32";
            case 3217L: return "bfk_ia32_vcvtsd2usi64";
            case 3218L: return "bfk_ia32_vcvtss2si32";
            case 3219L: return "bfk_ia32_vcvtss2si64";
            case 3220L: return "bfk_ia32_vcvtss2usi32";
            case 3221L: return "bfk_ia32_vcvtss2usi64";
            case 3222L: return "bfk_ia32_vcvttsd2si32";
            case 3223L: return "bfk_ia32_vcvttsd2si64";
            case 3224L: return "bfk_ia32_vcvttsd2usi32";
            case 3225L: return "bfk_ia32_vcvttsd2usi64";
            case 3226L: return "bfk_ia32_vcvttss2si32";
            case 3227L: return "bfk_ia32_vcvttss2si64";
            case 3228L: return "bfk_ia32_vcvttss2usi32";
            case 3229L: return "bfk_ia32_vcvttss2usi64";
            case 3230L: return "bfk_ia32_vec_ext_v16qi";
            case 3231L: return "bfk_ia32_vec_ext_v2df";
            case 3232L: return "bfk_ia32_vec_ext_v2di";
            case 3233L: return "bfk_ia32_vec_ext_v2si";
            case 3234L: return "bfk_ia32_vec_ext_v4hi";
            case 3235L: return "bfk_ia32_vec_ext_v4sf";
            case 3236L: return "bfk_ia32_vec_ext_v4si";
            case 3237L: return "bfk_ia32_vec_ext_v8hi";
            case 3238L: return "bfk_ia32_vec_init_v2si";
            case 3239L: return "bfk_ia32_vec_init_v4hi";
            case 3240L: return "bfk_ia32_vec_init_v8qi";
            case 3241L: return "bfk_ia32_vec_pack_sfix";
            case 3242L: return "bfk_ia32_vec_pack_sfix256";
            case 3243L: return "bfk_ia32_vec_pack_sfix512";
            case 3244L: return "bfk_ia32_vec_perm_v16qi";
            case 3245L: return "bfk_ia32_vec_perm_v16qi_u";
            case 3246L: return "bfk_ia32_vec_perm_v2df";
            case 3247L: return "bfk_ia32_vec_perm_v2di";
            case 3248L: return "bfk_ia32_vec_perm_v2di_u";
            case 3249L: return "bfk_ia32_vec_perm_v4df";
            case 3250L: return "bfk_ia32_vec_perm_v4sf";
            case 3251L: return "bfk_ia32_vec_perm_v4si";
            case 3252L: return "bfk_ia32_vec_perm_v4si_u";
            case 3253L: return "bfk_ia32_vec_perm_v8hi";
            case 3254L: return "bfk_ia32_vec_perm_v8hi_u";
            case 3255L: return "bfk_ia32_vec_perm_v8sf";
            case 3256L: return "bfk_ia32_vec_set_v16qi";
            case 3257L: return "bfk_ia32_vec_set_v2di";
            case 3258L: return "bfk_ia32_vec_set_v4hi";
            case 3259L: return "bfk_ia32_vec_set_v4sf";
            case 3260L: return "bfk_ia32_vec_set_v4si";
            case 3261L: return "bfk_ia32_vec_set_v8hi";
            case 3262L: return "bfk_ia32_vextractf128_pd256";
            case 3263L: return "bfk_ia32_vextractf128_ps256";
            case 3264L: return "bfk_ia32_vextractf128_si256";
            case 3265L: return "bfk_ia32_vfmaddpd";
            case 3266L: return "bfk_ia32_vfmaddpd128_mask";
            case 3267L: return "bfk_ia32_vfmaddpd128_mask3";
            case 3268L: return "bfk_ia32_vfmaddpd128_maskz";
            case 3269L: return "bfk_ia32_vfmaddpd256";
            case 3270L: return "bfk_ia32_vfmaddpd256_mask";
            case 3271L: return "bfk_ia32_vfmaddpd256_mask3";
            case 3272L: return "bfk_ia32_vfmaddpd256_maskz";
            case 3273L: return "bfk_ia32_vfmaddpd512_mask";
            case 3274L: return "bfk_ia32_vfmaddpd512_mask3";
            case 3275L: return "bfk_ia32_vfmaddpd512_maskz";
            case 3276L: return "bfk_ia32_vfmaddps";
            case 3277L: return "bfk_ia32_vfmaddps128_mask";
            case 3278L: return "bfk_ia32_vfmaddps128_mask3";
            case 3279L: return "bfk_ia32_vfmaddps128_maskz";
            case 3280L: return "bfk_ia32_vfmaddps256";
            case 3281L: return "bfk_ia32_vfmaddps256_mask";
            case 3282L: return "bfk_ia32_vfmaddps256_mask3";
            case 3283L: return "bfk_ia32_vfmaddps256_maskz";
            case 3284L: return "bfk_ia32_vfmaddps512_mask";
            case 3285L: return "bfk_ia32_vfmaddps512_mask3";
            case 3286L: return "bfk_ia32_vfmaddps512_maskz";
            case 3287L: return "bfk_ia32_vfmaddsd";
            case 3288L: return "bfk_ia32_vfmaddsd3";
            case 3289L: return "bfk_ia32_vfmaddsd3_mask";
            case 3290L: return "bfk_ia32_vfmaddsd3_mask3";
            case 3291L: return "bfk_ia32_vfmaddsd3_maskz";
            case 3292L: return "bfk_ia32_vfmaddsd3_round";
            case 3293L: return "bfk_ia32_vfmaddss";
            case 3294L: return "bfk_ia32_vfmaddss3";
            case 3295L: return "bfk_ia32_vfmaddss3_mask";
            case 3296L: return "bfk_ia32_vfmaddss3_mask3";
            case 3297L: return "bfk_ia32_vfmaddss3_maskz";
            case 3298L: return "bfk_ia32_vfmaddss3_round";
            case 3299L: return "bfk_ia32_vfmaddsubpd";
            case 3300L: return "bfk_ia32_vfmaddsubpd128_mask";
            case 3301L: return "bfk_ia32_vfmaddsubpd128_mask3";
            case 3302L: return "bfk_ia32_vfmaddsubpd128_maskz";
            case 3303L: return "bfk_ia32_vfmaddsubpd256";
            case 3304L: return "bfk_ia32_vfmaddsubpd256_mask";
            case 3305L: return "bfk_ia32_vfmaddsubpd256_mask3";
            case 3306L: return "bfk_ia32_vfmaddsubpd256_maskz";
            case 3307L: return "bfk_ia32_vfmaddsubpd512_mask";
            case 3308L: return "bfk_ia32_vfmaddsubpd512_mask3";
            case 3309L: return "bfk_ia32_vfmaddsubpd512_maskz";
            case 3310L: return "bfk_ia32_vfmaddsubps";
            case 3311L: return "bfk_ia32_vfmaddsubps128_mask";
            case 3312L: return "bfk_ia32_vfmaddsubps128_mask3";
            case 3313L: return "bfk_ia32_vfmaddsubps128_maskz";
            case 3314L: return "bfk_ia32_vfmaddsubps256";
            case 3315L: return "bfk_ia32_vfmaddsubps256_mask";
            case 3316L: return "bfk_ia32_vfmaddsubps256_mask3";
            case 3317L: return "bfk_ia32_vfmaddsubps256_maskz";
            case 3318L: return "bfk_ia32_vfmaddsubps512_mask";
            case 3319L: return "bfk_ia32_vfmaddsubps512_mask3";
            case 3320L: return "bfk_ia32_vfmaddsubps512_maskz";
            case 3321L: return "bfk_ia32_vfmsubaddpd";
            case 3322L: return "bfk_ia32_vfmsubaddpd128_mask3";
            case 3323L: return "bfk_ia32_vfmsubaddpd256";
            case 3324L: return "bfk_ia32_vfmsubaddpd256_mask3";
            case 3325L: return "bfk_ia32_vfmsubaddpd512_mask3";
            case 3326L: return "bfk_ia32_vfmsubaddps";
            case 3327L: return "bfk_ia32_vfmsubaddps128_mask3";
            case 3328L: return "bfk_ia32_vfmsubaddps256";
            case 3329L: return "bfk_ia32_vfmsubaddps256_mask3";
            case 3330L: return "bfk_ia32_vfmsubaddps512_mask3";
            case 3331L: return "bfk_ia32_vfmsubpd";
            case 3332L: return "bfk_ia32_vfmsubpd128_mask3";
            case 3333L: return "bfk_ia32_vfmsubpd256";
            case 3334L: return "bfk_ia32_vfmsubpd256_mask3";
            case 3335L: return "bfk_ia32_vfmsubpd512_mask";
            case 3336L: return "bfk_ia32_vfmsubpd512_mask3";
            case 3337L: return "bfk_ia32_vfmsubps";
            case 3338L: return "bfk_ia32_vfmsubps128_mask3";
            case 3339L: return "bfk_ia32_vfmsubps256";
            case 3340L: return "bfk_ia32_vfmsubps256_mask3";
            case 3341L: return "bfk_ia32_vfmsubps512_mask";
            case 3342L: return "bfk_ia32_vfmsubps512_mask3";
            case 3343L: return "bfk_ia32_vfmsubsd";
            case 3344L: return "bfk_ia32_vfmsubsd3_mask3";
            case 3345L: return "bfk_ia32_vfmsubss";
            case 3346L: return "bfk_ia32_vfmsubss3_mask3";
            case 3347L: return "bfk_ia32_vfnmaddpd";
            case 3348L: return "bfk_ia32_vfnmaddpd128_mask";
            case 3349L: return "bfk_ia32_vfnmaddpd256";
            case 3350L: return "bfk_ia32_vfnmaddpd256_mask";
            case 3351L: return "bfk_ia32_vfnmaddpd512_mask";
            case 3352L: return "bfk_ia32_vfnmaddps";
            case 3353L: return "bfk_ia32_vfnmaddps128_mask";
            case 3354L: return "bfk_ia32_vfnmaddps256";
            case 3355L: return "bfk_ia32_vfnmaddps256_mask";
            case 3356L: return "bfk_ia32_vfnmaddps512_mask";
            case 3357L: return "bfk_ia32_vfnmaddsd";
            case 3358L: return "bfk_ia32_vfnmaddss";
            case 3359L: return "bfk_ia32_vfnmsubpd";
            case 3360L: return "bfk_ia32_vfnmsubpd128_mask";
            case 3361L: return "bfk_ia32_vfnmsubpd128_mask3";
            case 3362L: return "bfk_ia32_vfnmsubpd256";
            case 3363L: return "bfk_ia32_vfnmsubpd256_mask";
            case 3364L: return "bfk_ia32_vfnmsubpd256_mask3";
            case 3365L: return "bfk_ia32_vfnmsubpd512_mask";
            case 3366L: return "bfk_ia32_vfnmsubpd512_mask3";
            case 3367L: return "bfk_ia32_vfnmsubps";
            case 3368L: return "bfk_ia32_vfnmsubps128_mask";
            case 3369L: return "bfk_ia32_vfnmsubps128_mask3";
            case 3370L: return "bfk_ia32_vfnmsubps256";
            case 3371L: return "bfk_ia32_vfnmsubps256_mask";
            case 3372L: return "bfk_ia32_vfnmsubps256_mask3";
            case 3373L: return "bfk_ia32_vfnmsubps512_mask";
            case 3374L: return "bfk_ia32_vfnmsubps512_mask3";
            case 3375L: return "bfk_ia32_vfnmsubsd";
            case 3376L: return "bfk_ia32_vfnmsubsd3_mask3";
            case 3377L: return "bfk_ia32_vfnmsubss";
            case 3378L: return "bfk_ia32_vfnmsubss3_mask3";
            case 3379L: return "bfk_ia32_vfrczpd";
            case 3380L: return "bfk_ia32_vfrczpd256";
            case 3381L: return "bfk_ia32_vfrczps";
            case 3382L: return "bfk_ia32_vfrczps256";
            case 3383L: return "bfk_ia32_vfrczsd";
            case 3384L: return "bfk_ia32_vfrczss";
            case 3385L: return "bfk_ia32_vgf2p8affineinvqb_v16qi";
            case 3386L: return "bfk_ia32_vgf2p8affineinvqb_v16qi_mask";
            case 3387L: return "bfk_ia32_vgf2p8affineinvqb_v32qi";
            case 3388L: return "bfk_ia32_vgf2p8affineinvqb_v32qi_mask";
            case 3389L: return "bfk_ia32_vgf2p8affineinvqb_v64qi";
            case 3390L: return "bfk_ia32_vgf2p8affineinvqb_v64qi_mask";
            case 3391L: return "bfk_ia32_vgf2p8affineqb_v16qi";
            case 3392L: return "bfk_ia32_vgf2p8affineqb_v16qi_mask";
            case 3393L: return "bfk_ia32_vgf2p8affineqb_v32qi";
            case 3394L: return "bfk_ia32_vgf2p8affineqb_v32qi_mask";
            case 3395L: return "bfk_ia32_vgf2p8affineqb_v64qi";
            case 3396L: return "bfk_ia32_vgf2p8affineqb_v64qi_mask";
            case 3397L: return "bfk_ia32_vgf2p8mulb_v16qi";
            case 3398L: return "bfk_ia32_vgf2p8mulb_v16qi_mask";
            case 3399L: return "bfk_ia32_vgf2p8mulb_v32qi";
            case 3400L: return "bfk_ia32_vgf2p8mulb_v32qi_mask";
            case 3401L: return "bfk_ia32_vgf2p8mulb_v64qi";
            case 3402L: return "bfk_ia32_vgf2p8mulb_v64qi_mask";
            case 3403L: return "bfk_ia32_vinsertf128_pd256";
            case 3404L: return "bfk_ia32_vinsertf128_ps256";
            case 3405L: return "bfk_ia32_vinsertf128_si256";
            case 3406L: return "bfk_ia32_vp4dpwssd";
            case 3407L: return "bfk_ia32_vp4dpwssd_mask";
            case 3408L: return "bfk_ia32_vp4dpwssds";
            case 3409L: return "bfk_ia32_vp4dpwssds_mask";
            case 3410L: return "bfk_ia32_vpclmulqdq_v2di";
            case 3411L: return "bfk_ia32_vpclmulqdq_v4di";
            case 3412L: return "bfk_ia32_vpclmulqdq_v8di";
            case 3413L: return "bfk_ia32_vpcmov";
            case 3414L: return "bfk_ia32_vpcmov256";
            case 3415L: return "bfk_ia32_vpcmov_256";
            case 3416L: return "bfk_ia32_vpcmov_v16hi256";
            case 3417L: return "bfk_ia32_vpcmov_v16qi";
            case 3418L: return "bfk_ia32_vpcmov_v2df";
            case 3419L: return "bfk_ia32_vpcmov_v2di";
            case 3420L: return "bfk_ia32_vpcmov_v32qi256";
            case 3421L: return "bfk_ia32_vpcmov_v4df256";
            case 3422L: return "bfk_ia32_vpcmov_v4di256";
            case 3423L: return "bfk_ia32_vpcmov_v4sf";
            case 3424L: return "bfk_ia32_vpcmov_v4si";
            case 3425L: return "bfk_ia32_vpcmov_v8hi";
            case 3426L: return "bfk_ia32_vpcmov_v8sf256";
            case 3427L: return "bfk_ia32_vpcmov_v8si256";
            case 3428L: return "bfk_ia32_vpcomb";
            case 3429L: return "bfk_ia32_vpcomd";
            case 3430L: return "bfk_ia32_vpcomeqb";
            case 3431L: return "bfk_ia32_vpcomeqd";
            case 3432L: return "bfk_ia32_vpcomeqq";
            case 3433L: return "bfk_ia32_vpcomequb";
            case 3434L: return "bfk_ia32_vpcomequd";
            case 3435L: return "bfk_ia32_vpcomequq";
            case 3436L: return "bfk_ia32_vpcomequw";
            case 3437L: return "bfk_ia32_vpcomeqw";
            case 3438L: return "bfk_ia32_vpcomfalseb";
            case 3439L: return "bfk_ia32_vpcomfalsed";
            case 3440L: return "bfk_ia32_vpcomfalseq";
            case 3441L: return "bfk_ia32_vpcomfalseub";
            case 3442L: return "bfk_ia32_vpcomfalseud";
            case 3443L: return "bfk_ia32_vpcomfalseuq";
            case 3444L: return "bfk_ia32_vpcomfalseuw";
            case 3445L: return "bfk_ia32_vpcomfalsew";
            case 3446L: return "bfk_ia32_vpcomgeb";
            case 3447L: return "bfk_ia32_vpcomged";
            case 3448L: return "bfk_ia32_vpcomgeq";
            case 3449L: return "bfk_ia32_vpcomgeub";
            case 3450L: return "bfk_ia32_vpcomgeud";
            case 3451L: return "bfk_ia32_vpcomgeuq";
            case 3452L: return "bfk_ia32_vpcomgeuw";
            case 3453L: return "bfk_ia32_vpcomgew";
            case 3454L: return "bfk_ia32_vpcomgtb";
            case 3455L: return "bfk_ia32_vpcomgtd";
            case 3456L: return "bfk_ia32_vpcomgtq";
            case 3457L: return "bfk_ia32_vpcomgtub";
            case 3458L: return "bfk_ia32_vpcomgtud";
            case 3459L: return "bfk_ia32_vpcomgtuq";
            case 3460L: return "bfk_ia32_vpcomgtuw";
            case 3461L: return "bfk_ia32_vpcomgtw";
            case 3462L: return "bfk_ia32_vpcomleb";
            case 3463L: return "bfk_ia32_vpcomled";
            case 3464L: return "bfk_ia32_vpcomleq";
            case 3465L: return "bfk_ia32_vpcomleub";
            case 3466L: return "bfk_ia32_vpcomleud";
            case 3467L: return "bfk_ia32_vpcomleuq";
            case 3468L: return "bfk_ia32_vpcomleuw";
            case 3469L: return "bfk_ia32_vpcomlew";
            case 3470L: return "bfk_ia32_vpcomltb";
            case 3471L: return "bfk_ia32_vpcomltd";
            case 3472L: return "bfk_ia32_vpcomltq";
            case 3473L: return "bfk_ia32_vpcomltub";
            case 3474L: return "bfk_ia32_vpcomltud";
            case 3475L: return "bfk_ia32_vpcomltuq";
            case 3476L: return "bfk_ia32_vpcomltuw";
            case 3477L: return "bfk_ia32_vpcomltw";
            case 3478L: return "bfk_ia32_vpcomneb";
            case 3479L: return "bfk_ia32_vpcomned";
            case 3480L: return "bfk_ia32_vpcomneq";
            case 3481L: return "bfk_ia32_vpcomneqb";
            case 3482L: return "bfk_ia32_vpcomneqd";
            case 3483L: return "bfk_ia32_vpcomneqq";
            case 3484L: return "bfk_ia32_vpcomnequb";
            case 3485L: return "bfk_ia32_vpcomnequd";
            case 3486L: return "bfk_ia32_vpcomnequq";
            case 3487L: return "bfk_ia32_vpcomnequw";
            case 3488L: return "bfk_ia32_vpcomneqw";
            case 3489L: return "bfk_ia32_vpcomneub";
            case 3490L: return "bfk_ia32_vpcomneud";
            case 3491L: return "bfk_ia32_vpcomneuq";
            case 3492L: return "bfk_ia32_vpcomneuw";
            case 3493L: return "bfk_ia32_vpcomnew";
            case 3494L: return "bfk_ia32_vpcomq";
            case 3495L: return "bfk_ia32_vpcomtrueb";
            case 3496L: return "bfk_ia32_vpcomtrued";
            case 3497L: return "bfk_ia32_vpcomtrueq";
            case 3498L: return "bfk_ia32_vpcomtrueub";
            case 3499L: return "bfk_ia32_vpcomtrueud";
            case 3500L: return "bfk_ia32_vpcomtrueuq";
            case 3501L: return "bfk_ia32_vpcomtrueuw";
            case 3502L: return "bfk_ia32_vpcomtruew";
            case 3503L: return "bfk_ia32_vpcomub";
            case 3504L: return "bfk_ia32_vpcomud";
            case 3505L: return "bfk_ia32_vpcomuq";
            case 3506L: return "bfk_ia32_vpcomuw";
            case 3507L: return "bfk_ia32_vpcomw";
            case 3508L: return "bfk_ia32_vpconflictdi_128_mask";
            case 3509L: return "bfk_ia32_vpconflictdi_256_mask";
            case 3510L: return "bfk_ia32_vpconflictdi_512_mask";
            case 3511L: return "bfk_ia32_vpconflictsi_128_mask";
            case 3512L: return "bfk_ia32_vpconflictsi_256_mask";
            case 3513L: return "bfk_ia32_vpconflictsi_512_mask";
            case 3514L: return "bfk_ia32_vpdpbusd128_mask";
            case 3515L: return "bfk_ia32_vpdpbusd128_maskz";
            case 3516L: return "bfk_ia32_vpdpbusd256_mask";
            case 3517L: return "bfk_ia32_vpdpbusd256_maskz";
            case 3518L: return "bfk_ia32_vpdpbusd512_mask";
            case 3519L: return "bfk_ia32_vpdpbusd512_maskz";
            case 3520L: return "bfk_ia32_vpdpbusd_v16si";
            case 3521L: return "bfk_ia32_vpdpbusd_v16si_mask";
            case 3522L: return "bfk_ia32_vpdpbusd_v16si_maskz";
            case 3523L: return "bfk_ia32_vpdpbusd_v4si";
            case 3524L: return "bfk_ia32_vpdpbusd_v4si_mask";
            case 3525L: return "bfk_ia32_vpdpbusd_v4si_maskz";
            case 3526L: return "bfk_ia32_vpdpbusd_v8si";
            case 3527L: return "bfk_ia32_vpdpbusd_v8si_mask";
            case 3528L: return "bfk_ia32_vpdpbusd_v8si_maskz";
            case 3529L: return "bfk_ia32_vpdpbusds128_mask";
            case 3530L: return "bfk_ia32_vpdpbusds128_maskz";
            case 3531L: return "bfk_ia32_vpdpbusds256_mask";
            case 3532L: return "bfk_ia32_vpdpbusds256_maskz";
            case 3533L: return "bfk_ia32_vpdpbusds512_mask";
            case 3534L: return "bfk_ia32_vpdpbusds512_maskz";
            case 3535L: return "bfk_ia32_vpdpbusds_v16si";
            case 3536L: return "bfk_ia32_vpdpbusds_v16si_mask";
            case 3537L: return "bfk_ia32_vpdpbusds_v16si_maskz";
            case 3538L: return "bfk_ia32_vpdpbusds_v4si";
            case 3539L: return "bfk_ia32_vpdpbusds_v4si_mask";
            case 3540L: return "bfk_ia32_vpdpbusds_v4si_maskz";
            case 3541L: return "bfk_ia32_vpdpbusds_v8si";
            case 3542L: return "bfk_ia32_vpdpbusds_v8si_mask";
            case 3543L: return "bfk_ia32_vpdpbusds_v8si_maskz";
            case 3544L: return "bfk_ia32_vpdpwssd128_mask";
            case 3545L: return "bfk_ia32_vpdpwssd128_maskz";
            case 3546L: return "bfk_ia32_vpdpwssd256_mask";
            case 3547L: return "bfk_ia32_vpdpwssd256_maskz";
            case 3548L: return "bfk_ia32_vpdpwssd512_mask";
            case 3549L: return "bfk_ia32_vpdpwssd512_maskz";
            case 3550L: return "bfk_ia32_vpdpwssd_v16si";
            case 3551L: return "bfk_ia32_vpdpwssd_v16si_mask";
            case 3552L: return "bfk_ia32_vpdpwssd_v16si_maskz";
            case 3553L: return "bfk_ia32_vpdpwssd_v4si";
            case 3554L: return "bfk_ia32_vpdpwssd_v4si_mask";
            case 3555L: return "bfk_ia32_vpdpwssd_v4si_maskz";
            case 3556L: return "bfk_ia32_vpdpwssd_v8si";
            case 3557L: return "bfk_ia32_vpdpwssd_v8si_mask";
            case 3558L: return "bfk_ia32_vpdpwssd_v8si_maskz";
            case 3559L: return "bfk_ia32_vpdpwssds128_mask";
            case 3560L: return "bfk_ia32_vpdpwssds128_maskz";
            case 3561L: return "bfk_ia32_vpdpwssds256_mask";
            case 3562L: return "bfk_ia32_vpdpwssds256_maskz";
            case 3563L: return "bfk_ia32_vpdpwssds512_mask";
            case 3564L: return "bfk_ia32_vpdpwssds512_maskz";
            case 3565L: return "bfk_ia32_vpdpwssds_v16si";
            case 3566L: return "bfk_ia32_vpdpwssds_v16si_mask";
            case 3567L: return "bfk_ia32_vpdpwssds_v16si_maskz";
            case 3568L: return "bfk_ia32_vpdpwssds_v4si";
            case 3569L: return "bfk_ia32_vpdpwssds_v4si_mask";
            case 3570L: return "bfk_ia32_vpdpwssds_v4si_maskz";
            case 3571L: return "bfk_ia32_vpdpwssds_v8si";
            case 3572L: return "bfk_ia32_vpdpwssds_v8si_mask";
            case 3573L: return "bfk_ia32_vpdpwssds_v8si_maskz";
            case 3574L: return "bfk_ia32_vperm2f128_pd256";
            case 3575L: return "bfk_ia32_vperm2f128_ps256";
            case 3576L: return "bfk_ia32_vperm2f128_si256";
            case 3577L: return "bfk_ia32_vpermi2vard128_mask";
            case 3578L: return "bfk_ia32_vpermi2vard256_mask";
            case 3579L: return "bfk_ia32_vpermi2vard512_mask";
            case 3580L: return "bfk_ia32_vpermi2varhi128_mask";
            case 3581L: return "bfk_ia32_vpermi2varhi256_mask";
            case 3582L: return "bfk_ia32_vpermi2varhi512_mask";
            case 3583L: return "bfk_ia32_vpermi2varpd128_mask";
            case 3584L: return "bfk_ia32_vpermi2varpd256_mask";
            case 3585L: return "bfk_ia32_vpermi2varpd512_mask";
            case 3586L: return "bfk_ia32_vpermi2varps128_mask";
            case 3587L: return "bfk_ia32_vpermi2varps256_mask";
            case 3588L: return "bfk_ia32_vpermi2varps512_mask";
            case 3589L: return "bfk_ia32_vpermi2varq128_mask";
            case 3590L: return "bfk_ia32_vpermi2varq256_mask";
            case 3591L: return "bfk_ia32_vpermi2varq512_mask";
            case 3592L: return "bfk_ia32_vpermi2varqi128_mask";
            case 3593L: return "bfk_ia32_vpermi2varqi256_mask";
            case 3594L: return "bfk_ia32_vpermi2varqi512_mask";
            case 3595L: return "bfk_ia32_vpermil2pd";
            case 3596L: return "bfk_ia32_vpermil2pd256";
            case 3597L: return "bfk_ia32_vpermil2ps";
            case 3598L: return "bfk_ia32_vpermil2ps256";
            case 3599L: return "bfk_ia32_vpermilpd";
            case 3600L: return "bfk_ia32_vpermilpd256";
            case 3601L: return "bfk_ia32_vpermilpd256_mask";
            case 3602L: return "bfk_ia32_vpermilpd512_mask";
            case 3603L: return "bfk_ia32_vpermilpd_mask";
            case 3604L: return "bfk_ia32_vpermilps";
            case 3605L: return "bfk_ia32_vpermilps256";
            case 3606L: return "bfk_ia32_vpermilps256_mask";
            case 3607L: return "bfk_ia32_vpermilps512_mask";
            case 3608L: return "bfk_ia32_vpermilps_mask";
            case 3609L: return "bfk_ia32_vpermilvarpd";
            case 3610L: return "bfk_ia32_vpermilvarpd256";
            case 3611L: return "bfk_ia32_vpermilvarpd256_mask";
            case 3612L: return "bfk_ia32_vpermilvarpd512";
            case 3613L: return "bfk_ia32_vpermilvarpd512_mask";
            case 3614L: return "bfk_ia32_vpermilvarpd_mask";
            case 3615L: return "bfk_ia32_vpermilvarps";
            case 3616L: return "bfk_ia32_vpermilvarps256";
            case 3617L: return "bfk_ia32_vpermilvarps256_mask";
            case 3618L: return "bfk_ia32_vpermilvarps512";
            case 3619L: return "bfk_ia32_vpermilvarps512_mask";
            case 3620L: return "bfk_ia32_vpermilvarps_mask";
            case 3621L: return "bfk_ia32_vpermt2vard128_mask";
            case 3622L: return "bfk_ia32_vpermt2vard128_maskz";
            case 3623L: return "bfk_ia32_vpermt2vard256_mask";
            case 3624L: return "bfk_ia32_vpermt2vard256_maskz";
            case 3625L: return "bfk_ia32_vpermt2vard512_mask";
            case 3626L: return "bfk_ia32_vpermt2vard512_maskz";
            case 3627L: return "bfk_ia32_vpermt2varhi128_mask";
            case 3628L: return "bfk_ia32_vpermt2varhi128_maskz";
            case 3629L: return "bfk_ia32_vpermt2varhi256_mask";
            case 3630L: return "bfk_ia32_vpermt2varhi256_maskz";
            case 3631L: return "bfk_ia32_vpermt2varhi512_mask";
            case 3632L: return "bfk_ia32_vpermt2varhi512_maskz";
            case 3633L: return "bfk_ia32_vpermt2varpd128_mask";
            case 3634L: return "bfk_ia32_vpermt2varpd128_maskz";
            case 3635L: return "bfk_ia32_vpermt2varpd256_mask";
            case 3636L: return "bfk_ia32_vpermt2varpd256_maskz";
            case 3637L: return "bfk_ia32_vpermt2varpd512_mask";
            case 3638L: return "bfk_ia32_vpermt2varpd512_maskz";
            case 3639L: return "bfk_ia32_vpermt2varps128_mask";
            case 3640L: return "bfk_ia32_vpermt2varps128_maskz";
            case 3641L: return "bfk_ia32_vpermt2varps256_mask";
            case 3642L: return "bfk_ia32_vpermt2varps256_maskz";
            case 3643L: return "bfk_ia32_vpermt2varps512_mask";
            case 3644L: return "bfk_ia32_vpermt2varps512_maskz";
            case 3645L: return "bfk_ia32_vpermt2varq128_mask";
            case 3646L: return "bfk_ia32_vpermt2varq128_maskz";
            case 3647L: return "bfk_ia32_vpermt2varq256_mask";
            case 3648L: return "bfk_ia32_vpermt2varq256_maskz";
            case 3649L: return "bfk_ia32_vpermt2varq512_mask";
            case 3650L: return "bfk_ia32_vpermt2varq512_maskz";
            case 3651L: return "bfk_ia32_vpermt2varqi128_mask";
            case 3652L: return "bfk_ia32_vpermt2varqi128_maskz";
            case 3653L: return "bfk_ia32_vpermt2varqi256_mask";
            case 3654L: return "bfk_ia32_vpermt2varqi256_maskz";
            case 3655L: return "bfk_ia32_vpermt2varqi512_mask";
            case 3656L: return "bfk_ia32_vpermt2varqi512_maskz";
            case 3657L: return "bfk_ia32_vphaddbd";
            case 3658L: return "bfk_ia32_vphaddbq";
            case 3659L: return "bfk_ia32_vphaddbw";
            case 3660L: return "bfk_ia32_vphadddq";
            case 3661L: return "bfk_ia32_vphaddubd";
            case 3662L: return "bfk_ia32_vphaddubq";
            case 3663L: return "bfk_ia32_vphaddubw";
            case 3664L: return "bfk_ia32_vphaddudq";
            case 3665L: return "bfk_ia32_vphadduwd";
            case 3666L: return "bfk_ia32_vphadduwq";
            case 3667L: return "bfk_ia32_vphaddwd";
            case 3668L: return "bfk_ia32_vphaddwq";
            case 3669L: return "bfk_ia32_vphsubbw";
            case 3670L: return "bfk_ia32_vphsubdq";
            case 3671L: return "bfk_ia32_vphsubwd";
            case 3672L: return "bfk_ia32_vplzcntd_128_mask";
            case 3673L: return "bfk_ia32_vplzcntd_256_mask";
            case 3674L: return "bfk_ia32_vplzcntd_512_mask";
            case 3675L: return "bfk_ia32_vplzcntq_128_mask";
            case 3676L: return "bfk_ia32_vplzcntq_256_mask";
            case 3677L: return "bfk_ia32_vplzcntq_512_mask";
            case 3678L: return "bfk_ia32_vpmacsdd";
            case 3679L: return "bfk_ia32_vpmacsdqh";
            case 3680L: return "bfk_ia32_vpmacsdql";
            case 3681L: return "bfk_ia32_vpmacssdd";
            case 3682L: return "bfk_ia32_vpmacssdqh";
            case 3683L: return "bfk_ia32_vpmacssdql";
            case 3684L: return "bfk_ia32_vpmacsswd";
            case 3685L: return "bfk_ia32_vpmacssww";
            case 3686L: return "bfk_ia32_vpmacswd";
            case 3687L: return "bfk_ia32_vpmacsww";
            case 3688L: return "bfk_ia32_vpmadcsswd";
            case 3689L: return "bfk_ia32_vpmadcswd";
            case 3690L: return "bfk_ia32_vpmadd52huq128_mask";
            case 3691L: return "bfk_ia32_vpmadd52huq128_maskz";
            case 3692L: return "bfk_ia32_vpmadd52huq256_mask";
            case 3693L: return "bfk_ia32_vpmadd52huq256_maskz";
            case 3694L: return "bfk_ia32_vpmadd52huq512_mask";
            case 3695L: return "bfk_ia32_vpmadd52huq512_maskz";
            case 3696L: return "bfk_ia32_vpmadd52luq128_mask";
            case 3697L: return "bfk_ia32_vpmadd52luq128_maskz";
            case 3698L: return "bfk_ia32_vpmadd52luq256_mask";
            case 3699L: return "bfk_ia32_vpmadd52luq256_maskz";
            case 3700L: return "bfk_ia32_vpmadd52luq512_mask";
            case 3701L: return "bfk_ia32_vpmadd52luq512_maskz";
            case 3702L: return "bfk_ia32_vpmultishiftqb128_mask";
            case 3703L: return "bfk_ia32_vpmultishiftqb256_mask";
            case 3704L: return "bfk_ia32_vpmultishiftqb512_mask";
            case 3705L: return "bfk_ia32_vpopcntb_128";
            case 3706L: return "bfk_ia32_vpopcntb_256";
            case 3707L: return "bfk_ia32_vpopcntb_512";
            case 3708L: return "bfk_ia32_vpopcntd_128";
            case 3709L: return "bfk_ia32_vpopcntd_256";
            case 3710L: return "bfk_ia32_vpopcntd_512";
            case 3711L: return "bfk_ia32_vpopcntq_128";
            case 3712L: return "bfk_ia32_vpopcntq_256";
            case 3713L: return "bfk_ia32_vpopcntq_512";
            case 3714L: return "bfk_ia32_vpopcntw_128";
            case 3715L: return "bfk_ia32_vpopcntw_256";
            case 3716L: return "bfk_ia32_vpopcntw_512";
            case 3717L: return "bfk_ia32_vpopcountb_v16qi";
            case 3718L: return "bfk_ia32_vpopcountb_v16qi_mask";
            case 3719L: return "bfk_ia32_vpopcountb_v32qi";
            case 3720L: return "bfk_ia32_vpopcountb_v32qi_mask";
            case 3721L: return "bfk_ia32_vpopcountb_v64qi";
            case 3722L: return "bfk_ia32_vpopcountb_v64qi_mask";
            case 3723L: return "bfk_ia32_vpopcountd_v16si";
            case 3724L: return "bfk_ia32_vpopcountd_v16si_mask";
            case 3725L: return "bfk_ia32_vpopcountd_v4si";
            case 3726L: return "bfk_ia32_vpopcountd_v4si_mask";
            case 3727L: return "bfk_ia32_vpopcountd_v8si";
            case 3728L: return "bfk_ia32_vpopcountd_v8si_mask";
            case 3729L: return "bfk_ia32_vpopcountq_v2di";
            case 3730L: return "bfk_ia32_vpopcountq_v2di_mask";
            case 3731L: return "bfk_ia32_vpopcountq_v4di";
            case 3732L: return "bfk_ia32_vpopcountq_v4di_mask";
            case 3733L: return "bfk_ia32_vpopcountq_v8di";
            case 3734L: return "bfk_ia32_vpopcountq_v8di_mask";
            case 3735L: return "bfk_ia32_vpopcountw_v16hi";
            case 3736L: return "bfk_ia32_vpopcountw_v16hi_mask";
            case 3737L: return "bfk_ia32_vpopcountw_v32hi";
            case 3738L: return "bfk_ia32_vpopcountw_v32hi_mask";
            case 3739L: return "bfk_ia32_vpopcountw_v8hi";
            case 3740L: return "bfk_ia32_vpopcountw_v8hi_mask";
            case 3741L: return "bfk_ia32_vpperm";
            case 3742L: return "bfk_ia32_vprotb";
            case 3743L: return "bfk_ia32_vprotbi";
            case 3744L: return "bfk_ia32_vprotd";
            case 3745L: return "bfk_ia32_vprotdi";
            case 3746L: return "bfk_ia32_vprotq";
            case 3747L: return "bfk_ia32_vprotqi";
            case 3748L: return "bfk_ia32_vprotw";
            case 3749L: return "bfk_ia32_vprotwi";
            case 3750L: return "bfk_ia32_vpshab";
            case 3751L: return "bfk_ia32_vpshad";
            case 3752L: return "bfk_ia32_vpshaq";
            case 3753L: return "bfk_ia32_vpshaw";
            case 3754L: return "bfk_ia32_vpshlb";
            case 3755L: return "bfk_ia32_vpshld";
            case 3756L: return "bfk_ia32_vpshld_v16hi";
            case 3757L: return "bfk_ia32_vpshld_v16hi_mask";
            case 3758L: return "bfk_ia32_vpshld_v16si";
            case 3759L: return "bfk_ia32_vpshld_v16si_mask";
            case 3760L: return "bfk_ia32_vpshld_v2di";
            case 3761L: return "bfk_ia32_vpshld_v2di_mask";
            case 3762L: return "bfk_ia32_vpshld_v32hi";
            case 3763L: return "bfk_ia32_vpshld_v32hi_mask";
            case 3764L: return "bfk_ia32_vpshld_v4di";
            case 3765L: return "bfk_ia32_vpshld_v4di_mask";
            case 3766L: return "bfk_ia32_vpshld_v4si";
            case 3767L: return "bfk_ia32_vpshld_v4si_mask";
            case 3768L: return "bfk_ia32_vpshld_v8di";
            case 3769L: return "bfk_ia32_vpshld_v8di_mask";
            case 3770L: return "bfk_ia32_vpshld_v8hi";
            case 3771L: return "bfk_ia32_vpshld_v8hi_mask";
            case 3772L: return "bfk_ia32_vpshld_v8si";
            case 3773L: return "bfk_ia32_vpshld_v8si_mask";
            case 3774L: return "bfk_ia32_vpshldd128_mask";
            case 3775L: return "bfk_ia32_vpshldd256_mask";
            case 3776L: return "bfk_ia32_vpshldd512_mask";
            case 3777L: return "bfk_ia32_vpshldq128_mask";
            case 3778L: return "bfk_ia32_vpshldq256_mask";
            case 3779L: return "bfk_ia32_vpshldq512_mask";
            case 3780L: return "bfk_ia32_vpshldv_v16hi";
            case 3781L: return "bfk_ia32_vpshldv_v16hi_mask";
            case 3782L: return "bfk_ia32_vpshldv_v16hi_maskz";
            case 3783L: return "bfk_ia32_vpshldv_v16si";
            case 3784L: return "bfk_ia32_vpshldv_v16si_mask";
            case 3785L: return "bfk_ia32_vpshldv_v16si_maskz";
            case 3786L: return "bfk_ia32_vpshldv_v2di";
            case 3787L: return "bfk_ia32_vpshldv_v2di_mask";
            case 3788L: return "bfk_ia32_vpshldv_v2di_maskz";
            case 3789L: return "bfk_ia32_vpshldv_v32hi";
            case 3790L: return "bfk_ia32_vpshldv_v32hi_mask";
            case 3791L: return "bfk_ia32_vpshldv_v32hi_maskz";
            case 3792L: return "bfk_ia32_vpshldv_v4di";
            case 3793L: return "bfk_ia32_vpshldv_v4di_mask";
            case 3794L: return "bfk_ia32_vpshldv_v4di_maskz";
            case 3795L: return "bfk_ia32_vpshldv_v4si";
            case 3796L: return "bfk_ia32_vpshldv_v4si_mask";
            case 3797L: return "bfk_ia32_vpshldv_v4si_maskz";
            case 3798L: return "bfk_ia32_vpshldv_v8di";
            case 3799L: return "bfk_ia32_vpshldv_v8di_mask";
            case 3800L: return "bfk_ia32_vpshldv_v8di_maskz";
            case 3801L: return "bfk_ia32_vpshldv_v8hi";
            case 3802L: return "bfk_ia32_vpshldv_v8hi_mask";
            case 3803L: return "bfk_ia32_vpshldv_v8hi_maskz";
            case 3804L: return "bfk_ia32_vpshldv_v8si";
            case 3805L: return "bfk_ia32_vpshldv_v8si_mask";
            case 3806L: return "bfk_ia32_vpshldv_v8si_maskz";
            case 3807L: return "bfk_ia32_vpshldvd128_mask";
            case 3808L: return "bfk_ia32_vpshldvd128_maskz";
            case 3809L: return "bfk_ia32_vpshldvd256_mask";
            case 3810L: return "bfk_ia32_vpshldvd256_maskz";
            case 3811L: return "bfk_ia32_vpshldvd512_mask";
            case 3812L: return "bfk_ia32_vpshldvd512_maskz";
            case 3813L: return "bfk_ia32_vpshldvq128_mask";
            case 3814L: return "bfk_ia32_vpshldvq128_maskz";
            case 3815L: return "bfk_ia32_vpshldvq256_mask";
            case 3816L: return "bfk_ia32_vpshldvq256_maskz";
            case 3817L: return "bfk_ia32_vpshldvq512_mask";
            case 3818L: return "bfk_ia32_vpshldvq512_maskz";
            case 3819L: return "bfk_ia32_vpshldvw128_mask";
            case 3820L: return "bfk_ia32_vpshldvw128_maskz";
            case 3821L: return "bfk_ia32_vpshldvw256_mask";
            case 3822L: return "bfk_ia32_vpshldvw256_maskz";
            case 3823L: return "bfk_ia32_vpshldvw512_mask";
            case 3824L: return "bfk_ia32_vpshldvw512_maskz";
            case 3825L: return "bfk_ia32_vpshldw128_mask";
            case 3826L: return "bfk_ia32_vpshldw256_mask";
            case 3827L: return "bfk_ia32_vpshldw512_mask";
            case 3828L: return "bfk_ia32_vpshlq";
            case 3829L: return "bfk_ia32_vpshlw";
            case 3830L: return "bfk_ia32_vpshrd_v16hi";
            case 3831L: return "bfk_ia32_vpshrd_v16hi_mask";
            case 3832L: return "bfk_ia32_vpshrd_v16si";
            case 3833L: return "bfk_ia32_vpshrd_v16si_mask";
            case 3834L: return "bfk_ia32_vpshrd_v2di";
            case 3835L: return "bfk_ia32_vpshrd_v2di_mask";
            case 3836L: return "bfk_ia32_vpshrd_v32hi";
            case 3837L: return "bfk_ia32_vpshrd_v32hi_mask";
            case 3838L: return "bfk_ia32_vpshrd_v4di";
            case 3839L: return "bfk_ia32_vpshrd_v4di_mask";
            case 3840L: return "bfk_ia32_vpshrd_v4si";
            case 3841L: return "bfk_ia32_vpshrd_v4si_mask";
            case 3842L: return "bfk_ia32_vpshrd_v8di";
            case 3843L: return "bfk_ia32_vpshrd_v8di_mask";
            case 3844L: return "bfk_ia32_vpshrd_v8hi";
            case 3845L: return "bfk_ia32_vpshrd_v8hi_mask";
            case 3846L: return "bfk_ia32_vpshrd_v8si";
            case 3847L: return "bfk_ia32_vpshrd_v8si_mask";
            case 3848L: return "bfk_ia32_vpshrdd128_mask";
            case 3849L: return "bfk_ia32_vpshrdd256_mask";
            case 3850L: return "bfk_ia32_vpshrdd512_mask";
            case 3851L: return "bfk_ia32_vpshrdq128_mask";
            case 3852L: return "bfk_ia32_vpshrdq256_mask";
            case 3853L: return "bfk_ia32_vpshrdq512_mask";
            case 3854L: return "bfk_ia32_vpshrdv_v16hi";
            case 3855L: return "bfk_ia32_vpshrdv_v16hi_mask";
            case 3856L: return "bfk_ia32_vpshrdv_v16hi_maskz";
            case 3857L: return "bfk_ia32_vpshrdv_v16si";
            case 3858L: return "bfk_ia32_vpshrdv_v16si_mask";
            case 3859L: return "bfk_ia32_vpshrdv_v16si_maskz";
            case 3860L: return "bfk_ia32_vpshrdv_v2di";
            case 3861L: return "bfk_ia32_vpshrdv_v2di_mask";
            case 3862L: return "bfk_ia32_vpshrdv_v2di_maskz";
            case 3863L: return "bfk_ia32_vpshrdv_v32hi";
            case 3864L: return "bfk_ia32_vpshrdv_v32hi_mask";
            case 3865L: return "bfk_ia32_vpshrdv_v32hi_maskz";
            case 3866L: return "bfk_ia32_vpshrdv_v4di";
            case 3867L: return "bfk_ia32_vpshrdv_v4di_mask";
            case 3868L: return "bfk_ia32_vpshrdv_v4di_maskz";
            case 3869L: return "bfk_ia32_vpshrdv_v4si";
            case 3870L: return "bfk_ia32_vpshrdv_v4si_mask";
            case 3871L: return "bfk_ia32_vpshrdv_v4si_maskz";
            case 3872L: return "bfk_ia32_vpshrdv_v8di";
            case 3873L: return "bfk_ia32_vpshrdv_v8di_mask";
            case 3874L: return "bfk_ia32_vpshrdv_v8di_maskz";
            case 3875L: return "bfk_ia32_vpshrdv_v8hi";
            case 3876L: return "bfk_ia32_vpshrdv_v8hi_mask";
            case 3877L: return "bfk_ia32_vpshrdv_v8hi_maskz";
            case 3878L: return "bfk_ia32_vpshrdv_v8si";
            case 3879L: return "bfk_ia32_vpshrdv_v8si_mask";
            case 3880L: return "bfk_ia32_vpshrdv_v8si_maskz";
            case 3881L: return "bfk_ia32_vpshrdvd128_mask";
            case 3882L: return "bfk_ia32_vpshrdvd128_maskz";
            case 3883L: return "bfk_ia32_vpshrdvd256_mask";
            case 3884L: return "bfk_ia32_vpshrdvd256_maskz";
            case 3885L: return "bfk_ia32_vpshrdvd512_mask";
            case 3886L: return "bfk_ia32_vpshrdvd512_maskz";
            case 3887L: return "bfk_ia32_vpshrdvq128_mask";
            case 3888L: return "bfk_ia32_vpshrdvq128_maskz";
            case 3889L: return "bfk_ia32_vpshrdvq256_mask";
            case 3890L: return "bfk_ia32_vpshrdvq256_maskz";
            case 3891L: return "bfk_ia32_vpshrdvq512_mask";
            case 3892L: return "bfk_ia32_vpshrdvq512_maskz";
            case 3893L: return "bfk_ia32_vpshrdvw128_mask";
            case 3894L: return "bfk_ia32_vpshrdvw128_maskz";
            case 3895L: return "bfk_ia32_vpshrdvw256_mask";
            case 3896L: return "bfk_ia32_vpshrdvw256_maskz";
            case 3897L: return "bfk_ia32_vpshrdvw512_mask";
            case 3898L: return "bfk_ia32_vpshrdvw512_maskz";
            case 3899L: return "bfk_ia32_vpshrdw128_mask";
            case 3900L: return "bfk_ia32_vpshrdw256_mask";
            case 3901L: return "bfk_ia32_vpshrdw512_mask";
            case 3902L: return "bfk_ia32_vpshufbitqmb128_mask";
            case 3903L: return "bfk_ia32_vpshufbitqmb256_mask";
            case 3904L: return "bfk_ia32_vpshufbitqmb512_mask";
            case 3905L: return "bfk_ia32_vtestcpd";
            case 3906L: return "bfk_ia32_vtestcpd256";
            case 3907L: return "bfk_ia32_vtestcps";
            case 3908L: return "bfk_ia32_vtestcps256";
            case 3909L: return "bfk_ia32_vtestnzcpd";
            case 3910L: return "bfk_ia32_vtestnzcpd256";
            case 3911L: return "bfk_ia32_vtestnzcps";
            case 3912L: return "bfk_ia32_vtestnzcps256";
            case 3913L: return "bfk_ia32_vtestzpd";
            case 3914L: return "bfk_ia32_vtestzpd256";
            case 3915L: return "bfk_ia32_vtestzps";
            case 3916L: return "bfk_ia32_vtestzps256";
            case 3917L: return "bfk_ia32_vzeroall";
            case 3918L: return "bfk_ia32_vzeroupper";
            case 3919L: return "bfk_ia32_wbinvd";
            case 3920L: return "bfk_ia32_wbnoinvd";
            case 3921L: return "bfk_ia32_wrfsbase32";
            case 3922L: return "bfk_ia32_wrfsbase64";
            case 3923L: return "bfk_ia32_wrgsbase32";
            case 3924L: return "bfk_ia32_wrgsbase64";
            case 3925L: return "bfk_ia32_writeeflags_u32";
            case 3926L: return "bfk_ia32_writeeflags_u64";
            case 3927L: return "bfk_ia32_wrpkru";
            case 3928L: return "bfk_ia32_wrssd";
            case 3929L: return "bfk_ia32_wrssq";
            case 3930L: return "bfk_ia32_wrussd";
            case 3931L: return "bfk_ia32_wrussq";
            case 3932L: return "bfk_ia32_xabort";
            case 3933L: return "bfk_ia32_xbegin";
            case 3934L: return "bfk_ia32_xend";
            case 3935L: return "bfk_ia32_xgetbv";
            case 3936L: return "bfk_ia32_xorpd";
            case 3937L: return "bfk_ia32_xorpd128_mask";
            case 3938L: return "bfk_ia32_xorpd256";
            case 3939L: return "bfk_ia32_xorpd256_mask";
            case 3940L: return "bfk_ia32_xorpd512_mask";
            case 3941L: return "bfk_ia32_xorps";
            case 3942L: return "bfk_ia32_xorps128_mask";
            case 3943L: return "bfk_ia32_xorps256";
            case 3944L: return "bfk_ia32_xorps256_mask";
            case 3945L: return "bfk_ia32_xorps512_mask";
            case 3946L: return "bfk_ia32_xrstor";
            case 3947L: return "bfk_ia32_xrstor64";
            case 3948L: return "bfk_ia32_xrstors";
            case 3949L: return "bfk_ia32_xrstors64";
            case 3950L: return "bfk_ia32_xsave";
            case 3951L: return "bfk_ia32_xsave64";
            case 3952L: return "bfk_ia32_xsavec";
            case 3953L: return "bfk_ia32_xsavec64";
            case 3954L: return "bfk_ia32_xsaveopt";
            case 3955L: return "bfk_ia32_xsaveopt64";
            case 3956L: return "bfk_ia32_xsaves";
            case 3957L: return "bfk_ia32_xsaves64";
            case 3958L: return "bfk_ia32_xsetbv";
            case 3959L: return "bfk_ia32_xtest";
            case 3960L: return "bfk_iceil";
            case 3961L: return "bfk_iceilf";
            case 3962L: return "bfk_iceill";
            case 3963L: return "bfk_ifloor";
            case 3964L: return "bfk_ifloorf";
            case 3965L: return "bfk_ifloorl";
            case 3966L: return "bfk_ilogb";
            case 3967L: return "bfk_ilogbf";
            case 3968L: return "bfk_ilogbl";
            case 3969L: return "bfk_imaxabs";
            case 3970L: return "bfk_index";
            case 3971L: return "bfk_inf";
            case 3972L: return "bfk_inff";
            case 3973L: return "bfk_inff32";
            case 3974L: return "bfk_inff32x";
            case 3975L: return "bfk_inff64";
            case 3976L: return "bfk_inff64x";
            case 3977L: return "bfk_infl";
            case 3978L: return "bfk_init_descriptor";
            case 3979L: return "bfk_init_dwarf_reg_size_table";
            case 3980L: return "bfk_init_heap_trampoline";
            case 3981L: return "bfk_init_trampoline";
            case 3982L: return "bfk_irint";
            case 3983L: return "bfk_irintf";
            case 3984L: return "bfk_irintl";
            case 3985L: return "bfk_iround";
            case 3986L: return "bfk_iroundf";
            case 3987L: return "bfk_iroundl";
            case 3988L: return "bfk_isalnum";
            case 3989L: return "bfk_isalpha";
            case 3990L: return "bfk_isascii";
            case 3991L: return "bfk_isblank";
            case 3992L: return "bfk_iscntrl";
            case 3993L: return "bfk_isdigit";
            case 3994L: return "bfk_isfinite";
            case 3995L: return "bfk_isgraph";
            case 3996L: return "bfk_isgreater";
            case 3997L: return "bfk_isgreaterequal";
            case 3998L: return "bfk_isinf";
            case 3999L: return "bfk_isinf_sign";
            case 4000L: return "bfk_isinff";
            case 4001L: return "bfk_isinfl";
            case 4002L: return "bfk_isless";
            case 4003L: return "bfk_islessequal";
            case 4004L: return "bfk_islessgreater";
            case 4005L: return "bfk_islower";
            case 4006L: return "bfk_isnan";
            case 4007L: return "bfk_isnanf";
            case 4008L: return "bfk_isnanl";
            case 4009L: return "bfk_isnormal";
            case 4010L: return "bfk_isprint";
            case 4011L: return "bfk_ispunct";
            case 4012L: return "bfk_isspace";
            case 4013L: return "bfk_isunordered";
            case 4014L: return "bfk_isupper";
            case 4015L: return "bfk_iswalnum";
            case 4016L: return "bfk_iswalpha";
            case 4017L: return "bfk_iswblank";
            case 4018L: return "bfk_iswcntrl";
            case 4019L: return "bfk_iswdigit";
            case 4020L: return "bfk_iswgraph";
            case 4021L: return "bfk_iswlower";
            case 4022L: return "bfk_iswprint";
            case 4023L: return "bfk_iswpunct";
            case 4024L: return "bfk_iswspace";
            case 4025L: return "bfk_iswupper";
            case 4026L: return "bfk_iswxdigit";
            case 4027L: return "bfk_isxdigit";
            case 4028L: return "bfk_j0";
            case 4029L: return "bfk_j0f";
            case 4030L: return "bfk_j0l";
            case 4031L: return "bfk_j1";
            case 4032L: return "bfk_j1f";
            case 4033L: return "bfk_j1l";
            case 4034L: return "bfk_jn";
            case 4035L: return "bfk_jnf";
            case 4036L: return "bfk_jnl";
            case 4037L: return "bfk_labs";
            case 4038L: return "bfk_lceil";
            case 4039L: return "bfk_lceilf";
            case 4040L: return "bfk_lceill";
            case 4041L: return "bfk_ldexp";
            case 4042L: return "bfk_ldexpf";
            case 4043L: return "bfk_ldexpl";
            case 4044L: return "bfk_lfloor";
            case 4045L: return "bfk_lfloorf";
            case 4046L: return "bfk_lfloorl";
            case 4047L: return "bfk_lgamma";
            case 4048L: return "bfk_lgamma_r";
            case 4049L: return "bfk_lgammaf";
            case 4050L: return "bfk_lgammaf_r";
            case 4051L: return "bfk_lgammal";
            case 4052L: return "bfk_lgammal_r";
            case 4053L: return "bfk_llabs";
            case 4054L: return "bfk_llceil";
            case 4055L: return "bfk_llceilf";
            case 4056L: return "bfk_llceill";
            case 4057L: return "bfk_llfloor";
            case 4058L: return "bfk_llfloorf";
            case 4059L: return "bfk_llfloorl";
            case 4060L: return "bfk_llrint";
            case 4061L: return "bfk_llrintf";
            case 4062L: return "bfk_llrintl";
            case 4063L: return "bfk_llround";
            case 4064L: return "bfk_llroundf";
            case 4065L: return "bfk_llroundl";
            case 4066L: return "bfk_log";
            case 4067L: return "bfk_log10";
            case 4068L: return "bfk_log10f";
            case 4069L: return "bfk_log10l";
            case 4070L: return "bfk_log1p";
            case 4071L: return "bfk_log1pf";
            case 4072L: return "bfk_log1pl";
            case 4073L: return "bfk_log2";
            case 4074L: return "bfk_log2f";
            case 4075L: return "bfk_log2l";
            case 4076L: return "bfk_logb";
            case 4077L: return "bfk_logbf";
            case 4078L: return "bfk_logbl";
            case 4079L: return "bfk_logf";
            case 4080L: return "bfk_logl";
            case 4081L: return "bfk_longjmp";
            case 4082L: return "bfk_lrint";
            case 4083L: return "bfk_lrintf";
            case 4084L: return "bfk_lrintl";
            case 4085L: return "bfk_lround";
            case 4086L: return "bfk_lroundf";
            case 4087L: return "bfk_lroundl";
            case 4088L: return "bfk_malloc";
            case 4089L: return "bfk_memchr";
            case 4090L: return "bfk_memcmp";
            case 4091L: return "bfk_memcmp_eq";
            case 4092L: return "bfk_memcpy";
            case 4093L: return "bfk_memmove";
            case 4094L: return "bfk_mempcpy";
            case 4095L: return "bfk_memset";
            case 4096L: return "bfk_modf";
            case 4097L: return "bfk_modff";
            case 4098L: return "bfk_modfl";
            case 4099L: return "bfk_ms_va_copy";
            case 4100L: return "bfk_ms_va_end";
            case 4101L: return "bfk_ms_va_start";
            case 4102L: return "bfk_mul_overflow";
            case 4103L: return "bfk_mul_overflow_p";
            case 4104L: return "bfk_nan";
            case 4105L: return "bfk_nanf";
            case 4106L: return "bfk_nanf32";
            case 4107L: return "bfk_nanf32x";
            case 4108L: return "bfk_nanf64";
            case 4109L: return "bfk_nanf64x";
            case 4110L: return "bfk_nanl";
            case 4111L: return "bfk_nans";
            case 4112L: return "bfk_nansf";
            case 4113L: return "bfk_nansf32";
            case 4114L: return "bfk_nansf32x";
            case 4115L: return "bfk_nansf64";
            case 4116L: return "bfk_nansf64x";
            case 4117L: return "bfk_nansl";
            case 4118L: return "bfk_nearbyint";
            case 4119L: return "bfk_nearbyintf";
            case 4120L: return "bfk_nearbyintf32";
            case 4121L: return "bfk_nearbyintf32x";
            case 4122L: return "bfk_nearbyintf64";
            case 4123L: return "bfk_nearbyintf64x";
            case 4124L: return "bfk_nearbyintl";
            case 4125L: return "bfk_next_arg";
            case 4126L: return "bfk_nextafter";
            case 4127L: return "bfk_nextafterf";
            case 4128L: return "bfk_nextafterl";
            case 4129L: return "bfk_nexttoward";
            case 4130L: return "bfk_nexttowardf";
            case 4131L: return "bfk_nexttowardl";
            case 4132L: return "bfk_nonlocal_goto";
            case 4133L: return "bfk_nontemporal_load";
            case 4134L: return "bfk_nontemporal_store";
            case 4135L: return "bfk_objc_memmove_collectable";
            case 4136L: return "bfk_object_size";
            case 4137L: return "bfk_omp_get_num_teams";
            case 4138L: return "bfk_omp_get_num_threads";
            case 4139L: return "bfk_omp_get_team_num";
            case 4140L: return "bfk_omp_get_thread_num";
            case 4141L: return "bfk_operator_delete";
            case 4142L: return "bfk_operator_new";
            case 4143L: return "bfk_os_log_format";
            case 4144L: return "bfk_os_log_format_buffer_size";
            case 4145L: return "bfk_parity";
            case 4146L: return "bfk_parityimax";
            case 4147L: return "bfk_parityl";
            case 4148L: return "bfk_parityll";
            case 4149L: return "bfk_popcount";
            case 4150L: return "bfk_popcountimax";
            case 4151L: return "bfk_popcountl";
            case 4152L: return "bfk_popcountll";
            case 4153L: return "bfk_posix_memalign";
            case 4154L: return "bfk_pow";
            case 4155L: return "bfk_pow10";
            case 4156L: return "bfk_pow10f";
            case 4157L: return "bfk_pow10l";
            case 4158L: return "bfk_powf";
            case 4159L: return "bfk_powi";
            case 4160L: return "bfk_powif";
            case 4161L: return "bfk_powil";
            case 4162L: return "bfk_powl";
            case 4163L: return "bfk_prefetch";
            case 4164L: return "bfk_printf";
            case 4165L: return "bfk_printf_unlocked";
            case 4166L: return "bfk_profile_func_enter";
            case 4167L: return "bfk_profile_func_exit";
            case 4168L: return "bfk_putc";
            case 4169L: return "bfk_putc_unlocked";
            case 4170L: return "bfk_putchar";
            case 4171L: return "bfk_putchar_unlocked";
            case 4172L: return "bfk_puts";
            case 4173L: return "bfk_puts_unlocked";
            case 4174L: return "bfk_readcyclecounter";
            case 4175L: return "bfk_realloc";
            case 4176L: return "bfk_remainder";
            case 4177L: return "bfk_remainderf";
            case 4178L: return "bfk_remainderl";
            case 4179L: return "bfk_remquo";
            case 4180L: return "bfk_remquof";
            case 4181L: return "bfk_remquol";
            case 4182L: return "bfk_return";
            case 4183L: return "bfk_return_address";
            case 4184L: return "bfk_rindex";
            case 4185L: return "bfk_rint";
            case 4186L: return "bfk_rintf";
            case 4187L: return "bfk_rintf32";
            case 4188L: return "bfk_rintf32x";
            case 4189L: return "bfk_rintf64";
            case 4190L: return "bfk_rintf64x";
            case 4191L: return "bfk_rintl";
            case 4192L: return "bfk_round";
            case 4193L: return "bfk_roundf";
            case 4194L: return "bfk_roundf32";
            case 4195L: return "bfk_roundf32x";
            case 4196L: return "bfk_roundf64";
            case 4197L: return "bfk_roundf64x";
            case 4198L: return "bfk_roundl";
            case 4199L: return "bfk_sadd_overflow";
            case 4200L: return "bfk_saddl_overflow";
            case 4201L: return "bfk_saddll_overflow";
            case 4202L: return "bfk_saveregs";
            case 4203L: return "bfk_scalb";
            case 4204L: return "bfk_scalbf";
            case 4205L: return "bfk_scalbl";
            case 4206L: return "bfk_scalbln";
            case 4207L: return "bfk_scalblnf";
            case 4208L: return "bfk_scalblnl";
            case 4209L: return "bfk_scalbn";
            case 4210L: return "bfk_scalbnf";
            case 4211L: return "bfk_scalbnl";
            case 4212L: return "bfk_scanf";
            case 4213L: return "bfk_set_thread_pointer";
            case 4214L: return "bfk_setjmp";
            case 4215L: return "bfk_setjmp_dispatcher";
            case 4216L: return "bfk_setjmp_receiver";
            case 4217L: return "bfk_setjmp_setup";
            case 4218L: return "bfk_shufflevector";
            case 4219L: return "bfk_signbit";
            case 4220L: return "bfk_signbitf";
            case 4221L: return "bfk_signbitl";
            case 4222L: return "bfk_significand";
            case 4223L: return "bfk_significandf";
            case 4224L: return "bfk_significandl";
            case 4225L: return "bfk_sin";
            case 4226L: return "bfk_sincos";
            case 4227L: return "bfk_sincosf";
            case 4228L: return "bfk_sincosl";
            case 4229L: return "bfk_sinf";
            case 4230L: return "bfk_sinh";
            case 4231L: return "bfk_sinhf";
            case 4232L: return "bfk_sinhl";
            case 4233L: return "bfk_sinl";
            case 4234L: return "bfk_smul_overflow";
            case 4235L: return "bfk_smull_overflow";
            case 4236L: return "bfk_smulll_overflow";
            case 4237L: return "bfk_snprintf";
            case 4238L: return "bfk_sprintf";
            case 4239L: return "bfk_sqrt";
            case 4240L: return "bfk_sqrtf";
            case 4241L: return "bfk_sqrtf32";
            case 4242L: return "bfk_sqrtf32x";
            case 4243L: return "bfk_sqrtf64";
            case 4244L: return "bfk_sqrtf64x";
            case 4245L: return "bfk_sqrtl";
            case 4246L: return "bfk_sscanf";
            case 4247L: return "bfk_ssub_overflow";
            case 4248L: return "bfk_ssubl_overflow";
            case 4249L: return "bfk_ssubll_overflow";
            case 4250L: return "bfk_stack_restore";
            case 4251L: return "bfk_stack_save";
            case 4252L: return "bfk_stdarg_start";
            case 4253L: return "bfk_stpcpy";
            case 4254L: return "bfk_stpncpy";
            case 4255L: return "bfk_strcasecmp";
            case 4256L: return "bfk_strcat";
            case 4257L: return "bfk_strchr";
            case 4258L: return "bfk_strcmp";
            case 4259L: return "bfk_strcpy";
            case 4260L: return "bfk_strcspn";
            case 4261L: return "bfk_strdup";
            case 4262L: return "bfk_strerror";
            case 4263L: return "bfk_strfmon";
            case 4264L: return "bfk_strftime";
            case 4265L: return "bfk_strlcat";
            case 4266L: return "bfk_strlcpy";
            case 4267L: return "bfk_strlen";
            case 4268L: return "bfk_strncasecmp";
            case 4269L: return "bfk_strncat";
            case 4270L: return "bfk_strncmp";
            case 4271L: return "bfk_strncpy";
            case 4272L: return "bfk_strndup";
            case 4273L: return "bfk_strpbrk";
            case 4274L: return "bfk_strrchr";
            case 4275L: return "bfk_strspn";
            case 4276L: return "bfk_strstr";
            case 4277L: return "bfk_strtok";
            case 4278L: return "bfk_strxfrm";
            case 4279L: return "bfk_sub_overflow";
            case 4280L: return "bfk_sub_overflow_p";
            case 4281L: return "bfk_subc";
            case 4282L: return "bfk_subcb";
            case 4283L: return "bfk_subcl";
            case 4284L: return "bfk_subcll";
            case 4285L: return "bfk_subcs";
            case 4286L: return "bfk_sync_add_and_fetch";
            case 4287L: return "bfk_sync_add_and_fetch_1";
            case 4288L: return "bfk_sync_add_and_fetch_16";
            case 4289L: return "bfk_sync_add_and_fetch_2";
            case 4290L: return "bfk_sync_add_and_fetch_4";
            case 4291L: return "bfk_sync_add_and_fetch_8";
            case 4292L: return "bfk_sync_and_and_fetch";
            case 4293L: return "bfk_sync_and_and_fetch_1";
            case 4294L: return "bfk_sync_and_and_fetch_16";
            case 4295L: return "bfk_sync_and_and_fetch_2";
            case 4296L: return "bfk_sync_and_and_fetch_4";
            case 4297L: return "bfk_sync_and_and_fetch_8";
            case 4298L: return "bfk_sync_bool_compare_and_swap";
            case 4299L: return "bfk_sync_bool_compare_and_swap_1";
            case 4300L: return "bfk_sync_bool_compare_and_swap_16";
            case 4301L: return "bfk_sync_bool_compare_and_swap_2";
            case 4302L: return "bfk_sync_bool_compare_and_swap_4";
            case 4303L: return "bfk_sync_bool_compare_and_swap_8";
            case 4304L: return "bfk_sync_fetch_and_add";
            case 4305L: return "bfk_sync_fetch_and_add_1";
            case 4306L: return "bfk_sync_fetch_and_add_16";
            case 4307L: return "bfk_sync_fetch_and_add_2";
            case 4308L: return "bfk_sync_fetch_and_add_4";
            case 4309L: return "bfk_sync_fetch_and_add_8";
            case 4310L: return "bfk_sync_fetch_and_and";
            case 4311L: return "bfk_sync_fetch_and_and_1";
            case 4312L: return "bfk_sync_fetch_and_and_16";
            case 4313L: return "bfk_sync_fetch_and_and_2";
            case 4314L: return "bfk_sync_fetch_and_and_4";
            case 4315L: return "bfk_sync_fetch_and_and_8";
            case 4316L: return "bfk_sync_fetch_and_max";
            case 4317L: return "bfk_sync_fetch_and_min";
            case 4318L: return "bfk_sync_fetch_and_nand";
            case 4319L: return "bfk_sync_fetch_and_nand_1";
            case 4320L: return "bfk_sync_fetch_and_nand_16";
            case 4321L: return "bfk_sync_fetch_and_nand_2";
            case 4322L: return "bfk_sync_fetch_and_nand_4";
            case 4323L: return "bfk_sync_fetch_and_nand_8";
            case 4324L: return "bfk_sync_fetch_and_or";
            case 4325L: return "bfk_sync_fetch_and_or_1";
            case 4326L: return "bfk_sync_fetch_and_or_16";
            case 4327L: return "bfk_sync_fetch_and_or_2";
            case 4328L: return "bfk_sync_fetch_and_or_4";
            case 4329L: return "bfk_sync_fetch_and_or_8";
            case 4330L: return "bfk_sync_fetch_and_sub";
            case 4331L: return "bfk_sync_fetch_and_sub_1";
            case 4332L: return "bfk_sync_fetch_and_sub_16";
            case 4333L: return "bfk_sync_fetch_and_sub_2";
            case 4334L: return "bfk_sync_fetch_and_sub_4";
            case 4335L: return "bfk_sync_fetch_and_sub_8";
            case 4336L: return "bfk_sync_fetch_and_umax";
            case 4337L: return "bfk_sync_fetch_and_umin";
            case 4338L: return "bfk_sync_fetch_and_xor";
            case 4339L: return "bfk_sync_fetch_and_xor_1";
            case 4340L: return "bfk_sync_fetch_and_xor_16";
            case 4341L: return "bfk_sync_fetch_and_xor_2";
            case 4342L: return "bfk_sync_fetch_and_xor_4";
            case 4343L: return "bfk_sync_fetch_and_xor_8";
            case 4344L: return "bfk_sync_lock_release";
            case 4345L: return "bfk_sync_lock_release_1";
            case 4346L: return "bfk_sync_lock_release_16";
            case 4347L: return "bfk_sync_lock_release_2";
            case 4348L: return "bfk_sync_lock_release_4";
            case 4349L: return "bfk_sync_lock_release_8";
            case 4350L: return "bfk_sync_lock_test_and_set";
            case 4351L: return "bfk_sync_lock_test_and_set_1";
            case 4352L: return "bfk_sync_lock_test_and_set_16";
            case 4353L: return "bfk_sync_lock_test_and_set_2";
            case 4354L: return "bfk_sync_lock_test_and_set_4";
            case 4355L: return "bfk_sync_lock_test_and_set_8";
            case 4356L: return "bfk_sync_nand_and_fetch";
            case 4357L: return "bfk_sync_nand_and_fetch_1";
            case 4358L: return "bfk_sync_nand_and_fetch_16";
            case 4359L: return "bfk_sync_nand_and_fetch_2";
            case 4360L: return "bfk_sync_nand_and_fetch_4";
            case 4361L: return "bfk_sync_nand_and_fetch_8";
            case 4362L: return "bfk_sync_or_and_fetch";
            case 4363L: return "bfk_sync_or_and_fetch_1";
            case 4364L: return "bfk_sync_or_and_fetch_16";
            case 4365L: return "bfk_sync_or_and_fetch_2";
            case 4366L: return "bfk_sync_or_and_fetch_4";
            case 4367L: return "bfk_sync_or_and_fetch_8";
            case 4368L: return "bfk_sync_sub_and_fetch";
            case 4369L: return "bfk_sync_sub_and_fetch_1";
            case 4370L: return "bfk_sync_sub_and_fetch_16";
            case 4371L: return "bfk_sync_sub_and_fetch_2";
            case 4372L: return "bfk_sync_sub_and_fetch_4";
            case 4373L: return "bfk_sync_sub_and_fetch_8";
            case 4374L: return "bfk_sync_swap";
            case 4375L: return "bfk_sync_swap_1";
            case 4376L: return "bfk_sync_swap_16";
            case 4377L: return "bfk_sync_swap_2";
            case 4378L: return "bfk_sync_swap_4";
            case 4379L: return "bfk_sync_swap_8";
            case 4380L: return "bfk_sync_synchronize";
            case 4381L: return "bfk_sync_val_compare_and_swap";
            case 4382L: return "bfk_sync_val_compare_and_swap_1";
            case 4383L: return "bfk_sync_val_compare_and_swap_16";
            case 4384L: return "bfk_sync_val_compare_and_swap_2";
            case 4385L: return "bfk_sync_val_compare_and_swap_4";
            case 4386L: return "bfk_sync_val_compare_and_swap_8";
            case 4387L: return "bfk_sync_xor_and_fetch";
            case 4388L: return "bfk_sync_xor_and_fetch_1";
            case 4389L: return "bfk_sync_xor_and_fetch_16";
            case 4390L: return "bfk_sync_xor_and_fetch_2";
            case 4391L: return "bfk_sync_xor_and_fetch_4";
            case 4392L: return "bfk_sync_xor_and_fetch_8";
            case 4393L: return "bfk_sysv_va_copy";
            case 4394L: return "bfk_sysv_va_end";
            case 4395L: return "bfk_sysv_va_start";
            case 4396L: return "bfk_tan";
            case 4397L: return "bfk_tanf";
            case 4398L: return "bfk_tanh";
            case 4399L: return "bfk_tanhf";
            case 4400L: return "bfk_tanhl";
            case 4401L: return "bfk_tanl";
            case 4402L: return "bfk_tgamma";
            case 4403L: return "bfk_tgammaf";
            case 4404L: return "bfk_tgammal";
            case 4405L: return "bfk_thread_pointer";
            case 4406L: return "bfk_toascii";
            case 4407L: return "bfk_tolower";
            case 4408L: return "bfk_toupper";
            case 4409L: return "bfk_towlower";
            case 4410L: return "bfk_towupper";
            case 4411L: return "bfk_trap";
            case 4412L: return "bfk_trunc";
            case 4413L: return "bfk_truncf";
            case 4414L: return "bfk_truncf32";
            case 4415L: return "bfk_truncf32x";
            case 4416L: return "bfk_truncf64";
            case 4417L: return "bfk_truncf64x";
            case 4418L: return "bfk_truncl";
            case 4419L: return "bfk_uadd_overflow";
            case 4420L: return "bfk_uaddl_overflow";
            case 4421L: return "bfk_uaddll_overflow";
            case 4422L: return "bfk_umul_overflow";
            case 4423L: return "bfk_umull_overflow";
            case 4424L: return "bfk_umulll_overflow";
            case 4425L: return "bfk_unpredictable";
            case 4426L: return "bfk_unreachable";
            case 4427L: return "bfk_unwind_init";
            case 4428L: return "bfk_unwind_resume";
            case 4429L: return "bfk_update_setjmp_buf";
            case 4430L: return "bfk_usub_overflow";
            case 4431L: return "bfk_usubl_overflow";
            case 4432L: return "bfk_usubll_overflow";
            case 4433L: return "bfk_va_arg";
            case 4434L: return "bfk_va_arg_pack";
            case 4435L: return "bfk_va_arg_pack_len";
            case 4436L: return "bfk_va_copy";
            case 4437L: return "bfk_va_end";
            case 4438L: return "bfk_va_start";
            case 4439L: return "bfk_varargs_start";
            case 4440L: return "bfk_vfork";
            case 4441L: return "bfk_vfprintf";
            case 4442L: return "bfk_vfscanf";
            case 4443L: return "bfk_vprintf";
            case 4444L: return "bfk_vscanf";
            case 4445L: return "bfk_vsnprintf";
            case 4446L: return "bfk_vsprintf";
            case 4447L: return "bfk_vsscanf";
            case 4448L: return "bfk_wcschr";
            case 4449L: return "bfk_wcscmp";
            case 4450L: return "bfk_wcslen";
            case 4451L: return "bfk_wcsncmp";
            case 4452L: return "bfk_wmemchr";
            case 4453L: return "bfk_wmemcmp";
            case 4454L: return "bfk_y0";
            case 4455L: return "bfk_y0f";
            case 4456L: return "bfk_y0l";
            case 4457L: return "bfk_y1";
            case 4458L: return "bfk_y1f";
            case 4459L: return "bfk_y1l";
            case 4460L: return "bfk_yn";
            case 4461L: return "bfk_ynf";
            case 4462L: return "bfk_ynl";
            case 4463L: return "bfk_last";
            default: return "";
        }
    }

    std::string a_builtin_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L,
            2122L,
            2123L,
            2124L,
            2125L,
            2126L,
            2127L,
            2128L,
            2129L,
            2130L,
            2131L,
            2132L,
            2133L,
            2134L,
            2135L,
            2136L,
            2137L,
            2138L,
            2139L,
            2140L,
            2141L,
            2142L,
            2143L,
            2144L,
            2145L,
            2146L,
            2147L,
            2148L,
            2149L,
            2150L,
            2151L,
            2152L,
            2153L,
            2154L,
            2155L,
            2156L,
            2157L,
            2158L,
            2159L,
            2160L,
            2161L,
            2162L,
            2163L,
            2164L,
            2165L,
            2166L,
            2167L,
            2168L,
            2169L,
            2170L,
            2171L,
            2172L,
            2173L,
            2174L,
            2175L,
            2176L,
            2177L,
            2178L,
            2179L,
            2180L,
            2181L,
            2182L,
            2183L,
            2184L,
            2185L,
            2186L,
            2187L,
            2188L,
            2189L,
            2190L,
            2191L,
            2192L,
            2193L,
            2194L,
            2195L,
            2196L,
            2197L,
            2198L,
            2199L,
            2200L,
            2201L,
            2202L,
            2203L,
            2204L,
            2205L,
            2206L,
            2207L,
            2208L,
            2209L,
            2210L,
            2211L,
            2212L,
            2213L,
            2214L,
            2215L,
            2216L,
            2217L,
            2218L,
            2219L,
            2220L,
            2221L,
            2222L,
            2223L,
            2224L,
            2225L,
            2226L,
            2227L,
            2228L,
            2229L,
            2230L,
            2231L,
            2232L,
            2233L,
            2234L,
            2235L,
            2236L,
            2237L,
            2238L,
            2239L,
            2240L,
            2241L,
            2242L,
            2243L,
            2244L,
            2245L,
            2246L,
            2247L,
            2248L,
            2249L,
            2250L,
            2251L,
            2252L,
            2253L,
            2254L,
            2255L,
            2256L,
            2257L,
            2258L,
            2259L,
            2260L,
            2261L,
            2262L,
            2263L,
            2264L,
            2265L,
            2266L,
            2267L,
            2268L,
            2269L,
            2270L,
            2271L,
            2272L,
            2273L,
            2274L,
            2275L,
            2276L,
            2277L,
            2278L,
            2279L,
            2280L,
            2281L,
            2282L,
            2283L,
            2284L,
            2285L,
            2286L,
            2287L,
            2288L,
            2289L,
            2290L,
            2291L,
            2292L,
            2293L,
            2294L,
            2295L,
            2296L,
            2297L,
            2298L,
            2299L,
            2300L,
            2301L,
            2302L,
            2303L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2320L,
            2321L,
            2322L,
            2323L,
            2324L,
            2325L,
            2326L,
            2327L,
            2328L,
            2329L,
            2330L,
            2331L,
            2332L,
            2333L,
            2334L,
            2335L,
            2336L,
            2337L,
            2338L,
            2339L,
            2340L,
            2341L,
            2342L,
            2343L,
            2344L,
            2345L,
            2346L,
            2347L,
            2348L,
            2349L,
            2350L,
            2351L,
            2352L,
            2353L,
            2354L,
            2355L,
            2356L,
            2357L,
            2358L,
            2359L,
            2360L,
            2361L,
            2362L,
            2363L,
            2364L,
            2365L,
            2366L,
            2367L,
            2368L,
            2369L,
            2370L,
            2371L,
            2372L,
            2373L,
            2374L,
            2375L,
            2376L,
            2377L,
            2378L,
            2379L,
            2380L,
            2381L,
            2382L,
            2383L,
            2384L,
            2385L,
            2386L,
            2387L,
            2388L,
            2389L,
            2390L,
            2391L,
            2392L,
            2393L,
            2394L,
            2395L,
            2396L,
            2397L,
            2398L,
            2399L,
            2400L,
            2401L,
            2402L,
            2403L,
            2404L,
            2405L,
            2406L,
            2407L,
            2408L,
            2409L,
            2410L,
            2411L,
            2412L,
            2413L,
            2414L,
            2415L,
            2416L,
            2417L,
            2418L,
            2419L,
            2420L,
            2421L,
            2422L,
            2423L,
            2424L,
            2425L,
            2426L,
            2427L,
            2428L,
            2429L,
            2430L,
            2431L,
            2432L,
            2433L,
            2434L,
            2435L,
            2436L,
            2437L,
            2438L,
            2439L,
            2440L,
            2441L,
            2442L,
            2443L,
            2444L,
            2445L,
            2446L,
            2447L,
            2448L,
            2449L,
            2450L,
            2451L,
            2452L,
            2453L,
            2454L,
            2455L,
            2456L,
            2457L,
            2458L,
            2459L,
            2460L,
            2461L,
            2462L,
            2463L,
            2464L,
            2465L,
            2466L,
            2467L,
            2468L,
            2469L,
            2470L,
            2471L,
            2472L,
            2473L,
            2474L,
            2475L,
            2476L,
            2477L,
            2478L,
            2479L,
            2480L,
            2481L,
            2482L,
            2483L,
            2484L,
            2485L,
            2486L,
            2487L,
            2488L,
            2489L,
            2490L,
            2491L,
            2492L,
            2493L,
            2494L,
            2495L,
            2496L,
            2497L,
            2498L,
            2499L,
            2500L,
            2501L,
            2502L,
            2503L,
            2504L,
            2505L,
            2506L,
            2507L,
            2508L,
            2509L,
            2510L,
            2511L,
            2512L,
            2513L,
            2514L,
            2515L,
            2516L,
            2517L,
            2518L,
            2519L,
            2520L,
            2521L,
            2522L,
            2523L,
            2524L,
            2525L,
            2526L,
            2527L,
            2528L,
            2529L,
            2530L,
            2531L,
            2532L,
            2533L,
            2534L,
            2535L,
            2536L,
            2537L,
            2538L,
            2539L,
            2540L,
            2541L,
            2542L,
            2543L,
            2544L,
            2545L,
            2546L,
            2547L,
            2548L,
            2549L,
            2550L,
            2551L,
            2552L,
            2553L,
            2554L,
            2555L,
            2556L,
            2557L,
            2558L,
            2559L,
            2560L,
            2561L,
            2562L,
            2563L,
            2564L,
            2565L,
            2566L,
            2567L,
            2568L,
            2569L,
            2570L,
            2571L,
            2572L,
            2573L,
            2574L,
            2575L,
            2576L,
            2577L,
            2578L,
            2579L,
            2580L,
            2581L,
            2582L,
            2583L,
            2584L,
            2585L,
            2586L,
            2587L,
            2588L,
            2589L,
            2590L,
            2591L,
            2592L,
            2593L,
            2594L,
            2595L,
            2596L,
            2597L,
            2598L,
            2599L,
            2600L,
            2601L,
            2602L,
            2603L,
            2604L,
            2605L,
            2606L,
            2607L,
            2608L,
            2609L,
            2610L,
            2611L,
            2612L,
            2613L,
            2614L,
            2615L,
            2616L,
            2617L,
            2618L,
            2619L,
            2620L,
            2621L,
            2622L,
            2623L,
            2624L,
            2625L,
            2626L,
            2627L,
            2628L,
            2629L,
            2630L,
            2631L,
            2632L,
            2633L,
            2634L,
            2635L,
            2636L,
            2637L,
            2638L,
            2639L,
            2640L,
            2641L,
            2642L,
            2643L,
            2644L,
            2645L,
            2646L,
            2647L,
            2648L,
            2649L,
            2650L,
            2651L,
            2652L,
            2653L,
            2654L,
            2655L,
            2656L,
            2657L,
            2658L,
            2659L,
            2660L,
            2661L,
            2662L,
            2663L,
            2664L,
            2665L,
            2666L,
            2667L,
            2668L,
            2669L,
            2670L,
            2671L,
            2672L,
            2673L,
            2674L,
            2675L,
            2676L,
            2677L,
            2678L,
            2679L,
            2680L,
            2681L,
            2682L,
            2683L,
            2684L,
            2685L,
            2686L,
            2687L,
            2688L,
            2689L,
            2690L,
            2691L,
            2692L,
            2693L,
            2694L,
            2695L,
            2696L,
            2697L,
            2698L,
            2699L,
            2700L,
            2701L,
            2702L,
            2703L,
            2704L,
            2705L,
            2706L,
            2707L,
            2708L,
            2709L,
            2710L,
            2711L,
            2712L,
            2713L,
            2714L,
            2715L,
            2716L,
            2717L,
            2718L,
            2719L,
            2720L,
            2721L,
            2722L,
            2723L,
            2724L,
            2725L,
            2726L,
            2727L,
            2728L,
            2729L,
            2730L,
            2731L,
            2732L,
            2733L,
            2734L,
            2735L,
            2736L,
            2737L,
            2738L,
            2739L,
            2740L,
            2741L,
            2742L,
            2743L,
            2744L,
            2745L,
            2746L,
            2747L,
            2748L,
            2749L,
            2750L,
            2751L,
            2752L,
            2753L,
            2754L,
            2755L,
            2756L,
            2757L,
            2758L,
            2759L,
            2760L,
            2761L,
            2762L,
            2763L,
            2764L,
            2765L,
            2766L,
            2767L,
            2768L,
            2769L,
            2770L,
            2771L,
            2772L,
            2773L,
            2774L,
            2775L,
            2776L,
            2777L,
            2778L,
            2779L,
            2780L,
            2781L,
            2782L,
            2783L,
            2784L,
            2785L,
            2786L,
            2787L,
            2788L,
            2789L,
            2790L,
            2791L,
            2792L,
            2793L,
            2794L,
            2795L,
            2796L,
            2797L,
            2798L,
            2799L,
            2800L,
            2801L,
            2802L,
            2803L,
            2804L,
            2805L,
            2806L,
            2807L,
            2808L,
            2809L,
            2810L,
            2811L,
            2812L,
            2813L,
            2814L,
            2815L,
            2816L,
            2817L,
            2818L,
            2819L,
            2820L,
            2821L,
            2822L,
            2823L,
            2824L,
            2825L,
            2826L,
            2827L,
            2828L,
            2829L,
            2830L,
            2831L,
            2832L,
            2833L,
            2834L,
            2835L,
            2836L,
            2837L,
            2838L,
            2839L,
            2840L,
            2841L,
            2842L,
            2843L,
            2844L,
            2845L,
            2846L,
            2847L,
            2848L,
            2849L,
            2850L,
            2851L,
            2852L,
            2853L,
            2854L,
            2855L,
            2856L,
            2857L,
            2858L,
            2859L,
            2860L,
            2861L,
            2862L,
            2863L,
            2864L,
            2865L,
            2866L,
            2867L,
            2868L,
            2869L,
            2870L,
            2871L,
            2872L,
            2873L,
            2874L,
            2875L,
            2876L,
            2877L,
            2878L,
            2879L,
            2880L,
            2881L,
            2882L,
            2883L,
            2884L,
            2885L,
            2886L,
            2887L,
            2888L,
            2889L,
            2890L,
            2891L,
            2892L,
            2893L,
            2894L,
            2895L,
            2896L,
            2897L,
            2898L,
            2899L,
            2900L,
            2901L,
            2902L,
            2903L,
            2904L,
            2905L,
            2906L,
            2907L,
            2908L,
            2909L,
            2910L,
            2911L,
            2912L,
            2913L,
            2914L,
            2915L,
            2916L,
            2917L,
            2918L,
            2919L,
            2920L,
            2921L,
            2922L,
            2923L,
            2924L,
            2925L,
            2926L,
            2927L,
            2928L,
            2929L,
            2930L,
            2931L,
            2932L,
            2933L,
            2934L,
            2935L,
            2936L,
            2937L,
            2938L,
            2939L,
            2940L,
            2941L,
            2942L,
            2943L,
            2944L,
            2945L,
            2946L,
            2947L,
            2948L,
            2949L,
            2950L,
            2951L,
            2952L,
            2953L,
            2954L,
            2955L,
            2956L,
            2957L,
            2958L,
            2959L,
            2960L,
            2961L,
            2962L,
            2963L,
            2964L,
            2965L,
            2966L,
            2967L,
            2968L,
            2969L,
            2970L,
            2971L,
            2972L,
            2973L,
            2974L,
            2975L,
            2976L,
            2977L,
            2978L,
            2979L,
            2980L,
            2981L,
            2982L,
            2983L,
            2984L,
            2985L,
            2986L,
            2987L,
            2988L,
            2989L,
            2990L,
            2991L,
            2992L,
            2993L,
            2994L,
            2995L,
            2996L,
            2997L,
            2998L,
            2999L,
            3000L,
            3001L,
            3002L,
            3003L,
            3004L,
            3005L,
            3006L,
            3007L,
            3008L,
            3009L,
            3010L,
            3011L,
            3012L,
            3013L,
            3014L,
            3015L,
            3016L,
            3017L,
            3018L,
            3019L,
            3020L,
            3021L,
            3022L,
            3023L,
            3024L,
            3025L,
            3026L,
            3027L,
            3028L,
            3029L,
            3030L,
            3031L,
            3032L,
            3033L,
            3034L,
            3035L,
            3036L,
            3037L,
            3038L,
            3039L,
            3040L,
            3041L,
            3042L,
            3043L,
            3044L,
            3045L,
            3046L,
            3047L,
            3048L,
            3049L,
            3050L,
            3051L,
            3052L,
            3053L,
            3054L,
            3055L,
            3056L,
            3057L,
            3058L,
            3059L,
            3060L,
            3061L,
            3062L,
            3063L,
            3064L,
            3065L,
            3066L,
            3067L,
            3068L,
            3069L,
            3070L,
            3071L,
            3072L,
            3073L,
            3074L,
            3075L,
            3076L,
            3077L,
            3078L,
            3079L,
            3080L,
            3081L,
            3082L,
            3083L,
            3084L,
            3085L,
            3086L,
            3087L,
            3088L,
            3089L,
            3090L,
            3091L,
            3092L,
            3093L,
            3094L,
            3095L,
            3096L,
            3097L,
            3098L,
            3099L,
            3100L,
            3101L,
            3102L,
            3103L,
            3104L,
            3105L,
            3106L,
            3107L,
            3108L,
            3109L,
            3110L,
            3111L,
            3112L,
            3113L,
            3114L,
            3115L,
            3116L,
            3117L,
            3118L,
            3119L,
            3120L,
            3121L,
            3122L,
            3123L,
            3124L,
            3125L,
            3126L,
            3127L,
            3128L,
            3129L,
            3130L,
            3131L,
            3132L,
            3133L,
            3134L,
            3135L,
            3136L,
            3137L,
            3138L,
            3139L,
            3140L,
            3141L,
            3142L,
            3143L,
            3144L,
            3145L,
            3146L,
            3147L,
            3148L,
            3149L,
            3150L,
            3151L,
            3152L,
            3153L,
            3154L,
            3155L,
            3156L,
            3157L,
            3158L,
            3159L,
            3160L,
            3161L,
            3162L,
            3163L,
            3164L,
            3165L,
            3166L,
            3167L,
            3168L,
            3169L,
            3170L,
            3171L,
            3172L,
            3173L,
            3174L,
            3175L,
            3176L,
            3177L,
            3178L,
            3179L,
            3180L,
            3181L,
            3182L,
            3183L,
            3184L,
            3185L,
            3186L,
            3187L,
            3188L,
            3189L,
            3190L,
            3191L,
            3192L,
            3193L,
            3194L,
            3195L,
            3196L,
            3197L,
            3198L,
            3199L,
            3200L,
            3201L,
            3202L,
            3203L,
            3204L,
            3205L,
            3206L,
            3207L,
            3208L,
            3209L,
            3210L,
            3211L,
            3212L,
            3213L,
            3214L,
            3215L,
            3216L,
            3217L,
            3218L,
            3219L,
            3220L,
            3221L,
            3222L,
            3223L,
            3224L,
            3225L,
            3226L,
            3227L,
            3228L,
            3229L,
            3230L,
            3231L,
            3232L,
            3233L,
            3234L,
            3235L,
            3236L,
            3237L,
            3238L,
            3239L,
            3240L,
            3241L,
            3242L,
            3243L,
            3244L,
            3245L,
            3246L,
            3247L,
            3248L,
            3249L,
            3250L,
            3251L,
            3252L,
            3253L,
            3254L,
            3255L,
            3256L,
            3257L,
            3258L,
            3259L,
            3260L,
            3261L,
            3262L,
            3263L,
            3264L,
            3265L,
            3266L,
            3267L,
            3268L,
            3269L,
            3270L,
            3271L,
            3272L,
            3273L,
            3274L,
            3275L,
            3276L,
            3277L,
            3278L,
            3279L,
            3280L,
            3281L,
            3282L,
            3283L,
            3284L,
            3285L,
            3286L,
            3287L,
            3288L,
            3289L,
            3290L,
            3291L,
            3292L,
            3293L,
            3294L,
            3295L,
            3296L,
            3297L,
            3298L,
            3299L,
            3300L,
            3301L,
            3302L,
            3303L,
            3304L,
            3305L,
            3306L,
            3307L,
            3308L,
            3309L,
            3310L,
            3311L,
            3312L,
            3313L,
            3314L,
            3315L,
            3316L,
            3317L,
            3318L,
            3319L,
            3320L,
            3321L,
            3322L,
            3323L,
            3324L,
            3325L,
            3326L,
            3327L,
            3328L,
            3329L,
            3330L,
            3331L,
            3332L,
            3333L,
            3334L,
            3335L,
            3336L,
            3337L,
            3338L,
            3339L,
            3340L,
            3341L,
            3342L,
            3343L,
            3344L,
            3345L,
            3346L,
            3347L,
            3348L,
            3349L,
            3350L,
            3351L,
            3352L,
            3353L,
            3354L,
            3355L,
            3356L,
            3357L,
            3358L,
            3359L,
            3360L,
            3361L,
            3362L,
            3363L,
            3364L,
            3365L,
            3366L,
            3367L,
            3368L,
            3369L,
            3370L,
            3371L,
            3372L,
            3373L,
            3374L,
            3375L,
            3376L,
            3377L,
            3378L,
            3379L,
            3380L,
            3381L,
            3382L,
            3383L,
            3384L,
            3385L,
            3386L,
            3387L,
            3388L,
            3389L,
            3390L,
            3391L,
            3392L,
            3393L,
            3394L,
            3395L,
            3396L,
            3397L,
            3398L,
            3399L,
            3400L,
            3401L,
            3402L,
            3403L,
            3404L,
            3405L,
            3406L,
            3407L,
            3408L,
            3409L,
            3410L,
            3411L,
            3412L,
            3413L,
            3414L,
            3415L,
            3416L,
            3417L,
            3418L,
            3419L,
            3420L,
            3421L,
            3422L,
            3423L,
            3424L,
            3425L,
            3426L,
            3427L,
            3428L,
            3429L,
            3430L,
            3431L,
            3432L,
            3433L,
            3434L,
            3435L,
            3436L,
            3437L,
            3438L,
            3439L,
            3440L,
            3441L,
            3442L,
            3443L,
            3444L,
            3445L,
            3446L,
            3447L,
            3448L,
            3449L,
            3450L,
            3451L,
            3452L,
            3453L,
            3454L,
            3455L,
            3456L,
            3457L,
            3458L,
            3459L,
            3460L,
            3461L,
            3462L,
            3463L,
            3464L,
            3465L,
            3466L,
            3467L,
            3468L,
            3469L,
            3470L,
            3471L,
            3472L,
            3473L,
            3474L,
            3475L,
            3476L,
            3477L,
            3478L,
            3479L,
            3480L,
            3481L,
            3482L,
            3483L,
            3484L,
            3485L,
            3486L,
            3487L,
            3488L,
            3489L,
            3490L,
            3491L,
            3492L,
            3493L,
            3494L,
            3495L,
            3496L,
            3497L,
            3498L,
            3499L,
            3500L,
            3501L,
            3502L,
            3503L,
            3504L,
            3505L,
            3506L,
            3507L,
            3508L,
            3509L,
            3510L,
            3511L,
            3512L,
            3513L,
            3514L,
            3515L,
            3516L,
            3517L,
            3518L,
            3519L,
            3520L,
            3521L,
            3522L,
            3523L,
            3524L,
            3525L,
            3526L,
            3527L,
            3528L,
            3529L,
            3530L,
            3531L,
            3532L,
            3533L,
            3534L,
            3535L,
            3536L,
            3537L,
            3538L,
            3539L,
            3540L,
            3541L,
            3542L,
            3543L,
            3544L,
            3545L,
            3546L,
            3547L,
            3548L,
            3549L,
            3550L,
            3551L,
            3552L,
            3553L,
            3554L,
            3555L,
            3556L,
            3557L,
            3558L,
            3559L,
            3560L,
            3561L,
            3562L,
            3563L,
            3564L,
            3565L,
            3566L,
            3567L,
            3568L,
            3569L,
            3570L,
            3571L,
            3572L,
            3573L,
            3574L,
            3575L,
            3576L,
            3577L,
            3578L,
            3579L,
            3580L,
            3581L,
            3582L,
            3583L,
            3584L,
            3585L,
            3586L,
            3587L,
            3588L,
            3589L,
            3590L,
            3591L,
            3592L,
            3593L,
            3594L,
            3595L,
            3596L,
            3597L,
            3598L,
            3599L,
            3600L,
            3601L,
            3602L,
            3603L,
            3604L,
            3605L,
            3606L,
            3607L,
            3608L,
            3609L,
            3610L,
            3611L,
            3612L,
            3613L,
            3614L,
            3615L,
            3616L,
            3617L,
            3618L,
            3619L,
            3620L,
            3621L,
            3622L,
            3623L,
            3624L,
            3625L,
            3626L,
            3627L,
            3628L,
            3629L,
            3630L,
            3631L,
            3632L,
            3633L,
            3634L,
            3635L,
            3636L,
            3637L,
            3638L,
            3639L,
            3640L,
            3641L,
            3642L,
            3643L,
            3644L,
            3645L,
            3646L,
            3647L,
            3648L,
            3649L,
            3650L,
            3651L,
            3652L,
            3653L,
            3654L,
            3655L,
            3656L,
            3657L,
            3658L,
            3659L,
            3660L,
            3661L,
            3662L,
            3663L,
            3664L,
            3665L,
            3666L,
            3667L,
            3668L,
            3669L,
            3670L,
            3671L,
            3672L,
            3673L,
            3674L,
            3675L,
            3676L,
            3677L,
            3678L,
            3679L,
            3680L,
            3681L,
            3682L,
            3683L,
            3684L,
            3685L,
            3686L,
            3687L,
            3688L,
            3689L,
            3690L,
            3691L,
            3692L,
            3693L,
            3694L,
            3695L,
            3696L,
            3697L,
            3698L,
            3699L,
            3700L,
            3701L,
            3702L,
            3703L,
            3704L,
            3705L,
            3706L,
            3707L,
            3708L,
            3709L,
            3710L,
            3711L,
            3712L,
            3713L,
            3714L,
            3715L,
            3716L,
            3717L,
            3718L,
            3719L,
            3720L,
            3721L,
            3722L,
            3723L,
            3724L,
            3725L,
            3726L,
            3727L,
            3728L,
            3729L,
            3730L,
            3731L,
            3732L,
            3733L,
            3734L,
            3735L,
            3736L,
            3737L,
            3738L,
            3739L,
            3740L,
            3741L,
            3742L,
            3743L,
            3744L,
            3745L,
            3746L,
            3747L,
            3748L,
            3749L,
            3750L,
            3751L,
            3752L,
            3753L,
            3754L,
            3755L,
            3756L,
            3757L,
            3758L,
            3759L,
            3760L,
            3761L,
            3762L,
            3763L,
            3764L,
            3765L,
            3766L,
            3767L,
            3768L,
            3769L,
            3770L,
            3771L,
            3772L,
            3773L,
            3774L,
            3775L,
            3776L,
            3777L,
            3778L,
            3779L,
            3780L,
            3781L,
            3782L,
            3783L,
            3784L,
            3785L,
            3786L,
            3787L,
            3788L,
            3789L,
            3790L,
            3791L,
            3792L,
            3793L,
            3794L,
            3795L,
            3796L,
            3797L,
            3798L,
            3799L,
            3800L,
            3801L,
            3802L,
            3803L,
            3804L,
            3805L,
            3806L,
            3807L,
            3808L,
            3809L,
            3810L,
            3811L,
            3812L,
            3813L,
            3814L,
            3815L,
            3816L,
            3817L,
            3818L,
            3819L,
            3820L,
            3821L,
            3822L,
            3823L,
            3824L,
            3825L,
            3826L,
            3827L,
            3828L,
            3829L,
            3830L,
            3831L,
            3832L,
            3833L,
            3834L,
            3835L,
            3836L,
            3837L,
            3838L,
            3839L,
            3840L,
            3841L,
            3842L,
            3843L,
            3844L,
            3845L,
            3846L,
            3847L,
            3848L,
            3849L,
            3850L,
            3851L,
            3852L,
            3853L,
            3854L,
            3855L,
            3856L,
            3857L,
            3858L,
            3859L,
            3860L,
            3861L,
            3862L,
            3863L,
            3864L,
            3865L,
            3866L,
            3867L,
            3868L,
            3869L,
            3870L,
            3871L,
            3872L,
            3873L,
            3874L,
            3875L,
            3876L,
            3877L,
            3878L,
            3879L,
            3880L,
            3881L,
            3882L,
            3883L,
            3884L,
            3885L,
            3886L,
            3887L,
            3888L,
            3889L,
            3890L,
            3891L,
            3892L,
            3893L,
            3894L,
            3895L,
            3896L,
            3897L,
            3898L,
            3899L,
            3900L,
            3901L,
            3902L,
            3903L,
            3904L,
            3905L,
            3906L,
            3907L,
            3908L,
            3909L,
            3910L,
            3911L,
            3912L,
            3913L,
            3914L,
            3915L,
            3916L,
            3917L,
            3918L,
            3919L,
            3920L,
            3921L,
            3922L,
            3923L,
            3924L,
            3925L,
            3926L,
            3927L,
            3928L,
            3929L,
            3930L,
            3931L,
            3932L,
            3933L,
            3934L,
            3935L,
            3936L,
            3937L,
            3938L,
            3939L,
            3940L,
            3941L,
            3942L,
            3943L,
            3944L,
            3945L,
            3946L,
            3947L,
            3948L,
            3949L,
            3950L,
            3951L,
            3952L,
            3953L,
            3954L,
            3955L,
            3956L,
            3957L,
            3958L,
            3959L,
            3960L,
            3961L,
            3962L,
            3963L,
            3964L,
            3965L,
            3966L,
            3967L,
            3968L,
            3969L,
            3970L,
            3971L,
            3972L,
            3973L,
            3974L,
            3975L,
            3976L,
            3977L,
            3978L,
            3979L,
            3980L,
            3981L,
            3982L,
            3983L,
            3984L,
            3985L,
            3986L,
            3987L,
            3988L,
            3989L,
            3990L,
            3991L,
            3992L,
            3993L,
            3994L,
            3995L,
            3996L,
            3997L,
            3998L,
            3999L,
            4000L,
            4001L,
            4002L,
            4003L,
            4004L,
            4005L,
            4006L,
            4007L,
            4008L,
            4009L,
            4010L,
            4011L,
            4012L,
            4013L,
            4014L,
            4015L,
            4016L,
            4017L,
            4018L,
            4019L,
            4020L,
            4021L,
            4022L,
            4023L,
            4024L,
            4025L,
            4026L,
            4027L,
            4028L,
            4029L,
            4030L,
            4031L,
            4032L,
            4033L,
            4034L,
            4035L,
            4036L,
            4037L,
            4038L,
            4039L,
            4040L,
            4041L,
            4042L,
            4043L,
            4044L,
            4045L,
            4046L,
            4047L,
            4048L,
            4049L,
            4050L,
            4051L,
            4052L,
            4053L,
            4054L,
            4055L,
            4056L,
            4057L,
            4058L,
            4059L,
            4060L,
            4061L,
            4062L,
            4063L,
            4064L,
            4065L,
            4066L,
            4067L,
            4068L,
            4069L,
            4070L,
            4071L,
            4072L,
            4073L,
            4074L,
            4075L,
            4076L,
            4077L,
            4078L,
            4079L,
            4080L,
            4081L,
            4082L,
            4083L,
            4084L,
            4085L,
            4086L,
            4087L,
            4088L,
            4089L,
            4090L,
            4091L,
            4092L,
            4093L,
            4094L,
            4095L,
            4096L,
            4097L,
            4098L,
            4099L,
            4100L,
            4101L,
            4102L,
            4103L,
            4104L,
            4105L,
            4106L,
            4107L,
            4108L,
            4109L,
            4110L,
            4111L,
            4112L,
            4113L,
            4114L,
            4115L,
            4116L,
            4117L,
            4118L,
            4119L,
            4120L,
            4121L,
            4122L,
            4123L,
            4124L,
            4125L,
            4126L,
            4127L,
            4128L,
            4129L,
            4130L,
            4131L,
            4132L,
            4133L,
            4134L,
            4135L,
            4136L,
            4137L,
            4138L,
            4139L,
            4140L,
            4141L,
            4142L,
            4143L,
            4144L,
            4145L,
            4146L,
            4147L,
            4148L,
            4149L,
            4150L,
            4151L,
            4152L,
            4153L,
            4154L,
            4155L,
            4156L,
            4157L,
            4158L,
            4159L,
            4160L,
            4161L,
            4162L,
            4163L,
            4164L,
            4165L,
            4166L,
            4167L,
            4168L,
            4169L,
            4170L,
            4171L,
            4172L,
            4173L,
            4174L,
            4175L,
            4176L,
            4177L,
            4178L,
            4179L,
            4180L,
            4181L,
            4182L,
            4183L,
            4184L,
            4185L,
            4186L,
            4187L,
            4188L,
            4189L,
            4190L,
            4191L,
            4192L,
            4193L,
            4194L,
            4195L,
            4196L,
            4197L,
            4198L,
            4199L,
            4200L,
            4201L,
            4202L,
            4203L,
            4204L,
            4205L,
            4206L,
            4207L,
            4208L,
            4209L,
            4210L,
            4211L,
            4212L,
            4213L,
            4214L,
            4215L,
            4216L,
            4217L,
            4218L,
            4219L,
            4220L,
            4221L,
            4222L,
            4223L,
            4224L,
            4225L,
            4226L,
            4227L,
            4228L,
            4229L,
            4230L,
            4231L,
            4232L,
            4233L,
            4234L,
            4235L,
            4236L,
            4237L,
            4238L,
            4239L,
            4240L,
            4241L,
            4242L,
            4243L,
            4244L,
            4245L,
            4246L,
            4247L,
            4248L,
            4249L,
            4250L,
            4251L,
            4252L,
            4253L,
            4254L,
            4255L,
            4256L,
            4257L,
            4258L,
            4259L,
            4260L,
            4261L,
            4262L,
            4263L,
            4264L,
            4265L,
            4266L,
            4267L,
            4268L,
            4269L,
            4270L,
            4271L,
            4272L,
            4273L,
            4274L,
            4275L,
            4276L,
            4277L,
            4278L,
            4279L,
            4280L,
            4281L,
            4282L,
            4283L,
            4284L,
            4285L,
            4286L,
            4287L,
            4288L,
            4289L,
            4290L,
            4291L,
            4292L,
            4293L,
            4294L,
            4295L,
            4296L,
            4297L,
            4298L,
            4299L,
            4300L,
            4301L,
            4302L,
            4303L,
            4304L,
            4305L,
            4306L,
            4307L,
            4308L,
            4309L,
            4310L,
            4311L,
            4312L,
            4313L,
            4314L,
            4315L,
            4316L,
            4317L,
            4318L,
            4319L,
            4320L,
            4321L,
            4322L,
            4323L,
            4324L,
            4325L,
            4326L,
            4327L,
            4328L,
            4329L,
            4330L,
            4331L,
            4332L,
            4333L,
            4334L,
            4335L,
            4336L,
            4337L,
            4338L,
            4339L,
            4340L,
            4341L,
            4342L,
            4343L,
            4344L,
            4345L,
            4346L,
            4347L,
            4348L,
            4349L,
            4350L,
            4351L,
            4352L,
            4353L,
            4354L,
            4355L,
            4356L,
            4357L,
            4358L,
            4359L,
            4360L,
            4361L,
            4362L,
            4363L,
            4364L,
            4365L,
            4366L,
            4367L,
            4368L,
            4369L,
            4370L,
            4371L,
            4372L,
            4373L,
            4374L,
            4375L,
            4376L,
            4377L,
            4378L,
            4379L,
            4380L,
            4381L,
            4382L,
            4383L,
            4384L,
            4385L,
            4386L,
            4387L,
            4388L,
            4389L,
            4390L,
            4391L,
            4392L,
            4393L,
            4394L,
            4395L,
            4396L,
            4397L,
            4398L,
            4399L,
            4400L,
            4401L,
            4402L,
            4403L,
            4404L,
            4405L,
            4406L,
            4407L,
            4408L,
            4409L,
            4410L,
            4411L,
            4412L,
            4413L,
            4414L,
            4415L,
            4416L,
            4417L,
            4418L,
            4419L,
            4420L,
            4421L,
            4422L,
            4423L,
            4424L,
            4425L,
            4426L,
            4427L,
            4428L,
            4429L,
            4430L,
            4431L,
            4432L,
            4433L,
            4434L,
            4435L,
            4436L,
            4437L,
            4438L,
            4439L,
            4440L,
            4441L,
            4442L,
            4443L,
            4444L,
            4445L,
            4446L,
            4447L,
            4448L,
            4449L,
            4450L,
            4451L,
            4452L,
            4453L,
            4454L,
            4455L,
            4456L,
            4457L,
            4458L,
            4459L,
            4460L,
            4461L,
            4462L,
            4463L
        };
        static const std::vector<int64_t> retval(values, values + 4464);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_kind_tag() {
        return stringify::a_builtin_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 377
namespace stringify {
    const char* an_access_specifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "as_public";
            case 1L: return "as_protected";
            case 2L: return "as_private";
            case 3L: return "as_inaccessible";
            default: return "";
        }
    }

    std::string an_access_specifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_access_specifier_tag(i);
        if (s.empty())
            s = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_access_specifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_access_specifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_access_specifier_tag(i);
        if (retval.empty()) {
            retval = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_access_specifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_access_specifier_tag() {
        return stringify::an_access_specifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 397
namespace stringify {
    const char* an_assembly_visibility_tag(int64_t i) {
        switch (i) {
            case 0L: return "av_none";
            case 1L: return "av_public";
            case 2L: return "av_private";
            default: return "";
        }
    }

    std::string an_assembly_visibility_tag(int64_t i, const std::string &strip) {
        std::string s = an_assembly_visibility_tag(i);
        if (s.empty())
            s = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_assembly_visibility_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_assembly_visibility_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_assembly_visibility_tag(i);
        if (retval.empty()) {
            retval = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_assembly_visibility_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_assembly_visibility_tag() {
        return stringify::an_assembly_visibility_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 416
namespace stringify {
    const char* a_name_linkage_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "nlk_none";
            case 1L: return "nlk_internal";
            case 2L: return "nlk_cplusplus_external";
            case 3L: return "nlk_last_standard";
            default: return "";
        }
    }

    std::string a_name_linkage_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_name_linkage_kind_tag(i);
        if (s.empty())
            s = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_name_linkage_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_name_linkage_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_name_linkage_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_name_linkage_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_name_linkage_kind_tag() {
        return stringify::a_name_linkage_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 1550
namespace stringify {
    const char* an_element_position_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "epk_error";
            case 1L: return "epk_specialization_header";
            case 2L: return "epk_noreturn";
            case 3L: return "epk_last";
            default: return "";
        }
    }

    std::string an_element_position_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_element_position_kind_tag(i);
        if (s.empty())
            s = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_element_position_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_element_position_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_element_position_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_element_position_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_element_position_kind_tag() {
        return stringify::an_element_position_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 1661
namespace stringify {
    const char* an_ELF_visibility_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "evk_unspecified";
            case 1L: return "evk_hidden";
            case 2L: return "evk_protected";
            case 3L: return "evk_internal";
            case 4L: return "evk_default";
            default: return "";
        }
    }

    std::string an_ELF_visibility_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ELF_visibility_kind_tag(i);
        if (s.empty())
            s = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ELF_visibility_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ELF_visibility_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ELF_visibility_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ELF_visibility_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ELF_visibility_kind_tag() {
        return stringify::an_ELF_visibility_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 2216
namespace stringify {
    const char* a_special_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfk_none";
            case 1L: return "sfk_constructor";
            case 2L: return "sfk_destructor";
            case 3L: return "sfk_conversion";
            case 4L: return "sfk_udl_operator";
            case 5L: return "sfk_operator";
            case 6L: return "sfk_lambda_entry_point";
            case 7L: return "sfk_deduction_guide";
            case 8L: return "sfk_static_constructor";
            case 9L: return "sfk_finalizer";
            case 10L: return "sfk_idisposable_dispose";
            case 11L: return "sfk_dispose_bool";
            case 12L: return "sfk_object_finalize";
            case 13L: return "sfk_property_get";
            case 14L: return "sfk_property_set";
            case 15L: return "sfk_event_add";
            case 16L: return "sfk_event_remove";
            case 17L: return "sfk_last_accessor";
            case 18L: return "sfk_gnu_sync_concrete_function";
            case 19L: return "sfk_gnu_atomic_nongeneric_function";
            case 20L: return "sfk_gnu_atomic_generic_function";
            case 21L: return "sfk_last";
            default: return "";
        }
    }

    std::string a_special_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_special_function_kind_tag(i);
        if (s.empty())
            s = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_special_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_special_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_special_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_special_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_special_function_kind_tag() {
        return stringify::a_special_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 2380
namespace stringify {
    const char* an_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aak_empty";
            case 1L: return "aak_raw_token";
            case 2L: return "aak_token";
            case 3L: return "aak_constant";
            case 4L: return "aak_type";
            case 5L: return "aak_expression";
            case 6L: return "aak_last";
            default: return "";
        }
    }

    std::string an_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_arg_kind_tag() {
        return stringify::an_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 2456
namespace stringify {
    const char* an_attribute_family_tag(int64_t i) {
        switch (i) {
            case 0L: return "af_internal";
            case 1L: return "af_std";
            case 2L: return "af_gnu";
            case 3L: return "af_ms_declspec";
            case 4L: return "af_alignas";
            case 5L: return "af_last";
            default: return "";
        }
    }

    std::string an_attribute_family_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_family_tag(i);
        if (s.empty())
            s = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_family_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_family_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_family_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_family_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_family_tag() {
        return stringify::an_attribute_family_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 2481
namespace stringify {
    const char* an_attribute_location_tag(int64_t i) {
        switch (i) {
            case 0L: return "al_implicit";
            case 1L: return "al_prefix";
            case 2L: return "al_tag_name";
            case 3L: return "al_post_tag_definition";
            case 4L: return "al_base_specifier";
            case 5L: return "al_specifier";
            case 6L: return "al_declarator_id";
            case 7L: return "al_post_ptr_or_ref";
            case 8L: return "al_post_array";
            case 9L: return "al_post_func";
            case 10L: return "al_postfix";
            case 11L: return "al_predeclarator";
            case 12L: return "al_id_equivalent";
            case 13L: return "al_trailing_return";
            case 14L: return "al_post_initializer";
            case 15L: return "al_namespace";
            case 16L: return "al_gnu_namespace";
            case 17L: return "al_label";
            case 18L: return "al_explicit";
            case 19L: return "al_enumerator";
            case 20L: return "al_id_equivalent_as_postfix";
            case 21L: return "al_last";
            default: return "";
        }
    }

    std::string an_attribute_location_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_location_tag(i);
        if (s.empty())
            s = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_location_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_location_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_location_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_location_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_location_tag() {
        return stringify::an_attribute_location_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 2550
namespace stringify {
    const char* an_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ak_unrecognized";
            case 1L: return "ak_empty_attr";
            case 2L: return "ak_attr_using_prefix";
            case 3L: return "ak_align";
            case 4L: return "ak_base_check";
            case 5L: return "ak_carries_dependency";
            case 6L: return "ak_deprecated";
            case 7L: return "ak_final";
            case 8L: return "ak_hiding";
            case 9L: return "ak_noreturn";
            case 10L: return "ak_override";
            case 11L: return "ak_nodiscard";
            case 12L: return "ak_maybe_unused";
            case 13L: return "ak_fallthrough";
            case 14L: return "ak_enable_if";
            case 15L: return "ak_overloadable";
            case 16L: return "ak_naked";
            case 17L: return "ak_noinline";
            case 18L: return "ak_nothrow";
            case 19L: return "ak_section";
            case 20L: return "ak_alias";
            case 21L: return "ak_alloc_size";
            case 22L: return "ak_always_inline";
            case 23L: return "ak_artificial";
            case 24L: return "ak_cdecl";
            case 25L: return "ak_cleanup";
            case 26L: return "ak_cold";
            case 27L: return "ak_common";
            case 28L: return "ak_const";
            case 29L: return "ak_constructor";
            case 30L: return "ak_destructor";
            case 31L: return "ak_error";
            case 32L: return "ak_externally_visible";
            case 33L: return "ak_fastcall";
            case 34L: return "ak_flatten";
            case 35L: return "ak_format";
            case 36L: return "ak_format_arg";
            case 37L: return "ak_gnu_inline";
            case 38L: return "ak_hot";
            case 39L: return "ak_ifunc";
            case 40L: return "ak_init_priority";
            case 41L: return "ak_malloc";
            case 42L: return "ak_may_alias";
            case 43L: return "ak_mode";
            case 44L: return "ak_no_instrument_function";
            case 45L: return "ak_no_check_memory_usage";
            case 46L: return "ak_nocommon";
            case 47L: return "ak_nonnull";
            case 48L: return "ak_packed";
            case 49L: return "ak_pure";
            case 50L: return "ak_sentinel";
            case 51L: return "ak_stdcall";
            case 52L: return "ak_strong";
            case 53L: return "ak_target";
            case 54L: return "ak_tls_model";
            case 55L: return "ak_transparent_union";
            case 56L: return "ak_unused";
            case 57L: return "ak_used";
            case 58L: return "ak_vector_size";
            case 59L: return "ak_visibility";
            case 60L: return "ak_warn_unused_result";
            case 61L: return "ak_warning";
            case 62L: return "ak_weak";
            case 63L: return "ak_weakref";
            case 64L: return "ak_abi_tag";
            case 65L: return "ak_appdomain";
            case 66L: return "ak_assembly_info";
            case 67L: return "ak_dllexport";
            case 68L: return "ak_dllimport";
            case 69L: return "ak_edg_interior_ptr_alias";
            case 70L: return "ak_edg_pin_ptr_alias";
            case 71L: return "ak_empty_bases";
            case 72L: return "ak_implementation_key";
            case 73L: return "ak_intrin_type";
            case 74L: return "ak_jitintrinsic";
            case 75L: return "ak_noalias";
            case 76L: return "ak_non_user_code";
            case 77L: return "ak_novtable";
            case 78L: return "ak_process";
            case 79L: return "ak_property";
            case 80L: return "ak_restrict";
            case 81L: return "ak_safebuffers";
            case 82L: return "ak_selectany";
            case 83L: return "ak_thread";
            case 84L: return "ak_uuid";
            case 85L: return "ak_layout_as_external";
            case 86L: return "ak_no_empty_identity_interface";
            case 87L: return "ak_no_ftm";
            case 88L: return "ak_no_refcount";
            case 89L: return "ak_no_release_return";
            case 90L: return "ak_no_weakreferencesource";
            case 91L: return "ak_one_phase_constructed";
            case 92L: return "ak_allocator";
            case 93L: return "ak_host";
            case 94L: return "ak_global";
            case 95L: return "ak_device";
            case 96L: return "ak_shared";
            case 97L: return "ak_local";
            case 98L: return "ak_constant";
            case 99L: return "ak_edg_e1";
            case 100L: return "ak_edg_n1";
            case 101L: return "ak_pragma_pack_state";
            case 102L: return "ak_last";
            default: return "";
        }
    }

    std::string an_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L
        };
        static const std::vector<int64_t> retval(values, values + 103);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_kind_tag() {
        return stringify::an_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 3171
namespace stringify {
    const char* a_constant_repr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ck_error";
            case 1L: return "ck_integer";
            case 2L: return "ck_fixed_point";
            case 3L: return "ck_string";
            case 4L: return "ck_float";
            case 5L: return "ck_complex";
            case 6L: return "ck_imaginary";
            case 7L: return "ck_address";
            case 8L: return "ck_ptr_to_member";
            case 9L: return "ck_label_difference";
            case 10L: return "ck_stack_offset";
            case 11L: return "ck_dynamic_init";
            case 12L: return "ck_aggregate";
            case 13L: return "ck_init_repeat";
            case 14L: return "ck_template_param";
            case 15L: return "ck_designator";
            case 16L: return "ck_upc_threads";
            case 17L: return "ck_upc_mythread";
            case 18L: return "ck_void";
            case 19L: return "ck_last";
            default: return "";
        }
    }

    std::string a_constant_repr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constant_repr_kind_tag(i);
        if (s.empty())
            s = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constant_repr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constant_repr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constant_repr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constant_repr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constant_repr_kind_tag() {
        return stringify::a_constant_repr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 3223
namespace stringify {
    const char* an_address_base_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "abk_routine";
            case 1L: return "abk_variable";
            case 2L: return "abk_constant";
            case 3L: return "abk_temporary";
            case 4L: return "abk_uuidof";
            case 5L: return "abk_typeid";
            case 6L: return "abk_cli_typeid";
            case 7L: return "abk_cli_array";
            case 8L: return "abk_label";
            case 9L: return "abk_last";
            default: return "";
        }
    }

    std::string an_address_base_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_address_base_kind_tag(i);
        if (s.empty())
            s = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_address_base_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_address_base_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_address_base_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_address_base_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_address_base_kind_tag() {
        return stringify::an_address_base_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 3484
namespace stringify {
    const char* a_dynamic_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dik_none";
            case 1L: return "dik_zero";
            case 2L: return "dik_constant";
            case 3L: return "dik_expression";
            case 4L: return "dik_class_result_via_ctor";
            case 5L: return "dik_constructor";
            case 6L: return "dik_nonconstant_aggregate";
            case 7L: return "dik_bitwise_copy";
            default: return "";
        }
    }

    std::string a_dynamic_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dynamic_init_kind_tag(i);
        if (s.empty())
            s = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dynamic_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dynamic_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dynamic_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dynamic_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dynamic_init_kind_tag() {
        return stringify::a_dynamic_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 3901
namespace stringify {
    const char* a_template_param_constant_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpck_param";
            case 1L: return "tpck_expression";
            case 2L: return "tpck_member";
            case 3L: return "tpck_unknown_function";
            case 4L: return "tpck_address";
            case 5L: return "tpck_sizeof";
            case 6L: return "tpck_alignof";
            case 7L: return "tpck_uuidof";
            case 8L: return "tpck_typeid";
            case 9L: return "tpck_noexcept";
            case 10L: return "tpck_template_ref";
            case 11L: return "tpck_integer_pack";
            case 12L: return "tpck_destructor";
            default: return "";
        }
    }

    std::string a_template_param_constant_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_constant_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_constant_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_constant_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_constant_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_constant_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_constant_kind_tag() {
        return stringify::a_template_param_constant_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 4035
namespace stringify {
    const char* a_character_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "chk_default";
            case 1L: return "chk_wchar_t";
            case 2L: return "chk_char16_t";
            case 3L: return "chk_char32_t";
            case 4L: return "chk_last";
            default: return "";
        }
    }

    std::string a_character_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_character_kind_tag(i);
        if (s.empty())
            s = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_character_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_character_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_character_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_character_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_character_kind_tag() {
        return stringify::a_character_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 4809
namespace stringify {
    const char* a_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tk_error";
            case 1L: return "tk_void";
            case 2L: return "tk_integer";
            case 3L: return "tk_fixed_point";
            case 4L: return "tk_float";
            case 5L: return "tk_imaginary";
            case 6L: return "tk_complex";
            case 7L: return "tk_pointer";
            case 8L: return "tk_routine";
            case 9L: return "tk_array";
            case 10L: return "tk_class";
            case 11L: return "tk_struct";
            case 12L: return "tk_union";
            case 13L: return "tk_typeref";
            case 14L: return "tk_ptr_to_member";
            case 15L: return "tk_template_param";
            case 16L: return "tk_vector";
            case 17L: return "tk_nullptr";
            case 18L: return "tk_unknown";
            default: return "";
        }
    }

    std::string a_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_kind_tag(i);
        if (s.empty())
            s = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_kind_tag() {
        return stringify::a_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 4857
namespace stringify {
    const char* an_integer_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ik_char";
            case 1L: return "ik_signed_char";
            case 2L: return "ik_unsigned_char";
            case 3L: return "ik_short";
            case 4L: return "ik_unsigned_short";
            case 5L: return "ik_int";
            case 6L: return "ik_unsigned_int";
            case 7L: return "ik_long";
            case 8L: return "ik_unsigned_long";
            case 9L: return "ik_long_long";
            case 10L: return "ik_unsigned_long_long";
            case 11L: return "ik_int128";
            case 12L: return "ik_unsigned_int128";
            case 13L: return "ik_none";
            default: return "";
        }
    }

    std::string an_integer_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_integer_kind_tag(i);
        if (s.empty())
            s = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_integer_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_integer_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_integer_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_integer_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_integer_kind_tag() {
        return stringify::an_integer_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 4947
namespace stringify {
    const char* a_fixed_point_precision_tag(int64_t i) {
        switch (i) {
            case 0L: return "fpp_short";
            case 1L: return "fpp_default";
            case 2L: return "fpp_long";
            case 3L: return "fpp_last";
            default: return "";
        }
    }

    std::string a_fixed_point_precision_tag(int64_t i, const std::string &strip) {
        std::string s = a_fixed_point_precision_tag(i);
        if (s.empty())
            s = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_fixed_point_precision_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_fixed_point_precision_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_fixed_point_precision_tag(i);
        if (retval.empty()) {
            retval = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_fixed_point_precision_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_fixed_point_precision_tag() {
        return stringify::a_fixed_point_precision_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 4979
namespace stringify {
    const char* a_float_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "fk_float";
            case 1L: return "fk_double";
            case 2L: return "fk_long_double";
            case 3L: return "fk_float80";
            case 4L: return "fk_float128";
            case 5L: return "fk_last";
            default: return "";
        }
    }

    std::string a_float_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_float_kind_tag(i);
        if (s.empty())
            s = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_float_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_float_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_float_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_float_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_float_kind_tag() {
        return stringify::a_float_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5061
namespace stringify {
    const char* an_asm_operand_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aoc_invalid";
            case 1L: return "aoc_end_of_constraint";
            case 2L: return "aoc_mod_earlyclobber";
            case 3L: return "aoc_mod_commutative_ops";
            case 4L: return "aoc_mod_ignore";
            case 5L: return "aoc_mod_ignore_char";
            case 6L: return "aoc_mod_disparage_slightly";
            case 7L: return "aoc_mod_disparage_severely";
            case 8L: return "aoc_any";
            case 9L: return "aoc_general";
            case 10L: return "aoc_match_0";
            case 11L: return "aoc_match_1";
            case 12L: return "aoc_match_2";
            case 13L: return "aoc_match_3";
            case 14L: return "aoc_match_4";
            case 15L: return "aoc_match_5";
            case 16L: return "aoc_match_6";
            case 17L: return "aoc_match_7";
            case 18L: return "aoc_match_8";
            case 19L: return "aoc_match_9";
            case 20L: return "aoc_reg_integer";
            case 21L: return "aoc_reg_float";
            case 22L: return "aoc_mem_any";
            case 23L: return "aoc_mem_load";
            case 24L: return "aoc_mem_offset";
            case 25L: return "aoc_mem_nonoffset";
            case 26L: return "aoc_mem_autoinc";
            case 27L: return "aoc_mem_autodec";
            case 28L: return "aoc_imm_int";
            case 29L: return "aoc_imm_number";
            case 30L: return "aoc_imm_symbol";
            case 31L: return "aoc_imm_float";
            case 32L: return "aoc_reg_a";
            case 33L: return "aoc_reg_b";
            case 34L: return "aoc_reg_c";
            case 35L: return "aoc_reg_d";
            case 36L: return "aoc_reg_si";
            case 37L: return "aoc_reg_di";
            case 38L: return "aoc_reg_legacy";
            case 39L: return "aoc_reg_q";
            case 40L: return "aoc_reg_Q";
            case 41L: return "aoc_reg_ad";
            case 42L: return "aoc_reg_float_tos";
            case 43L: return "aoc_reg_float_second";
            case 44L: return "aoc_reg_sse";
            case 45L: return "aoc_reg_sse2";
            case 46L: return "aoc_reg_mmx";
            case 47L: return "aoc_imm_short_shift";
            case 48L: return "aoc_imm_long_shift";
            case 49L: return "aoc_imm_lea_shift";
            case 50L: return "aoc_imm_signed8";
            case 51L: return "aoc_imm_unsigned8";
            case 52L: return "aoc_imm_and_zext";
            case 53L: return "aoc_imm_80387";
            case 54L: return "aoc_imm_sse";
            case 55L: return "aoc_imm_sext32";
            case 56L: return "aoc_imm_zext32";
            case 57L: return "aoc_last";
            default: return "";
        }
    }

    std::string an_asm_operand_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_constraint_kind_tag(i);
        if (s.empty())
            s = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L
        };
        static const std::vector<int64_t> retval(values, values + 58);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_constraint_kind_tag() {
        return stringify::an_asm_operand_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5226
namespace stringify {
    const char* an_asm_operand_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "aom_invalid";
            case 1L: return "aom_input";
            case 2L: return "aom_output";
            case 3L: return "aom_modify";
            default: return "";
        }
    }

    std::string an_asm_operand_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_modifier_tag(i);
        if (s.empty())
            s = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_modifier_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_modifier_tag() {
        return stringify::an_asm_operand_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5237
namespace stringify {
    const char* a_named_register_tag(int64_t i) {
        switch (i) {
            case 0L: return "anr_invalid";
            case 1L: return "anr_memory";
            case 2L: return "anr_a";
            case 3L: return "anr_b";
            case 4L: return "anr_c";
            case 5L: return "anr_d";
            case 6L: return "anr_si";
            case 7L: return "anr_di";
            case 8L: return "anr_bp";
            case 9L: return "anr_sp";
            case 10L: return "anr_r8";
            case 11L: return "anr_r9";
            case 12L: return "anr_r10";
            case 13L: return "anr_r11";
            case 14L: return "anr_r12";
            case 15L: return "anr_r13";
            case 16L: return "anr_r14";
            case 17L: return "anr_r15";
            case 18L: return "anr_st";
            case 19L: return "anr_st1";
            case 20L: return "anr_st2";
            case 21L: return "anr_st3";
            case 22L: return "anr_st4";
            case 23L: return "anr_st5";
            case 24L: return "anr_st6";
            case 25L: return "anr_st7";
            case 26L: return "anr_mm0";
            case 27L: return "anr_mm1";
            case 28L: return "anr_mm2";
            case 29L: return "anr_mm3";
            case 30L: return "anr_mm4";
            case 31L: return "anr_mm5";
            case 32L: return "anr_mm6";
            case 33L: return "anr_mm7";
            case 34L: return "anr_f0";
            case 35L: return "anr_f1";
            case 36L: return "anr_f2";
            case 37L: return "anr_f3";
            case 38L: return "anr_f4";
            case 39L: return "anr_f5";
            case 40L: return "anr_f6";
            case 41L: return "anr_f7";
            case 42L: return "anr_f8";
            case 43L: return "anr_f9";
            case 44L: return "anr_f10";
            case 45L: return "anr_f11";
            case 46L: return "anr_f12";
            case 47L: return "anr_f13";
            case 48L: return "anr_f14";
            case 49L: return "anr_f15";
            case 50L: return "anr_flags";
            case 51L: return "anr_fpsr";
            case 52L: return "anr_dirflag";
            case 53L: return "anr_16";
            case 54L: return "anr_17";
            case 55L: return "anr_18";
            case 56L: return "anr_19";
            case 57L: return "anr_20";
            case 58L: return "anr_unrecognized";
            case 59L: return "anr_last";
            default: return "";
        }
    }

    std::string a_named_register_tag(int64_t i, const std::string &strip) {
        std::string s = a_named_register_tag(i);
        if (s.empty())
            s = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_named_register_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_named_register_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_named_register_tag(i);
        if (retval.empty()) {
            retval = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_named_register_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_named_register_tag() {
        return stringify::a_named_register_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5412
namespace stringify {
    const char* a_type_qualifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "tqt_const";
            case 1L: return "tqt_volatile";
            case 2L: return "tqt_restrict";
            case 3L: return "tqt_c11_atomic";
            case 4L: return "tqt_nullable";
            case 5L: return "tqt_nonnull";
            case 6L: return "tqt_null_unspecified";
            case 7L: return "tqt_unaligned";
            case 8L: return "tqt_near";
            case 9L: return "tqt_far";
            case 10L: return "tqt_upc_shared";
            case 11L: return "tqt_upc_strict";
            case 12L: return "tqt_upc_relaxed";
            case 13L: return "tqt_lsb_named_address_space";
            default: return "";
        }
    }

    std::string a_type_qualifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_qualifier_tag(i);
        if (s.empty())
            s = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_qualifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_qualifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_qualifier_tag(i);
        if (retval.empty()) {
            retval = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_qualifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_qualifier_tag() {
        return stringify::a_type_qualifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5514
namespace stringify {
    const char* a_upc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_pk_access";
            case 1L: return "upc_pk_coherence";
            default: return "";
        }
    }

    std::string a_upc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_pragma_kind_tag() {
        return stringify::a_upc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5524
namespace stringify {
    const char* a_upc_access_method_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_access_unspecified";
            case 1L: return "upc_access_strict";
            case 2L: return "upc_access_relaxed";
            default: return "";
        }
    }

    std::string a_upc_access_method_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_access_method_tag(i);
        if (s.empty())
            s = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_access_method_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_access_method_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_access_method_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_access_method_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_access_method_tag() {
        return stringify::a_upc_access_method_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5535
namespace stringify {
    const char* a_upc_coherence_stack_operation_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_coherence_stack_noop";
            case 1L: return "upc_coherence_stack_save";
            case 2L: return "upc_coherence_stack_restore";
            default: return "";
        }
    }

    std::string a_upc_coherence_stack_operation_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_coherence_stack_operation_tag(i);
        if (s.empty())
            s = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_coherence_stack_operation_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_coherence_stack_operation_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_coherence_stack_operation_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_coherence_stack_operation_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_coherence_stack_operation_tag() {
        return stringify::a_upc_coherence_stack_operation_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5717
namespace stringify {
    const char* a_stdc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pk_none";
            case 1L: return "stdc_pk_fp_contract";
            case 2L: return "stdc_pk_fenv_access";
            case 3L: return "stdc_pk_cx_limited_range";
            case 4L: return "stdc_pk_fx_full_precision";
            case 5L: return "stdc_pk_fx_fract_overflow";
            case 6L: return "stdc_pk_fx_accum_overflow";
            case 7L: return "stdc_pk_last";
            default: return "";
        }
    }

    std::string a_stdc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_kind_tag() {
        return stringify::a_stdc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5743
namespace stringify {
    const char* a_stdc_pragma_value_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pv_none";
            case 1L: return "stdc_pv_off";
            case 2L: return "stdc_pv_on";
            case 3L: return "stdc_pv_sat";
            case 4L: return "stdc_pv_default";
            default: return "";
        }
    }

    std::string a_stdc_pragma_value_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_value_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_value_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_value_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_value_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_value_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_value_tag() {
        return stringify::a_stdc_pragma_value_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5764
namespace stringify {
    const char* a_gcc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gcc_pk_none";
            case 1L: return "gcc_pk_system_header";
            case 2L: return "gcc_pk_visibility_push";
            case 3L: return "gcc_pk_visibility_pop";
            case 4L: return "gcc_pk_target";
            case 5L: return "gcc_pk_push_options";
            case 6L: return "gcc_pk_pop_options";
            case 7L: return "gcc_pk_reset_options";
            case 8L: return "gcc_pk_last";
            default: return "";
        }
    }

    std::string a_gcc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_gcc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_gcc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_gcc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_gcc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_gcc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_gcc_pragma_kind_tag() {
        return stringify::a_gcc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 5808
namespace stringify {
    const char* a_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pk_none";
            case 1L: return "pk_printf_args";
            case 2L: return "pk_scanf_args";
            case 3L: return "pk_lint_argsused";
            case 4L: return "pk_lint_varargs_count";
            case 5L: return "pk_lint_notreached";
            case 6L: return "pk_instantiate";
            case 7L: return "pk_do_not_instantiate";
            case 8L: return "pk_can_instantiate";
            case 9L: return "pk_inline_template";
            case 10L: return "pk_pack";
            case 11L: return "pk_ident_pragma";
            case 12L: return "pk_ident_directive";
            case 13L: return "pk_weak";
            case 14L: return "pk_once";
            case 15L: return "pk_hdrstop";
            case 16L: return "pk_no_pch";
            case 17L: return "pk_define_type_info";
            case 18L: return "pk_stdc";
            case 19L: return "pk_upc";
            case 20L: return "pk_redefine_extname";
            case 21L: return "pk_enable_ldscope";
            case 22L: return "pk_disable_ldscope";
            case 23L: return "pk_gcc";
            case 24L: return "pk_diag_suppress";
            case 25L: return "pk_diag_remark";
            case 26L: return "pk_diag_warning";
            case 27L: return "pk_diag_error";
            case 28L: return "pk_diag_once";
            case 29L: return "pk_diag_default";
            case 30L: return "pk_test_next_statement";
            case 31L: return "pk_test_next_decl";
            case 32L: return "pk_test_immediate";
            case 33L: return "pk_test_immediate_text";
            case 34L: return "pk_test_immediate_pp_text";
            case 35L: return "pk_test_other";
            case 36L: return "pk_test_bind_next_pass";
            case 37L: return "pk_checking_pragma";
            case 38L: return "pk_db_opt";
            case 39L: return "pk_db_name";
            case 40L: return "pk_if_exists";
            case 41L: return "pk_push_macro";
            case 42L: return "pk_pop_macro";
            case 43L: return "pk_start_map_region";
            case 44L: return "pk_stop_map_region";
            case 45L: return "pk_setlocale";
            case 46L: return "pk_comment";
            case 47L: return "pk_conform";
            case 48L: return "pk_include_alias";
            case 49L: return "pk_unrecognized";
            case 50L: return "pk_last";
            default: return "";
        }
    }

    std::string a_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L
        };
        static const std::vector<int64_t> retval(values, values + 51);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_kind_tag() {
        return stringify::a_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6034
namespace stringify {
    const char* a_microsoft_pragma_comment_type_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpct_compiler";
            case 1L: return "mpct_exestr";
            case 2L: return "mpct_lib";
            case 3L: return "mpct_linker";
            case 4L: return "mpct_user";
            case 5L: return "mpct_last";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_comment_type_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_comment_type_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_comment_type_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_comment_type_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_comment_type_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_comment_type_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_comment_type_tag() {
        return stringify::a_microsoft_pragma_comment_type_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6048
namespace stringify {
    const char* a_microsoft_pragma_conform_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpck_forScope";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_conform_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_conform_kind_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_conform_kind_tag() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_conform_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_conform_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_conform_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_conform_kind_tag() {
        return stringify::a_microsoft_pragma_conform_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6355
namespace stringify {
    const char* a_calling_convention_tag(int64_t i) {
        switch (i) {
            case 0L: return "cc_default";
            case 1L: return "cc_cdecl";
            case 2L: return "cc_fastcall";
            case 3L: return "cc_stdcall";
            case 4L: return "cc_thiscall";
            case 5L: return "cc_vectorcall";
            case 6L: return "cc_clrcall";
            case 7L: return "cc_last";
            default: return "";
        }
    }

    std::string a_calling_convention_tag(int64_t i, const std::string &strip) {
        std::string s = a_calling_convention_tag(i);
        if (s.empty())
            s = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_calling_convention_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_calling_convention_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_calling_convention_tag(i);
        if (retval.empty()) {
            retval = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_calling_convention_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_calling_convention_tag() {
        return stringify::a_calling_convention_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6388
namespace stringify {
    const char* a_decl_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "dmt_dllimport";
            case 1L: return "dmt_dllexport";
            case 2L: return "dmt_thread";
            case 3L: return "dmt_microsoft_inline";
            case 4L: return "dmt_forceinline";
            case 5L: return "dmt_selectany";
            case 6L: return "dmt_novtable";
            case 7L: return "dmt_noalias";
            case 8L: return "dmt_restrict";
            case 9L: return "dmt_safebuffers";
            case 10L: return "dmt_global_link_scope";
            case 11L: return "dmt_symbolic_link_scope";
            case 12L: return "dmt_hidden_link_scope";
            case 13L: return "dmt_host";
            case 14L: return "dmt_global";
            case 15L: return "dmt_device";
            case 16L: return "dmt_shared";
            case 17L: return "dmt_local";
            case 18L: return "dmt_constant";
            case 19L: return "dmt_last";
            default: return "";
        }
    }

    std::string a_decl_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_decl_modifier_tag(i);
        if (s.empty())
            s = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_decl_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_decl_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_decl_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_decl_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_decl_modifier_tag() {
        return stringify::a_decl_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6543
namespace stringify {
    const char* a_ref_qualifier_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rqk_default";
            case 1L: return "rqk_lvalue";
            case 2L: return "rqk_rvalue";
            default: return "";
        }
    }

    std::string a_ref_qualifier_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ref_qualifier_kind_tag(i);
        if (s.empty())
            s = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ref_qualifier_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ref_qualifier_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ref_qualifier_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ref_qualifier_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ref_qualifier_kind_tag() {
        return stringify::a_ref_qualifier_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 6818
namespace stringify {
    const char* a_templ_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tak_type";
            case 1L: return "tak_nontype";
            case 2L: return "tak_template";
            case 3L: return "tak_start_of_pack_expansion";
            default: return "";
        }
    }

    std::string a_templ_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_templ_arg_kind_tag(i);
        if (s.empty())
            s = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_templ_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_templ_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_templ_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_templ_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_templ_arg_kind_tag() {
        return stringify::a_templ_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 7427
namespace stringify {
    const char* an_anonymous_union_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "auk_none";
            case 1L: return "auk_variable";
            case 2L: return "auk_field";
            default: return "";
        }
    }

    std::string an_anonymous_union_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_anonymous_union_kind_tag(i);
        if (s.empty())
            s = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_anonymous_union_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_anonymous_union_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_anonymous_union_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_anonymous_union_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_anonymous_union_kind_tag() {
        return stringify::an_anonymous_union_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 7442
namespace stringify {
    const char* an_inheritance_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ihk_none";
            case 1L: return "ihk_single";
            case 2L: return "ihk_multiple";
            case 3L: return "ihk_virtual";
            default: return "";
        }
    }

    std::string an_inheritance_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_inheritance_kind_tag(i);
        if (s.empty())
            s = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_inheritance_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_inheritance_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_inheritance_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_inheritance_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_inheritance_kind_tag() {
        return stringify::an_inheritance_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 7476
namespace stringify {
    const char* a_cli_class_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cctk_standard";
            case 1L: return "cctk_value";
            case 2L: return "cctk_ref";
            case 3L: return "cctk_interface";
            case 4L: return "cctk_unresolved";
            default: return "";
        }
    }

    std::string a_cli_class_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_class_type_kind_tag(i);
        if (s.empty())
            s = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_class_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_class_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_class_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_class_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_class_type_kind_tag() {
        return stringify::a_cli_class_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 7509
namespace stringify {
    const char* a_property_or_event_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pek_declspec_property";
            case 1L: return "pek_cli_property";
            case 2L: return "pek_cli_event";
            default: return "";
        }
    }

    std::string a_property_or_event_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_property_or_event_kind_tag(i);
        if (s.empty())
            s = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_property_or_event_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_property_or_event_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_property_or_event_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_property_or_event_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_property_or_event_kind_tag() {
        return stringify::a_property_or_event_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 7642
namespace stringify {
    const char* a_rewritten_property_reference_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rprk_none";
            case 1L: return "rprk_compound_assignment";
            case 2L: return "rprk_pre_incr_decr";
            case 3L: return "rprk_post_incr_decr";
            case 4L: return "rprk_comma_discard_first";
            case 5L: return "rprk_comma_discard_second";
            default: return "";
        }
    }

    std::string a_rewritten_property_reference_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_rewritten_property_reference_kind_tag(i);
        if (s.empty())
            s = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_rewritten_property_reference_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_rewritten_property_reference_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_rewritten_property_reference_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_rewritten_property_reference_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_rewritten_property_reference_kind_tag() {
        return stringify::a_rewritten_property_reference_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 8309
namespace stringify {
    const char* a_template_param_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tptk_param";
            case 1L: return "tptk_member";
            case 2L: return "tptk_unknown";
            default: return "";
        }
    }

    std::string a_template_param_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_type_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_type_kind_tag() {
        return stringify::a_template_param_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 8575
namespace stringify {
    const char* a_based_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "btk_qualified";
            case 1L: return "btk_rvalue_reference";
            case 2L: return "btk_reference";
            case 3L: return "btk_ptr_to_member";
            case 4L: return "btk_unqualified_array_type";
            case 5L: return "btk_handle";
            case 6L: return "btk_tracking_ref";
            case 7L: return "btk_interior_ptr";
            case 8L: return "btk_pin_ptr";
            case 9L: return "btk_cppcx_box";
            case 10L: return "btk_pointer";
            default: return "";
        }
    }

    std::string a_based_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_based_type_kind_tag(i);
        if (s.empty())
            s = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_based_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_based_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_based_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_based_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_based_type_kind_tag() {
        return stringify::a_based_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 8633
namespace stringify {
    const char* a_pointer_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "pmt_ptr32";
            case 1L: return "pmt_ptr64";
            case 2L: return "pmt_sptr";
            case 3L: return "pmt_uptr";
            case 4L: return "pmt_last";
            default: return "";
        }
    }

    std::string a_pointer_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_pointer_modifier_tag(i);
        if (s.empty())
            s = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pointer_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pointer_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pointer_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pointer_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pointer_modifier_tag() {
        return stringify::a_pointer_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 9768
namespace stringify {
    const char* a_storage_class_tag(int64_t i) {
        switch (i) {
            case 0L: return "sc_unspecified";
            case 1L: return "sc_extern";
            case 2L: return "sc_static";
            case 3L: return "sc_auto";
            case 4L: return "sc_typedef";
            case 5L: return "sc_register";
            case 6L: return "sc_asm";
            case 7L: return "sc_last";
            default: return "";
        }
    }

    std::string a_storage_class_tag(int64_t i, const std::string &strip) {
        std::string s = a_storage_class_tag(i);
        if (s.empty())
            s = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_storage_class_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_storage_class_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_storage_class_tag(i);
        if (retval.empty()) {
            retval = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_storage_class_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_storage_class_tag() {
        return stringify::a_storage_class_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 9810
namespace stringify {
    const char* an_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "initk_none";
            case 1L: return "initk_static";
            case 2L: return "initk_dynamic";
            case 3L: return "initk_zero";
            case 4L: return "initk_function_local";
            case 5L: return "initk_binding";
            default: return "";
        }
    }

    std::string an_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_kind_tag(i);
        if (s.empty())
            s = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_kind_tag() {
        return stringify::an_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 10858
namespace stringify {
    const char* an_opname_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "onk_none";
            case 1L: return "onk_new";
            case 2L: return "onk_delete";
            case 3L: return "onk_array_new";
            case 4L: return "onk_array_delete";
            case 5L: return "onk_plus";
            case 6L: return "onk_minus";
            case 7L: return "onk_star";
            case 8L: return "onk_divide";
            case 9L: return "onk_remainder";
            case 10L: return "onk_excl_or";
            case 11L: return "onk_ampersand";
            case 12L: return "onk_or";
            case 13L: return "onk_compl";
            case 14L: return "onk_not";
            case 15L: return "onk_assign";
            case 16L: return "onk_lt";
            case 17L: return "onk_gt";
            case 18L: return "onk_plus_assign";
            case 19L: return "onk_minus_assign";
            case 20L: return "onk_times_assign";
            case 21L: return "onk_divide_assign";
            case 22L: return "onk_remainder_assign";
            case 23L: return "onk_excl_or_assign";
            case 24L: return "onk_and_assign";
            case 25L: return "onk_or_assign";
            case 26L: return "onk_shift_left";
            case 27L: return "onk_shift_right";
            case 28L: return "onk_shift_right_assign";
            case 29L: return "onk_shift_left_assign";
            case 30L: return "onk_eq";
            case 31L: return "onk_ne";
            case 32L: return "onk_le";
            case 33L: return "onk_ge";
            case 34L: return "onk_and_and";
            case 35L: return "onk_or_or";
            case 36L: return "onk_plus_plus";
            case 37L: return "onk_minus_minus";
            case 38L: return "onk_comma";
            case 39L: return "onk_arrow_star";
            case 40L: return "onk_arrow";
            case 41L: return "onk_function_call";
            case 42L: return "onk_subscript";
            case 43L: return "onk_question";
            case 44L: return "onk_gnu_min";
            case 45L: return "onk_gnu_max";
            case 46L: return "onk_await";
            case 47L: return "onk_last";
            default: return "";
        }
    }

    std::string an_opname_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_opname_kind_tag(i);
        if (s.empty())
            s = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_opname_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L
        };
        static const std::vector<int64_t> retval(values, values + 48);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_opname_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_opname_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_opname_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_opname_kind_tag() {
        return stringify::an_opname_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 10912
namespace stringify {
    const char* a_ctor_or_dtor_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cdk_none";
            case 1L: return "cdk_complete";
            case 2L: return "cdk_subobject";
            case 3L: return "cdk_deleting";
            case 4L: return "cdk_delegation";
            case 5L: return "cdk_last";
            default: return "";
        }
    }

    std::string a_ctor_or_dtor_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ctor_or_dtor_kind_tag(i);
        if (s.empty())
            s = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ctor_or_dtor_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ctor_or_dtor_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ctor_or_dtor_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ctor_or_dtor_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ctor_or_dtor_kind_tag() {
        return stringify::a_ctor_or_dtor_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 12165
namespace stringify {
    const char* an_expr_node_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "enk_error";
            case 1L: return "enk_operation";
            case 2L: return "enk_constant";
            case 3L: return "enk_variable";
            case 4L: return "enk_field";
            case 5L: return "enk_temp_init";
            case 6L: return "enk_new_delete";
            case 7L: return "enk_lambda";
            case 8L: return "enk_gcnew";
            case 9L: return "enk_throw";
            case 10L: return "enk_condition";
            case 11L: return "enk_object_lifetime";
            case 12L: return "enk_typeid";
            case 13L: return "enk_sizeof";
            case 14L: return "enk_sizeof_pack";
            case 15L: return "enk_alignof";
            case 16L: return "enk_address_of_ellipsis";
            case 17L: return "enk_statement";
            case 18L: return "enk_reuse_value";
            case 19L: return "enk_lowered_eh_construct";
            case 20L: return "enk_result_of_overriding_function";
            case 21L: return "enk_routine";
            case 22L: return "enk_vla_dealloc";
            case 23L: return "enk_type_operand";
            case 24L: return "enk_builtin_operation";
            case 25L: return "enk_param_ref";
            case 26L: return "enk_braced_init_list";
            case 27L: return "enk_c11_generic";
            case 28L: return "enk_builtin_choose_expr";
            case 29L: return "enk_yield";
            case 30L: return "enk_await";
            case 31L: return "enk_fold";
            case 32L: return "enk_last";
            default: return "";
        }
    }

    std::string an_expr_node_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_node_kind_tag(i);
        if (s.empty())
            s = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_node_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_node_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_node_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_node_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_node_kind_tag() {
        return stringify::an_expr_node_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 12288
namespace stringify {
    const char* a_lowered_eh_construct_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "leck_caught_object_address";
            case 1L: return "leck_thrown_object_address";
            case 2L: return "leck_cleanup_state";
            case 3L: return "leck_unreachable_cleanup_state";
            case 4L: return "leck_function_prologue";
            case 5L: return "leck_function_epilogue";
            case 6L: return "leck_catch_epilogue";
            case 7L: return "leck_try_epilogue";
            case 8L: return "leck_exception_caught";
            case 9L: return "leck_exception_started";
            case 10L: return "leck_initialization_completed";
            case 11L: return "leck_internal_try";
            default: return "";
        }
    }

    std::string a_lowered_eh_construct_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_lowered_eh_construct_kind_tag(i);
        if (s.empty())
            s = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_lowered_eh_construct_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_lowered_eh_construct_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_lowered_eh_construct_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_lowered_eh_construct_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_lowered_eh_construct_kind_tag() {
        return stringify::a_lowered_eh_construct_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 12330
namespace stringify {
    const char* an_expr_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "eok_address_of";
            case 1L: return "eok_reference_to";
            case 2L: return "eok_handle_to";
            case 3L: return "eok_indirect";
            case 4L: return "eok_ref_indirect";
            case 5L: return "eok_cast";
            case 6L: return "eok_lvalue_cast";
            case 7L: return "eok_ref_cast";
            case 8L: return "eok_lvalue_adjust";
            case 9L: return "eok_class_rvalue_adjust";
            case 10L: return "eok_box";
            case 11L: return "eok_handle_to_box";
            case 12L: return "eok_unbox";
            case 13L: return "eok_unbox_lvalue";
            case 14L: return "eok_base_class_cast";
            case 15L: return "eok_derived_class_cast";
            case 16L: return "eok_pm_base_class_cast";
            case 17L: return "eok_pm_derived_class_cast";
            case 18L: return "eok_dynamic_cast";
            case 19L: return "eok_ref_dynamic_cast";
            case 20L: return "eok_bool_cast";
            case 21L: return "eok_array_to_pointer";
            case 22L: return "eok_dot_vacuous_destructor_call";
            case 23L: return "eok_points_to_vacuous_destructor_call";
            case 24L: return "eok_assume";
            case 25L: return "eok_noexcept";
            case 26L: return "eok_parens";
            case 27L: return "eok_negate";
            case 28L: return "eok_unary_plus";
            case 29L: return "eok_complement";
            case 30L: return "eok_not";
            case 31L: return "eok_vector_not";
            case 32L: return "eok_vector_fill";
            case 33L: return "eok_xconj";
            case 34L: return "eok_real_part";
            case 35L: return "eok_imag_part";
            case 36L: return "eok_post_incr";
            case 37L: return "eok_post_decr";
            case 38L: return "eok_pre_incr";
            case 39L: return "eok_pre_decr";
            case 40L: return "eok_add";
            case 41L: return "eok_subtract";
            case 42L: return "eok_multiply";
            case 43L: return "eok_divide";
            case 44L: return "eok_remainder";
            case 45L: return "eok_jmultiply";
            case 46L: return "eok_jdivide";
            case 47L: return "eok_fjadd";
            case 48L: return "eok_jfadd";
            case 49L: return "eok_fjsubtract";
            case 50L: return "eok_jfsubtract";
            case 51L: return "eok_padd";
            case 52L: return "eok_psubtract";
            case 53L: return "eok_pdiff";
            case 54L: return "eok_shiftl";
            case 55L: return "eok_shiftr";
            case 56L: return "eok_and";
            case 57L: return "eok_or";
            case 58L: return "eok_xor";
            case 59L: return "eok_eq";
            case 60L: return "eok_ne";
            case 61L: return "eok_gt";
            case 62L: return "eok_lt";
            case 63L: return "eok_ge";
            case 64L: return "eok_le";
            case 65L: return "eok_vector_eq";
            case 66L: return "eok_vector_ne";
            case 67L: return "eok_vector_gt";
            case 68L: return "eok_vector_lt";
            case 69L: return "eok_vector_ge";
            case 70L: return "eok_vector_le";
            case 71L: return "eok_gnu_min";
            case 72L: return "eok_gnu_max";
            case 73L: return "eok_assign";
            case 74L: return "eok_add_assign";
            case 75L: return "eok_subtract_assign";
            case 76L: return "eok_multiply_assign";
            case 77L: return "eok_divide_assign";
            case 78L: return "eok_remainder_assign";
            case 79L: return "eok_shiftl_assign";
            case 80L: return "eok_shiftr_assign";
            case 81L: return "eok_and_assign";
            case 82L: return "eok_or_assign";
            case 83L: return "eok_xor_assign";
            case 84L: return "eok_padd_assign";
            case 85L: return "eok_psubtract_assign";
            case 86L: return "eok_bassign";
            case 87L: return "eok_land";
            case 88L: return "eok_lor";
            case 89L: return "eok_vector_land";
            case 90L: return "eok_vector_lor";
            case 91L: return "eok_comma";
            case 92L: return "eok_subscript";
            case 93L: return "eok_vector_subscript";
            case 94L: return "eok_dot_field";
            case 95L: return "eok_points_to_field";
            case 96L: return "eok_pm_field";
            case 97L: return "eok_pm_points_to_field";
            case 98L: return "eok_dot_pm_func_ptr";
            case 99L: return "eok_points_to_pm_func_ptr";
            case 100L: return "eok_dot_static";
            case 101L: return "eok_points_to_static";
            case 102L: return "eok_virtual_function_ptr";
            case 103L: return "eok_question";
            case 104L: return "eok_vector_question";
            case 105L: return "eok_call";
            case 106L: return "eok_dot_member_call";
            case 107L: return "eok_points_to_member_call";
            case 108L: return "eok_dot_pm_call";
            case 109L: return "eok_points_to_pm_call";
            case 110L: return "eok_cli_subscript";
            case 111L: return "eok_va_start";
            case 112L: return "eok_va_arg";
            case 113L: return "eok_va_end";
            case 114L: return "eok_va_copy";
            case 115L: return "eok_va_start_single_operand";
            case 116L: return "eok_lvalue";
            case 117L: return "eok_await";
            case 118L: return "eok_yield";
            case 119L: return "eok_error";
            case 120L: return "eok_last";
            default: return "";
        }
    }

    std::string an_expr_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_operator_kind_tag(i);
        if (s.empty())
            s = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L
        };
        static const std::vector<int64_t> retval(values, values + 121);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_operator_kind_tag() {
        return stringify::an_expr_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 12850
namespace stringify {
    const char* a_builtin_operation_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bok_offsetof";
            case 1L: return "bok_has_assign";
            case 2L: return "bok_has_copy";
            case 3L: return "bok_has_nothrow_assign";
            case 4L: return "bok_has_nothrow_constructor";
            case 5L: return "bok_has_nothrow_copy";
            case 6L: return "bok_has_trivial_assign";
            case 7L: return "bok_has_trivial_constructor";
            case 8L: return "bok_has_trivial_copy";
            case 9L: return "bok_has_trivial_destructor";
            case 10L: return "bok_has_user_destructor";
            case 11L: return "bok_has_virtual_destructor";
            case 12L: return "bok_is_abstract";
            case 13L: return "bok_is_base_of";
            case 14L: return "bok_is_class";
            case 15L: return "bok_is_convertible_to";
            case 16L: return "bok_is_empty";
            case 17L: return "bok_is_enum";
            case 18L: return "bok_is_pod";
            case 19L: return "bok_is_polymorphic";
            case 20L: return "bok_is_union";
            case 21L: return "bok_types_compatible";
            case 22L: return "bok_intaddr";
            case 23L: return "bok_is_trivial";
            case 24L: return "bok_is_standard_layout";
            case 25L: return "bok_is_trivially_copyable";
            case 26L: return "bok_is_literal_type";
            case 27L: return "bok_has_trivial_move_constructor";
            case 28L: return "bok_has_trivial_move_assign";
            case 29L: return "bok_has_nothrow_move_assign";
            case 30L: return "bok_is_constructible";
            case 31L: return "bok_is_nothrow_constructible";
            case 32L: return "bok_has_finalizer";
            case 33L: return "bok_is_delegate";
            case 34L: return "bok_is_interface_class";
            case 35L: return "bok_is_ref_array";
            case 36L: return "bok_is_ref_class";
            case 37L: return "bok_is_sealed";
            case 38L: return "bok_is_simple_value_class";
            case 39L: return "bok_is_value_class";
            case 40L: return "bok_is_final";
            case 41L: return "bok_is_trivially_constructible";
            case 42L: return "bok_is_destructible";
            case 43L: return "bok_is_nothrow_destructible";
            case 44L: return "bok_is_trivially_destructible";
            case 45L: return "bok_is_nothrow_assignable";
            case 46L: return "bok_is_trivially_assignable";
            case 47L: return "bok_builtin_shuffle";
            case 48L: return "bok_builtin_complex";
            case 49L: return "bok_is_valid_winrt_type";
            case 50L: return "bok_is_win_class";
            case 51L: return "bok_is_win_interface";
            case 52L: return "bok_builtin_shufflevector";
            case 53L: return "bok_builtin_convertvector";
            case 54L: return "bok_is_assignable";
            case 55L: return "bok_is_trivially_copy_assignable";
            case 56L: return "bok_builtin_addressof";
            case 57L: return "bok_has_unique_object_representations";
            case 58L: return "bok_is_aggregate";
            case 59L: return "bok_last";
            default: return "";
        }
    }

    std::string a_builtin_operation_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_operation_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_operation_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_operation_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_operation_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_operation_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_operation_kind_tag() {
        return stringify::a_builtin_operation_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 13213
namespace stringify {
    const char* a_local_expr_node_ref_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "lerk_none";
            case 1L: return "lerk_typeof";
            case 2L: return "lerk_generic_sizeof";
            case 3L: return "lerk_tpl_param_expr";
            case 4L: return "lerk_array_bound";
            case 5L: return "lerk_dep_array_bound";
            case 6L: return "lerk_decltype";
            case 7L: return "lerk_bit_field_width";
            default: return "";
        }
    }

    std::string a_local_expr_node_ref_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_local_expr_node_ref_kind_tag(i);
        if (s.empty())
            s = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_local_expr_node_ref_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_local_expr_node_ref_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_local_expr_node_ref_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_local_expr_node_ref_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_local_expr_node_ref_kind_tag() {
        return stringify::a_local_expr_node_ref_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 14049
namespace stringify {
    const char* a_statement_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stmk_expr";
            case 1L: return "stmk_if";
            case 2L: return "stmk_constexpr_if";
            case 3L: return "stmk_while";
            case 4L: return "stmk_goto";
            case 5L: return "stmk_label";
            case 6L: return "stmk_return";
            case 7L: return "stmk_coroutine";
            case 8L: return "stmk_coroutine_return";
            case 9L: return "stmk_block";
            case 10L: return "stmk_end_test_while";
            case 11L: return "stmk_for";
            case 12L: return "stmk_range_based_for";
            case 13L: return "stmk_for_each";
            case 14L: return "stmk_switch_case";
            case 15L: return "stmk_switch";
            case 16L: return "stmk_init";
            case 17L: return "stmk_asm";
            case 18L: return "stmk_asm_func_body";
            case 19L: return "stmk_try_block";
            case 20L: return "stmk_microsoft_try";
            case 21L: return "stmk_decl";
            case 22L: return "stmk_set_vla_size";
            case 23L: return "stmk_vla_decl";
            case 24L: return "stmk_upc_notify";
            case 25L: return "stmk_upc_wait";
            case 26L: return "stmk_upc_barrier";
            case 27L: return "stmk_upc_fence";
            case 28L: return "stmk_upc_forall";
            case 29L: return "stmk_assigned_goto";
            case 30L: return "stmk_empty";
            case 31L: return "stmk_stmt_expr_result";
            case 32L: return "stmk_last";
            default: return "";
        }
    }

    std::string a_statement_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_statement_kind_tag(i);
        if (s.empty())
            s = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_statement_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_statement_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_statement_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_statement_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_statement_kind_tag() {
        return stringify::a_statement_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 14278
namespace stringify {
    const char* a_for_each_pattern_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfepk_none";
            case 1L: return "sfepk_stl_pattern";
            case 2L: return "sfepk_cli_pattern";
            case 3L: return "sfepk_cli_array_pattern";
            case 4L: return "sfepk_array_pattern";
            default: return "";
        }
    }

    std::string a_for_each_pattern_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_for_each_pattern_kind_tag(i);
        if (s.empty())
            s = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_for_each_pattern_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_for_each_pattern_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_for_each_pattern_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_for_each_pattern_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_for_each_pattern_kind_tag() {
        return stringify::a_for_each_pattern_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15070
namespace stringify {
    const char* a_constructor_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cik_virtual_base_class";
            case 1L: return "cik_direct_base_class";
            case 2L: return "cik_field";
            case 3L: return "cik_delegation";
            default: return "";
        }
    }

    std::string a_constructor_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constructor_init_kind_tag(i);
        if (s.empty())
            s = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constructor_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constructor_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constructor_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constructor_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constructor_init_kind_tag() {
        return stringify::a_constructor_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15297
namespace stringify {
    const char* a_generic_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gck_none";
            case 1L: return "gck_type";
            case 2L: return "gck_naked_type_param";
            case 3L: return "gck_ref_class";
            case 4L: return "gck_value_class";
            case 5L: return "gck_gcnew";
            case 6L: return "gck_fail";
            default: return "";
        }
    }

    std::string a_generic_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_generic_constraint_kind_tag(i);
        if (s.empty())
            s = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_generic_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_generic_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_generic_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_generic_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_generic_constraint_kind_tag() {
        return stringify::a_generic_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15385
namespace stringify {
    const char* a_template_parameter_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpk_error";
            case 1L: return "tpk_type";
            case 2L: return "tpk_nontype";
            case 3L: return "tpk_template";
            default: return "";
        }
    }

    std::string a_template_parameter_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_parameter_kind_tag(i);
        if (s.empty())
            s = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_parameter_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_parameter_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_parameter_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_parameter_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_parameter_kind_tag() {
        return stringify::a_template_parameter_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15489
namespace stringify {
    const char* a_template_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "templk_none";
            case 1L: return "templk_class";
            case 2L: return "templk_function";
            case 3L: return "templk_variable";
            case 4L: return "templk_member_function";
            case 5L: return "templk_static_data_member";
            case 6L: return "templk_member_class";
            case 7L: return "templk_member_enum";
            case 8L: return "templk_template_template_param";
            default: return "";
        }
    }

    std::string a_template_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_kind_tag(i);
        if (s.empty())
            s = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_kind_tag() {
        return stringify::a_template_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15834
namespace stringify {
    const char* an_object_lifetime_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "olk_global_static";
            case 1L: return "olk_block";
            case 2L: return "olk_block_after_label";
            case 3L: return "olk_function_static";
            case 4L: return "olk_expr_temporary";
            case 5L: return "olk_try_block";
            default: return "";
        }
    }

    std::string an_object_lifetime_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_object_lifetime_kind_tag(i);
        if (s.empty())
            s = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_object_lifetime_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_object_lifetime_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_object_lifetime_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_object_lifetime_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_object_lifetime_kind_tag() {
        return stringify::an_object_lifetime_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15977
namespace stringify {
    const char* an_ms_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msak_none";
            case 1L: return "msak_unrecognized";
            case 2L: return "msak_misc";
            case 3L: return "msak_uuid";
            case 4L: return "msak_custom";
            case 5L: return "msak_edg_test";
            case 6L: return "msak_coclass";
            case 7L: return "msak_no_injected_text";
            case 8L: return "msak_last";
            default: return "";
        }
    }

    std::string an_ms_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_kind_tag() {
        return stringify::an_ms_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 15999
namespace stringify {
    const char* an_ms_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msaak_none";
            case 1L: return "msaak_integer";
            case 2L: return "msaak_boolean";
            case 3L: return "msaak_string";
            case 4L: return "msaak_uuid";
            case 5L: return "msaak_enumeration";
            case 6L: return "msaak_other";
            default: return "";
        }
    }

    std::string an_ms_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_arg_kind_tag() {
        return stringify::an_ms_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il_def.h line 16385
namespace stringify {
    const char* a_scope_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sck_file";
            case 1L: return "sck_func_prototype";
            case 2L: return "sck_block";
            case 3L: return "sck_namespace";
            case 4L: return "sck_namespace_extension";
            case 5L: return "sck_namespace_reactivation";
            case 6L: return "sck_class_struct_union";
            case 7L: return "sck_class_reactivation";
            case 8L: return "sck_template_declaration";
            case 9L: return "sck_template_instantiation";
            case 10L: return "sck_instantiation_context";
            case 11L: return "sck_pragma";
            case 12L: return "sck_function_access";
            case 13L: return "sck_condition";
            case 14L: return "sck_enum";
            case 15L: return "sck_function";
            case 16L: return "sck_none";
            default: return "";
        }
    }

    std::string a_scope_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_scope_kind_tag(i);
        if (s.empty())
            s = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_scope_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_scope_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_scope_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_scope_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_scope_kind_tag() {
        return stringify::a_scope_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/symbol_tbl.h line 436
namespace stringify {
    const char* a_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sk_keyword";
            case 1L: return "sk_macro";
            case 2L: return "sk_constant";
            case 3L: return "sk_type";
            case 4L: return "sk_class_or_struct_tag";
            case 5L: return "sk_union_tag";
            case 6L: return "sk_enum_tag";
            case 7L: return "sk_variable";
            case 8L: return "sk_field";
            case 9L: return "sk_static_data_member";
            case 10L: return "sk_member_function";
            case 11L: return "sk_routine";
            case 12L: return "sk_label";
            case 13L: return "sk_undefined";
            case 14L: return "sk_extern_variable";
            case 15L: return "sk_extern_routine";
            case 16L: return "sk_projection";
            case 17L: return "sk_overloaded_function";
            case 18L: return "sk_parameter";
            case 19L: return "sk_class_template";
            case 20L: return "sk_function_template";
            case 21L: return "sk_variable_template";
            case 22L: return "sk_namespace";
            case 23L: return "sk_namespace_projection";
            case 24L: return "sk_named_address_space";
            case 25L: return "sk_named_register";
            case 26L: return "sk_property_set";
            case 27L: return "sk_last";
            default: return "";
        }
    }

    std::string a_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_symbol_kind_tag() {
        return stringify::a_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/symbol_tbl.h line 725
namespace stringify {
    const char* a_dependent_type_fixup_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dtfk_arg_transfer_method";
            case 1L: return "dtfk_routine_calling_method";
            case 2L: return "dtfk_array_type_size";
            case 3L: return "dtfk_array_of_abstract_class_check";
            default: return "";
        }
    }

    std::string a_dependent_type_fixup_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dependent_type_fixup_kind_tag(i);
        if (s.empty())
            s = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dependent_type_fixup_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dependent_type_fixup_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dependent_type_fixup_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dependent_type_fixup_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dependent_type_fixup_kind_tag() {
        return stringify::a_dependent_type_fixup_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/symbol_tbl.h line 3934
namespace stringify {
    const char* a_cli_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cok_none";
            case 1L: return "cok_first";
            case 2L: return "cok_addition_assignment";
            case 3L: return "cok_address_of";
            case 4L: return "cok_assign";
            case 5L: return "cok_bitwise_and";
            case 6L: return "cok_bitwise_and_assignment";
            case 7L: return "cok_bitwise_or";
            case 8L: return "cok_bitwise_or_assignment";
            case 9L: return "cok_comma";
            case 10L: return "cok_decrement";
            case 11L: return "cok_division";
            case 12L: return "cok_division_assignment";
            case 13L: return "cok_equality";
            case 14L: return "cok_exclusive_or";
            case 15L: return "cok_exclusive_or_assignment";
            case 16L: return "cok_explicit";
            case 17L: return "cok_false";
            case 18L: return "cok_function_call";
            case 19L: return "cok_greater_than";
            case 20L: return "cok_greater_than_or_equal";
            case 21L: return "cok_implicit";
            case 22L: return "cok_increment";
            case 23L: return "cok_inequality";
            case 24L: return "cok_left_shift";
            case 25L: return "cok_left_shift_assignment";
            case 26L: return "cok_less_than";
            case 27L: return "cok_less_than_or_equal";
            case 28L: return "cok_logical_and";
            case 29L: return "cok_logical_not";
            case 30L: return "cok_logical_or";
            case 31L: return "cok_member_selection";
            case 32L: return "cok_modulus";
            case 33L: return "cok_modulus_assignment";
            case 34L: return "cok_multiply";
            case 35L: return "cok_multiplication_assignment";
            case 36L: return "cok_ones_complement";
            case 37L: return "cok_pointer_dereference";
            case 38L: return "cok_pointer_to_member_selection";
            case 39L: return "cok_right_shift";
            case 40L: return "cok_right_shift_assignment";
            case 41L: return "cok_signed_right_shift";
            case 42L: return "cok_subscript";
            case 43L: return "cok_subtraction";
            case 44L: return "cok_subtraction_assignment";
            case 45L: return "cok_true";
            case 46L: return "cok_unary_negation";
            case 47L: return "cok_unary_plus";
            case 48L: return "cok_unsigned_right_shift";
            case 49L: return "cok_unsigned_right_shift_assignment";
            case 50L: return "cok_last";
            default: return "";
        }
    }

    std::string a_cli_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_operator_kind_tag(i);
        if (s.empty())
            s = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L
        };
        static const std::vector<int64_t> retval(values, values + 51);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_operator_kind_tag() {
        return stringify::a_cli_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/symbol_tbl.h line 4828
namespace stringify {
    const char* a_cli_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "csk_none";
            case 1L: return "csk_first_namespace";
            case 2L: return "csk_system_namespace";
            case 3L: return "csk_system_collections_namespace";
            case 4L: return "csk_system_collections_generic_namespace";
            case 5L: return "csk_platform_details_namespace";
            case 6L: return "csk_platform_metadata_namespace";
            case 7L: return "csk_windows_namespace";
            case 8L: return "csk_windows_foundation_namespace";
            case 9L: return "csk_windows_foundation_metadata_namespace";
            case 10L: return "csk_windows_foundation_collections_namespace";
            case 11L: return "csk_system_byte_sign_unspecified";
            case 12L: return "csk_system_sbyte";
            case 13L: return "csk_system_byte";
            case 14L: return "csk_system_int16";
            case 15L: return "csk_system_uint16";
            case 16L: return "csk_system_int32";
            case 17L: return "csk_system_uint32";
            case 18L: return "csk_system_int32_is_long";
            case 19L: return "csk_system_uint32_is_long";
            case 20L: return "csk_system_int64";
            case 21L: return "csk_system_uint64";
            case 22L: return "csk_system_single";
            case 23L: return "csk_system_double";
            case 24L: return "csk_system_double_is_long";
            case 25L: return "csk_system_boolean";
            case 26L: return "csk_system_char";
            case 27L: return "csk_system_void";
            case 28L: return "csk_system_object";
            case 29L: return "csk_system_value_type";
            case 30L: return "csk_system_enum";
            case 31L: return "csk_system_type";
            case 32L: return "csk_system_string";
            case 33L: return "csk_system_delegate";
            case 34L: return "csk_system_multicast_delegate";
            case 35L: return "csk_system_idisposable";
            case 36L: return "csk_system_array";
            case 37L: return "csk_system_nullable";
            case 38L: return "csk_system_runtime_argument_handle";
            case 39L: return "csk_system_async_callback";
            case 40L: return "csk_system_iasync_result";
            case 41L: return "csk_system_attribute";
            case 42L: return "csk_system_attribute_targets";
            case 43L: return "csk_system_attribute_usage_attribute";
            case 44L: return "csk_system_flags_attribute";
            case 45L: return "csk_system_param_array_attribute";
            case 46L: return "csk_system_obsolete_attribute";
            case 47L: return "csk_system_collections_ienumerable";
            case 48L: return "csk_system_collections_generic_ienumerable";
            case 49L: return "csk_cli_array";
            case 50L: return "csk_interior_ptr";
            case 51L: return "csk_pin_ptr";
            case 52L: return "csk_size_t";
            case 53L: return "csk_platform_details_guid";
            case 54L: return "csk_platform_write_only_array";
            case 55L: return "csk_platform_callback_context";
            case 56L: return "csk_cppcx_box";
            case 57L: return "csk_abi_hstring";
            case 58L: return "csk_windows_foundation_event_registration_token";
            case 59L: return "csk_windows_foundation_metadata_allow_multiple_attribute";
            case 60L: return "csk_windows_foundation_metadata_deprecated_attribute";
            case 61L: return "csk_last";
            default: return "";
        }
    }

    std::string a_cli_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L
        };
        static const std::vector<int64_t> retval(values, values + 62);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_symbol_kind_tag() {
        return stringify::a_cli_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/lower_il.h line 421
namespace stringify {
    const char* an_insert_location_kind(int64_t i) {
        switch (i) {
            case 0L: return "ilk_after_statement";
            case 1L: return "ilk_block_start";
            case 2L: return "ilk_statement_creation";
            case 3L: return "ilk_before_expr";
            case 4L: return "ilk_after_expr";
            case 5L: return "ilk_expr_creation";
            default: return "";
        }
    }

    std::string an_insert_location_kind(int64_t i, const std::string &strip) {
        std::string s = an_insert_location_kind(i);
        if (s.empty())
            s = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_insert_location_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_insert_location_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_insert_location_kind(i);
        if (retval.empty()) {
            retval = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_insert_location_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_insert_location_kind() {
        return stringify::an_insert_location_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/disp/decls.c line 16203
namespace stringify {
    const char* an_end_of_decl_action(int64_t i) {
        switch (i) {
            case 0L: return "eoda_not_at_end";
            case 1L: return "eoda_deferred_actions";
            case 2L: return "eoda_check_semicolon";
            case 3L: return "eoda_skip_final_token";
            case 4L: return "eoda_done";
            default: return "";
        }
    }

    std::string an_end_of_decl_action(int64_t i, const std::string &strip) {
        std::string s = an_end_of_decl_action(i);
        if (s.empty())
            s = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_end_of_decl_action() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_end_of_decl_action(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_end_of_decl_action(i);
        if (retval.empty()) {
            retval = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_end_of_decl_action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_end_of_decl_action() {
        return stringify::an_end_of_decl_action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/exprutil.h line 99
namespace stringify {
    const char* an_expression_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ek_pp";
            case 1L: return "ek_integral_constant";
            case 2L: return "ek_template_arg";
            case 3L: return "ek_init_constant";
            case 4L: return "ek_normal";
            case 5L: return "ek_sizeof";
            default: return "";
        }
    }

    std::string an_expression_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expression_kind_tag(i);
        if (s.empty())
            s = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expression_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expression_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expression_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expression_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expression_kind_tag() {
        return stringify::an_expression_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/exprutil.h line 136
namespace stringify {
    const char* a_cast_source_form(int64_t i) {
        switch (i) {
            case 0L: return "csf_none";
            case 1L: return "csf_old_style";
            case 2L: return "csf_functional";
            case 3L: return "csf_static_cast";
            case 4L: return "csf_const_cast";
            case 5L: return "csf_reinterpret_cast";
            case 6L: return "csf_safe_cast";
            case 7L: return "csf_dynamic_cast";
            default: return "";
        }
    }

    std::string a_cast_source_form(int64_t i, const std::string &strip) {
        std::string s = a_cast_source_form(i);
        if (s.empty())
            s = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cast_source_form() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cast_source_form(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cast_source_form(i);
        if (retval.empty()) {
            retval = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cast_source_form::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cast_source_form() {
        return stringify::a_cast_source_form();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/exprutil.h line 155
namespace stringify {
    const char* a_type_class_kind(int64_t i) {
        switch (i) {
            case -1L: return "tck_none";
            case 0L: return "tck_void";
            case 1L: return "tck_integer";
            case 2L: return "tck_char";
            case 3L: return "tck_enum";
            case 4L: return "tck_bool";
            case 5L: return "tck_pointer";
            case 6L: return "tck_reference";
            case 7L: return "tck_offset";
            case 8L: return "tck_float";
            case 9L: return "tck_complex";
            case 10L: return "tck_routine";
            case 11L: return "tck_method";
            case 12L: return "tck_struct";
            case 13L: return "tck_union";
            case 14L: return "tck_array";
            case 15L: return "tck_string";
            default: return "";
        }
    }

    std::string a_type_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_class_kind(i);
        if (s.empty())
            s = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_class_kind() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_class_kind(i);
        if (retval.empty()) {
            retval = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_class_kind() {
        return stringify::a_type_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/exprutil.h line 237
namespace stringify {
    const char* an_operand_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ok_error";
            case 1L: return "ok_expression";
            case 2L: return "ok_constant";
            case 3L: return "ok_indefinite_function";
            case 4L: return "ok_sym_for_member";
            case 5L: return "ok_property_ref";
            case 6L: return "ok_event_ref";
            case 7L: return "ok_braced_init_list";
            case 8L: return "ok_undefined_symbol";
            default: return "";
        }
    }

    std::string an_operand_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_kind_tag(i);
        if (s.empty())
            s = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_kind_tag() {
        return stringify::an_operand_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/exprutil.h line 286
namespace stringify {
    const char* an_operand_state_tag(int64_t i) {
        switch (i) {
            case 0L: return "os_none";
            case 1L: return "os_glvalue";
            case 2L: return "os_prvalue";
            case 3L: return "os_function_designator";
            default: return "";
        }
    }

    std::string an_operand_state_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_state_tag(i);
        if (s.empty())
            s = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_state_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_state_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_state_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_state_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_state_tag() {
        return stringify::an_operand_state_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/il.h line 80
namespace stringify {
    const char* a_type_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tik_user";
            case 1L: return "tik_fundamental";
            case 2L: return "tik_enum";
            case 3L: return "tik_array";
            case 4L: return "tik_function";
            case 5L: return "tik_class";
            case 6L: return "tik_si_class";
            case 7L: return "tik_vmi_class";
            case 8L: return "tik_pbase";
            case 9L: return "tik_pointer";
            case 10L: return "tik_ptr_to_member";
            case 11L: return "tik_implementation";
            case 12L: return "tik_last";
            default: return "";
        }
    }

    std::string a_type_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_info_kind_tag(i);
        if (s.empty())
            s = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_info_kind_tag() {
        return stringify::a_type_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/ms_metadata.h line 19
namespace stringify {
    const char* a_cpp_cli_import_flag_tag(int64_t i) {
        switch (i) {
            case 0L: return "cpp_cli_none";
            case 1L: return "cpp_cli_as_friend_assembly";
            case 2L: return "cpp_cli_declspec_assembly_info";
            case 4L: return "cpp_cli_declspec_member_info";
            case 8L: return "cpp_cli_define_all_types";
            case 16L: return "cpp_cli_wchar_t_is_keyword";
            case 32L: return "cpp_cli_ide_custom_attributes";
            case 64L: return "cpp_cli_all_custom_attributes";
            default: return "";
        }
    }

    std::string a_cpp_cli_import_flag_tag(int64_t i, const std::string &strip) {
        std::string s = a_cpp_cli_import_flag_tag(i);
        if (s.empty())
            s = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cpp_cli_import_flag_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cpp_cli_import_flag_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cpp_cli_import_flag_tag(i);
        if (retval.empty()) {
            retval = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cpp_cli_import_flag_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cpp_cli_import_flag_tag() {
        return stringify::a_cpp_cli_import_flag_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/statements.h line 53
namespace stringify {
    const char* a_control_flow_descr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cfdk_block";
            case 1L: return "cfdk_init";
            case 2L: return "cfdk_goto";
            case 3L: return "cfdk_label";
            case 4L: return "cfdk_case_label";
            case 5L: return "cfdk_end_of_block";
            default: return "";
        }
    }

    std::string a_control_flow_descr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_control_flow_descr_kind_tag(i);
        if (s.empty())
            s = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_control_flow_descr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_control_flow_descr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_control_flow_descr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_control_flow_descr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_control_flow_descr_kind_tag() {
        return stringify::a_control_flow_descr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/sys_predef.h line 212
namespace stringify {
    const char* a_builtin_user_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bufk_first";
            case 1L: return "bufk_choose_expr";
            case 2L: return "bufk_launder";
            case 3L: return "bufk_last";
            default: return "";
        }
    }

    std::string a_builtin_user_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_user_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_user_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_user_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_user_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_user_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_user_function_kind_tag() {
        return stringify::a_builtin_user_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/sys_predef.h line 400
namespace stringify {
    const char* a_multiversion_arch_kind_tag(int64_t i) {
        switch (i) {
            case -1L: return "mvak_invalid";
            case 0L: return "mvak_unknown";
            case 1L: return "mvak_lowest_cpu";
            case 2L: return "mvak_cpu_bdver2";
            case 3L: return "mvak_cpu_corei7";
            case 4L: return "mvak_cpu_amdfam10h";
            case 5L: return "mvak_cpu_core2";
            case 6L: return "mvak_highest_cpu";
            case 7L: return "mvak_default_target";
            case 8L: return "mvak_lowest_isa";
            case 9L: return "mvak_isa_sse";
            case 10L: return "mvak_isa_sse2";
            case 11L: return "mvak_isa_sse3";
            case 12L: return "mvak_isa_ssse3";
            case 13L: return "mvak_isa_sse4";
            case 14L: return "mvak_isa_sse4a";
            case 15L: return "mvak_isa_sse4_1";
            case 16L: return "mvak_isa_sse4_2";
            case 17L: return "mvak_isa_popcnt";
            case 18L: return "mvak_isa_aes";
            case 19L: return "mvak_isa_pclmul";
            case 20L: return "mvak_isa_avx";
            case 21L: return "mvak_isa_bmi";
            case 22L: return "mvak_isa_fma4";
            case 23L: return "mvak_isa_xop";
            case 24L: return "mvak_isa_fma";
            case 25L: return "mvak_isa_bmi2";
            case 26L: return "mvak_isa_avx2";
            case 27L: return "mvak_isa_avx512f";
            case 28L: return "mvak_last";
            default: return "";
        }
    }

    std::string a_multiversion_arch_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_multiversion_arch_kind_tag(i);
        if (s.empty())
            s = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_multiversion_arch_kind_tag() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_multiversion_arch_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_multiversion_arch_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_multiversion_arch_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_multiversion_arch_kind_tag() {
        return stringify::a_multiversion_arch_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/util/decode.c line 4297
namespace stringify {
    const char* a_substitution_kind(int64_t i) {
        switch (i) {
            case 0L: return "subk_unscoped_template_name";
            case 1L: return "subk_prefix";
            case 2L: return "subk_template_prefix";
            case 3L: return "subk_type";
            case 4L: return "subk_template_template_param";
            default: return "";
        }
    }

    std::string a_substitution_kind(int64_t i, const std::string &strip) {
        std::string s = a_substitution_kind(i);
        if (s.empty())
            s = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_substitution_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_substitution_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_substitution_kind(i);
        if (retval.empty()) {
            retval = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_substitution_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_substitution_kind() {
        return stringify::a_substitution_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/include/cxxabi.h line 62
namespace stringify { namespace __cxxabiv1 { namespace __base_class_type_info {
    const char* __offset_flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__virtual_mask";
            case 2L: return "__public_mask";
            case 8L: return "__offset_shift";
            default: return "";
        }
    }

    std::string __offset_flags_masks(int64_t i, const std::string &strip) {
        std::string s = __offset_flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __offset_flags_masks() {
        static const int64_t values[] = {
            1L,
            2L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__base_class_type_info__offset_flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__base_class_type_info::__offset_flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__base_class_type_info__offset_flags_masks() {
        return stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/include/cxxabi.h line 77
namespace stringify { namespace __cxxabiv1 { namespace __vmi_class_type_info {
    const char* __flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__non_diamond_repeat_mask";
            case 2L: return "__diamond_shaped_mask";
            default: return "";
        }
    }

    std::string __flags_masks(int64_t i, const std::string &strip) {
        std::string s = __flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __flags_masks() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__vmi_class_type_info__flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__vmi_class_type_info::__flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__vmi_class_type_info__flags_masks() {
        return stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/include/cxxabi.h line 90
namespace stringify { namespace __cxxabiv1 { namespace __pbase_type_info {
    const char* __masks(int64_t i) {
        switch (i) {
            case 1L: return "__const_mask";
            case 2L: return "__volatile_mask";
            case 4L: return "__restrict_mask";
            case 8L: return "__incomplete_mask";
            case 16L: return "__incomplete_class_mask";
            default: return "";
        }
    }

    std::string __masks(int64_t i, const std::string &strip) {
        std::string s = __masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __masks() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__pbase_type_info__masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__pbase_type_info::__masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__pbase_type_info::__masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__pbase_type_info__masks() {
        return stringify::__cxxabiv1::__pbase_type_info::__masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/lib_src/rtti.c line 120
namespace stringify {
    const char* a_result_virtuality(int64_t i) {
        switch (i) {
            case 0L: return "rv_unknown";
            case 1L: return "rv_nonvirtual";
            case 2L: return "rv_directvirtual";
            default: return "";
        }
    }

    std::string a_result_virtuality(int64_t i, const std::string &strip) {
        std::string s = a_result_virtuality(i);
        if (s.empty())
            s = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_result_virtuality() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_result_virtuality(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_result_virtuality(i);
        if (retval.empty()) {
            retval = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_result_virtuality::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_result_virtuality() {
        return stringify::a_result_virtuality();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/lib_src/eh.h line 348
namespace stringify {
    const char* an_eh_stack_entry_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ehsek_old_try_block";
            case 1L: return "ehsek_function";
            case 2L: return "ehsek_throw_spec";
            case 3L: return "ehsek_throw_processing_marker";
            case 4L: return "ehsek_vec_new_or_delete";
            case 5L: return "ehsek_try_block";
            case 6L: return "ehsek_noexcept";
            default: return "";
        }
    }

    std::string an_eh_stack_entry_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_eh_stack_entry_kind_tag(i);
        if (s.empty())
            s = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_eh_stack_entry_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_eh_stack_entry_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_eh_stack_entry_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_eh_stack_entry_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_eh_stack_entry_kind_tag() {
        return stringify::an_eh_stack_entry_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_4.9/src/error.c line 115
namespace stringify {
    const char* a_diagnostic_category_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dck_standalone";
            case 1L: return "dck_primary";
            case 2L: return "dck_list";
            case 3L: return "dck_end_list";
            case 4L: return "dck_context_primary";
            case 5L: return "dck_end_context";
            case 6L: return "dck_macro_context";
            default: return "";
        }
    }

    std::string a_diagnostic_category_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_diagnostic_category_kind_tag(i);
        if (s.empty())
            s = "(a_diagnostic_category_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diagnostic_category_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diagnostic_category_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diagnostic_category_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_diagnostic_category_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diagnostic_category_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diagnostic_category_kind_tag() {
        return stringify::a_diagnostic_category_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_4.9/src/error.c line 158
namespace stringify {
    const char* a_message_segment_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msk_error_text_part";
            case 1L: return "msk_user_string";
            case 2L: return "msk_type";
            case 3L: return "msk_symbol";
            case 4L: return "msk_source_position";
            case 5L: return "msk_last";
            default: return "";
        }
    }

    std::string a_message_segment_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_message_segment_kind_tag(i);
        if (s.empty())
            s = "(a_message_segment_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_message_segment_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_message_segment_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_message_segment_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_message_segment_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_message_segment_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_message_segment_kind_tag() {
        return stringify::a_message_segment_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/edgRose.C line 6298
namespace stringify {
    const char* kinds_of_type_references(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_type_reference";
            case 1L: return "e_modifier_type_reference";
            case 2L: return "e_typeof_type_reference";
            case 3L: return "e_decltype_type_reference";
            case 4L: return "e_template_alias_type_reference";
            case 5L: return "e_last_type_reference";
            default: return "";
        }
    }

    std::string kinds_of_type_references(int64_t i, const std::string &strip) {
        std::string s = kinds_of_type_references(i);
        if (s.empty())
            s = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kinds_of_type_references() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_kinds_of_type_references(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::kinds_of_type_references(i);
        if (retval.empty()) {
            retval = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "kinds_of_type_references::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_kinds_of_type_references() {
        return stringify::kinds_of_type_references();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp line 137
namespace stringify { namespace ClangToSageTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToSageTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToSageTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToSageTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToSageTranslatorLanguage() {
        return stringify::ClangToSageTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageBuilder.h line 138
namespace stringify { namespace SageBuilder {
    const char* SourcePositionClassification(int64_t i) {
        switch (i) {
            case 0L: return "e_sourcePositionError";
            case 1L: return "e_sourcePositionDefault";
            case 2L: return "e_sourcePositionTransformation";
            case 3L: return "e_sourcePositionCompilerGenerated";
            case 4L: return "e_sourcePositionNullPointers";
            case 5L: return "e_sourcePositionFrontendConstruction";
            case 6L: return "e_sourcePosition_last";
            default: return "";
        }
    }

    std::string SourcePositionClassification(int64_t i, const std::string &strip) {
        std::string s = SourcePositionClassification(i);
        if (s.empty())
            s = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SourcePositionClassification() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySageBuilderSourcePositionClassification(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageBuilder::SourcePositionClassification(i);
        if (retval.empty()) {
            retval = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageBuilder::SourcePositionClassification::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageBuilderSourcePositionClassification() {
        return stringify::SageBuilder::SourcePositionClassification();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 133
namespace stringify { namespace PreprocessingInfo {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoRelativePositionType() {
        return stringify::PreprocessingInfo::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 154
namespace stringify { namespace PreprocessingInfo {
    const char* DirectiveType(int64_t i) {
        switch (i) {
            case 0L: return "CpreprocessorUnknownDeclaration";
            case 1L: return "C_StyleComment";
            case 2L: return "CplusplusStyleComment";
            case 3L: return "FortranStyleComment";
            case 4L: return "F90StyleComment";
            case 5L: return "CpreprocessorBlankLine";
            case 6L: return "CpreprocessorIncludeDeclaration";
            case 7L: return "CpreprocessorIncludeNextDeclaration";
            case 8L: return "CpreprocessorDefineDeclaration";
            case 9L: return "CpreprocessorUndefDeclaration";
            case 10L: return "CpreprocessorIfdefDeclaration";
            case 11L: return "CpreprocessorIfndefDeclaration";
            case 12L: return "CpreprocessorIfDeclaration";
            case 13L: return "CpreprocessorDeadIfDeclaration";
            case 14L: return "CpreprocessorElseDeclaration";
            case 15L: return "CpreprocessorElifDeclaration";
            case 16L: return "CpreprocessorEndifDeclaration";
            case 17L: return "CpreprocessorLineDeclaration";
            case 18L: return "CpreprocessorErrorDeclaration";
            case 19L: return "CpreprocessorWarningDeclaration";
            case 20L: return "CpreprocessorEmptyDeclaration";
            case 21L: return "CSkippedToken";
            case 22L: return "CMacroCall";
            case 23L: return "CMacroCallStatement";
            case 24L: return "LineReplacement";
            case 25L: return "ClinkageSpecificationStart";
            case 26L: return "ClinkageSpecificationEnd";
            case 27L: return "CpreprocessorIdentDeclaration";
            case 28L: return "CpreprocessorCompilerGeneratedLinemarker";
            case 29L: return "RawText";
            case 30L: return "LastDirectiveType";
            default: return "";
        }
    }

    std::string DirectiveType(int64_t i, const std::string &strip) {
        std::string s = DirectiveType(i);
        if (s.empty())
            s = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DirectiveType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoDirectiveType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::DirectiveType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::DirectiveType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoDirectiveType() {
        return stringify::PreprocessingInfo::DirectiveType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 522
namespace stringify { namespace ROSEAttributesList {
    const char* languageTypeEnum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_language";
            case 1L: return "e_C_language";
            case 2L: return "e_Cxx_language";
            case 3L: return "e_Fortran77_language";
            case 4L: return "e_Fortran9x_language";
            case 5L: return "e_lastLanguage";
            default: return "";
        }
    }

    std::string languageTypeEnum(int64_t i, const std::string &strip) {
        std::string s = languageTypeEnum(i);
        if (s.empty())
            s = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageTypeEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSEAttributesList_languageTypeEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSEAttributesList::languageTypeEnum(i);
        if (retval.empty()) {
            retval = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSEAttributesList::languageTypeEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSEAttributesList_languageTypeEnum() {
        return stringify::ROSEAttributesList::languageTypeEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 25
namespace stringify { namespace AstAttributeDOT {
    const char* DOTStyles(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTStyles";
            case 1L: return "filled";
            case 2L: return "not_filled";
            case 3L: return "END_OF_NODE_TYPE_LIST_DOTStyles";
            default: return "";
        }
    }

    std::string DOTStyles(int64_t i, const std::string &strip) {
        std::string s = DOTStyles(i);
        if (s.empty())
            s = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTStyles() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeDOT_DOTStyles(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttributeDOT::DOTStyles(i);
        if (retval.empty()) {
            retval = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttributeDOT::DOTStyles::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeDOT_DOTStyles() {
        return stringify::AstAttributeDOT::DOTStyles();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 90
namespace stringify { namespace DOTGraphNode {
    const char* DOTShapeTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTShapeTypes";
            case 1L: return "polygon";
            case 2L: return "ellipse";
            case 3L: return "record";
            case 4L: return "mrecord";
            case 5L: return "END_OF_NODE_TYPE_LIST_DOTShapeTypes";
            default: return "";
        }
    }

    std::string DOTShapeTypes(int64_t i, const std::string &strip) {
        std::string s = DOTShapeTypes(i);
        if (s.empty())
            s = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTShapeTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphNodeDOTShapeTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphNode::DOTShapeTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphNode::DOTShapeTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphNodeDOTShapeTypes() {
        return stringify::DOTGraphNode::DOTShapeTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 137
namespace stringify { namespace DOTGraphEdge {
    const char* DOTArrowTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementArrowTypes";
            case 1L: return "normal";
            case 2L: return "inv";
            case 3L: return "dot";
            case 4L: return "invdot";
            case 5L: return "odot";
            case 6L: return "invodot";
            case 7L: return "none";
            case 8L: return "tee";
            case 9L: return "empty";
            case 10L: return "invempty";
            case 11L: return "diamond";
            case 12L: return "odiamond";
            case 13L: return "ediamond";
            case 14L: return "crow";
            case 15L: return "box";
            case 16L: return "obox";
            case 17L: return "open";
            case 18L: return "halfopen";
            case 19L: return "vee";
            case 20L: return "END_OF_NODE_TYPE_LIST_DOTArrowTypes";
            default: return "";
        }
    }

    std::string DOTArrowTypes(int64_t i, const std::string &strip) {
        std::string s = DOTArrowTypes(i);
        if (s.empty())
            s = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTArrowTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphEdgeDOTArrowTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphEdge::DOTArrowTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphEdgeDOTArrowTypes() {
        return stringify::DOTGraphEdge::DOTArrowTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 12
namespace stringify { namespace AST_Graph {
    const char* pointerHandling(int64_t i) {
        switch (i) {
            case 0L: return "graph_NULL";
            case 1L: return "do_not_graph_NULL";
            default: return "";
        }
    }

    std::string pointerHandling(int64_t i, const std::string &strip) {
        std::string s = pointerHandling(i);
        if (s.empty())
            s = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& pointerHandling() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_pointerHandling(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::pointerHandling(i);
        if (retval.empty()) {
            retval = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::pointerHandling::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_pointerHandling() {
        return stringify::AST_Graph::pointerHandling();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 19
namespace stringify { namespace AST_Graph {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "memory_pool_traversal";
            case 1L: return "whole_graph_AST";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::traversalType(i);
        if (retval.empty()) {
            retval = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_traversalType() {
        return stringify::AST_Graph::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 30
namespace stringify {
    const char* omp_lock_hint_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_lock_hint_none";
            case 1L: return "omp_lock_hint_uncontended";
            case 2L: return "omp_lock_hint_contended";
            case 4L: return "omp_lock_hint_nonspeculative";
            case 8L: return "omp_lock_hint_speculative";
            default: return "";
        }
    }

    std::string omp_lock_hint_t(int64_t i, const std::string &strip) {
        std::string s = omp_lock_hint_t(i);
        if (s.empty())
            s = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_lock_hint_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_lock_hint_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_lock_hint_t(i);
        if (retval.empty()) {
            retval = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_lock_hint_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_lock_hint_t() {
        return stringify::omp_lock_hint_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 46
namespace stringify {
    const char* omp_sched_t(int64_t i) {
        switch (i) {
            case 1L: return "omp_sched_static";
            case 2L: return "omp_sched_dynamic";
            case 3L: return "omp_sched_guided";
            case 4L: return "omp_sched_auto";
            default: return "";
        }
    }

    std::string omp_sched_t(int64_t i, const std::string &strip) {
        std::string s = omp_sched_t(i);
        if (s.empty())
            s = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_sched_t() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_sched_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_sched_t(i);
        if (retval.empty()) {
            retval = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_sched_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_sched_t() {
        return stringify::omp_sched_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 57
namespace stringify {
    const char* omp_proc_bind_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_proc_bind_false";
            case 1L: return "omp_proc_bind_true";
            case 2L: return "omp_proc_bind_master";
            case 3L: return "omp_proc_bind_close";
            case 4L: return "omp_proc_bind_spread";
            default: return "";
        }
    }

    std::string omp_proc_bind_t(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_t(i);
        if (s.empty())
            s = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_proc_bind_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_proc_bind_t(i);
        if (retval.empty()) {
            retval = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_proc_bind_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_proc_bind_t() {
        return stringify::omp_proc_bind_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/OmpAttribute.h line 31
namespace stringify { namespace OmpSupport {
    const char* omp_construct_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_parallel";
            case 2L: return "e_for";
            case 3L: return "e_for_simd";
            case 4L: return "e_do";
            case 5L: return "e_workshare";
            case 6L: return "e_sections";
            case 7L: return "e_section";
            case 8L: return "e_single";
            case 9L: return "e_master";
            case 10L: return "e_critical";
            case 11L: return "e_barrier";
            case 12L: return "e_atomic";
            case 13L: return "e_flush";
            case 14L: return "e_target";
            case 15L: return "e_target_declare";
            case 16L: return "e_target_data";
            case 17L: return "e_target_update";
            case 18L: return "e_map";
            case 19L: return "e_device";
            case 20L: return "e_begin";
            case 21L: return "e_end";
            case 22L: return "e_threadprivate";
            case 23L: return "e_parallel_for";
            case 24L: return "e_parallel_for_simd";
            case 25L: return "e_parallel_do";
            case 26L: return "e_parallel_sections";
            case 27L: return "e_parallel_workshare";
            case 28L: return "e_task";
            case 29L: return "e_taskwait";
            case 30L: return "e_ordered_directive";
            case 31L: return "e_end_critical";
            case 32L: return "e_end_do";
            case 33L: return "e_end_master";
            case 34L: return "e_end_ordered";
            case 35L: return "e_end_parallel_do";
            case 36L: return "e_end_parallel_sections";
            case 37L: return "e_end_parallel_workshare";
            case 38L: return "e_end_parallel";
            case 39L: return "e_end_sections";
            case 40L: return "e_end_single";
            case 41L: return "e_end_task";
            case 42L: return "e_end_workshare";
            case 43L: return "e_default";
            case 44L: return "e_shared";
            case 45L: return "e_private";
            case 46L: return "e_firstprivate";
            case 47L: return "e_lastprivate";
            case 48L: return "e_copyin";
            case 49L: return "e_copyprivate";
            case 50L: return "e_proc_bind";
            case 51L: return "e_if";
            case 52L: return "e_num_threads";
            case 53L: return "e_nowait";
            case 54L: return "e_ordered_clause";
            case 55L: return "e_reduction";
            case 56L: return "e_schedule";
            case 57L: return "e_collapse";
            case 58L: return "e_untied";
            case 59L: return "e_mergeable";
            case 60L: return "e_final";
            case 61L: return "e_priority";
            case 62L: return "e_atomic_clause";
            case 63L: return "e_inbranch";
            case 64L: return "e_notinbranch";
            case 65L: return "e_depend";
            case 66L: return "e_default_none";
            case 67L: return "e_default_shared";
            case 68L: return "e_default_private";
            case 69L: return "e_default_firstprivate";
            case 70L: return "e_proc_bind_master";
            case 71L: return "e_proc_bind_close";
            case 72L: return "e_proc_bind_spread";
            case 73L: return "e_atomic_read";
            case 74L: return "e_atomic_write";
            case 75L: return "e_atomic_update";
            case 76L: return "e_atomic_capture";
            case 77L: return "e_reduction_plus";
            case 78L: return "e_reduction_mul";
            case 79L: return "e_reduction_minus";
            case 80L: return "e_reduction_bitand";
            case 81L: return "e_reduction_bitor";
            case 82L: return "e_reduction_bitxor";
            case 83L: return "e_reduction_logand";
            case 84L: return "e_reduction_logor";
            case 85L: return "e_reduction_and";
            case 86L: return "e_reduction_or";
            case 87L: return "e_reduction_eqv";
            case 88L: return "e_reduction_neqv";
            case 89L: return "e_reduction_max";
            case 90L: return "e_reduction_min";
            case 91L: return "e_reduction_iand";
            case 92L: return "e_reduction_ior";
            case 93L: return "e_reduction_ieor";
            case 94L: return "e_schedule_none";
            case 95L: return "e_schedule_static";
            case 96L: return "e_schedule_dynamic";
            case 97L: return "e_schedule_guided";
            case 98L: return "e_schedule_auto";
            case 99L: return "e_schedule_runtime";
            case 100L: return "e_map_alloc";
            case 101L: return "e_map_to";
            case 102L: return "e_map_from";
            case 103L: return "e_map_tofrom";
            case 104L: return "e_dist_data";
            case 105L: return "e_duplicate";
            case 106L: return "e_block";
            case 107L: return "e_cyclic";
            case 108L: return "e_simd";
            case 109L: return "e_declare_simd";
            case 110L: return "e_safelen";
            case 111L: return "e_simdlen";
            case 112L: return "e_uniform";
            case 113L: return "e_aligned";
            case 114L: return "e_linear";
            case 115L: return "e_depend_in";
            case 116L: return "e_depend_out";
            case 117L: return "e_depend_inout";
            case 118L: return "e_not_omp";
            default: return "";
        }
    }

    std::string omp_construct_enum(int64_t i, const std::string &strip) {
        std::string s = omp_construct_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_construct_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L
        };
        static const std::vector<int64_t> retval(values, values + 119);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_construct_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_construct_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_construct_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_construct_enum() {
        return stringify::OmpSupport::omp_construct_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 12
namespace stringify { namespace ROSE_token_ids {
    const char* whitespace(int64_t i) {
        switch (i) {
            case 0L: return "T_NOTKNOWN";
            default: return "";
        }
    }

    std::string whitespace(int64_t i, const std::string &strip) {
        std::string s = whitespace(i);
        if (s.empty())
            s = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& whitespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_ids_whitespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::whitespace(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::whitespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_ids_whitespace() {
        return stringify::ROSE_token_ids::whitespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 21
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_keywords() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 159
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_alternate_tok(int64_t i) {
        switch (i) {
            case 0L: return "C_CXX_LEFT_CURLY_ALT";
            case 1L: return "C_CXX_RIGHT_CURLY_ALT";
            case 2L: return "C_CXX_LEFT_SQUARE_ALT";
            case 3L: return "C_CXX_RIGHT_SQUARE_ALT";
            case 4L: return "C_CXX_HASH_ALT";
            case 5L: return "C_CXX_HASH_HASH_ALT";
            case 6L: return "C_CXX_and_ALT";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_alternate_tok(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_alternate_tok(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_alternate_tok() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_alternate_tok(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_alternate_tok() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 171
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "C_CXX_COMMENTS";
            case 100001L: return "C_CXX_STRING_LITERALS";
            case 100002L: return "C_CXX_IDENTIFIER";
            case 100003L: return "C_CXX_PREPROCESSING_INFO";
            case 100004L: return "C_CXX_UNIDENTIFIED_TOKEN";
            case 100005L: return "C_CXX_SYNTAX";
            case 100006L: return "C_CXX_WHITESPACE";
            case 100007L: return "C_CXX_PRAGMA";
            case 100008L: return "C_CXX_ERROR";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L,
            100005L,
            100006L,
            100007L,
            100008L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_Additional_Info() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualCFG.h line 47
namespace stringify { namespace VirtualCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            case 5L: return "eckDoConditionPassed";
            case 6L: return "eckDoConditionFailed";
            case 7L: return "eckForallIndicesInRange";
            case 8L: return "eckForallIndicesNotInRange";
            case 9L: return "eckComputedGotoCaseLabel";
            case 10L: return "eckArithmeticIfLess";
            case 11L: return "eckArithmeticIfEqual";
            case 12L: return "eckArithmeticIfGreater";
            case 13L: return "eckInterprocedural";
            case 14L: return "eckError";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualCFG_EdgeConditionKind() {
        return stringify::VirtualCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualBinCFG.h line 15
namespace stringify { namespace VirtualBinCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualBinCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualBinCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualBinCFG_EdgeConditionKind() {
        return stringify::VirtualBinCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/DisassemblerX86.h line 139
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace DisassemblerX86 {
    const char* RegisterMode(int64_t i) {
        switch (i) {
            case 0L: return "rmLegacyByte";
            case 1L: return "rmRexByte";
            case 2L: return "rmWord";
            case 3L: return "rmDWord";
            case 4L: return "rmQWord";
            case 5L: return "rmSegment";
            case 6L: return "rmST";
            case 7L: return "rmMM";
            case 8L: return "rmXMM";
            case 9L: return "rmControl";
            case 10L: return "rmDebug";
            case 11L: return "rmReturnNull";
            default: return "";
        }
    }

    std::string RegisterMode(int64_t i, const std::string &strip) {
        std::string s = RegisterMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::DisassemblerX86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegisterMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86RegisterMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::DisassemblerX86::RegisterMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::DisassemblerX86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::DisassemblerX86::RegisterMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86RegisterMode() {
        return stringify::Rose::BinaryAnalysis::DisassemblerX86::RegisterMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/DisassemblerX86.h line 144
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace DisassemblerX86 {
    const char* MMPrefix(int64_t i) {
        switch (i) {
            case 0L: return "mmNone";
            case 1L: return "mmF3";
            case 2L: return "mm66";
            case 3L: return "mmF2";
            default: return "";
        }
    }

    std::string MMPrefix(int64_t i, const std::string &strip) {
        std::string s = MMPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::DisassemblerX86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MMPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86MMPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::DisassemblerX86::MMPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::DisassemblerX86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::DisassemblerX86::MMPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86MMPrefix() {
        return stringify::Rose::BinaryAnalysis::DisassemblerX86::MMPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsArm.h line 10
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* ArmRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "arm_regclass_gpr";
            case 1L: return "arm_regclass_psr";
            default: return "";
        }
    }

    std::string ArmRegisterClass(int64_t i, const std::string &strip) {
        std::string s = ArmRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ArmRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArmRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArmRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ArmRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ArmRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ArmRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArmRegisterClass() {
        return stringify::Rose::BinaryAnalysis::ArmRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsArm.h line 16
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* ArmProgramStatusRegister(int64_t i) {
        switch (i) {
            case 0L: return "arm_psr_current";
            case 1L: return "arm_psr_saved";
            default: return "";
        }
    }

    std::string ArmProgramStatusRegister(int64_t i, const std::string &strip) {
        std::string s = ArmProgramStatusRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ArmProgramStatusRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArmProgramStatusRegister() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArmProgramStatusRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ArmProgramStatusRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ArmProgramStatusRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ArmProgramStatusRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArmProgramStatusRegister() {
        return stringify::Rose::BinaryAnalysis::ArmProgramStatusRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsArm.h line 22
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* ArmInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "arm_unknown_instruction";
            case 1L: return "arm_adc";
            case 2L: return "arm_adcs";
            case 3L: return "arm_add";
            case 4L: return "arm_adds";
            case 5L: return "arm_and";
            case 6L: return "arm_ands";
            case 7L: return "arm_b";
            case 8L: return "arm_bic";
            case 9L: return "arm_bics";
            case 10L: return "arm_bkpt";
            case 11L: return "arm_bl";
            case 12L: return "arm_blx";
            case 13L: return "arm_bx";
            case 14L: return "arm_bxj";
            case 15L: return "arm_clz";
            case 16L: return "arm_cmn";
            case 17L: return "arm_cmp";
            case 18L: return "arm_eor";
            case 19L: return "arm_eors";
            case 20L: return "arm_ldm";
            case 21L: return "arm_ldmda";
            case 22L: return "arm_ldmdb";
            case 23L: return "arm_ldmia";
            case 24L: return "arm_ldmib";
            case 25L: return "arm_ldr";
            case 26L: return "arm_ldrb";
            case 27L: return "arm_ldrbt";
            case 28L: return "arm_ldrd";
            case 29L: return "arm_ldrsb";
            case 30L: return "arm_ldrsh";
            case 31L: return "arm_ldrt";
            case 32L: return "arm_ldruh";
            case 33L: return "arm_mla";
            case 34L: return "arm_mlas";
            case 35L: return "arm_mov";
            case 36L: return "arm_movs";
            case 37L: return "arm_mrs";
            case 38L: return "arm_msr";
            case 39L: return "arm_mul";
            case 40L: return "arm_muls";
            case 41L: return "arm_mvn";
            case 42L: return "arm_mvns";
            case 43L: return "arm_orr";
            case 44L: return "arm_orrs";
            case 45L: return "arm_qadd";
            case 46L: return "arm_qdadd";
            case 47L: return "arm_qdsub";
            case 48L: return "arm_qsub";
            case 49L: return "arm_rsb";
            case 50L: return "arm_rsbs";
            case 51L: return "arm_rsc";
            case 52L: return "arm_rscs";
            case 53L: return "arm_sbc";
            case 54L: return "arm_sbcs";
            case 55L: return "arm_setend";
            case 56L: return "arm_smlabb";
            case 57L: return "arm_smlabt";
            case 58L: return "arm_smlal";
            case 59L: return "arm_smlalbb";
            case 60L: return "arm_smlalbt";
            case 61L: return "arm_smlals";
            case 62L: return "arm_smlaltb";
            case 63L: return "arm_smlaltt";
            case 64L: return "arm_smlatb";
            case 65L: return "arm_smlatt";
            case 66L: return "arm_smlawb";
            case 67L: return "arm_smlawt";
            case 68L: return "arm_smluwb";
            case 69L: return "arm_smluwt";
            case 70L: return "arm_smulbb";
            case 71L: return "arm_smulbt";
            case 72L: return "arm_smull";
            case 73L: return "arm_smulls";
            case 74L: return "arm_smultb";
            case 75L: return "arm_smultt";
            case 76L: return "arm_stm";
            case 77L: return "arm_stmda";
            case 78L: return "arm_stmdb";
            case 79L: return "arm_stmia";
            case 80L: return "arm_stmib";
            case 81L: return "arm_str";
            case 82L: return "arm_strb";
            case 83L: return "arm_strbt";
            case 84L: return "arm_strd";
            case 85L: return "arm_strh";
            case 86L: return "arm_strt";
            case 87L: return "arm_sub";
            case 88L: return "arm_subs";
            case 89L: return "arm_swi";
            case 90L: return "arm_swp";
            case 91L: return "arm_teq";
            case 92L: return "arm_tst";
            case 93L: return "arm_umaal";
            case 94L: return "arm_umlal";
            case 95L: return "arm_umlals";
            case 96L: return "arm_umull";
            case 97L: return "arm_umulls";
            case 98L: return "arm_undefined";
            case 99L: return "arm_last_instruction";
            default: return "";
        }
    }

    std::string ArmInstructionKind(int64_t i, const std::string &strip) {
        std::string s = ArmInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ArmInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArmInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 100);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArmInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ArmInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ArmInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ArmInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArmInstructionKind() {
        return stringify::Rose::BinaryAnalysis::ArmInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsArm.h line 127
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* ArmInstructionCondition(int64_t i) {
        switch (i) {
            case 0L: return "arm_cond_unknown";
            case 1L: return "arm_cond_eq";
            case 2L: return "arm_cond_ne";
            case 3L: return "arm_cond_hs";
            case 4L: return "arm_cond_lo";
            case 5L: return "arm_cond_mi";
            case 6L: return "arm_cond_pl";
            case 7L: return "arm_cond_vs";
            case 8L: return "arm_cond_vc";
            case 9L: return "arm_cond_hi";
            case 10L: return "arm_cond_ls";
            case 11L: return "arm_cond_ge";
            case 12L: return "arm_cond_lt";
            case 13L: return "arm_cond_gt";
            case 14L: return "arm_cond_le";
            case 15L: return "arm_cond_al";
            case 16L: return "arm_cond_nv";
            default: return "";
        }
    }

    std::string ArmInstructionCondition(int64_t i, const std::string &strip) {
        std::string s = ArmInstructionCondition(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ArmInstructionCondition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArmInstructionCondition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArmInstructionCondition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ArmInstructionCondition(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ArmInstructionCondition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ArmInstructionCondition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArmInstructionCondition() {
        return stringify::Rose::BinaryAnalysis::ArmInstructionCondition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/DisassemblerMips.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace DisassemblerMips { namespace Mips32 {
    const char* Architecture(int64_t i) {
        switch (i) {
            case 0L: return "Release1";
            case 1L: return "Release2";
            case 2L: return "Release3";
            case 3L: return "Micro";
            default: return "";
        }
    }

    std::string Architecture(int64_t i, const std::string &strip) {
        std::string s = Architecture(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::DisassemblerMips::Mips32::Architecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Architecture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerMipsMips32Architecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::DisassemblerMips::Mips32::Architecture(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::DisassemblerMips::Mips32::Architecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::DisassemblerMips::Mips32::Architecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerMipsMips32Architecture() {
        return stringify::Rose::BinaryAnalysis::DisassemblerMips::Mips32::Architecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 12
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionSize(int64_t i) {
        switch (i) {
            case 0L: return "x86_insnsize_none";
            case 1L: return "x86_insnsize_16";
            case 2L: return "x86_insnsize_32";
            case 3L: return "x86_insnsize_64";
            default: return "";
        }
    }

    std::string X86InstructionSize(int64_t i, const std::string &strip) {
        std::string s = X86InstructionSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionSize() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionSize() {
        return stringify::Rose::BinaryAnalysis::X86InstructionSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 20
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "x86_regclass_gpr";
            case 1L: return "x86_regclass_segment";
            case 2L: return "x86_regclass_cr";
            case 3L: return "x86_regclass_dr";
            case 4L: return "x86_regclass_st";
            case 5L: return "x86_regclass_xmm";
            case 6L: return "x86_regclass_ip";
            case 7L: return "x86_regclass_flags";
            default: return "";
        }
    }

    std::string X86RegisterClass(int64_t i, const std::string &strip) {
        std::string s = X86RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RegisterClass() {
        return stringify::Rose::BinaryAnalysis::X86RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 33
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86SegmentRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_segreg_es";
            case 1L: return "x86_segreg_cs";
            case 2L: return "x86_segreg_ss";
            case 3L: return "x86_segreg_ds";
            case 4L: return "x86_segreg_fs";
            case 5L: return "x86_segreg_gs";
            case 16L: return "x86_segreg_none";
            default: return "";
        }
    }

    std::string X86SegmentRegister(int64_t i, const std::string &strip) {
        std::string s = X86SegmentRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86SegmentRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86SegmentRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86SegmentRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86SegmentRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86SegmentRegister() {
        return stringify::Rose::BinaryAnalysis::X86SegmentRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86GeneralPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_gpr_ax";
            case 1L: return "x86_gpr_cx";
            case 2L: return "x86_gpr_dx";
            case 3L: return "x86_gpr_bx";
            case 4L: return "x86_gpr_sp";
            case 5L: return "x86_gpr_bp";
            case 6L: return "x86_gpr_si";
            case 7L: return "x86_gpr_di";
            case 8L: return "x86_gpr_r8";
            case 9L: return "x86_gpr_r9";
            case 10L: return "x86_gpr_r10";
            case 11L: return "x86_gpr_r11";
            case 12L: return "x86_gpr_r12";
            case 13L: return "x86_gpr_r13";
            case 14L: return "x86_gpr_r14";
            case 15L: return "x86_gpr_r15";
            default: return "";
        }
    }

    std::string X86GeneralPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = X86GeneralPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86GeneralPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86GeneralPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86GeneralPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86GeneralPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 64
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86StRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_st_0";
            case 1L: return "x86_st_1";
            case 2L: return "x86_st_2";
            case 3L: return "x86_st_3";
            case 4L: return "x86_st_4";
            case 5L: return "x86_st_5";
            case 6L: return "x86_st_6";
            case 7L: return "x86_st_7";
            case 8L: return "x86_st_nregs";
            default: return "";
        }
    }

    std::string X86StRegister(int64_t i, const std::string &strip) {
        std::string s = X86StRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86StRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86StRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86StRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86StRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86StRegister() {
        return stringify::Rose::BinaryAnalysis::X86StRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 77
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flags(int64_t i) {
        switch (i) {
            case 0L: return "x86_flags_status";
            case 1L: return "x86_flags_fpstatus";
            case 2L: return "x86_flags_fptag";
            case 3L: return "x86_flags_fpctl";
            case 4L: return "x86_flags_mxcsr";
            default: return "";
        }
    }

    std::string X86Flags(int64_t i, const std::string &strip) {
        std::string s = X86Flags(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flags(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flags() {
        return stringify::Rose::BinaryAnalysis::X86Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 86
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flag(int64_t i) {
        switch (i) {
            case 0L: return "x86_flag_cf";
            case 2L: return "x86_flag_pf";
            case 4L: return "x86_flag_af";
            case 6L: return "x86_flag_zf";
            case 7L: return "x86_flag_sf";
            case 8L: return "x86_flag_tf";
            case 9L: return "x86_flag_if";
            case 10L: return "x86_flag_df";
            case 11L: return "x86_flag_of";
            case 12L: return "x86_flag_iopl";
            case 14L: return "x86_flag_nt";
            case 16L: return "x86_flag_rf";
            case 17L: return "x86_flag_vm";
            case 18L: return "x86_flag_ac";
            case 19L: return "x86_flag_vif";
            case 20L: return "x86_flag_vip";
            case 21L: return "x86_flag_id";
            default: return "";
        }
    }

    std::string X86Flag(int64_t i, const std::string &strip) {
        std::string s = X86Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flag() {
        static const int64_t values[] = {
            0L,
            2L,
            4L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            14L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flag() {
        return stringify::Rose::BinaryAnalysis::X86Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 107
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86BranchPrediction(int64_t i) {
        switch (i) {
            case 0L: return "x86_branch_prediction_none";
            case 1L: return "x86_branch_prediction_taken";
            case 2L: return "x86_branch_prediction_not_taken";
            default: return "";
        }
    }

    std::string X86BranchPrediction(int64_t i, const std::string &strip) {
        std::string s = X86BranchPrediction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86BranchPrediction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86BranchPrediction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86BranchPrediction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86BranchPrediction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86BranchPrediction() {
        return stringify::Rose::BinaryAnalysis::X86BranchPrediction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 115
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RepeatPrefix(int64_t i) {
        switch (i) {
            case 0L: return "x86_repeat_none";
            case 1L: return "x86_repeat_repne";
            case 2L: return "x86_repeat_repe";
            default: return "";
        }
    }

    std::string X86RepeatPrefix(int64_t i, const std::string &strip) {
        std::string s = X86RepeatPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RepeatPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RepeatPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RepeatPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RepeatPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RepeatPrefix() {
        return stringify::Rose::BinaryAnalysis::X86RepeatPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsX86.h line 124
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Exception(int64_t i) {
        switch (i) {
            case 0L: return "x86_exception_int";
            case 1L: return "x86_exception_sysenter";
            case 2L: return "x86_exception_syscall";
            case 3L: return "x86_exception_de";
            case 4L: return "x86_exception_db";
            case 5L: return "x86_exception_bp";
            case 6L: return "x86_exception_of";
            case 7L: return "x86_exception_br";
            case 8L: return "x86_exception_ud";
            case 9L: return "x86_exception_nm";
            case 10L: return "x86_exception_df";
            case 11L: return "x86_exception_ts";
            case 12L: return "x86_exception_np";
            case 13L: return "x86_exception_ss";
            case 14L: return "x86_exception_gp";
            case 15L: return "x86_exception_pf";
            case 16L: return "x86_exception_mf";
            case 17L: return "x86_exception_ac";
            case 18L: return "x86_exception_mc";
            case 19L: return "x86_exception_xm";
            default: return "";
        }
    }

    std::string X86Exception(int64_t i, const std::string &strip) {
        std::string s = X86Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Exception() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Exception() {
        return stringify::Rose::BinaryAnalysis::X86Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86Init.h line 24
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "x86_unknown_instruction";
            case 1L: return "x86_aaa";
            case 2L: return "x86_aad";
            case 3L: return "x86_aam";
            case 4L: return "x86_aas";
            case 5L: return "x86_adc";
            case 6L: return "x86_add";
            case 7L: return "x86_addpd";
            case 8L: return "x86_addps";
            case 9L: return "x86_addsd";
            case 10L: return "x86_addss";
            case 11L: return "x86_addsubpd";
            case 12L: return "x86_addsubps";
            case 13L: return "x86_and";
            case 14L: return "x86_andnpd";
            case 15L: return "x86_andnps";
            case 16L: return "x86_andpd";
            case 17L: return "x86_andps";
            case 18L: return "x86_arpl";
            case 19L: return "x86_blendpd";
            case 20L: return "x86_blendps";
            case 21L: return "x86_blendvpd";
            case 22L: return "x86_blendvps";
            case 23L: return "x86_bound";
            case 24L: return "x86_bsf";
            case 25L: return "x86_bsr";
            case 26L: return "x86_bswap";
            case 27L: return "x86_bt";
            case 28L: return "x86_btc";
            case 29L: return "x86_btr";
            case 30L: return "x86_bts";
            case 31L: return "x86_call";
            case 32L: return "x86_cbw";
            case 33L: return "x86_cdq";
            case 34L: return "x86_cdqe";
            case 35L: return "x86_clc";
            case 36L: return "x86_cld";
            case 37L: return "x86_clflush";
            case 38L: return "x86_clgi";
            case 39L: return "x86_cli";
            case 40L: return "x86_clts";
            case 41L: return "x86_cmc";
            case 42L: return "x86_cmova";
            case 43L: return "x86_cmovae";
            case 44L: return "x86_cmovb";
            case 45L: return "x86_cmovbe";
            case 46L: return "x86_cmove";
            case 47L: return "x86_cmovg";
            case 48L: return "x86_cmovge";
            case 49L: return "x86_cmovl";
            case 50L: return "x86_cmovle";
            case 51L: return "x86_cmovne";
            case 52L: return "x86_cmovno";
            case 53L: return "x86_cmovns";
            case 54L: return "x86_cmovo";
            case 55L: return "x86_cmovpe";
            case 56L: return "x86_cmovpo";
            case 57L: return "x86_cmovs";
            case 58L: return "x86_cmp";
            case 59L: return "x86_cmppd";
            case 60L: return "x86_cmpps";
            case 61L: return "x86_cmpsb";
            case 62L: return "x86_cmpsd";
            case 63L: return "x86_cmpsq";
            case 64L: return "x86_cmpss";
            case 65L: return "x86_cmpsw";
            case 66L: return "x86_cmpxchg";
            case 67L: return "x86_cmpxchg16b";
            case 68L: return "x86_cmpxchg8b";
            case 69L: return "x86_comisd";
            case 70L: return "x86_comiss";
            case 71L: return "x86_cpuid";
            case 72L: return "x86_cqo";
            case 73L: return "x86_crc32";
            case 74L: return "x86_cvtdq2pd";
            case 75L: return "x86_cvtdq2ps";
            case 76L: return "x86_cvtpd2dq";
            case 77L: return "x86_cvtpd2pi";
            case 78L: return "x86_cvtpd2ps";
            case 79L: return "x86_cvtpi2pd";
            case 80L: return "x86_cvtpi2ps";
            case 81L: return "x86_cvtps2dq";
            case 82L: return "x86_cvtps2pd";
            case 83L: return "x86_cvtps2pi";
            case 84L: return "x86_cvtsd2si";
            case 85L: return "x86_cvtsd2ss";
            case 86L: return "x86_cvtsi2sd";
            case 87L: return "x86_cvtsi2ss";
            case 88L: return "x86_cvtss2sd";
            case 89L: return "x86_cvtss2si";
            case 90L: return "x86_cvttpd2dq";
            case 91L: return "x86_cvttpd2pi";
            case 92L: return "x86_cvttps2dq";
            case 93L: return "x86_cvttps2pi";
            case 94L: return "x86_cvttsd2si";
            case 95L: return "x86_cvttss2si";
            case 96L: return "x86_cwd";
            case 97L: return "x86_cwde";
            case 98L: return "x86_daa";
            case 99L: return "x86_das";
            case 100L: return "x86_dec";
            case 101L: return "x86_div";
            case 102L: return "x86_divpd";
            case 103L: return "x86_divps";
            case 104L: return "x86_divsd";
            case 105L: return "x86_divss";
            case 106L: return "x86_dppd";
            case 107L: return "x86_dpps";
            case 108L: return "x86_emms";
            case 109L: return "x86_enter";
            case 110L: return "x86_extractps";
            case 111L: return "x86_extrq";
            case 112L: return "x86_f2xm1";
            case 113L: return "x86_fabs";
            case 114L: return "x86_fadd";
            case 115L: return "x86_faddp";
            case 116L: return "x86_farcall";
            case 117L: return "x86_farjmp";
            case 118L: return "x86_fbld";
            case 119L: return "x86_fbstp";
            case 120L: return "x86_fchs";
            case 121L: return "x86_fcmovb";
            case 122L: return "x86_fcmovbe";
            case 123L: return "x86_fcmove";
            case 124L: return "x86_fcmovnb";
            case 125L: return "x86_fcmovnbe";
            case 126L: return "x86_fcmovne";
            case 127L: return "x86_fcmovnu";
            case 128L: return "x86_fcmovu";
            case 129L: return "x86_fcom";
            case 130L: return "x86_fcomi";
            case 131L: return "x86_fcomip";
            case 132L: return "x86_fcomp";
            case 133L: return "x86_fcompp";
            case 134L: return "x86_fcos";
            case 135L: return "x86_fdecstp";
            case 136L: return "x86_fdiv";
            case 137L: return "x86_fdivp";
            case 138L: return "x86_fdivr";
            case 139L: return "x86_fdivrp";
            case 140L: return "x86_femms";
            case 141L: return "x86_ffree";
            case 142L: return "x86_fiadd";
            case 143L: return "x86_ficom";
            case 144L: return "x86_ficomp";
            case 145L: return "x86_fidiv";
            case 146L: return "x86_fidivr";
            case 147L: return "x86_fild";
            case 148L: return "x86_fimul";
            case 149L: return "x86_fincstp";
            case 150L: return "x86_fist";
            case 151L: return "x86_fistp";
            case 152L: return "x86_fisttp";
            case 153L: return "x86_fisub";
            case 154L: return "x86_fisubr";
            case 155L: return "x86_fld";
            case 156L: return "x86_fld1";
            case 157L: return "x86_fldcw";
            case 158L: return "x86_fldenv";
            case 159L: return "x86_fldl2e";
            case 160L: return "x86_fldl2t";
            case 161L: return "x86_fldlg2";
            case 162L: return "x86_fldln2";
            case 163L: return "x86_fldpi";
            case 164L: return "x86_fldz";
            case 165L: return "x86_fmul";
            case 166L: return "x86_fmulp";
            case 167L: return "x86_fnclex";
            case 168L: return "x86_fninit";
            case 169L: return "x86_fnop";
            case 170L: return "x86_fnsave";
            case 171L: return "x86_fnstcw";
            case 172L: return "x86_fnstenv";
            case 173L: return "x86_fnstsw";
            case 174L: return "x86_fpatan";
            case 175L: return "x86_fprem";
            case 176L: return "x86_fprem1";
            case 177L: return "x86_fptan";
            case 178L: return "x86_frndint";
            case 179L: return "x86_frstor";
            case 180L: return "x86_fscale";
            case 181L: return "x86_fsin";
            case 182L: return "x86_fsincos";
            case 183L: return "x86_fsqrt";
            case 184L: return "x86_fst";
            case 185L: return "x86_fstp";
            case 186L: return "x86_fsub";
            case 187L: return "x86_fsubp";
            case 188L: return "x86_fsubr";
            case 189L: return "x86_fsubrp";
            case 190L: return "x86_ftst";
            case 191L: return "x86_fucom";
            case 192L: return "x86_fucomi";
            case 193L: return "x86_fucomip";
            case 194L: return "x86_fucomp";
            case 195L: return "x86_fucompp";
            case 196L: return "x86_fwait";
            case 197L: return "x86_fxam";
            case 198L: return "x86_fxch";
            case 199L: return "x86_fxrstor";
            case 200L: return "x86_fxsave";
            case 201L: return "x86_fxtract";
            case 202L: return "x86_fyl2x";
            case 203L: return "x86_fyl2xp1";
            case 204L: return "x86_getsec";
            case 205L: return "x86_haddpd";
            case 206L: return "x86_haddps";
            case 207L: return "x86_hlt";
            case 208L: return "x86_hsubpd";
            case 209L: return "x86_hsubps";
            case 210L: return "x86_idiv";
            case 211L: return "x86_imul";
            case 212L: return "x86_in";
            case 213L: return "x86_inc";
            case 214L: return "x86_insb";
            case 215L: return "x86_insd";
            case 216L: return "x86_insertps";
            case 217L: return "x86_insertq";
            case 218L: return "x86_insw";
            case 219L: return "x86_int";
            case 220L: return "x86_int1";
            case 221L: return "x86_int3";
            case 222L: return "x86_into";
            case 223L: return "x86_invd";
            case 224L: return "x86_invept";
            case 225L: return "x86_invlpg";
            case 226L: return "x86_invlpga";
            case 227L: return "x86_invvpid";
            case 228L: return "x86_iret";
            case 229L: return "x86_ja";
            case 230L: return "x86_jae";
            case 231L: return "x86_jb";
            case 232L: return "x86_jbe";
            case 233L: return "x86_jcxz";
            case 234L: return "x86_je";
            case 235L: return "x86_jecxz";
            case 236L: return "x86_jg";
            case 237L: return "x86_jge";
            case 238L: return "x86_jl";
            case 239L: return "x86_jle";
            case 240L: return "x86_jmp";
            case 241L: return "x86_jmpe";
            case 242L: return "x86_jne";
            case 243L: return "x86_jno";
            case 244L: return "x86_jns";
            case 245L: return "x86_jo";
            case 246L: return "x86_jpe";
            case 247L: return "x86_jpo";
            case 248L: return "x86_jrcxz";
            case 249L: return "x86_js";
            case 250L: return "x86_lahf";
            case 251L: return "x86_lar";
            case 252L: return "x86_lddqu";
            case 253L: return "x86_ldmxcsr";
            case 254L: return "x86_lds";
            case 255L: return "x86_lea";
            case 256L: return "x86_leave";
            case 257L: return "x86_les";
            case 258L: return "x86_lfence";
            case 259L: return "x86_lfs";
            case 260L: return "x86_lgdt";
            case 261L: return "x86_lgs";
            case 262L: return "x86_lidt";
            case 263L: return "x86_lldt";
            case 264L: return "x86_lmsw";
            case 265L: return "x86_lock";
            case 266L: return "x86_lodsb";
            case 267L: return "x86_lodsd";
            case 268L: return "x86_lodsq";
            case 269L: return "x86_lodsw";
            case 270L: return "x86_loop";
            case 271L: return "x86_loopnz";
            case 272L: return "x86_loopz";
            case 273L: return "x86_lsl";
            case 274L: return "x86_lss";
            case 275L: return "x86_ltr";
            case 276L: return "x86_lzcnt";
            case 277L: return "x86_maskmovq";
            case 278L: return "x86_maxpd";
            case 279L: return "x86_maxps";
            case 280L: return "x86_maxsd";
            case 281L: return "x86_maxss";
            case 282L: return "x86_mfence";
            case 283L: return "x86_minpd";
            case 284L: return "x86_minps";
            case 285L: return "x86_minsd";
            case 286L: return "x86_minss";
            case 287L: return "x86_monitor";
            case 288L: return "x86_mov";
            case 289L: return "x86_movapd";
            case 290L: return "x86_movaps";
            case 291L: return "x86_movbe";
            case 292L: return "x86_movd";
            case 293L: return "x86_movddup";
            case 294L: return "x86_movdq2q";
            case 295L: return "x86_movdqa";
            case 296L: return "x86_movdqu";
            case 297L: return "x86_movhlps";
            case 298L: return "x86_movhpd";
            case 299L: return "x86_movhps";
            case 300L: return "x86_movlhps";
            case 301L: return "x86_movlpd";
            case 302L: return "x86_movlps";
            case 303L: return "x86_movmskpd";
            case 304L: return "x86_movmskps";
            case 305L: return "x86_movntdq";
            case 306L: return "x86_movntdqa";
            case 307L: return "x86_movnti";
            case 308L: return "x86_movntpd";
            case 309L: return "x86_movntps";
            case 310L: return "x86_movntq";
            case 311L: return "x86_movntsd";
            case 312L: return "x86_movntss";
            case 313L: return "x86_movq";
            case 314L: return "x86_movq2dq";
            case 315L: return "x86_movsb";
            case 316L: return "x86_movsd";
            case 317L: return "x86_movsd_sse";
            case 318L: return "x86_movshdup";
            case 319L: return "x86_movsldup";
            case 320L: return "x86_movsq";
            case 321L: return "x86_movss";
            case 322L: return "x86_movsw";
            case 323L: return "x86_movsx";
            case 324L: return "x86_movsxd";
            case 325L: return "x86_movupd";
            case 326L: return "x86_movups";
            case 327L: return "x86_movzx";
            case 328L: return "x86_mpsadbw";
            case 329L: return "x86_mul";
            case 330L: return "x86_mulpd";
            case 331L: return "x86_mulps";
            case 332L: return "x86_mulsd";
            case 333L: return "x86_mulss";
            case 334L: return "x86_mwait";
            case 335L: return "x86_neg";
            case 336L: return "x86_nop";
            case 337L: return "x86_not";
            case 338L: return "x86_or";
            case 339L: return "x86_orpd";
            case 340L: return "x86_orps";
            case 341L: return "x86_out";
            case 342L: return "x86_outs";
            case 343L: return "x86_outsb";
            case 344L: return "x86_outsd";
            case 345L: return "x86_outsw";
            case 346L: return "x86_pabsb";
            case 347L: return "x86_pabsd";
            case 348L: return "x86_pabsw";
            case 349L: return "x86_packssdw";
            case 350L: return "x86_packsswb";
            case 351L: return "x86_packusdw";
            case 352L: return "x86_packuswb";
            case 353L: return "x86_paddb";
            case 354L: return "x86_paddd";
            case 355L: return "x86_paddq";
            case 356L: return "x86_paddsb";
            case 357L: return "x86_paddsw";
            case 358L: return "x86_paddusb";
            case 359L: return "x86_paddusw";
            case 360L: return "x86_paddw";
            case 361L: return "x86_palignr";
            case 362L: return "x86_pand";
            case 363L: return "x86_pandn";
            case 364L: return "x86_pause";
            case 365L: return "x86_pavgb";
            case 366L: return "x86_pavgusb";
            case 367L: return "x86_pavgw";
            case 368L: return "x86_pblendvb";
            case 369L: return "x86_pblendw";
            case 370L: return "x86_pcmpeqb";
            case 371L: return "x86_pcmpeqd";
            case 372L: return "x86_pcmpeqq";
            case 373L: return "x86_pcmpeqw";
            case 374L: return "x86_pcmpestri";
            case 375L: return "x86_pcmpestrm";
            case 376L: return "x86_pcmpgtb";
            case 377L: return "x86_pcmpgtd";
            case 378L: return "x86_pcmpgtq";
            case 379L: return "x86_pcmpgtw";
            case 380L: return "x86_pcmpistri";
            case 381L: return "x86_pcmpistrm";
            case 382L: return "x86_pextrb";
            case 383L: return "x86_pextrd";
            case 384L: return "x86_pextrq";
            case 385L: return "x86_pextrw";
            case 386L: return "x86_pf2id";
            case 387L: return "x86_pf2iw";
            case 388L: return "x86_pfacc";
            case 389L: return "x86_pfadd";
            case 390L: return "x86_pfcmpeq";
            case 391L: return "x86_pfcmpge";
            case 392L: return "x86_pfcmpgt";
            case 393L: return "x86_pfmax";
            case 394L: return "x86_pfmin";
            case 395L: return "x86_pfmul";
            case 396L: return "x86_pfnacc";
            case 397L: return "x86_pfpnacc";
            case 398L: return "x86_pfrcp";
            case 399L: return "x86_pfrcpit1";
            case 400L: return "x86_pfrcpit2";
            case 401L: return "x86_pfrsqit1";
            case 402L: return "x86_pfrsqrt";
            case 403L: return "x86_pfsub";
            case 404L: return "x86_pfsubr";
            case 405L: return "x86_phaddd";
            case 406L: return "x86_phaddsw";
            case 407L: return "x86_phaddw";
            case 408L: return "x86_phminposuw";
            case 409L: return "x86_phsubd";
            case 410L: return "x86_phsubsw";
            case 411L: return "x86_phsubw";
            case 412L: return "x86_pi2fd";
            case 413L: return "x86_pi2fw";
            case 414L: return "x86_pinsrb";
            case 415L: return "x86_pinsrd";
            case 416L: return "x86_pinsrq";
            case 417L: return "x86_pinsrw";
            case 418L: return "x86_pmaddubsw";
            case 419L: return "x86_pmaddwd";
            case 420L: return "x86_pmaxsb";
            case 421L: return "x86_pmaxsd";
            case 422L: return "x86_pmaxsw";
            case 423L: return "x86_pmaxub";
            case 424L: return "x86_pmaxud";
            case 425L: return "x86_pmaxuw";
            case 426L: return "x86_pminsb";
            case 427L: return "x86_pminsd";
            case 428L: return "x86_pminsw";
            case 429L: return "x86_pminub";
            case 430L: return "x86_pminud";
            case 431L: return "x86_pminuw";
            case 432L: return "x86_pmovmskb";
            case 433L: return "x86_pmovsxbd";
            case 434L: return "x86_pmovsxbq";
            case 435L: return "x86_pmovsxbw";
            case 436L: return "x86_pmovsxdq";
            case 437L: return "x86_pmovsxwd";
            case 438L: return "x86_pmovsxwq";
            case 439L: return "x86_pmovzxbd";
            case 440L: return "x86_pmovzxbq";
            case 441L: return "x86_pmovzxbw";
            case 442L: return "x86_pmovzxdq";
            case 443L: return "x86_pmovzxwd";
            case 444L: return "x86_pmovzxwq";
            case 445L: return "x86_pmuldq";
            case 446L: return "x86_pmulhrsw";
            case 447L: return "x86_pmulhrw";
            case 448L: return "x86_pmulhuw";
            case 449L: return "x86_pmulhw";
            case 450L: return "x86_pmulld";
            case 451L: return "x86_pmullw";
            case 452L: return "x86_pmuludq";
            case 453L: return "x86_pop";
            case 454L: return "x86_popa";
            case 455L: return "x86_popad";
            case 456L: return "x86_popcnt";
            case 457L: return "x86_popf";
            case 458L: return "x86_popfd";
            case 459L: return "x86_popfq";
            case 460L: return "x86_por";
            case 461L: return "x86_prefetch";
            case 462L: return "x86_prefetchnta";
            case 463L: return "x86_prefetcht0";
            case 464L: return "x86_prefetcht1";
            case 465L: return "x86_prefetcht2";
            case 466L: return "x86_prefetchw";
            case 467L: return "x86_psadbw";
            case 468L: return "x86_pshufb";
            case 469L: return "x86_pshufd";
            case 470L: return "x86_pshufhw";
            case 471L: return "x86_pshuflw";
            case 472L: return "x86_pshufw";
            case 473L: return "x86_psignb";
            case 474L: return "x86_psignd";
            case 475L: return "x86_psignw";
            case 476L: return "x86_pslld";
            case 477L: return "x86_pslldq";
            case 478L: return "x86_psllq";
            case 479L: return "x86_psllw";
            case 480L: return "x86_psrad";
            case 481L: return "x86_psraq";
            case 482L: return "x86_psraw";
            case 483L: return "x86_psrld";
            case 484L: return "x86_psrldq";
            case 485L: return "x86_psrlq";
            case 486L: return "x86_psrlw";
            case 487L: return "x86_psubb";
            case 488L: return "x86_psubd";
            case 489L: return "x86_psubq";
            case 490L: return "x86_psubsb";
            case 491L: return "x86_psubsw";
            case 492L: return "x86_psubusb";
            case 493L: return "x86_psubusw";
            case 494L: return "x86_psubw";
            case 495L: return "x86_pswapd";
            case 496L: return "x86_ptest";
            case 497L: return "x86_punpckhbw";
            case 498L: return "x86_punpckhdq";
            case 499L: return "x86_punpckhqdq";
            case 500L: return "x86_punpckhwd";
            case 501L: return "x86_punpcklbw";
            case 502L: return "x86_punpckldq";
            case 503L: return "x86_punpcklqdq";
            case 504L: return "x86_punpcklwd";
            case 505L: return "x86_push";
            case 506L: return "x86_pusha";
            case 507L: return "x86_pushad";
            case 508L: return "x86_pushf";
            case 509L: return "x86_pushfd";
            case 510L: return "x86_pushfq";
            case 511L: return "x86_pxor";
            case 512L: return "x86_rcl";
            case 513L: return "x86_rcpps";
            case 514L: return "x86_rcpss";
            case 515L: return "x86_rcr";
            case 516L: return "x86_rdmsr";
            case 517L: return "x86_rdpmc";
            case 518L: return "x86_rdtsc";
            case 519L: return "x86_rdtscp";
            case 520L: return "x86_rep_insb";
            case 521L: return "x86_rep_insd";
            case 522L: return "x86_rep_insw";
            case 523L: return "x86_rep_lodsb";
            case 524L: return "x86_rep_lodsd";
            case 525L: return "x86_rep_lodsq";
            case 526L: return "x86_rep_lodsw";
            case 527L: return "x86_rep_movsb";
            case 528L: return "x86_rep_movsd";
            case 529L: return "x86_rep_movsq";
            case 530L: return "x86_rep_movsw";
            case 531L: return "x86_rep_outsb";
            case 532L: return "x86_rep_outsd";
            case 533L: return "x86_rep_outsw";
            case 534L: return "x86_rep_stosb";
            case 535L: return "x86_rep_stosd";
            case 536L: return "x86_rep_stosq";
            case 537L: return "x86_rep_stosw";
            case 538L: return "x86_repe_cmpsb";
            case 539L: return "x86_repe_cmpsd";
            case 540L: return "x86_repe_cmpsq";
            case 541L: return "x86_repe_cmpsw";
            case 542L: return "x86_repe_scasb";
            case 543L: return "x86_repe_scasd";
            case 544L: return "x86_repe_scasq";
            case 545L: return "x86_repe_scasw";
            case 546L: return "x86_repne_cmpsb";
            case 547L: return "x86_repne_cmpsd";
            case 548L: return "x86_repne_cmpsq";
            case 549L: return "x86_repne_cmpsw";
            case 550L: return "x86_repne_scasb";
            case 551L: return "x86_repne_scasd";
            case 552L: return "x86_repne_scasq";
            case 553L: return "x86_repne_scasw";
            case 554L: return "x86_ret";
            case 555L: return "x86_retf";
            case 556L: return "x86_rol";
            case 557L: return "x86_ror";
            case 558L: return "x86_roundpd";
            case 559L: return "x86_roundps";
            case 560L: return "x86_roundsd";
            case 561L: return "x86_roundss";
            case 562L: return "x86_rsm";
            case 563L: return "x86_rsqrtps";
            case 564L: return "x86_rsqrtss";
            case 565L: return "x86_sahf";
            case 566L: return "x86_salc";
            case 567L: return "x86_sar";
            case 568L: return "x86_sbb";
            case 569L: return "x86_scasb";
            case 570L: return "x86_scasd";
            case 571L: return "x86_scasq";
            case 572L: return "x86_scasw";
            case 573L: return "x86_seta";
            case 574L: return "x86_setae";
            case 575L: return "x86_setb";
            case 576L: return "x86_setbe";
            case 577L: return "x86_sete";
            case 578L: return "x86_setg";
            case 579L: return "x86_setge";
            case 580L: return "x86_setl";
            case 581L: return "x86_setle";
            case 582L: return "x86_setne";
            case 583L: return "x86_setno";
            case 584L: return "x86_setns";
            case 585L: return "x86_seto";
            case 586L: return "x86_setpe";
            case 587L: return "x86_setpo";
            case 588L: return "x86_sets";
            case 589L: return "x86_sfence";
            case 590L: return "x86_sgdt";
            case 591L: return "x86_shl";
            case 592L: return "x86_shld";
            case 593L: return "x86_shr";
            case 594L: return "x86_shrd";
            case 595L: return "x86_shufpd";
            case 596L: return "x86_shufps";
            case 597L: return "x86_sidt";
            case 598L: return "x86_skinit";
            case 599L: return "x86_sldt";
            case 600L: return "x86_smsw";
            case 601L: return "x86_sqrtpd";
            case 602L: return "x86_sqrtps";
            case 603L: return "x86_sqrtsd";
            case 604L: return "x86_sqrtss";
            case 605L: return "x86_stc";
            case 606L: return "x86_std";
            case 607L: return "x86_stgi";
            case 608L: return "x86_sti";
            case 609L: return "x86_stmxcsr";
            case 610L: return "x86_stos";
            case 611L: return "x86_stosb";
            case 612L: return "x86_stosd";
            case 613L: return "x86_stosq";
            case 614L: return "x86_stosw";
            case 615L: return "x86_str";
            case 616L: return "x86_sub";
            case 617L: return "x86_subpd";
            case 618L: return "x86_subps";
            case 619L: return "x86_subsd";
            case 620L: return "x86_subss";
            case 621L: return "x86_swapgs";
            case 622L: return "x86_syscall";
            case 623L: return "x86_sysenter";
            case 624L: return "x86_sysexit";
            case 625L: return "x86_sysret";
            case 626L: return "x86_test";
            case 627L: return "x86_ucomisd";
            case 628L: return "x86_ucomiss";
            case 629L: return "x86_ud2";
            case 630L: return "x86_unpckhpd";
            case 631L: return "x86_unpckhps";
            case 632L: return "x86_unpcklpd";
            case 633L: return "x86_unpcklps";
            case 634L: return "x86_verr";
            case 635L: return "x86_verw";
            case 636L: return "x86_vmcall";
            case 637L: return "x86_vmclear";
            case 638L: return "x86_vmlaunch";
            case 639L: return "x86_vmload";
            case 640L: return "x86_vmmcall";
            case 641L: return "x86_vmoff";
            case 642L: return "x86_vmptrld";
            case 643L: return "x86_vmptrst";
            case 644L: return "x86_vmread";
            case 645L: return "x86_vmresume";
            case 646L: return "x86_vmrun";
            case 647L: return "x86_vmsave";
            case 648L: return "x86_vmwrite";
            case 649L: return "x86_vmxoff";
            case 650L: return "x86_vmxon";
            case 651L: return "x86_wait";
            case 652L: return "x86_wbinvd";
            case 653L: return "x86_wrmsr";
            case 654L: return "x86_xadd";
            case 655L: return "x86_xchg";
            case 656L: return "x86_xgetbv";
            case 657L: return "x86_xlatb";
            case 658L: return "x86_xor";
            case 659L: return "x86_xorpd";
            case 660L: return "x86_xorps";
            case 661L: return "x86_xrstor";
            case 662L: return "x86_xsave";
            case 663L: return "x86_xsetbv";
            case 664L: return "x86_last_instruction";
            default: return "";
        }
    }

    std::string X86InstructionKind(int64_t i, const std::string &strip) {
        std::string s = X86InstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L
        };
        static const std::vector<int64_t> retval(values, values + 665);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionKind() {
        return stringify::Rose::BinaryAnalysis::X86InstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/Assembler.h line 76
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Assembler {
    const char* EncodingType(int64_t i) {
        switch (i) {
            case 0L: return "ET_SHORTEST";
            case 1L: return "ET_LONGEST";
            case 2L: return "ET_MATCHES";
            default: return "";
        }
    }

    std::string EncodingType(int64_t i, const std::string &strip) {
        std::string s = EncodingType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EncodingType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerEncodingType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Assembler::EncodingType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Assembler::EncodingType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerEncodingType() {
        return stringify::Rose::BinaryAnalysis::Assembler::EncodingType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 142
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* OperandDefn(int64_t i) {
        switch (i) {
            case 0L: return "od_none";
            case 1L: return "od_AL";
            case 2L: return "od_AX";
            case 3L: return "od_EAX";
            case 4L: return "od_RAX";
            case 5L: return "od_DX";
            case 6L: return "od_CS";
            case 7L: return "od_DS";
            case 8L: return "od_ES";
            case 9L: return "od_FS";
            case 10L: return "od_GS";
            case 11L: return "od_SS";
            case 12L: return "od_rel8";
            case 13L: return "od_rel16";
            case 14L: return "od_rel32";
            case 15L: return "od_rel64";
            case 16L: return "od_ptr16_16";
            case 17L: return "od_ptr16_32";
            case 18L: return "od_ptr16_64";
            case 19L: return "od_r8";
            case 20L: return "od_r16";
            case 21L: return "od_r32";
            case 22L: return "od_r64";
            case 23L: return "od_imm8";
            case 24L: return "od_imm16";
            case 25L: return "od_imm32";
            case 26L: return "od_imm64";
            case 27L: return "od_r_m8";
            case 28L: return "od_r_m16";
            case 29L: return "od_r_m32";
            case 30L: return "od_r_m64";
            case 31L: return "od_m";
            case 32L: return "od_m8";
            case 33L: return "od_m16";
            case 34L: return "od_m32";
            case 35L: return "od_m64";
            case 36L: return "od_m128";
            case 37L: return "od_m16_16";
            case 38L: return "od_m16_32";
            case 39L: return "od_m16_64";
            case 40L: return "od_m16a16";
            case 41L: return "od_m16a32";
            case 42L: return "od_m32a32";
            case 43L: return "od_m16a64";
            case 44L: return "od_moffs8";
            case 45L: return "od_moffs16";
            case 46L: return "od_moffs32";
            case 47L: return "od_moffs64";
            case 48L: return "od_sreg";
            case 49L: return "od_m32fp";
            case 50L: return "od_m64fp";
            case 51L: return "od_m80fp";
            case 52L: return "od_st0";
            case 53L: return "od_st1";
            case 54L: return "od_st2";
            case 55L: return "od_st3";
            case 56L: return "od_st4";
            case 57L: return "od_st5";
            case 58L: return "od_st6";
            case 59L: return "od_st7";
            case 60L: return "od_sti";
            case 61L: return "od_mm";
            case 62L: return "od_mm_m32";
            case 63L: return "od_mm_m64";
            case 64L: return "od_xmm";
            case 65L: return "od_xmm_m16";
            case 66L: return "od_xmm_m32";
            case 67L: return "od_xmm_m64";
            case 68L: return "od_xmm_m128";
            case 69L: return "od_XMM0";
            case 70L: return "od_0";
            case 71L: return "od_1";
            case 72L: return "od_m80";
            case 73L: return "od_dec";
            case 74L: return "od_m80bcd";
            case 75L: return "od_m2byte";
            case 76L: return "od_m14_28byte";
            case 77L: return "od_m94_108byte";
            case 78L: return "od_m512byte";
            case 79L: return "od_r16_m16";
            case 80L: return "od_r32_m8";
            case 81L: return "od_r32_m16";
            case 82L: return "od_r64_m16";
            case 83L: return "od_CR0";
            case 84L: return "od_CR7";
            case 85L: return "od_CR8";
            case 86L: return "od_CR0CR7";
            case 87L: return "od_DR0DR7";
            case 88L: return "od_reg";
            case 89L: return "od_CL";
            default: return "";
        }
    }

    std::string OperandDefn(int64_t i, const std::string &strip) {
        std::string s = OperandDefn(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OperandDefn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L
        };
        static const std::vector<int64_t> retval(values, values + 90);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86OperandDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::OperandDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86OperandDefn() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 383
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* MemoryReferencePattern(int64_t i) {
        switch (i) {
            case 0L: return "mrp_unknown";
            case 1L: return "mrp_disp";
            case 2L: return "mrp_index";
            case 3L: return "mrp_index_disp";
            case 4L: return "mrp_base";
            case 5L: return "mrp_base_disp";
            case 6L: return "mrp_base_index";
            case 7L: return "mrp_base_index_disp";
            default: return "";
        }
    }

    std::string MemoryReferencePattern(int64_t i, const std::string &strip) {
        std::string s = MemoryReferencePattern(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryReferencePattern() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 10
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcWordSize(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_32";
            case 1L: return "powerpc_64";
            default: return "";
        }
    }

    std::string PowerpcWordSize(int64_t i, const std::string &strip) {
        std::string s = PowerpcWordSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcWordSize() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcWordSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcWordSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcWordSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcWordSize() {
        return stringify::Rose::BinaryAnalysis::PowerpcWordSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 16
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_unknown_instruction";
            case 1L: return "powerpc_add";
            case 2L: return "powerpc_add_record";
            case 3L: return "powerpc_addo";
            case 4L: return "powerpc_addo_record";
            case 5L: return "powerpc_addc";
            case 6L: return "powerpc_addc_record";
            case 7L: return "powerpc_addco";
            case 8L: return "powerpc_addco_record";
            case 9L: return "powerpc_adde";
            case 10L: return "powerpc_adde_record";
            case 11L: return "powerpc_addeo";
            case 12L: return "powerpc_addeo_record";
            case 13L: return "powerpc_addi";
            case 14L: return "powerpc_addic";
            case 15L: return "powerpc_addic_record";
            case 16L: return "powerpc_addis";
            case 17L: return "powerpc_addme";
            case 18L: return "powerpc_addme_record";
            case 19L: return "powerpc_addmeo";
            case 20L: return "powerpc_addmeo_record";
            case 21L: return "powerpc_addze";
            case 22L: return "powerpc_addze_record";
            case 23L: return "powerpc_addzeo";
            case 24L: return "powerpc_addzeo_record";
            case 25L: return "powerpc_and";
            case 26L: return "powerpc_and_record";
            case 27L: return "powerpc_andc";
            case 28L: return "powerpc_andc_record";
            case 29L: return "powerpc_andi_record";
            case 30L: return "powerpc_andis_record";
            case 31L: return "powerpc_b";
            case 32L: return "powerpc_ba";
            case 33L: return "powerpc_bl";
            case 34L: return "powerpc_bla";
            case 35L: return "powerpc_bc";
            case 36L: return "powerpc_bca";
            case 37L: return "powerpc_bcl";
            case 38L: return "powerpc_bcla";
            case 39L: return "powerpc_bcctr";
            case 40L: return "powerpc_bcctrl";
            case 41L: return "powerpc_bclr";
            case 42L: return "powerpc_bclrl";
            case 43L: return "powerpc_cmp";
            case 44L: return "powerpc_cmpi";
            case 45L: return "powerpc_cmpl";
            case 46L: return "powerpc_cmpli";
            case 47L: return "powerpc_cntlzd";
            case 48L: return "powerpc_cntlzd_record";
            case 49L: return "powerpc_cntlzw";
            case 50L: return "powerpc_cntlzw_record";
            case 51L: return "powerpc_crand";
            case 52L: return "powerpc_crandc";
            case 53L: return "powerpc_creqv";
            case 54L: return "powerpc_crnand";
            case 55L: return "powerpc_crnor";
            case 56L: return "powerpc_cror";
            case 57L: return "powerpc_crorc";
            case 58L: return "powerpc_crxor";
            case 59L: return "powerpc_dcbf";
            case 60L: return "powerpc_dcba";
            case 61L: return "powerpc_dcbi";
            case 62L: return "powerpc_dcbst";
            case 63L: return "powerpc_dcbt";
            case 64L: return "powerpc_dcbtst";
            case 65L: return "powerpc_dcbz";
            case 66L: return "powerpc_divd";
            case 67L: return "powerpc_divd_record";
            case 68L: return "powerpc_divdo";
            case 69L: return "powerpc_divdo_record";
            case 70L: return "powerpc_divdu";
            case 71L: return "powerpc_divdu_record";
            case 72L: return "powerpc_divduo";
            case 73L: return "powerpc_divduo_record";
            case 74L: return "powerpc_divw";
            case 75L: return "powerpc_divw_record";
            case 76L: return "powerpc_divwo";
            case 77L: return "powerpc_divwo_record";
            case 78L: return "powerpc_divwu";
            case 79L: return "powerpc_divwu_record";
            case 80L: return "powerpc_divwuo";
            case 81L: return "powerpc_divwuo_record";
            case 82L: return "powerpc_dst";
            case 83L: return "powerpc_dstt";
            case 84L: return "powerpc_dstst";
            case 85L: return "powerpc_dststt";
            case 86L: return "powerpc_dss";
            case 87L: return "powerpc_dssall";
            case 88L: return "powerpc_eciwx";
            case 89L: return "powerpc_ecowx";
            case 90L: return "powerpc_eieio";
            case 91L: return "powerpc_eqv";
            case 92L: return "powerpc_eqv_record";
            case 93L: return "powerpc_extsb";
            case 94L: return "powerpc_extsb_record";
            case 95L: return "powerpc_extsh";
            case 96L: return "powerpc_extsh_record";
            case 97L: return "powerpc_extsw";
            case 98L: return "powerpc_extsw_record";
            case 99L: return "powerpc_fabs";
            case 100L: return "powerpc_fabs_record";
            case 101L: return "powerpc_fadd";
            case 102L: return "powerpc_fadd_record";
            case 103L: return "powerpc_fadds";
            case 104L: return "powerpc_fadds_record";
            case 105L: return "powerpc_fcfid";
            case 106L: return "powerpc_fcfid_record";
            case 107L: return "powerpc_fcmpo";
            case 108L: return "powerpc_fcmpu";
            case 109L: return "powerpc_fctid";
            case 110L: return "powerpc_fctid_record";
            case 111L: return "powerpc_fctidz";
            case 112L: return "powerpc_fctidz_record";
            case 113L: return "powerpc_fctiw";
            case 114L: return "powerpc_fctiw_record";
            case 115L: return "powerpc_fctiwz";
            case 116L: return "powerpc_fctiwz_record";
            case 117L: return "powerpc_fdiv";
            case 118L: return "powerpc_fdiv_record";
            case 119L: return "powerpc_fdivs";
            case 120L: return "powerpc_fdivs_record";
            case 121L: return "powerpc_fmadd";
            case 122L: return "powerpc_fmadd_record";
            case 123L: return "powerpc_fmadds";
            case 124L: return "powerpc_fmadds_record";
            case 125L: return "powerpc_fmr";
            case 126L: return "powerpc_fmr_record";
            case 127L: return "powerpc_fmsub";
            case 128L: return "powerpc_fmsub_record";
            case 129L: return "powerpc_fmsubs";
            case 130L: return "powerpc_fmsubs_record";
            case 131L: return "powerpc_fmul";
            case 132L: return "powerpc_fmul_record";
            case 133L: return "powerpc_fmuls";
            case 134L: return "powerpc_fmuls_record";
            case 135L: return "powerpc_fnabs";
            case 136L: return "powerpc_fnabs_record";
            case 137L: return "powerpc_fneg";
            case 138L: return "powerpc_fneg_record";
            case 139L: return "powerpc_fnmadd";
            case 140L: return "powerpc_fnmadd_record";
            case 141L: return "powerpc_fnmadds";
            case 142L: return "powerpc_fnmadds_record";
            case 143L: return "powerpc_fnmsub";
            case 144L: return "powerpc_fnmsub_record";
            case 145L: return "powerpc_fnmsubs";
            case 146L: return "powerpc_fnmsubs_record";
            case 147L: return "powerpc_fpmul";
            case 148L: return "powerpc_fxmul";
            case 149L: return "powerpc_fxpmul";
            case 150L: return "powerpc_fxsmul";
            case 151L: return "powerpc_fpadd";
            case 152L: return "powerpc_fpsub";
            case 153L: return "powerpc_fpre";
            case 154L: return "powerpc_fprsqrte";
            case 155L: return "powerpc_fpmr";
            case 156L: return "powerpc_fpabs";
            case 157L: return "powerpc_lfssx";
            case 158L: return "powerpc_fpneg";
            case 159L: return "powerpc_lfssux";
            case 160L: return "powerpc_fprsp";
            case 161L: return "powerpc_lfsdx";
            case 162L: return "powerpc_fpnabs";
            case 163L: return "powerpc_lfsdux";
            case 164L: return "powerpc_lfxsx";
            case 165L: return "powerpc_fsmr";
            case 166L: return "powerpc_lfxsux";
            case 167L: return "powerpc_lfxdx";
            case 168L: return "powerpc_fsabs";
            case 169L: return "powerpc_lfxdux";
            case 170L: return "powerpc_lfpsx";
            case 171L: return "powerpc_fsneg";
            case 172L: return "powerpc_lfpsux";
            case 173L: return "powerpc_lfpdx";
            case 174L: return "powerpc_fsnabs";
            case 175L: return "powerpc_lfpdux";
            case 176L: return "powerpc_stfpiwx";
            case 177L: return "powerpc_fxmr";
            case 178L: return "powerpc_fpctiw";
            case 179L: return "powerpc_stfssx";
            case 180L: return "powerpc_stfssux";
            case 181L: return "powerpc_fpctiwz";
            case 182L: return "powerpc_stfsdx";
            case 183L: return "powerpc_stfsdux";
            case 184L: return "powerpc_stfxsx";
            case 185L: return "powerpc_fsmtp";
            case 186L: return "powerpc_stfxsux";
            case 187L: return "powerpc_stfxdx";
            case 188L: return "powerpc_stfxdux";
            case 189L: return "powerpc_stfpsx";
            case 190L: return "powerpc_fsmfp";
            case 191L: return "powerpc_stfpsux";
            case 192L: return "powerpc_stfpdx";
            case 193L: return "powerpc_stfpdux";
            case 194L: return "powerpc_fpsel";
            case 195L: return "powerpc_fpmadd";
            case 196L: return "powerpc_fpmsub";
            case 197L: return "powerpc_fxmadd";
            case 198L: return "powerpc_fxcpmadd";
            case 199L: return "powerpc_fxcsmadd";
            case 200L: return "powerpc_fpnmadd";
            case 201L: return "powerpc_fxnmadd";
            case 202L: return "powerpc_fxcpnmadd";
            case 203L: return "powerpc_fxcsnmadd";
            case 204L: return "powerpc_fxcpnpma";
            case 205L: return "powerpc_fxmsub";
            case 206L: return "powerpc_fxcsnpma";
            case 207L: return "powerpc_fxcpmsub";
            case 208L: return "powerpc_fxcpnsma";
            case 209L: return "powerpc_fxcsmsub";
            case 210L: return "powerpc_fxcsnsma";
            case 211L: return "powerpc_fpnmsub";
            case 212L: return "powerpc_fxcxma";
            case 213L: return "powerpc_fxnmsub";
            case 214L: return "powerpc_fxcxnpma";
            case 215L: return "powerpc_fxcpnmsub";
            case 216L: return "powerpc_fxcxnsma";
            case 217L: return "powerpc_fxcsnmsub";
            case 218L: return "powerpc_fxcxnms";
            case 219L: return "powerpc_fre";
            case 220L: return "powerpc_fre_record";
            case 221L: return "powerpc_fres";
            case 222L: return "powerpc_fres_record";
            case 223L: return "powerpc_frsp";
            case 224L: return "powerpc_frsp_record";
            case 225L: return "powerpc_frsqrte";
            case 226L: return "powerpc_frsqrte_record";
            case 227L: return "powerpc_frsqrtes";
            case 228L: return "powerpc_frsqrtes_record";
            case 229L: return "powerpc_fsel";
            case 230L: return "powerpc_fsel_record";
            case 231L: return "powerpc_fsqrt";
            case 232L: return "powerpc_fsqrt_record";
            case 233L: return "powerpc_fsqrts";
            case 234L: return "powerpc_fsqrts_record";
            case 235L: return "powerpc_fsub";
            case 236L: return "powerpc_fsub_record";
            case 237L: return "powerpc_fsubs";
            case 238L: return "powerpc_fsubs_record";
            case 239L: return "powerpc_icbi";
            case 240L: return "powerpc_isync";
            case 241L: return "powerpc_lbz";
            case 242L: return "powerpc_lbzu";
            case 243L: return "powerpc_lbzux";
            case 244L: return "powerpc_lbzx";
            case 245L: return "powerpc_ld";
            case 246L: return "powerpc_ldarx";
            case 247L: return "powerpc_ldu";
            case 248L: return "powerpc_ldux";
            case 249L: return "powerpc_ldx";
            case 250L: return "powerpc_lfd";
            case 251L: return "powerpc_lfdu";
            case 252L: return "powerpc_lfdux";
            case 253L: return "powerpc_lfdx";
            case 254L: return "powerpc_lfs";
            case 255L: return "powerpc_lfsu";
            case 256L: return "powerpc_lfsux";
            case 257L: return "powerpc_lfsx";
            case 258L: return "powerpc_lha";
            case 259L: return "powerpc_lhau";
            case 260L: return "powerpc_lhaux";
            case 261L: return "powerpc_lhax";
            case 262L: return "powerpc_lhbrx";
            case 263L: return "powerpc_lhz";
            case 264L: return "powerpc_lhzu";
            case 265L: return "powerpc_lhzux";
            case 266L: return "powerpc_lhzx";
            case 267L: return "powerpc_lmw";
            case 268L: return "powerpc_lswi";
            case 269L: return "powerpc_lswx";
            case 270L: return "powerpc_lwa";
            case 271L: return "powerpc_lwarx";
            case 272L: return "powerpc_lwaux";
            case 273L: return "powerpc_lwax";
            case 274L: return "powerpc_lwbrx";
            case 275L: return "powerpc_lwz";
            case 276L: return "powerpc_lwzu";
            case 277L: return "powerpc_lwzux";
            case 278L: return "powerpc_lwzx";
            case 279L: return "powerpc_mcrf";
            case 280L: return "powerpc_mcrfs";
            case 281L: return "powerpc_mcrxr";
            case 282L: return "powerpc_mfcr";
            case 283L: return "powerpc_mffs";
            case 284L: return "powerpc_mffs_record";
            case 285L: return "powerpc_mfmsr";
            case 286L: return "powerpc_mfspr";
            case 287L: return "powerpc_mfsr";
            case 288L: return "powerpc_mfsrin";
            case 289L: return "powerpc_mftb";
            case 290L: return "powerpc_mtcrf";
            case 291L: return "powerpc_mtfsb0";
            case 292L: return "powerpc_mtfsb0_record";
            case 293L: return "powerpc_mtfsb1";
            case 294L: return "powerpc_mtfsb1_record";
            case 295L: return "powerpc_mtfsf";
            case 296L: return "powerpc_mtfsf_record";
            case 297L: return "powerpc_mtfsfi";
            case 298L: return "powerpc_mtfsfi_record";
            case 299L: return "powerpc_mtmsr";
            case 300L: return "powerpc_mtmsrd";
            case 301L: return "powerpc_mtspr";
            case 302L: return "powerpc_mtsr";
            case 303L: return "powerpc_mtsrd";
            case 304L: return "powerpc_mtsrdin";
            case 305L: return "powerpc_mtsrin";
            case 306L: return "powerpc_mulhd";
            case 307L: return "powerpc_mulhd_record";
            case 308L: return "powerpc_mulhdu";
            case 309L: return "powerpc_mulhdu_record";
            case 310L: return "powerpc_mulhw";
            case 311L: return "powerpc_mulhw_record";
            case 312L: return "powerpc_mulhwu";
            case 313L: return "powerpc_mulhwu_record";
            case 314L: return "powerpc_mulld";
            case 315L: return "powerpc_mulld_record";
            case 316L: return "powerpc_mulldo";
            case 317L: return "powerpc_mulldo_record";
            case 318L: return "powerpc_mulli";
            case 319L: return "powerpc_mullw";
            case 320L: return "powerpc_mullw_record";
            case 321L: return "powerpc_mullwo";
            case 322L: return "powerpc_mullwo_record";
            case 323L: return "powerpc_nand";
            case 324L: return "powerpc_nand_record";
            case 325L: return "powerpc_neg";
            case 326L: return "powerpc_neg_record";
            case 327L: return "powerpc_nego";
            case 328L: return "powerpc_nego_record";
            case 329L: return "powerpc_nor";
            case 330L: return "powerpc_nor_record";
            case 331L: return "powerpc_or";
            case 332L: return "powerpc_or_record";
            case 333L: return "powerpc_orc";
            case 334L: return "powerpc_orc_record";
            case 335L: return "powerpc_ori";
            case 336L: return "powerpc_oris";
            case 337L: return "powerpc_popcntb";
            case 338L: return "powerpc_rfi";
            case 339L: return "powerpc_rfid";
            case 340L: return "powerpc_rldcl";
            case 341L: return "powerpc_rldcl_record";
            case 342L: return "powerpc_rldcr";
            case 343L: return "powerpc_rldcr_record";
            case 344L: return "powerpc_rldic";
            case 345L: return "powerpc_rldic_record";
            case 346L: return "powerpc_rldicl";
            case 347L: return "powerpc_rldicl_record";
            case 348L: return "powerpc_rldicr";
            case 349L: return "powerpc_rldicr_record";
            case 350L: return "powerpc_rldimi";
            case 351L: return "powerpc_rldimi_record";
            case 352L: return "powerpc_rlwimi";
            case 353L: return "powerpc_rlwimi_record";
            case 354L: return "powerpc_rlwinm";
            case 355L: return "powerpc_rlwinm_record";
            case 356L: return "powerpc_rlwnm";
            case 357L: return "powerpc_rlwnm_record";
            case 358L: return "powerpc_sc";
            case 359L: return "powerpc_slbia";
            case 360L: return "powerpc_slbie";
            case 361L: return "powerpc_sld";
            case 362L: return "powerpc_sld_record";
            case 363L: return "powerpc_slw";
            case 364L: return "powerpc_slw_record";
            case 365L: return "powerpc_srad";
            case 366L: return "powerpc_srad_record";
            case 367L: return "powerpc_sradi";
            case 368L: return "powerpc_sradi_record";
            case 369L: return "powerpc_srd";
            case 370L: return "powerpc_srd_record";
            case 371L: return "powerpc_sraw";
            case 372L: return "powerpc_sraw_record";
            case 373L: return "powerpc_srawi";
            case 374L: return "powerpc_srawi_record";
            case 375L: return "powerpc_srw";
            case 376L: return "powerpc_srw_record";
            case 377L: return "powerpc_stb";
            case 378L: return "powerpc_stbu";
            case 379L: return "powerpc_stbux";
            case 380L: return "powerpc_stbx";
            case 381L: return "powerpc_std";
            case 382L: return "powerpc_stdcx_record";
            case 383L: return "powerpc_stdu";
            case 384L: return "powerpc_stdux";
            case 385L: return "powerpc_stdx";
            case 386L: return "powerpc_stfd";
            case 387L: return "powerpc_stfdu";
            case 388L: return "powerpc_stfdux";
            case 389L: return "powerpc_stfdx";
            case 390L: return "powerpc_stfiwx";
            case 391L: return "powerpc_stfs";
            case 392L: return "powerpc_stfsu";
            case 393L: return "powerpc_stfsux";
            case 394L: return "powerpc_stfsx";
            case 395L: return "powerpc_sth";
            case 396L: return "powerpc_sthbrx";
            case 397L: return "powerpc_sthu";
            case 398L: return "powerpc_sthux";
            case 399L: return "powerpc_sthx";
            case 400L: return "powerpc_stmw";
            case 401L: return "powerpc_stswi";
            case 402L: return "powerpc_stswx";
            case 403L: return "powerpc_stw";
            case 404L: return "powerpc_stwbrx";
            case 405L: return "powerpc_stwcx_record";
            case 406L: return "powerpc_stwu";
            case 407L: return "powerpc_stwux";
            case 408L: return "powerpc_stwx";
            case 409L: return "powerpc_subf";
            case 410L: return "powerpc_subf_record";
            case 411L: return "powerpc_subfo";
            case 412L: return "powerpc_subfo_record";
            case 413L: return "powerpc_subfc";
            case 414L: return "powerpc_subfc_record";
            case 415L: return "powerpc_subfco";
            case 416L: return "powerpc_subfco_record";
            case 417L: return "powerpc_subfe";
            case 418L: return "powerpc_subfe_record";
            case 419L: return "powerpc_subfeo";
            case 420L: return "powerpc_subfeo_record";
            case 421L: return "powerpc_subfic";
            case 422L: return "powerpc_subfme";
            case 423L: return "powerpc_subfme_record";
            case 424L: return "powerpc_subfmeo";
            case 425L: return "powerpc_subfmeo_record";
            case 426L: return "powerpc_subfze";
            case 427L: return "powerpc_subfze_record";
            case 428L: return "powerpc_subfzeo";
            case 429L: return "powerpc_subfzeo_record";
            case 430L: return "powerpc_sync";
            case 431L: return "powerpc_td";
            case 432L: return "powerpc_tdi";
            case 433L: return "powerpc_tlbia";
            case 434L: return "powerpc_tlbie";
            case 435L: return "powerpc_tlbsync";
            case 436L: return "powerpc_tw";
            case 437L: return "powerpc_twi";
            case 438L: return "powerpc_xor";
            case 439L: return "powerpc_xor_record";
            case 440L: return "powerpc_xori";
            case 441L: return "powerpc_xoris";
            case 442L: return "powerpc_last_instruction";
            default: return "";
        }
    }

    std::string PowerpcInstructionKind(int64_t i, const std::string &strip) {
        std::string s = PowerpcInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L
        };
        static const std::vector<int64_t> retval(values, values + 443);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcInstructionKind() {
        return stringify::Rose::BinaryAnalysis::PowerpcInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 463
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_regclass_unknown";
            case 1L: return "powerpc_regclass_gpr";
            case 2L: return "powerpc_regclass_fpr";
            case 3L: return "powerpc_regclass_cr";
            case 4L: return "powerpc_regclass_fpscr";
            case 5L: return "powerpc_regclass_spr";
            case 6L: return "powerpc_regclass_tbr";
            case 7L: return "powerpc_regclass_msr";
            case 8L: return "powerpc_regclass_sr";
            case 9L: return "powerpc_regclass_iar";
            case 10L: return "powerpc_regclass_pvr";
            case 11L: return "powerpc_last_register_class";
            default: return "";
        }
    }

    std::string PowerpcRegisterClass(int64_t i, const std::string &strip) {
        std::string s = PowerpcRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcRegisterClass() {
        return stringify::Rose::BinaryAnalysis::PowerpcRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 479
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcConditionRegisterAccessGranularity(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_condreggranularity_whole";
            case 1L: return "powerpc_condreggranularity_field";
            case 2L: return "powerpc_condreggranularity_bit";
            default: return "";
        }
    }

    std::string PowerpcConditionRegisterAccessGranularity(int64_t i, const std::string &strip) {
        std::string s = PowerpcConditionRegisterAccessGranularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcConditionRegisterAccessGranularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity() {
        return stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 486
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 1L: return "powerpc_spr_xer";
            case 8L: return "powerpc_spr_lr";
            case 9L: return "powerpc_spr_ctr";
            case 18L: return "powerpc_spr_dsisr";
            case 19L: return "powerpc_spr_dar";
            case 22L: return "powerpc_spr_dec";
            default: return "";
        }
    }

    std::string PowerpcSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcSpecialPurposeRegister() {
        static const int64_t values[] = {
            1L,
            8L,
            9L,
            18L,
            19L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsPowerpc.h line 497
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcTimeBaseRegister(int64_t i) {
        switch (i) {
            case 268L: return "powerpc_tbr_tbl";
            case 269L: return "powerpc_tbr_tbu";
            default: return "";
        }
    }

    std::string PowerpcTimeBaseRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcTimeBaseRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcTimeBaseRegister() {
        static const int64_t values[] = {
            268L,
            269L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcTimeBaseRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcTimeBaseRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcTimeBaseRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/Registers.h line 281
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace RegisterDictionary { namespace SortBySize {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "ASCENDING";
            case 1L: return "DESCENDING";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection() {
        return stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsMips.h line 9
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "mips_regclass_gpr";
            case 1L: return "mips_regclass_spr";
            case 2L: return "mips_regclass_fpr";
            case 3L: return "mips_regclass_fcsr";
            case 4L: return "mips_regclass_cp0gpr";
            case 5L: return "mips_regclass_cp2gpr";
            case 6L: return "mips_regclass_cp2spr";
            case 7L: return "mips_regclass_sgpr";
            default: return "";
        }
    }

    std::string MipsRegisterClass(int64_t i, const std::string &strip) {
        std::string s = MipsRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsRegisterClass() {
        return stringify::Rose::BinaryAnalysis::MipsRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsMips.h line 21
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsFcsrMinors(int64_t i) {
        switch (i) {
            case 0L: return "mips_fcsr_all";
            case 1L: return "mips_fcsr_fccr";
            case 2L: return "mips_fcsr_fexr";
            case 3L: return "mips_fcsr_fenr";
            default: return "";
        }
    }

    std::string MipsFcsrMinors(int64_t i, const std::string &strip) {
        std::string s = MipsFcsrMinors(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsFcsrMinors() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsFcsrMinors(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsFcsrMinors(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsFcsrMinors::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsFcsrMinors() {
        return stringify::Rose::BinaryAnalysis::MipsFcsrMinors();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsMips.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "mips_spr_hi";
            case 1L: return "mips_spr_lo";
            case 2L: return "mips_spr_pc";
            case 3L: return "mips_spr_fir";
            case 4L: return "mips_spr_fcsr";
            default: return "";
        }
    }

    std::string MipsSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = MipsSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsMips.h line 38
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "mips_unknown_instruction";
            case 1L: return "mips_abs_s";
            case 2L: return "mips_abs_d";
            case 3L: return "mips_abs_ps";
            case 4L: return "mips_add";
            case 5L: return "mips_add_s";
            case 6L: return "mips_add_d";
            case 7L: return "mips_add_ps";
            case 8L: return "mips_addi";
            case 9L: return "mips_addiu";
            case 10L: return "mips_addu";
            case 11L: return "mips_alnv_ps";
            case 12L: return "mips_and";
            case 13L: return "mips_andi";
            case 14L: return "mips_bc1f";
            case 15L: return "mips_bc1fl";
            case 16L: return "mips_bc1t";
            case 17L: return "mips_bc1tl";
            case 18L: return "mips_bc2f";
            case 19L: return "mips_bc2fl";
            case 20L: return "mips_bc2t";
            case 21L: return "mips_bc2tl";
            case 22L: return "mips_beq";
            case 23L: return "mips_beql";
            case 24L: return "mips_bgez";
            case 25L: return "mips_bgezal";
            case 26L: return "mips_bgezall";
            case 27L: return "mips_bgezl";
            case 28L: return "mips_bgtz";
            case 29L: return "mips_bgtzl";
            case 30L: return "mips_blez";
            case 31L: return "mips_blezl";
            case 32L: return "mips_bltz";
            case 33L: return "mips_bltzal";
            case 34L: return "mips_bltzall";
            case 35L: return "mips_bltzl";
            case 36L: return "mips_bne";
            case 37L: return "mips_bnel";
            case 38L: return "mips_break";
            case 39L: return "mips_c_f_s";
            case 40L: return "mips_c_un_s";
            case 41L: return "mips_c_eq_s";
            case 42L: return "mips_c_ueq_s";
            case 43L: return "mips_c_olt_s";
            case 44L: return "mips_c_ult_s";
            case 45L: return "mips_c_ole_s";
            case 46L: return "mips_c_ule_s";
            case 47L: return "mips_c_sf_s";
            case 48L: return "mips_c_ngle_s";
            case 49L: return "mips_c_seq_s";
            case 50L: return "mips_c_ngl_s";
            case 51L: return "mips_c_lt_s";
            case 52L: return "mips_c_nge_s";
            case 53L: return "mips_c_le_s";
            case 54L: return "mips_c_ngt_s";
            case 55L: return "mips_c_f_d";
            case 56L: return "mips_c_un_d";
            case 57L: return "mips_c_eq_d";
            case 58L: return "mips_c_ueq_d";
            case 59L: return "mips_c_olt_d";
            case 60L: return "mips_c_ult_d";
            case 61L: return "mips_c_ole_d";
            case 62L: return "mips_c_ule_d";
            case 63L: return "mips_c_sf_d";
            case 64L: return "mips_c_ngle_d";
            case 65L: return "mips_c_seq_d";
            case 66L: return "mips_c_ngl_d";
            case 67L: return "mips_c_lt_d";
            case 68L: return "mips_c_nge_d";
            case 69L: return "mips_c_le_d";
            case 70L: return "mips_c_ngt_d";
            case 71L: return "mips_c_f_ps";
            case 72L: return "mips_c_un_ps";
            case 73L: return "mips_c_eq_ps";
            case 74L: return "mips_c_ueq_ps";
            case 75L: return "mips_c_olt_ps";
            case 76L: return "mips_c_ult_ps";
            case 77L: return "mips_c_ole_ps";
            case 78L: return "mips_c_ule_ps";
            case 79L: return "mips_c_sf_ps";
            case 80L: return "mips_c_ngle_ps";
            case 81L: return "mips_c_seq_ps";
            case 82L: return "mips_c_ngl_ps";
            case 83L: return "mips_c_lt_ps";
            case 84L: return "mips_c_nge_ps";
            case 85L: return "mips_c_le_ps";
            case 86L: return "mips_c_ngt_ps";
            case 87L: return "mips_cache";
            case 88L: return "mips_cachee";
            case 89L: return "mips_ceil_l_s";
            case 90L: return "mips_ceil_l_d";
            case 91L: return "mips_ceil_w_s";
            case 92L: return "mips_ceil_w_d";
            case 93L: return "mips_cfc1";
            case 94L: return "mips_cfc2";
            case 95L: return "mips_clo";
            case 96L: return "mips_clz";
            case 97L: return "mips_cop2";
            case 98L: return "mips_ctc1";
            case 99L: return "mips_ctc2";
            case 100L: return "mips_cvt_d_s";
            case 101L: return "mips_cvt_d_w";
            case 102L: return "mips_cvt_d_l";
            case 103L: return "mips_cvt_l_s";
            case 104L: return "mips_cvt_l_d";
            case 105L: return "mips_cvt_ps_s";
            case 106L: return "mips_cvt_s_d";
            case 107L: return "mips_cvt_s_w";
            case 108L: return "mips_cvt_s_l";
            case 109L: return "mips_cvt_s_pl";
            case 110L: return "mips_cvt_s_pu";
            case 111L: return "mips_cvt_w_s";
            case 112L: return "mips_cvt_w_d";
            case 113L: return "mips_di";
            case 114L: return "mips_div";
            case 115L: return "mips_div_s";
            case 116L: return "mips_div_d";
            case 117L: return "mips_divu";
            case 118L: return "mips_ehb";
            case 119L: return "mips_ei";
            case 120L: return "mips_eret";
            case 121L: return "mips_ext";
            case 122L: return "mips_floor_l_s";
            case 123L: return "mips_floor_l_d";
            case 124L: return "mips_floor_w_s";
            case 125L: return "mips_floor_w_d";
            case 126L: return "mips_ins";
            case 127L: return "mips_j";
            case 128L: return "mips_jal";
            case 129L: return "mips_jalr";
            case 130L: return "mips_jalr_hb";
            case 131L: return "mips_jalx";
            case 132L: return "mips_jr";
            case 133L: return "mips_jr_hb";
            case 134L: return "mips_lb";
            case 135L: return "mips_lbe";
            case 136L: return "mips_lbu";
            case 137L: return "mips_lbue";
            case 138L: return "mips_ldc1";
            case 139L: return "mips_ldc2";
            case 140L: return "mips_ldxc1";
            case 141L: return "mips_lh";
            case 142L: return "mips_lhe";
            case 143L: return "mips_lhu";
            case 144L: return "mips_lhue";
            case 145L: return "mips_ll";
            case 146L: return "mips_lle";
            case 147L: return "mips_lui";
            case 148L: return "mips_luxc1";
            case 149L: return "mips_lw";
            case 150L: return "mips_lwc1";
            case 151L: return "mips_lwc2";
            case 152L: return "mips_lwe";
            case 153L: return "mips_lwl";
            case 154L: return "mips_lwle";
            case 155L: return "mips_lwr";
            case 156L: return "mips_lwre";
            case 157L: return "mips_lwxc1";
            case 158L: return "mips_madd";
            case 159L: return "mips_madd_s";
            case 160L: return "mips_madd_d";
            case 161L: return "mips_madd_ps";
            case 162L: return "mips_maddu";
            case 163L: return "mips_mfc0";
            case 164L: return "mips_mfc1";
            case 165L: return "mips_mfc2";
            case 166L: return "mips_mfhc1";
            case 167L: return "mips_mfhc2";
            case 168L: return "mips_mfhi";
            case 169L: return "mips_mflo";
            case 170L: return "mips_mov_s";
            case 171L: return "mips_mov_d";
            case 172L: return "mips_mov_ps";
            case 173L: return "mips_movf";
            case 174L: return "mips_movf_s";
            case 175L: return "mips_movf_d";
            case 176L: return "mips_movf_ps";
            case 177L: return "mips_movn";
            case 178L: return "mips_movn_s";
            case 179L: return "mips_movn_d";
            case 180L: return "mips_movn_ps";
            case 181L: return "mips_movt";
            case 182L: return "mips_movt_s";
            case 183L: return "mips_movt_d";
            case 184L: return "mips_movt_ps";
            case 185L: return "mips_movz";
            case 186L: return "mips_movz_s";
            case 187L: return "mips_movz_d";
            case 188L: return "mips_movz_ps";
            case 189L: return "mips_msub";
            case 190L: return "mips_msub_s";
            case 191L: return "mips_msub_d";
            case 192L: return "mips_msub_ps";
            case 193L: return "mips_msubu";
            case 194L: return "mips_mtc0";
            case 195L: return "mips_mtc1";
            case 196L: return "mips_mtc2";
            case 197L: return "mips_mthc1";
            case 198L: return "mips_mthc2";
            case 199L: return "mips_mthi";
            case 200L: return "mips_mtlo";
            case 201L: return "mips_mul";
            case 202L: return "mips_mul_s";
            case 203L: return "mips_mul_d";
            case 204L: return "mips_mul_ps";
            case 205L: return "mips_mult";
            case 206L: return "mips_multu";
            case 207L: return "mips_neg_s";
            case 208L: return "mips_neg_d";
            case 209L: return "mips_neg_ps";
            case 210L: return "mips_nmadd_s";
            case 211L: return "mips_nmadd_d";
            case 212L: return "mips_nmadd_ps";
            case 213L: return "mips_nmsub_s";
            case 214L: return "mips_nmsub_d";
            case 215L: return "mips_nmsub_ps";
            case 216L: return "mips_nop";
            case 217L: return "mips_nor";
            case 218L: return "mips_or";
            case 219L: return "mips_ori";
            case 220L: return "mips_pause";
            case 221L: return "mips_pll_ps";
            case 222L: return "mips_plu_ps";
            case 223L: return "mips_pref";
            case 224L: return "mips_prefe";
            case 225L: return "mips_prefx";
            case 226L: return "mips_pul_ps";
            case 227L: return "mips_puu_ps";
            case 228L: return "mips_rdhwr";
            case 229L: return "mips_rdpgpr";
            case 230L: return "mips_recip_s";
            case 231L: return "mips_recip_d";
            case 232L: return "mips_rotr";
            case 233L: return "mips_rotrv";
            case 234L: return "mips_round_l_s";
            case 235L: return "mips_round_l_d";
            case 236L: return "mips_round_w_s";
            case 237L: return "mips_round_w_d";
            case 238L: return "mips_rsqrt_s";
            case 239L: return "mips_rsqrt_d";
            case 240L: return "mips_sb";
            case 241L: return "mips_sbe";
            case 242L: return "mips_sc";
            case 243L: return "mips_sce";
            case 244L: return "mips_sdc1";
            case 245L: return "mips_sdc2";
            case 246L: return "mips_sdxc1";
            case 247L: return "mips_seb";
            case 248L: return "mips_seh";
            case 249L: return "mips_sh";
            case 250L: return "mips_she";
            case 251L: return "mips_sll";
            case 252L: return "mips_sllv";
            case 253L: return "mips_slt";
            case 254L: return "mips_slti";
            case 255L: return "mips_sltiu";
            case 256L: return "mips_sltu";
            case 257L: return "mips_sqrt_s";
            case 258L: return "mips_sqrt_d";
            case 259L: return "mips_sra";
            case 260L: return "mips_srav";
            case 261L: return "mips_srl";
            case 262L: return "mips_srlv";
            case 263L: return "mips_ssnop";
            case 264L: return "mips_sub";
            case 265L: return "mips_sub_s";
            case 266L: return "mips_sub_d";
            case 267L: return "mips_sub_ps";
            case 268L: return "mips_subu";
            case 269L: return "mips_suxc1";
            case 270L: return "mips_sw";
            case 271L: return "mips_swc1";
            case 272L: return "mips_swc2";
            case 273L: return "mips_swe";
            case 274L: return "mips_swl";
            case 275L: return "mips_swle";
            case 276L: return "mips_swr";
            case 277L: return "mips_swre";
            case 278L: return "mips_swxc1";
            case 279L: return "mips_sync";
            case 280L: return "mips_synci";
            case 281L: return "mips_syscall";
            case 282L: return "mips_teq";
            case 283L: return "mips_teqi";
            case 284L: return "mips_tge";
            case 285L: return "mips_tgei";
            case 286L: return "mips_tgeiu";
            case 287L: return "mips_tgeu";
            case 288L: return "mips_tlbinv";
            case 289L: return "mips_tlbinvf";
            case 290L: return "mips_tlbp";
            case 291L: return "mips_tlbr";
            case 292L: return "mips_tlbwi";
            case 293L: return "mips_tlbwr";
            case 294L: return "mips_tlt";
            case 295L: return "mips_tlti";
            case 296L: return "mips_tltiu";
            case 297L: return "mips_tltu";
            case 298L: return "mips_tne";
            case 299L: return "mips_tnei";
            case 300L: return "mips_trunc_l_s";
            case 301L: return "mips_trunc_l_d";
            case 302L: return "mips_trunc_w_s";
            case 303L: return "mips_trunc_w_d";
            case 304L: return "mips_wait";
            case 305L: return "mips_wrpgpr";
            case 306L: return "mips_wsbh";
            case 307L: return "mips_xor";
            case 308L: return "mips_xori";
            case 309L: return "mips_last_instruction";
            default: return "";
        }
    }

    std::string MipsInstructionKind(int64_t i, const std::string &strip) {
        std::string s = MipsInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L
        };
        static const std::vector<int64_t> retval(values, values + 310);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInstructionKind() {
        return stringify::Rose::BinaryAnalysis::MipsInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 15
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kFamily(int64_t i) {
        switch (i) {
            case 1L: return "m68k_68000_only";
            case 2L: return "m68k_68ec000";
            case 4L: return "m68k_68hc000";
            case 7L: return "m68k_68000";
            case 8L: return "m68k_68008";
            case 16L: return "m68k_68010";
            case 32L: return "m68k_68012";
            case 255L: return "m68k_generation_1";
            case 256L: return "m68k_68020_only";
            case 512L: return "m68k_68ec020";
            case 768L: return "m68k_68020";
            case 1024L: return "m68k_68030_only";
            case 4096L: return "m68k_68ec030";
            case 8192L: return "m68k_68030";
            case 65280L: return "m68k_generation_2";
            case 65536L: return "m68k_68040_only";
            case 131072L: return "m68k_68ec040";
            case 262144L: return "m68k_68lc040";
            case 458752L: return "m68k_68040";
            case 16711680L: return "m68k_generation_3";
            case 16777216L: return "m68k_freescale_cpu32";
            case 33554432L: return "m68k_freescale_isaa";
            case 67108864L: return "m68k_freescale_isab";
            case 134217728L: return "m68k_freescale_isac";
            case 268435456L: return "m68k_freescale_fpu";
            case 536870912L: return "m68k_freescale_mac";
            case 1073741824L: return "m68k_freescale_emac";
            case 2147483648L: return "m68k_freescale_emacb";
            case 4278190080L: return "m68k_freescale";
            case 4294967295L: return "m68k_family";
            default: return "";
        }
    }

    std::string M68kFamily(int64_t i, const std::string &strip) {
        std::string s = M68kFamily(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kFamily() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            7L,
            8L,
            16L,
            32L,
            255L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            65280L,
            65536L,
            131072L,
            262144L,
            458752L,
            16711680L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4278190080L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kFamily(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kFamily() {
        return stringify::Rose::BinaryAnalysis::M68kFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 53
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "m68k_regclass_data";
            case 1L: return "m68k_regclass_addr";
            case 2L: return "m68k_regclass_fpr";
            case 3L: return "m68k_regclass_spr";
            case 4L: return "m68k_regclass_mac";
            case 5L: return "m68k_regclass_sup";
            default: return "";
        }
    }

    std::string M68kRegisterClass(int64_t i, const std::string &strip) {
        std::string s = M68kRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kRegisterClass() {
        return stringify::Rose::BinaryAnalysis::M68kRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 63
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_spr_pc";
            case 1L: return "m68k_spr_sr";
            case 2L: return "m68k_spr_fpcr";
            case 3L: return "m68k_spr_fpsr";
            case 4L: return "m68k_spr_fpiar";
            default: return "";
        }
    }

    std::string M68kSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 72
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kMacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_mac_macsr";
            case 1L: return "m68k_mac_acc0";
            case 2L: return "m68k_mac_acc1";
            case 3L: return "m68k_mac_acc2";
            case 4L: return "m68k_mac_acc3";
            case 5L: return "m68k_mac_ext01";
            case 6L: return "m68k_mac_ext23";
            case 7L: return "m68k_mac_ext0";
            case 8L: return "m68k_mac_ext1";
            case 9L: return "m68k_mac_ext2";
            case 10L: return "m68k_mac_ext3";
            case 11L: return "m68k_mac_mask";
            default: return "";
        }
    }

    std::string M68kMacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kMacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kMacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kMacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kMacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kMacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kMacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kMacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 88
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEmacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_emac_macsr";
            case 1L: return "m68k_emac_acc0";
            case 2L: return "m68k_emac_acc1";
            case 3L: return "m68k_emac_acc2";
            case 4L: return "m68k_emac_acc3";
            case 5L: return "m68k_emac_mask";
            default: return "";
        }
    }

    std::string M68kEmacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kEmacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEmacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEmacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEmacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEmacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEmacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kEmacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 98
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSupervisorRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_sup_vbr";
            case 1L: return "m68k_sup_ssp";
            case 2L: return "m68k_sup_sfc";
            case 3L: return "m68k_sup_dfc";
            case 4L: return "m68k_sup_cacr";
            case 5L: return "m68k_sup_asid";
            case 6L: return "m68k_sup_acr0";
            case 7L: return "m68k_sup_acr1";
            case 8L: return "m68k_sup_acr2";
            case 9L: return "m68k_sup_acr3";
            case 10L: return "m68k_sup_mmubar";
            case 11L: return "m68k_sup_rombar0";
            case 12L: return "m68k_sup_rombar1";
            case 13L: return "m68k_sup_rambar0";
            case 14L: return "m68k_sup_rambar1";
            case 15L: return "m68k_sup_mbar";
            case 16L: return "m68k_sup_mpcr";
            case 17L: return "m68k_sup_edrambar";
            case 18L: return "m68k_sup_secmbar";
            case 19L: return "m68k_sup_0_pcr1";
            case 20L: return "m68k_sup_0_pcr2";
            case 21L: return "m68k_sup_0_pcr3";
            case 22L: return "m68k_sup_1_pcr1";
            case 23L: return "m68k_sup_1_pcr2";
            case 24L: return "m68k_sup_1_pcr3";
            default: return "";
        }
    }

    std::string M68kSupervisorRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSupervisorRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSupervisorRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSupervisorRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSupervisorRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSupervisorRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSupervisorRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSupervisorRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 185
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEffectiveAddressMode(int64_t i) {
        switch (i) {
            case 0L: return "m68k_eam_unknown";
            case 1L: return "m68k_eam_drd";
            case 2L: return "m68k_eam_ard";
            case 3L: return "m68k_eam_rd";
            case 4L: return "m68k_eam_ari";
            case 8L: return "m68k_eam_inc";
            case 16L: return "m68k_eam_dec";
            case 32L: return "m68k_eam_dsp";
            case 60L: return "m68k_eam_ri";
            case 64L: return "m68k_eam_idx8";
            case 128L: return "m68k_eam_idxbd";
            case 192L: return "m68k_eam_idx";
            case 256L: return "m68k_eam_mpost";
            case 512L: return "m68k_eam_mpre";
            case 768L: return "m68k_eam_mi";
            case 1024L: return "m68k_eam_pcdsp";
            case 2048L: return "m68k_eam_pcidx8";
            case 4096L: return "m68k_eam_pcidxbd";
            case 6144L: return "m68k_eam_pcidx";
            case 8192L: return "m68k_eam_pcmpost";
            case 16384L: return "m68k_eam_pcmpre";
            case 24576L: return "m68k_eam_pcmi";
            case 29568L: return "m68k_eam_234";
            case 31744L: return "m68k_eam_pc";
            case 32768L: return "m68k_eam_absw";
            case 65536L: return "m68k_eam_absl";
            case 98304L: return "m68k_eam_abs";
            case 123903L: return "m68k_eam_alter";
            case 131044L: return "m68k_eam_control";
            case 131072L: return "m68k_eam_imm";
            case 262140L: return "m68k_eam_memory";
            case 262141L: return "m68k_eam_data";
            case 262143L: return "m68k_eam_all";
            default: return "";
        }
    }

    std::string M68kEffectiveAddressMode(int64_t i, const std::string &strip) {
        std::string s = M68kEffectiveAddressMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEffectiveAddressMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            60L,
            64L,
            128L,
            192L,
            256L,
            512L,
            768L,
            1024L,
            2048L,
            4096L,
            6144L,
            8192L,
            16384L,
            24576L,
            29568L,
            31744L,
            32768L,
            65536L,
            98304L,
            123903L,
            131044L,
            131072L,
            262140L,
            262141L,
            262143L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEffectiveAddressMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEffectiveAddressMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEffectiveAddressMode() {
        return stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 239
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kDataFormat(int64_t i) {
        switch (i) {
            case 0L: return "m68k_fmt_i32";
            case 1L: return "m68k_fmt_f32";
            case 2L: return "m68k_fmt_f96";
            case 3L: return "m68k_fmt_p96";
            case 4L: return "m68k_fmt_i16";
            case 5L: return "m68k_fmt_f64";
            case 6L: return "m68k_fmt_i8";
            case 255L: return "m68k_fmt_unknown";
            default: return "";
        }
    }

    std::string M68kDataFormat(int64_t i, const std::string &strip) {
        std::string s = M68kDataFormat(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kDataFormat() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kDataFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kDataFormat(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kDataFormat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kDataFormat() {
        return stringify::Rose::BinaryAnalysis::M68kDataFormat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/InstructionEnumsM68k.h line 251
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "m68k_unknown_instruction";
            case 1L: return "m68k_abcd";
            case 2L: return "m68k_add";
            case 3L: return "m68k_adda";
            case 4L: return "m68k_addi";
            case 5L: return "m68k_addq";
            case 6L: return "m68k_addx";
            case 7L: return "m68k_and";
            case 8L: return "m68k_andi";
            case 9L: return "m68k_asl";
            case 10L: return "m68k_asr";
            case 11L: return "m68k_bcc";
            case 12L: return "m68k_bcs";
            case 13L: return "m68k_beq";
            case 14L: return "m68k_bge";
            case 15L: return "m68k_bgt";
            case 16L: return "m68k_bhi";
            case 17L: return "m68k_ble";
            case 18L: return "m68k_bls";
            case 19L: return "m68k_blt";
            case 20L: return "m68k_bmi";
            case 21L: return "m68k_bne";
            case 22L: return "m68k_bpl";
            case 23L: return "m68k_bvc";
            case 24L: return "m68k_bvs";
            case 25L: return "m68k_bchg";
            case 26L: return "m68k_bclr";
            case 27L: return "m68k_bfchg";
            case 28L: return "m68k_bfclr";
            case 29L: return "m68k_bfexts";
            case 30L: return "m68k_bfextu";
            case 31L: return "m68k_bfins";
            case 32L: return "m68k_bfset";
            case 33L: return "m68k_bftst";
            case 34L: return "m68k_bkpt";
            case 35L: return "m68k_bra";
            case 36L: return "m68k_bset";
            case 37L: return "m68k_bsr";
            case 38L: return "m68k_btst";
            case 39L: return "m68k_callm";
            case 40L: return "m68k_cas";
            case 41L: return "m68k_cas2";
            case 42L: return "m68k_chk";
            case 43L: return "m68k_chk2";
            case 44L: return "m68k_clr";
            case 45L: return "m68k_cmp";
            case 46L: return "m68k_cmp2";
            case 47L: return "m68k_cmpa";
            case 48L: return "m68k_cmpi";
            case 49L: return "m68k_cmpm";
            case 50L: return "m68k_cpusha";
            case 51L: return "m68k_cpushl";
            case 52L: return "m68k_cpushp";
            case 53L: return "m68k_dbt";
            case 54L: return "m68k_dbf";
            case 55L: return "m68k_dbhi";
            case 56L: return "m68k_dbls";
            case 57L: return "m68k_dbcc";
            case 58L: return "m68k_dbcs";
            case 59L: return "m68k_dbne";
            case 60L: return "m68k_dbeq";
            case 61L: return "m68k_dbvc";
            case 62L: return "m68k_dbvs";
            case 63L: return "m68k_dbpl";
            case 64L: return "m68k_dbmi";
            case 65L: return "m68k_dbge";
            case 66L: return "m68k_dblt";
            case 67L: return "m68k_dbgt";
            case 68L: return "m68k_dble";
            case 69L: return "m68k_divs";
            case 70L: return "m68k_divsl";
            case 71L: return "m68k_divu";
            case 72L: return "m68k_divul";
            case 73L: return "m68k_eor";
            case 74L: return "m68k_eori";
            case 75L: return "m68k_exg";
            case 76L: return "m68k_ext";
            case 77L: return "m68k_extb";
            case 78L: return "m68k_fabs";
            case 79L: return "m68k_fadd";
            case 80L: return "m68k_fbeq";
            case 81L: return "m68k_fbne";
            case 82L: return "m68k_fbgt";
            case 83L: return "m68k_fbngt";
            case 84L: return "m68k_fbge";
            case 85L: return "m68k_fbnge";
            case 86L: return "m68k_fblt";
            case 87L: return "m68k_fbnlt";
            case 88L: return "m68k_fble";
            case 89L: return "m68k_fbnle";
            case 90L: return "m68k_fbgl";
            case 91L: return "m68k_fbngl";
            case 92L: return "m68k_fbgle";
            case 93L: return "m68k_fbngle";
            case 94L: return "m68k_fbogt";
            case 95L: return "m68k_fbule";
            case 96L: return "m68k_fboge";
            case 97L: return "m68k_fbult";
            case 98L: return "m68k_fbolt";
            case 99L: return "m68k_fbuge";
            case 100L: return "m68k_fbole";
            case 101L: return "m68k_fbugt";
            case 102L: return "m68k_fbogl";
            case 103L: return "m68k_fbueq";
            case 104L: return "m68k_fbor";
            case 105L: return "m68k_fbun";
            case 106L: return "m68k_fbf";
            case 107L: return "m68k_fbt";
            case 108L: return "m68k_fbsf";
            case 109L: return "m68k_fbst";
            case 110L: return "m68k_fbseq";
            case 111L: return "m68k_fbsne";
            case 112L: return "m68k_fcmp";
            case 113L: return "m68k_fdabs";
            case 114L: return "m68k_fdadd";
            case 115L: return "m68k_fddiv";
            case 116L: return "m68k_fdiv";
            case 117L: return "m68k_fdmove";
            case 118L: return "m68k_fdmul";
            case 119L: return "m68k_fdneg";
            case 120L: return "m68k_fdsqrt";
            case 121L: return "m68k_fdsub";
            case 122L: return "m68k_fint";
            case 123L: return "m68k_fintrz";
            case 124L: return "m68k_fmove";
            case 125L: return "m68k_fmovem";
            case 126L: return "m68k_fmul";
            case 127L: return "m68k_fneg";
            case 128L: return "m68k_fnop";
            case 129L: return "m68k_fsabs";
            case 130L: return "m68k_fsadd";
            case 131L: return "m68k_fsdiv";
            case 132L: return "m68k_fsmove";
            case 133L: return "m68k_fsmul";
            case 134L: return "m68k_fsneg";
            case 135L: return "m68k_fsqrt";
            case 136L: return "m68k_fssqrt";
            case 137L: return "m68k_fssub";
            case 138L: return "m68k_fsub";
            case 139L: return "m68k_ftst";
            case 140L: return "m68k_illegal";
            case 141L: return "m68k_jmp";
            case 142L: return "m68k_jsr";
            case 143L: return "m68k_lea";
            case 144L: return "m68k_link";
            case 145L: return "m68k_lsl";
            case 146L: return "m68k_lsr";
            case 147L: return "m68k_mac";
            case 148L: return "m68k_mov3q";
            case 149L: return "m68k_movclr";
            case 150L: return "m68k_move";
            case 151L: return "m68k_move_acc";
            case 152L: return "m68k_move_accext";
            case 153L: return "m68k_move_ccr";
            case 154L: return "m68k_move_macsr";
            case 155L: return "m68k_move_mask";
            case 156L: return "m68k_move_sr";
            case 157L: return "m68k_move16";
            case 158L: return "m68k_movea";
            case 159L: return "m68k_movec";
            case 160L: return "m68k_movem";
            case 161L: return "m68k_movep";
            case 162L: return "m68k_moveq";
            case 163L: return "m68k_msac";
            case 164L: return "m68k_muls";
            case 165L: return "m68k_mulu";
            case 166L: return "m68k_mvs";
            case 167L: return "m68k_mvz";
            case 168L: return "m68k_nbcd";
            case 169L: return "m68k_neg";
            case 170L: return "m68k_negx";
            case 171L: return "m68k_nop";
            case 172L: return "m68k_not";
            case 173L: return "m68k_or";
            case 174L: return "m68k_ori";
            case 175L: return "m68k_pack";
            case 176L: return "m68k_pea";
            case 177L: return "m68k_rol";
            case 178L: return "m68k_ror";
            case 179L: return "m68k_roxl";
            case 180L: return "m68k_roxr";
            case 181L: return "m68k_rtd";
            case 182L: return "m68k_rtm";
            case 183L: return "m68k_rtr";
            case 184L: return "m68k_rts";
            case 185L: return "m68k_sbcd";
            case 186L: return "m68k_st";
            case 187L: return "m68k_sf";
            case 188L: return "m68k_shi";
            case 189L: return "m68k_sls";
            case 190L: return "m68k_scc";
            case 191L: return "m68k_scs";
            case 192L: return "m68k_sne";
            case 193L: return "m68k_seq";
            case 194L: return "m68k_svc";
            case 195L: return "m68k_svs";
            case 196L: return "m68k_spl";
            case 197L: return "m68k_smi";
            case 198L: return "m68k_sge";
            case 199L: return "m68k_slt";
            case 200L: return "m68k_sgt";
            case 201L: return "m68k_sle";
            case 202L: return "m68k_sub";
            case 203L: return "m68k_suba";
            case 204L: return "m68k_subi";
            case 205L: return "m68k_subq";
            case 206L: return "m68k_subx";
            case 207L: return "m68k_swap";
            case 208L: return "m68k_tas";
            case 209L: return "m68k_trap";
            case 210L: return "m68k_trapt";
            case 211L: return "m68k_trapf";
            case 212L: return "m68k_traphi";
            case 213L: return "m68k_trapls";
            case 214L: return "m68k_trapcc";
            case 215L: return "m68k_trapcs";
            case 216L: return "m68k_trapne";
            case 217L: return "m68k_trapeq";
            case 218L: return "m68k_trapvc";
            case 219L: return "m68k_trapvs";
            case 220L: return "m68k_trappl";
            case 221L: return "m68k_trapmi";
            case 222L: return "m68k_trapge";
            case 223L: return "m68k_traplt";
            case 224L: return "m68k_trapgt";
            case 225L: return "m68k_traple";
            case 226L: return "m68k_trapv";
            case 227L: return "m68k_tst";
            case 228L: return "m68k_unlk";
            case 229L: return "m68k_unpk";
            case 230L: return "m68k_last_instruction";
            default: return "";
        }
    }

    std::string M68kInstructionKind(int64_t i, const std::string &strip) {
        std::string s = M68kInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L
        };
        static const std::vector<int64_t> retval(values, values + 231);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kInstructionKind() {
        return stringify::Rose::BinaryAnalysis::M68kInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Jovial_ROSE_Connection/Jovial_to_ROSE_translation.h line 11
namespace stringify { namespace Jovial_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_exponentiateOperator";
            case 2L: return "e_plusOperator";
            case 3L: return "e_minusOperator";
            case 4L: return "e_modOperator";
            case 5L: return "e_multiplyOperator";
            case 6L: return "e_divideOperator";
            case 7L: return "e_notOperator";
            case 8L: return "e_andOperator";
            case 9L: return "e_orOperator";
            case 10L: return "e_xorOperator";
            case 11L: return "e_equivOperator";
            case 12L: return "e_lessThanOperator";
            case 13L: return "e_greaterThanOperator";
            case 14L: return "e_lessThanOrEqualOperator";
            case 15L: return "e_greaterThanOrEqualOperator";
            case 16L: return "e_equalOperator";
            case 17L: return "e_notEqualOperator";
            case 18L: return "e_derefOperator";
            case 19L: return "e_assignOperator";
            case 20L: return "e_unaryPlusOperator";
            case 21L: return "e_unaryMinusOperator";
            case 22L: return "e_notAnOperator";
            case 23L: return "e_literalExpression";
            case 24L: return "e_referenceExpression";
            case 25L: return "e_by_phrase_expr";
            case 26L: return "e_then_phrase_expr";
            case 27L: return "e_while_phrase_expr";
            case 28L: return "e_words_per_entry_w";
            case 29L: return "e_words_per_entry_v";
            case 30L: return "e_for_while_by_stmt";
            case 31L: return "e_for_while_then_stmt";
            case 32L: return "e_for_by_while_stmt";
            case 33L: return "e_for_then_while_stmt";
            case 34L: return "e_simple_block_type_declaration";
            case 35L: return "e_block_type_declaration";
            case 36L: return "e_simple_table_type_declaration";
            case 37L: return "e_table_type_declaration";
            case 38L: return "e_anonymous_declaration";
            case 39L: return "e_compool_directive_stmt";
            case 40L: return "e_reducible_directive_stmt";
            case 41L: return "e_order_directive_stmt";
            case 42L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L
        };
        static const std::vector<int64_t> retval(values, values + 43);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyJovial_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Jovial_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Jovial_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyJovial_ROSE_TranslationExpressionKind() {
        return stringify::Jovial_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/ECJ_ROSE_Connection/JavaParserActionROSE.C line 4128
namespace stringify {
    const char* ops(int64_t i) {
        switch (i) {
            case 0L: return "ERROR_OPERATOR";
            case 2L: return "AND";
            case 3L: return "OR";
            case 4L: return "LESS";
            case 5L: return "LESS_EQUAL";
            case 6L: return "GREATER";
            case 7L: return "GREATER_EQUAL";
            case 8L: return "XOR";
            case 9L: return "DIVIDE";
            case 10L: return "LEFT_SHIFT";
            case 13L: return "MINUS";
            case 14L: return "PLUS";
            case 15L: return "MULTIPLY";
            case 16L: return "REMAINDER";
            case 17L: return "RIGHT_SHIFT";
            case 19L: return "UNSIGNED_RIGHT_SHIFT";
            case 100L: return "OR_OR";
            case 101L: return "AND_AND";
            case 102L: return "LAST_OPERATOR";
            default: return "";
        }
    }

    std::string ops(int64_t i, const std::string &strip) {
        std::string s = ops(i);
        if (s.empty())
            s = "(ops)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ops() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            13L,
            14L,
            15L,
            16L,
            17L,
            19L,
            100L,
            101L,
            102L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_ops(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ops(i);
        if (retval.empty()) {
            retval = "(ops)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ops::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ops() {
        return stringify::ops();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 14
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L
        };
        static const std::vector<int64_t> retval(values, values + 126);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 147
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 215
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 242
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_operators() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 321
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 10
namespace stringify {
    const char* ROSE_Fortran_Identifiers(int64_t i) {
        switch (i) {
            case 2L: return "ROSE_ABSTRACT";
            case 3L: return "ROSE_ACCESS";
            case 4L: return "ROSE_ACTION";
            case 5L: return "ROSE_ALLOCATE";
            case 6L: return "ROSE_ALLOCATABLE";
            case 7L: return "ROSE_ASSIGN";
            case 8L: return "ROSE_ASSOCIATE";
            case 9L: return "ROSE_ASYNCHRONOUS";
            case 10L: return "ROSE_BACKSPACE";
            case 11L: return "ROSE_BIND";
            case 12L: return "ROSE_BLANK";
            case 13L: return "ROSE_BLOCK_DATA";
            case 14L: return "ROSE_CALL";
            case 15L: return "ROSE_CHARACTER";
            case 16L: return "ROSE_CLASS";
            case 17L: return "ROSE_CLOSE";
            case 18L: return "ROSE_CONTINUE";
            case 19L: return "ROSE_CYCLE";
            case 20L: return "ROSE_CASE";
            case 21L: return "ROSE_COMMON";
            case 22L: return "ROSE_COMPLEX";
            case 23L: return "ROSE_CONTAINS";
            case 24L: return "ROSE_DEALLOCATE";
            case 25L: return "ROSE_DATA";
            case 26L: return "ROSE_DEFERRED";
            case 27L: return "ROSE_DELIM";
            case 28L: return "ROSE_DIMENSION";
            case 29L: return "ROSE_DO";
            case 30L: return "ROSE_DT";
            case 31L: return "ROSE_DOUBLEPRECISION";
            case 32L: return "ROSE_ENCODING";
            case 33L: return "ROSE_END_CASE";
            case 34L: return "ROSE_ENDDO";
            case 35L: return "ROSE_END_FILE";
            case 36L: return "ROSE_END_ENUM";
            case 37L: return "ROSE_END_INTERFACE";
            case 38L: return "ROSE_END_TYPE";
            case 39L: return "ROSE_ERR";
            case 40L: return "ROSE_ERRMSG";
            case 41L: return "ROSE_EXIT";
            case 42L: return "ROSE_ELSE";
            case 43L: return "ROSE_ELSEWHERE";
            case 44L: return "ROSE_ELSEIF";
            case 45L: return "ROSE_ENDIF";
            case 46L: return "ROSE_ENTRY";
            case 47L: return "ROSE_ENUM";
            case 49L: return "ROSE_ENUMERATOR";
            case 50L: return "ROSE_EQUIVALENCE";
            case 51L: return "ROSE_EXTERNAL";
            case 52L: return "ROSE_EXTENDS";
            case 53L: return "ROSE_FILE";
            case 54L: return "ROSE_FINAL";
            case 55L: return "ROSE_FMT";
            case 56L: return "ROSE_FORALL";
            case 57L: return "ROSE_FORM";
            case 58L: return "ROSE_FORMATTED";
            case 59L: return "ROSE_FORMAT";
            case 60L: return "ROSE_FLUSH";
            case 61L: return "ROSE_FUNCTION";
            case 62L: return "ROSE_GENERIC";
            case 63L: return "ROSE_GOTO";
            case 64L: return "ROSE_ID";
            case 65L: return "ROSE_IF";
            case 66L: return "ROSE_INQUIRE";
            case 67L: return "ROSE_INTEGER";
            case 68L: return "ROSE_IOMSG";
            case 69L: return "ROSE_IOSTAT";
            case 70L: return "ROSE_IMPLICIT";
            case 71L: return "ROSE_IMPLICIT_NONE";
            case 72L: return "ROSE_IMPORT";
            case 73L: return "ROSE_INTERFACE";
            case 74L: return "ROSE_INTENT";
            case 75L: return "ROSE_INTRINSIC";
            case 76L: return "ROSE_LEN";
            case 77L: return "ROSE_LOGICAL";
            case 78L: return "ROSE_KIND";
            case 79L: return "ROSE_MODULE_PROC";
            case 80L: return "ROSE_MODULE";
            case 81L: return "ROSE_NON_INTRINSIC";
            case 82L: return "ROSE_NON_OVERRIDABLE";
            case 83L: return "ROSE_NULL";
            case 84L: return "ROSE_NULLIFY";
            case 85L: return "ROSE_NAMELIST";
            case 86L: return "ROSE_NML";
            case 87L: return "ROSE_NONE";
            case 88L: return "ROSE_NOPASS";
            case 89L: return "ROSE_ONLY";
            case 90L: return "ROSE_OPTIONAL";
            case 91L: return "ROSE_PARAMETER";
            case 92L: return "ROSE_PASS";
            case 93L: return "ROSE_PAUSE";
            case 94L: return "ROSE_POINTER";
            case 96L: return "ROSE_PRINT";
            case 97L: return "ROSE_PRIVATE";
            case 98L: return "ROSE_PROCEDURE";
            case 99L: return "ROSE_PROGRAM";
            case 100L: return "ROSE_PROTECTED";
            case 101L: return "ROSE_READ";
            case 102L: return "ROSE_REAL";
            case 103L: return "ROSE_RETURN";
            case 104L: return "ROSE_REWIND";
            case 105L: return "ROSE_ROUND";
            case 106L: return "ROSE_SELECTCASE";
            case 107L: return "ROSE_SELECTTYPE";
            case 108L: return "ROSE_SEQUENCE";
            case 109L: return "ROSE_SAVE";
            case 110L: return "ROSE_SIGN";
            case 111L: return "ROSE_SIZE";
            case 112L: return "ROSE_SOURCE";
            case 113L: return "ROSE_STAT";
            case 114L: return "ROSE_STOP";
            case 115L: return "ROSE_SUBROUTINE";
            case 116L: return "ROSE_TARGET";
            case 117L: return "ROSE_THEN";
            case 118L: return "ROSE_DERIVED_DECL";
            case 119L: return "ROSE_TYPEIS";
            case 120L: return "ROSE_UNFORMATTED";
            case 121L: return "ROSE_UNIT";
            case 122L: return "ROSE_USE";
            case 123L: return "ROSE_VALUE";
            case 124L: return "ROSE_VOLATILE";
            case 125L: return "ROSE_WAIT";
            case 126L: return "ROSE_WHERE";
            case 127L: return "ROSE_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Identifiers(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Identifiers(i);
        if (s.empty())
            s = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Identifiers() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Identifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Identifiers(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Identifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Identifiers() {
        return stringify::ROSE_Fortran_Identifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 140
namespace stringify {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 1001L: return "ROSE_INTRINSIC_PLUS";
            case 1002L: return "ROSE_INTRINSIC_MINUS";
            case 1003L: return "ROSE_INTRINSIC_POWER";
            case 1004L: return "ROSE_INTRINSIC_CONCAT";
            case 1005L: return "ROSE_INTRINSIC_TIMES";
            case 1006L: return "ROSE_INTRINSIC_DIVIDE";
            case 1007L: return "ROSE_INTRINSIC_AND";
            case 1008L: return "ROSE_INTRINSIC_OR";
            case 1009L: return "ROSE_INTRINSIC_EQV";
            case 1010L: return "ROSE_INTRINSIC_NEQV";
            case 1011L: return "ROSE_INTRINSIC_EQ";
            case 1012L: return "ROSE_INTRINSIC_NE";
            case 1013L: return "ROSE_INTRINSIC_GE";
            case 1014L: return "ROSE_INTRINSIC_LE";
            case 1015L: return "ROSE_INTRINSIC_LT";
            case 1016L: return "ROSE_INTRINSIC_GT";
            case 1017L: return "ROSE_INTRINSIC_NOT";
            case 1018L: return "ROSE_INTRINSIC_OLDEQ";
            case 1019L: return "ROSE_INTRINSIC_OLDNE";
            case 1020L: return "ROSE_INTRINSIC_OLDGE";
            case 1021L: return "ROSE_INTRINSIC_OLDLE";
            case 1022L: return "ROSE_INTRINSIC_OLDLT";
            case 1023L: return "ROSE_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 167
namespace stringify {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 10001L: return "ROSE_FORT_COMMENTS";
            case 10002L: return "ROSE_STRING_LITERALS";
            case 10003L: return "ROSE_IDENTIFIER";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            10001L,
            10002L,
            10003L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_OpenFortranParser_ROSE_Connection/Fortran_to_ROSE_translation.h line 8
namespace stringify { namespace Fortran_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 5000L: return "e_fortran_first";
            case 5001L: return "e_public";
            case 5002L: return "e_private";
            case 5003L: return "e_allocatable";
            case 5004L: return "e_asynchronous";
            case 5005L: return "e_contiguous";
            case 5006L: return "e_external";
            case 5007L: return "e_intent_in";
            case 5008L: return "e_intent_out";
            case 5009L: return "e_intent_inout";
            case 5010L: return "e_intrinsic";
            case 5011L: return "e_optional";
            case 5012L: return "e_parameter";
            case 5013L: return "e_pointer";
            case 5014L: return "e_protected";
            case 5015L: return "e_save";
            case 5016L: return "e_target";
            case 5017L: return "e_value";
            case 5018L: return "e_volatile";
            case 5019L: return "e_elemental";
            case 5020L: return "e_impure";
            case 5021L: return "e_module";
            case 5022L: return "e_pure";
            case 5023L: return "e_recursive";
            case 5024L: return "e_exponentiateOperator";
            case 5025L: return "e_plusOperator";
            case 5026L: return "e_minusOperator";
            case 5027L: return "e_modOperator";
            case 5028L: return "e_multiplyOperator";
            case 5029L: return "e_divideOperator";
            case 5030L: return "e_andOperator";
            case 5031L: return "e_orOperator";
            case 5032L: return "e_xorOperator";
            case 5033L: return "e_equivOperator";
            case 5034L: return "e_lessThanOperator";
            case 5035L: return "e_greaterThanOperator";
            case 5036L: return "e_lessThanOrEqualOperator";
            case 5037L: return "e_greaterThanOrEqualOperator";
            case 5038L: return "e_equalOperator";
            case 5039L: return "e_notEqualOperator";
            case 5040L: return "e_unaryPlusOperator";
            case 5041L: return "e_unaryMinusOperator";
            case 5042L: return "e_notAnOperator";
            case 5043L: return "e_literalExpression";
            case 5044L: return "e_referenceExpression";
            case 5045L: return "e_array_shape";
            case 5046L: return "e_explicit_shape";
            case 5047L: return "e_assumed_or_implied_shape";
            case 5048L: return "e_assumed_shape";
            case 5049L: return "e_assumed_size";
            case 5050L: return "e_program_stmt";
            case 5051L: return "e_end_program_stmt";
            case 5052L: return "e_block_stmt";
            case 5053L: return "e_end_block_stmt";
            case 5054L: return "e_do_stmt";
            case 5055L: return "e_cuda_device";
            case 5056L: return "e_cuda_host";
            case 5057L: return "e_cuda_kernel";
            case 5058L: return "e_cuda_global";
            case 5059L: return "e_cuda_grid_global";
            case 5060L: return "e_cuda_managed";
            case 5061L: return "e_cuda_constant";
            case 5062L: return "e_cuda_shared";
            case 5063L: return "e_cuda_pinned";
            case 5064L: return "e_cuda_texture";
            case 5065L: return "e_fortran_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Fortran_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            5000L,
            5001L,
            5002L,
            5003L,
            5004L,
            5005L,
            5006L,
            5007L,
            5008L,
            5009L,
            5010L,
            5011L,
            5012L,
            5013L,
            5014L,
            5015L,
            5016L,
            5017L,
            5018L,
            5019L,
            5020L,
            5021L,
            5022L,
            5023L,
            5024L,
            5025L,
            5026L,
            5027L,
            5028L,
            5029L,
            5030L,
            5031L,
            5032L,
            5033L,
            5034L,
            5035L,
            5036L,
            5037L,
            5038L,
            5039L,
            5040L,
            5041L,
            5042L,
            5043L,
            5044L,
            5045L,
            5046L,
            5047L,
            5048L,
            5049L,
            5050L,
            5051L,
            5052L,
            5053L,
            5054L,
            5055L,
            5056L,
            5057L,
            5058L,
            5059L,
            5060L,
            5061L,
            5062L,
            5063L,
            5064L,
            5065L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFortran_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Fortran_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Fortran_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Fortran_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFortran_ROSE_TranslationExpressionKind() {
        return stringify::Fortran_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Cobol_ROSE_Connection/Cobol_to_ROSE_translation.h line 8
namespace stringify { namespace Cobol_ROSE_Translation {
    const char* ProgramSpec(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_recursive";
            case 2L: return "e_initial";
            case 3L: return "e_last";
            default: return "";
        }
    }

    std::string ProgramSpec(int64_t i, const std::string &strip) {
        std::string s = ProgramSpec(i);
        if (s.empty())
            s = "(Cobol_ROSE_Translation::ProgramSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ProgramSpec() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCobol_ROSE_TranslationProgramSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cobol_ROSE_Translation::ProgramSpec(i);
        if (retval.empty()) {
            retval = "(Cobol_ROSE_Translation::ProgramSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cobol_ROSE_Translation::ProgramSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCobol_ROSE_TranslationProgramSpec() {
        return stringify::Cobol_ROSE_Translation::ProgramSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Cobol_ROSE_Connection/Cobol_to_ROSE_translation.h line 21
namespace stringify { namespace Cobol_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_exponentiateOperator";
            case 2L: return "e_plusOperator";
            case 3L: return "e_minusOperator";
            case 4L: return "e_modOperator";
            case 5L: return "e_multiplyOperator";
            case 6L: return "e_divideOperator";
            case 7L: return "e_notOperator";
            case 8L: return "e_andOperator";
            case 9L: return "e_orOperator";
            case 10L: return "e_xorOperator";
            case 11L: return "e_equivOperator";
            case 12L: return "e_lessThanOperator";
            case 13L: return "e_greaterThanOperator";
            case 14L: return "e_lessThanOrEqualOperator";
            case 15L: return "e_greaterThanOrEqualOperator";
            case 16L: return "e_equalOperator";
            case 17L: return "e_notEqualOperator";
            case 18L: return "e_derefOperator";
            case 19L: return "e_assignOperator";
            case 20L: return "e_unaryPlusOperator";
            case 21L: return "e_unaryMinusOperator";
            case 22L: return "e_notAnOperator";
            case 23L: return "e_referenceExpression";
            case 24L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Cobol_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCobol_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cobol_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Cobol_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cobol_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCobol_ROSE_TranslationExpressionKind() {
        return stringify::Cobol_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 52
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "StatementScope";
            case 2L: return "SurroundingScope";
            case 3L: return "Preamble";
            case 4L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 66
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfCurrentScope";
            case 3L: return "BeforeCurrentPosition";
            case 4L: return "ReplaceCurrentPosition";
            case 5L: return "AfterCurrentPosition";
            case 6L: return "BottomOfCurrentScope";
            case 7L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 79
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "CurrentLocationTopOfScope";
            case 3L: return "CurrentLocationAfter";
            case 4L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            case 6L: return "CurrentLocationBottomOfScope";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 141
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "SurroundingScope";
            case 2L: return "ParentScope";
            case 3L: return "NestedLoopScope";
            case 4L: return "NestedConditionalScope";
            case 5L: return "FunctionScope";
            case 6L: return "FileScope";
            case 7L: return "GlobalScope";
            case 8L: return "Preamble";
            case 9L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 162
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfScope";
            case 3L: return "TopOfIncludeRegion";
            case 4L: return "BottomOfIncludeRegion";
            case 5L: return "BeforeCurrentPosition";
            case 6L: return "ReplaceCurrentPosition";
            case 7L: return "AfterCurrentPosition";
            case 8L: return "BottomOfScope";
            case 9L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 176
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "GlobalScopeTopOfScope";
            case 3L: return "GlobalScopeTopOfIncludeRegion";
            case 4L: return "GlobalScopeBottomOfIncludeRegion";
            case 5L: return "GlobalScopeBeforeCurrentPosition";
            case 6L: return "GlobalScopeReplaceCurrentPosition";
            case 7L: return "FunctionScopePreamble";
            case 8L: return "FunctionScopeTopOfScope";
            case 9L: return "FunctionScopeBeforeCurrentPosition";
            case 10L: return "FunctionScopeReplaceCurrentPosition";
            case 11L: return "FunctionScopeAfterCurrentPosition";
            case 12L: return "FunctionScopeBottomOfScope";
            case 13L: return "GlobalScopeAfterCurrentPosition";
            case 14L: return "GlobalScopeBottomOfScope";
            case 15L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/KLT/include/KLT/Core/descriptor.hpp line 18
namespace stringify { namespace KLT { namespace Descriptor {
    const char* tile_kind_e(int64_t i) {
        switch (i) {
            case -1L: return "e_not_tile";
            case 0L: return "e_static_tile";
            case 1L: return "e_last_klt_tile";
            default: return "";
        }
    }

    std::string tile_kind_e(int64_t i, const std::string &strip) {
        std::string s = tile_kind_e(i);
        if (s.empty())
            s = "(KLT::Descriptor::tile_kind_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& tile_kind_e() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyKLT_Descriptor_tile_kind_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::KLT::Descriptor::tile_kind_e(i);
        if (retval.empty()) {
            retval = "(KLT::Descriptor::tile_kind_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "KLT::Descriptor::tile_kind_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyKLT_Descriptor_tile_kind_e() {
        return stringify::KLT::Descriptor::tile_kind_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/KLT/include/KLT/Core/looptree.hpp line 30
namespace stringify { namespace KLT { namespace LoopTree {
    const char* kind_e(int64_t i) {
        switch (i) {
            case 0L: return "e_block";
            case 1L: return "e_cond";
            case 2L: return "e_loop";
            case 3L: return "e_tile";
            case 4L: return "e_stmt";
            case 5L: return "e_ignored";
            case 6L: return "e_unknown";
            default: return "";
        }
    }

    std::string kind_e(int64_t i, const std::string &strip) {
        std::string s = kind_e(i);
        if (s.empty())
            s = "(KLT::LoopTree::kind_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kind_e() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyKLT_LoopTree_kind_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::KLT::LoopTree::kind_e(i);
        if (retval.empty()) {
            retval = "(KLT::LoopTree::kind_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "KLT::LoopTree::kind_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyKLT_LoopTree_kind_e() {
        return stringify::KLT::LoopTree::kind_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/KLT/include/KLT/RTL/tile.h line 7
namespace stringify { namespace klt_tile_desc_t {
    const char* tile_kind_e(int64_t i) {
        switch (i) {
            case 0L: return "e_tile_static";
            case 1L: return "e_tile_dynamic";
            default: return "";
        }
    }

    std::string tile_kind_e(int64_t i, const std::string &strip) {
        std::string s = tile_kind_e(i);
        if (s.empty())
            s = "(klt_tile_desc_t::tile_kind_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& tile_kind_e() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_klt_tile_desc_t_tile_kind_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::klt_tile_desc_t::tile_kind_e(i);
        if (retval.empty()) {
            retval = "(klt_tile_desc_t::tile_kind_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "klt_tile_desc_t::tile_kind_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_klt_tile_desc_t_tile_kind_e() {
        return stringify::klt_tile_desc_t::tile_kind_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/MDCG/include/MDCG/Model/base.hpp line 24
namespace stringify { namespace MDCG { namespace Model {
    const char* model_elements_e(int64_t i) {
        switch (i) {
            case 0L: return "e_model_blank";
            case 1L: return "e_model_variable";
            case 2L: return "e_model_function";
            case 3L: return "e_model_field";
            case 4L: return "e_model_method";
            case 5L: return "e_model_type";
            case 6L: return "e_model_class";
            case 7L: return "e_model_namespace";
            default: return "";
        }
    }

    std::string model_elements_e(int64_t i, const std::string &strip) {
        std::string s = model_elements_e(i);
        if (s.empty())
            s = "(MDCG::Model::model_elements_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& model_elements_e() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyMDCG_Model_model_elements_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MDCG::Model::model_elements_e(i);
        if (retval.empty()) {
            retval = "(MDCG::Model::model_elements_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MDCG::Model::model_elements_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMDCG_Model_model_elements_e() {
        return stringify::MDCG::Model::model_elements_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/MDCG/include/MDCG/Model/base.hpp line 46
namespace stringify { namespace MDCG { namespace Model { namespace element_t {
    const char* kind_e(int64_t i) {
        switch (i) {
            case 0L: return "kind";
            default: return "";
        }
    }

    std::string kind_e(int64_t i, const std::string &strip) {
        std::string s = kind_e(i);
        if (s.empty())
            s = "(MDCG::Model::element_t::kind_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kind_e() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyMDCG_Model_element_t_kind_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MDCG::Model::element_t::kind_e(i);
        if (retval.empty()) {
            retval = "(MDCG::Model::element_t::kind_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MDCG::Model::element_t::kind_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMDCG_Model_element_t_kind_e() {
        return stringify::MDCG::Model::element_t::kind_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.h line 42
namespace stringify { namespace AstAttribute {
    const char* OwnershipPolicy(int64_t i) {
        switch (i) {
            case 0L: return "CONTAINER_OWNERSHIP";
            case 1L: return "NO_OWNERSHIP";
            case 2L: return "CUSTOM_OWNERSHIP";
            case 3L: return "UNKNOWN_OWNERSHIP";
            default: return "";
        }
    }

    std::string OwnershipPolicy(int64_t i, const std::string &strip) {
        std::string s = OwnershipPolicy(i);
        if (s.empty())
            s = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OwnershipPolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeOwnershipPolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttribute::OwnershipPolicy(i);
        if (retval.empty()) {
            retval = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttribute::OwnershipPolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeOwnershipPolicy() {
        return stringify::AstAttribute::OwnershipPolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.C line 21
namespace stringify {
    const char* WarningType(int64_t i) {
        switch (i) {
            case 0L: return "HAS_MEMORY_LEAK";
            case 1L: return "HAS_UNKNOWN_OWNERSHIP";
            case 2L: return "HAS_NULL_COPY";
            case 3L: return "HAS_SELF_COPY";
            case 4L: return "HAS_NO_CLASS_NAME";
            default: return "";
        }
    }

    std::string WarningType(int64_t i, const std::string &strip) {
        std::string s = WarningType(i);
        if (s.empty())
            s = "(WarningType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WarningType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyWarningType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::WarningType(i);
        if (retval.empty()) {
            retval = "(WarningType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "WarningType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyWarningType() {
        return stringify::WarningType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 60
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* LabelType(int64_t i) {
        switch (i) {
            case 1L: return "LABEL_UNDEF";
            case 2L: return "LABEL_OTHER";
            case 100L: return "LABEL_FUNCTIONCALL";
            case 101L: return "LABEL_FUNCTIONCALLRETURN";
            case 102L: return "LABEL_FUNCTIONENTRY";
            case 103L: return "LABEL_FUNCTIONEXIT";
            case 104L: return "LABEL_BLOCKBEGIN";
            case 105L: return "LABEL_BLOCKEND";
            case 106L: return "LABEL_EMPTY_STMT";
            case 107L: return "LABEL_FORK";
            case 108L: return "LABEL_JOIN";
            case 109L: return "LABEL_WORKSHARE";
            case 110L: return "LABEL_BARRIER";
            default: return "";
        }
    }

    std::string LabelType(int64_t i, const std::string &strip) {
        std::string s = LabelType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LabelType() {
        static const int64_t values[] = {
            1L,
            2L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyLabelType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::LabelType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::LabelType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyLabelType() {
        return stringify::CodeThorn::LabelProperty::LabelType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 94
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* IOType(int64_t i) {
        switch (i) {
            case 0L: return "LABELIO_NONE";
            case 1L: return "LABELIO_STDIN";
            case 2L: return "LABELIO_STDOUTVAR";
            case 3L: return "LABELIO_STDOUTCONST";
            case 4L: return "LABELIO_STDERR";
            default: return "";
        }
    }

    std::string IOType(int64_t i, const std::string &strip) {
        std::string s = IOType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IOType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyIOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::IOType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::IOType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyIOType() {
        return stringify::CodeThorn::LabelProperty::IOType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/SgNodeHelper.h line 509
namespace stringify { namespace SgNodeHelper { namespace Pattern { namespace OutputTarget {
    const char* OType(int64_t i) {
        switch (i) {
            case 0L: return "VAR";
            case 1L: return "INT";
            case 2L: return "UNKNOWNPRINTF";
            case 3L: return "UNKNOWNOPERATION";
            default: return "";
        }
    }

    std::string OType(int64_t i, const std::string &strip) {
        std::string s = OType(i);
        if (s.empty())
            s = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySgNodeHelperPatternOutputTargetOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgNodeHelper::Pattern::OutputTarget::OType(i);
        if (retval.empty()) {
            retval = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgNodeHelperPatternOutputTargetOType() {
        return stringify::SgNodeHelper::Pattern::OutputTarget::OType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/MFB/include/MFB/Sage/graph.hpp line 35
namespace stringify { namespace MFB { namespace Graph { namespace API {
    const char* link_kind_e(int64_t i) {
        switch (i) {
            case 0L: return "e_link_kind_unknown";
            case 1L: return "e_link_kind_defines";
            case 2L: return "e_link_kind_extends";
            case 3L: return "e_link_kind_specializes";
            case 4L: return "e_link_kind_represents";
            case 5L: return "e_link_kind_param";
            case 6L: return "e_link_kind_arg";
            case 7L: return "e_link_kind_type_base";
            case 8L: return "e_link_kind_last";
            default: return "";
        }
    }

    std::string link_kind_e(int64_t i, const std::string &strip) {
        std::string s = link_kind_e(i);
        if (s.empty())
            s = "(MFB::Graph::API::link_kind_e)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& link_kind_e() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyMFB_GraphAPIlink_kind_e(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MFB::Graph::API::link_kind_e(i);
        if (retval.empty()) {
            retval = "(MFB::Graph::API::link_kind_e)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MFB::Graph::API::link_kind_e::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMFB_GraphAPIlink_kind_e() {
        return stringify::MFB::Graph::API::link_kind_e();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFunctionSimilarity.h line 71
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* CValKind(int64_t i) {
        switch (i) {
            case 0L: return "CARTESIAN_POINT";
            case 1L: return "ORDERED_LIST";
            default: return "";
        }
    }

    std::string CValKind(int64_t i, const std::string &strip) {
        std::string s = CValKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CValKind() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityCValKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::CValKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityCValKind() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFunctionSimilarity.h line 83
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* Statistic(int64_t i) {
        switch (i) {
            case 0L: return "AVERAGE";
            case 1L: return "MEDIAN";
            case 2L: return "MAXIMUM";
            default: return "";
        }
    }

    std::string Statistic(int64_t i, const std::string &strip) {
        std::string s = Statistic(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statistic() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityStatistic(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::Statistic::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityStatistic() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryMagic.h line 16
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MagicNumber {
    const char* Mechanism(int64_t i) {
        switch (i) {
            case 0L: return "FAST";
            case 1L: return "SLOW";
            case 2L: return "NONE";
            default: return "";
        }
    }

    std::string Mechanism(int64_t i, const std::string &strip) {
        std::string s = Mechanism(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mechanism() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMagicNumberMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MagicNumber::Mechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMagicNumberMechanism() {
        return stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryConcolic.h line 68
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic { namespace Update {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::Update::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicUpdateFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::Update::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::Update::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::Update::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicUpdateFlag() {
        return stringify::Rose::BinaryAnalysis::Concolic::Update::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryHotPatch.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PATCH_REGISTER";
            case 1L: return "PATCH_NONE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordType() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryHotPatch.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "MATCH_CONTINUE";
            case 1L: return "MATCH_BREAK";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordBehavior() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCallingConvention.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackParameterOrder(int64_t i) {
        switch (i) {
            case 0L: return "LEFT_TO_RIGHT";
            case 1L: return "RIGHT_TO_LEFT";
            case 2L: return "ORDER_UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackParameterOrder(int64_t i, const std::string &strip) {
        std::string s = StackParameterOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackParameterOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackParameterOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackParameterOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackParameterOrder() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCallingConvention.h line 57
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackDirection(int64_t i) {
        switch (i) {
            case 0L: return "GROWS_UP";
            case 1L: return "GROWS_DOWN";
            default: return "";
        }
    }

    std::string StackDirection(int64_t i, const std::string &strip) {
        std::string s = StackDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackDirection() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCallingConvention.h line 63
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackCleanup(int64_t i) {
        switch (i) {
            case 0L: return "CLEANUP_BY_CALLER";
            case 1L: return "CLEANUP_BY_CALLEE";
            case 2L: return "CLEANUP_UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackCleanup(int64_t i, const std::string &strip) {
        std::string s = StackCleanup(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackCleanup() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackCleanup(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackCleanup::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackCleanup() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCallingConvention.h line 87
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention { namespace ParameterLocation {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_LOCATION";
            case 1L: return "REGISTER";
            case 2L: return "STACK";
            case 3L: return "ABSOLUTE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::ParameterLocation::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionParameterLocationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::ParameterLocation::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::ParameterLocation::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::ParameterLocation::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionParameterLocationType() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::ParameterLocation::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/DwarfLineMapper.h line 16
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace DwarfLineMapper {
    const char* Direction(int64_t i) {
        switch (i) {
            case 1L: return "ADDR2SRC";
            case 2L: return "SRC2ADDR";
            case 3L: return "BIDIRECTIONAL";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::DwarfLineMapper::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfLineMapperDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::DwarfLineMapper::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::DwarfLineMapper::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::DwarfLineMapper::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfLineMapperDirection() {
        return stringify::Rose::BinaryAnalysis::DwarfLineMapper::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryString.h line 195
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Strings {
    const char* State(int64_t i) {
        switch (i) {
            case -4L: return "ERROR_STATE";
            case -3L: return "INITIAL_STATE";
            case -2L: return "COMPLETED_STATE";
            case -1L: return "FINAL_STATE";
            case 0L: return "USER_DEFINED_0";
            case 1L: return "USER_DEFINED_1";
            case 2L: return "USER_DEFINED_2";
            case 128L: return "USER_DEFINED_MAX";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            -4L,
            -3L,
            -2L,
            -1L,
            0L,
            1L,
            2L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisStringsState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Strings::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Strings::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisStringsState() {
        return stringify::Rose::BinaryAnalysis::Strings::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryReachability.h line 23
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Reachability {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "NOT_REACHABLE";
            case 1L: return "PROGRAM_ENTRY_POINT";
            case 2L: return "EXPORTED_FUNCTION";
            case 4L: return "SIGNAL_HANDLER";
            case 128L: return "ASSUMED";
            case 256L: return "EXPLICIT_MEM_CONSTANT";
            case 512L: return "EXPLICIT_INSN_CONSTANT";
            case 1024L: return "IMPLICIT_FUNC_CONSTANT";
            case 65536L: return "USER_DEFINED_0";
            case 131072L: return "USER_DEFINED_1";
            case 262144L: return "USER_DEFINED_2";
            case 524288L: return "USER_DEFINED_3";
            case 1048576L: return "USER_DEFINED_4";
            case 2097152L: return "USER_DEFINED_5";
            case 4194304L: return "USER_DEFINED_6";
            case 8388608L: return "USER_DEFINED_7";
            case 16777216L: return "USER_DEFINED_8";
            case 33554432L: return "USER_DEFINED_9";
            case 67108864L: return "USER_DEFINED_10";
            case 134217728L: return "USER_DEFINED_11";
            case 268435456L: return "USER_DEFINED_12";
            case 536870912L: return "USER_DEFINED_13";
            case 1073741824L: return "USER_DEFINED_14";
            case 2147483648L: return "USER_DEFINED_15";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            128L,
            256L,
            512L,
            1024L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisReachabilityReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Reachability::Reason(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Reachability::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisReachabilityReason() {
        return stringify::Rose::BinaryAnalysis::Reachability::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySmtSolver.h line 42
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* LinkMode(int64_t i) {
        switch (i) {
            case 0L: return "LM_NONE";
            case 1L: return "LM_LIBRARY";
            case 2L: return "LM_EXECUTABLE";
            case 3L: return "LM_ANY";
            default: return "";
        }
    }

    std::string LinkMode(int64_t i, const std::string &strip) {
        std::string s = LinkMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LinkMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverLinkMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::LinkMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverLinkMode() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySmtSolver.h line 54
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_TYPE";
            case 1L: return "BOOLEAN";
            case 2L: return "BIT_VECTOR";
            case 3L: return "MEM_STATE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverType() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySmtSolver.h line 78
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Satisfiable(int64_t i) {
        switch (i) {
            case 0L: return "SAT_NO";
            case 1L: return "SAT_YES";
            case 2L: return "SAT_UNKNOWN";
            default: return "";
        }
    }

    std::string Satisfiable(int64_t i, const std::string &strip) {
        std::string s = Satisfiable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Satisfiable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverSatisfiable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Satisfiable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverSatisfiable() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySymbolicExprParser.h line 55
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExprParser { namespace Token {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "LTPAREN";
            case 2L: return "RTPAREN";
            case 3L: return "BITVECTOR";
            case 4L: return "SYMBOL";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExprParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExprParserTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExprParser::Token::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExprParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExprParser::Token::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExprParserTokenType() {
        return stringify::Rose::BinaryAnalysis::SymbolicExprParser::Token::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryDebugger.h line 25
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger {
    const char* DetachMode(int64_t i) {
        switch (i) {
            case 0L: return "KILL";
            case 1L: return "DETACH";
            case 2L: return "CONTINUE";
            case 3L: return "NOTHING";
            default: return "";
        }
    }

    std::string DetachMode(int64_t i, const std::string &strip) {
        std::string s = DetachMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::DetachMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DetachMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerDetachMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::DetachMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::DetachMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::DetachMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerDetachMode() {
        return stringify::Rose::BinaryAnalysis::Debugger::DetachMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryDebugger.h line 33
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger {
    const char* Flag(int64_t i) {
        switch (i) {
            case 1L: return "ATTACH";
            case 2L: return "REDIRECT_INPUT";
            case 4L: return "REDIRECT_OUTPUT";
            case 8L: return "REDIRECT_ERROR";
            case 16L: return "CLOSE_FILES";
            case 19L: return "DEFAULT_FLAGS";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerFlag() {
        return stringify::Rose::BinaryAnalysis::Debugger::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryDebugger.h line 158
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger {
    const char* RegPageStatus(int64_t i) {
        switch (i) {
            case 0L: return "REGPAGE_NONE";
            case 1L: return "REGPAGE_REGS";
            case 2L: return "REGPAGE_FPREGS";
            default: return "";
        }
    }

    std::string RegPageStatus(int64_t i, const std::string &strip) {
        std::string s = RegPageStatus(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::RegPageStatus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegPageStatus() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerRegPageStatus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::RegPageStatus(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::RegPageStatus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::RegPageStatus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerRegPageStatus() {
        return stringify::Rose::BinaryAnalysis::Debugger::RegPageStatus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/DispatcherX86.h line 176
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace DispatcherX86 {
    const char* AccessMode(int64_t i) {
        switch (i) {
            case 0L: return "READ_REGISTER";
            case 1L: return "PEEK_REGISTER";
            default: return "";
        }
    }

    std::string AccessMode(int64_t i, const std::string &strip) {
        std::string s = AccessMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AccessMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2DispatcherX86AccessMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::DispatcherX86::AccessMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::DispatcherX86::AccessMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2DispatcherX86AccessMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::DispatcherX86::AccessMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/SymbolicSemantics2.h line 759
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace SymbolicSemantics {
    const char* WritersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_WRITERS";
            case 1L: return "TRACK_LATEST_WRITER";
            case 2L: return "TRACK_ALL_WRITERS";
            default: return "";
        }
    }

    std::string WritersMode(int64_t i, const std::string &strip) {
        std::string s = WritersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WritersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsWritersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsWritersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/SymbolicSemantics2.h line 766
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace SymbolicSemantics {
    const char* DefinersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_DEFINERS";
            case 1L: return "TRACK_LATEST_DEFINER";
            case 2L: return "TRACK_ALL_DEFINERS";
            default: return "";
        }
    }

    std::string DefinersMode(int64_t i, const std::string &strip) {
        std::string s = DefinersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DefinersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsDefinersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsDefinersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/DispatcherPowerpc.C line 15
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace UpdateCr {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2UpdateCrFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::UpdateCr::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::UpdateCr::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2UpdateCrFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::UpdateCr::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/DispatcherPowerpc.C line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace SaveLink {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2SaveLinkFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::SaveLink::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::SaveLink::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2SaveLinkFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::SaveLink::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/BaseSemanticsTypes.h line 75
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace BaseSemantics {
    const char* InputOutputProperty(int64_t i) {
        switch (i) {
            case 0L: return "IO_READ";
            case 1L: return "IO_WRITE";
            case 2L: return "IO_INIT";
            case 3L: return "IO_READ_BEFORE_WRITE";
            case 4L: return "IO_READ_AFTER_WRITE";
            case 5L: return "IO_READ_UNINITIALIZED";
            default: return "";
        }
    }

    std::string InputOutputProperty(int64_t i, const std::string &strip) {
        std::string s = InputOutputProperty(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InputOutputProperty() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2BaseSemanticsInputOutputProperty(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2BaseSemanticsInputOutputProperty() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/DataFlowSemantics2.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace DataFlowSemantics { namespace DataFlowEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "CLOBBER";
            case 1L: return "AUGMENT";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2DataFlowSemanticsDataFlowEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2DataFlowSemanticsDataFlowEdgeEdgeType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/instructionSemantics/IntervalSemantics2.C line 652
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics2 { namespace IntervalSemantics {
    const char* Carry(int64_t i) {
        switch (i) {
            case 0L: return "C_FALSE";
            case 1L: return "C_TRUE";
            case 2L: return "C_UNKNOWN";
            default: return "";
        }
    }

    std::string Carry(int64_t i, const std::string &strip) {
        std::string s = Carry(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Carry() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemantics2IntervalSemanticsCarry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemantics2IntervalSemanticsCarry() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryDebugger.C line 14
namespace stringify {
    const char* __ptrace_request(int64_t i) {
        switch (i) {
            case 0L: return "PTRACE_ATTACH";
            case 1L: return "PTRACE_CONT";
            case 2L: return "PTRACE_DETACH";
            case 3L: return "PTRACE_GETREGS";
            case 4L: return "PTRACE_GETFPREGS";
            case 5L: return "PTRACE_KILL";
            case 6L: return "PTRACE_SETREGS";
            case 7L: return "PTRACE_SINGLESTEP";
            case 8L: return "PTRACE_TRACEME";
            case 9L: return "PTRACE_PEEKUSER";
            default: return "";
        }
    }

    std::string __ptrace_request(int64_t i, const std::string &strip) {
        std::string s = __ptrace_request(i);
        if (s.empty())
            s = "(__ptrace_request)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __ptrace_request() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify__ptrace_request(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__ptrace_request(i);
        if (retval.empty()) {
            retval = "(__ptrace_request)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__ptrace_request::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__ptrace_request() {
        return stringify::__ptrace_request();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryTaintedFlow.h line 23
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Taintedness(int64_t i) {
        switch (i) {
            case 0L: return "BOTTOM";
            case 1L: return "NOT_TAINTED";
            case 2L: return "TAINTED";
            case 3L: return "TOP";
            default: return "";
        }
    }

    std::string Taintedness(int64_t i, const std::string &strip) {
        std::string s = Taintedness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Taintedness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowTaintedness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Taintedness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowTaintedness() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryTaintedFlow.h line 30
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Approximation(int64_t i) {
        switch (i) {
            case 0L: return "UNDER_APPROXIMATE";
            case 1L: return "OVER_APPROXIMATE";
            default: return "";
        }
    }

    std::string Approximation(int64_t i, const std::string &strip) {
        std::string s = Approximation(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Approximation() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowApproximation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Approximation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowApproximation() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCodeInserter.h line 12
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Commit {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCommitBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Commit::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Commit::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCommitBoolean() {
        return stringify::Rose::BinaryAnalysis::Commit::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCodeInserter.h line 22
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* AggregationDirection(int64_t i) {
        switch (i) {
            case 1L: return "AGGREGATE_PREDECESSORS";
            case 2L: return "AGGREGATE_SUCCESSORS";
            default: return "";
        }
    }

    std::string AggregationDirection(int64_t i, const std::string &strip) {
        std::string s = AggregationDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregationDirection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterAggregationDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::AggregationDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterAggregationDirection() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCodeInserter.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* NopPadding(int64_t i) {
        switch (i) {
            case 0L: return "PAD_NOP_BACK";
            case 1L: return "PAD_NOP_FRONT";
            case 2L: return "PAD_RANDOM_BACK";
            default: return "";
        }
    }

    std::string NopPadding(int64_t i, const std::string &strip) {
        std::string s = NopPadding(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NopPadding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterNopPadding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::NopPadding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterNopPadding() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryCodeInserter.h line 52
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "RELOC_INDEX_ABS_LE32";
            case 1L: return "RELOC_INDEX_ABS_LE32HI";
            case 2L: return "RELOC_INDEX_ABS_BE32";
            case 3L: return "RELOC_ADDR_REL_LE32";
            case 4L: return "RELOC_ADDR_REL_BE32";
            case 5L: return "RELOC_INSN_ABS_LE32";
            case 6L: return "RELOC_INSN_REL_LE32";
            case 7L: return "RELOC_INSN_REL_BE32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::RelocType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterRelocType() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/Concolic/ConcolicExecutor.h line 20
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic { namespace VariableProvenance {
    const char* Whence(int64_t i) {
        switch (i) {
            case 0L: return "INVALID";
            case 1L: return "REGISTER";
            case 2L: return "MEMORY";
            default: return "";
        }
    }

    std::string Whence(int64_t i, const std::string &strip) {
        std::string s = Whence(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::VariableProvenance::Whence)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Whence() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicVariableProvenanceWhence(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::VariableProvenance::Whence(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::VariableProvenance::Whence)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::VariableProvenance::Whence::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicVariableProvenanceWhence() {
        return stringify::Rose::BinaryAnalysis::Concolic::VariableProvenance::Whence();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/libraryIdentification/FunctionIdDatabaseInterface.h line 28
namespace stringify { namespace LibraryIdentification {
    const char* DUPLICATE_OPTION(int64_t i) {
        switch (i) {
            case 0L: return "UNKNOWN";
            case 1L: return "COMBINE";
            case 2L: return "REPLACE";
            case 3L: return "NO_ADD";
            default: return "";
        }
    }

    std::string DUPLICATE_OPTION(int64_t i, const std::string &strip) {
        std::string s = DUPLICATE_OPTION(i);
        if (s.empty())
            s = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DUPLICATE_OPTION() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLibraryIdentificationDUPLICATE_OPTION(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LibraryIdentification::DUPLICATE_OPTION(i);
        if (retval.empty()) {
            retval = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LibraryIdentification::DUPLICATE_OPTION::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLibraryIdentificationDUPLICATE_OPTION() {
        return stringify::LibraryIdentification::DUPLICATE_OPTION();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySymbolicExpr.h line 61
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpr {
    const char* Operator(int64_t i) {
        switch (i) {
            case 0L: return "OP_ADD";
            case 1L: return "OP_AND";
            case 2L: return "OP_ASR";
            case 3L: return "OP_CONCAT";
            case 4L: return "OP_EQ";
            case 5L: return "OP_EXTRACT";
            case 6L: return "OP_INVERT";
            case 7L: return "OP_ITE";
            case 8L: return "OP_LET";
            case 9L: return "OP_LSSB";
            case 10L: return "OP_MSSB";
            case 11L: return "OP_NE";
            case 12L: return "OP_NEGATE";
            case 13L: return "OP_NOOP";
            case 14L: return "OP_OR";
            case 15L: return "OP_READ";
            case 16L: return "OP_ROL";
            case 17L: return "OP_ROR";
            case 18L: return "OP_SDIV";
            case 19L: return "OP_SET";
            case 20L: return "OP_SEXTEND";
            case 21L: return "OP_SGE";
            case 22L: return "OP_SGT";
            case 23L: return "OP_SHL0";
            case 24L: return "OP_SHL1";
            case 25L: return "OP_SHR0";
            case 26L: return "OP_SHR1";
            case 27L: return "OP_SLE";
            case 28L: return "OP_SLT";
            case 29L: return "OP_SMOD";
            case 30L: return "OP_SMUL";
            case 31L: return "OP_UDIV";
            case 32L: return "OP_UEXTEND";
            case 33L: return "OP_UGE";
            case 34L: return "OP_UGT";
            case 35L: return "OP_ULE";
            case 36L: return "OP_ULT";
            case 37L: return "OP_UMOD";
            case 38L: return "OP_UMUL";
            case 39L: return "OP_WRITE";
            case 40L: return "OP_XOR";
            case 41L: return "OP_ZEROP";
            case 42L: return "OP_FP_ABS";
            case 43L: return "OP_FP_NEGATE";
            case 44L: return "OP_FP_ADD";
            case 45L: return "OP_FP_MUL";
            case 46L: return "OP_FP_DIV";
            case 47L: return "OP_FP_MULADD";
            case 48L: return "OP_FP_SQRT";
            case 49L: return "OP_FP_MOD";
            case 50L: return "OP_FP_ROUND";
            case 51L: return "OP_FP_MIN";
            case 52L: return "OP_FP_MAX";
            case 53L: return "OP_FP_LE";
            case 54L: return "OP_FP_LT";
            case 55L: return "OP_FP_GE";
            case 56L: return "OP_FP_GT";
            case 57L: return "OP_FP_EQ";
            case 58L: return "OP_FP_ISNORM";
            case 59L: return "OP_FP_ISSUBNORM";
            case 60L: return "OP_FP_ISZERO";
            case 61L: return "OP_FP_ISINFINITE";
            case 62L: return "OP_FP_ISNAN";
            case 63L: return "OP_FP_ISNEG";
            case 64L: return "OP_FP_ISPOS";
            case 65L: return "OP_CONVERT";
            case 66L: return "OP_REINTERPRET";
            case 67L: return "OP_NONE";
            default: return "";
        }
    }

    std::string Operator(int64_t i, const std::string &strip) {
        std::string s = Operator(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpr::Operator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L
        };
        static const std::vector<int64_t> retval(values, values + 68);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExprOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpr::Operator(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpr::Operator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpr::Operator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExprOperator() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpr::Operator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySymbolicExpr.h line 163
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpr { namespace Formatter {
    const char* ShowComments(int64_t i) {
        switch (i) {
            case 0L: return "CMT_SILENT";
            case 1L: return "CMT_AFTER";
            case 2L: return "CMT_INSTEAD";
            default: return "";
        }
    }

    std::string ShowComments(int64_t i, const std::string &strip) {
        std::string s = ShowComments(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpr::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowComments() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExprFormatterShowComments(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpr::Formatter::ShowComments(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpr::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpr::Formatter::ShowComments::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExprFormatterShowComments() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpr::Formatter::ShowComments();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySymbolicExpr.h line 183
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpr {
    const char* VisitAction(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE";
            case 1L: return "TRUNCATE";
            case 2L: return "TERMINATE";
            default: return "";
        }
    }

    std::string VisitAction(int64_t i, const std::string &strip) {
        std::string s = VisitAction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpr::VisitAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VisitAction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExprVisitAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpr::VisitAction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpr::VisitAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpr::VisitAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExprVisitAction() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpr::VisitAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinarySymbolicExpr.h line 216
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpr { namespace Type {
    const char* TypeClass(int64_t i) {
        switch (i) {
            case 0L: return "INTEGER";
            case 1L: return "FP";
            case 2L: return "MEMORY";
            case 3L: return "INVALID";
            default: return "";
        }
    }

    std::string TypeClass(int64_t i, const std::string &strip) {
        std::string s = TypeClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpr::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExprTypeTypeClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpr::Type::TypeClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpr::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpr::Type::TypeClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExprTypeTypeClass() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpr::Type::TypeClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 33
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SearchMode(int64_t i) {
        switch (i) {
            case 0L: return "SEARCH_SINGLE_DFS";
            case 1L: return "SEARCH_SINGLE_BFS";
            case 2L: return "SEARCH_MULTI";
            default: return "";
        }
    }

    std::string SearchMode(int64_t i, const std::string &strip) {
        std::string s = SearchMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SearchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSearchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SearchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSearchMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 46
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* EdgeVisitOrder(int64_t i) {
        switch (i) {
            case 0L: return "VISIT_NATURAL";
            case 1L: return "VISIT_REVERSE";
            case 2L: return "VISIT_RANDOM";
            default: return "";
        }
    }

    std::string EdgeVisitOrder(int64_t i, const std::string &strip) {
        std::string s = EdgeVisitOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeVisitOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 53
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* IoMode(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string IoMode(int64_t i, const std::string &strip) {
        std::string s = IoMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathIoMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::IoMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathIoMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 56
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* MayOrMust(int64_t i) {
        switch (i) {
            case 0L: return "MAY";
            case 1L: return "MUST";
            default: return "";
        }
    }

    std::string MayOrMust(int64_t i, const std::string &strip) {
        std::string s = MayOrMust(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayOrMust() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathMayOrMust(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::MayOrMust::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathMayOrMust() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/BinaryFeasiblePath.h line 156
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath { namespace PathProcessor {
    const char* Action(int64_t i) {
        switch (i) {
            case 0L: return "BREAK";
            case 1L: return "CONTINUE";
            default: return "";
        }
    }

    std::string Action(int64_t i, const std::string &strip) {
        std::string s = Action(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Action() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathPathProcessorAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathPathProcessorAction() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractMemoryObject/memory_object_impl.h line 84
namespace stringify { namespace AbstractMemoryObject { namespace IndexSet {
    const char* Index_type(int64_t i) {
        switch (i) {
            case 0L: return "Integer_type";
            case 1L: return "Unknown_type";
            default: return "";
        }
    }

    std::string Index_type(int64_t i, const std::string &strip) {
        std::string s = Index_type(i);
        if (s.empty())
            s = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Index_type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyAbstractMemoryObjectIndexSetIndex_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AbstractMemoryObject::IndexSet::Index_type(i);
        if (retval.empty()) {
            retval = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAbstractMemoryObjectIndexSetIndex_type() {
        return stringify::AbstractMemoryObject::IndexSet::Index_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h line 121
namespace stringify { namespace CGFunction { namespace iterator {
    const char* direction(int64_t i) {
        switch (i) {
            case 0L: return "fw";
            case 1L: return "bw";
            default: return "";
        }
    }

    std::string direction(int64_t i, const std::string &strip) {
        std::string s = direction(i);
        if (s.empty())
            s = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCGFunction_iterator_direction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CGFunction::iterator::direction(i);
        if (retval.empty()) {
            retval = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CGFunction::iterator::direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCGFunction_iterator_direction() {
        return stringify::CGFunction::iterator::direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h line 60
namespace stringify { namespace TaintLattice {
    const char* Vertex(int64_t i) {
        switch (i) {
            case 0L: return "VERTEX_BOTTOM";
            case 1L: return "VERTEX_UNTAINTED";
            case 2L: return "VERTEX_TAINTED";
            default: return "";
        }
    }

    std::string Vertex(int64_t i, const std::string &strip) {
        std::string s = Vertex(i);
        if (s.empty())
            s = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Vertex() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaintLatticeVertex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TaintLattice::Vertex(i);
        if (retval.empty()) {
            retval = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TaintLattice::Vertex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaintLatticeVertex() {
        return stringify::TaintLattice::Vertex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h line 42
namespace stringify { namespace ConstrGraph {
    const char* levels(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "bottom";
            case 2L: return "constrKnown";
            case 3L: return "top";
            default: return "";
        }
    }

    std::string levels(int64_t i, const std::string &strip) {
        std::string s = levels(i);
        if (s.empty())
            s = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& levels() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyConstrGraph_levels(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstrGraph::levels(i);
        if (retval.empty()) {
            retval = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstrGraph::levels::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstrGraph_levels() {
        return stringify::ConstrGraph::levels();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/PDG.h line 32
namespace stringify { namespace SDG { namespace PDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_PDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::PDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::PDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_PDGEdgeEdgeType() {
        return stringify::SDG::PDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 21
namespace stringify { namespace SDG { namespace SDGNode {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "Entry";
            case 1L: return "ASTNode";
            case 2L: return "FunctionCall";
            case 3L: return "ActualIn";
            case 4L: return "ActualOut";
            case 5L: return "FormalIn";
            case 6L: return "FormalOut";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGNodeNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGNode::NodeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGNode::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGNodeNodeType() {
        return stringify::SDG::SDGNode::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 48
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            case 2L: return "ParameterIn";
            case 3L: return "ParameterOut";
            case 4L: return "Call";
            case 5L: return "Summary";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeEdgeType() {
        return stringify::SDG::SDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 58
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* ControlDependenceType(int64_t i) {
        switch (i) {
            case 0L: return "cdTrue";
            case 1L: return "cdFalse";
            case 2L: return "cdCase";
            case 3L: return "cdDefault";
            default: return "";
        }
    }

    std::string ControlDependenceType(int64_t i, const std::string &strip) {
        std::string s = ControlDependenceType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ControlDependenceType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeControlDependenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::ControlDependenceType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeControlDependenceType() {
        return stringify::SDG::SDGEdge::ControlDependenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 31
namespace stringify { namespace PtrAliasAnalysis {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::COLOR(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisCOLOR() {
        return stringify::PtrAliasAnalysis::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 33
namespace stringify { namespace PtrAliasAnalysis {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "REVERSE_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisTRAVERSAL_TYPE() {
        return stringify::PtrAliasAnalysis::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 279
namespace stringify { namespace CollectAliasRelations {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::COLOR(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsCOLOR() {
        return stringify::CollectAliasRelations::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 280
namespace stringify { namespace CollectAliasRelations {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "NON_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsTRAVERSAL_TYPE() {
        return stringify::CollectAliasRelations::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h line 13
namespace stringify { namespace DominatorTreesAndDominanceFrontiers {
    const char* Dir_ection(int64_t i) {
        switch (i) {
            case 0L: return "PRE_DOMINATOR";
            case 1L: return "POST_DOMINATOR";
            default: return "";
        }
    }

    std::string Dir_ection(int64_t i, const std::string &strip) {
        std::string s = Dir_ection(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Dir_ection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDir_ection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::Dir_ection(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDir_ection() {
        return stringify::DominatorTreesAndDominanceFrontiers::Dir_ection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h line 73
namespace stringify { namespace CallGraph {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCallGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CallGraph::EdgeType(i);
        if (retval.empty()) {
            retval = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CallGraph::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallGraphEdgeType() {
        return stringify::CallGraph::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 163
namespace stringify {
    const char* IRProcType(int64_t i) {
        switch (i) {
            case 0L: return "ProcType_PGM";
            case 1L: return "ProcType_SUB";
            case 2L: return "ProcType_FUNC";
            case 3L: return "ProcType_BDATA";
            case 4L: return "ProcType_ILLEGAL";
            default: return "";
        }
    }

    std::string IRProcType(int64_t i, const std::string &strip) {
        std::string s = IRProcType(i);
        if (s.empty())
            s = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRProcType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRProcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRProcType(i);
        if (retval.empty()) {
            retval = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRProcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRProcType() {
        return stringify::IRProcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 173
namespace stringify {
    const char* IRStmtType(int64_t i) {
        switch (i) {
            case 0L: return "SIMPLE";
            case 1L: return "COMPOUND";
            case 2L: return "LOOP";
            case 3L: return "END_TESTED_LOOP";
            case 4L: return "STRUCT_TWOWAY_CONDITIONAL";
            case 5L: return "STRUCT_MULTIWAY_CONDITIONAL";
            case 6L: return "USTRUCT_TWOWAY_CONDITIONAL_T";
            case 7L: return "USTRUCT_TWOWAY_CONDITIONAL_F";
            case 8L: return "USTRUCT_MULTIWAY_CONDITIONAL";
            case 9L: return "RETURN";
            case 10L: return "BREAK";
            case 11L: return "LOOP_CONTINUE";
            case 12L: return "ALTERNATE_PROC_ENTRY";
            case 13L: return "UNCONDITIONAL_JUMP";
            case 14L: return "UNCONDITIONAL_JUMP_I";
            case 15L: return "NONE";
            default: return "";
        }
    }

    std::string IRStmtType(int64_t i, const std::string &strip) {
        std::string s = IRStmtType(i);
        if (s.empty())
            s = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRStmtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRStmtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRStmtType(i);
        if (retval.empty()) {
            retval = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRStmtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRStmtType() {
        return stringify::IRStmtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h line 261
namespace stringify { namespace BaseGraph { namespace BiDirNodesIterator {
    const char* dirType(int64_t i) {
        switch (i) {
            case 0L: return "Forward";
            case 1L: return "Reverse";
            default: return "";
        }
    }

    std::string dirType(int64_t i, const std::string &strip) {
        std::string s = dirType(i);
        if (s.empty())
            s = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& dirType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBaseGraphBiDirNodesIterator_dirType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BaseGraph::BiDirNodesIterator::dirType(i);
        if (retval.empty()) {
            retval = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBaseGraphBiDirNodesIterator_dirType() {
        return stringify::BaseGraph::BiDirNodesIterator::dirType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h line 83
namespace stringify { namespace CFG {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "TRUE_EDGE";
            case 1L: return "FALLTHROUGH_EDGE";
            case 2L: return "FALSE_EDGE";
            case 3L: return "BACK_EDGE";
            case 4L: return "MULTIWAY_EDGE";
            case 5L: return "BREAK_EDGE";
            case 6L: return "CONTINUE_EDGE";
            case 7L: return "RETURN_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCFG_EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CFG::EdgeType(i);
        if (retval.empty()) {
            retval = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CFG::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCFG_EdgeType() {
        return stringify::CFG::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 63
namespace stringify { namespace RIFG {
    const char* EdgeDirection(int64_t i) {
        switch (i) {
            case 0L: return "ED_INCOMING";
            case 1L: return "ED_OUTGOING";
            default: return "";
        }
    }

    std::string EdgeDirection(int64_t i, const std::string &strip) {
        std::string s = EdgeDirection(i);
        if (s.empty())
            s = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_EdgeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::EdgeDirection(i);
        if (retval.empty()) {
            retval = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::EdgeDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_EdgeDirection() {
        return stringify::RIFG::EdgeDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 64
namespace stringify { namespace RIFG {
    const char* ForwardBackward(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string ForwardBackward(int64_t i, const std::string &strip) {
        std::string s = ForwardBackward(i);
        if (s.empty())
            s = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ForwardBackward() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_ForwardBackward(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::ForwardBackward(i);
        if (retval.empty()) {
            retval = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::ForwardBackward::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_ForwardBackward() {
        return stringify::RIFG::ForwardBackward();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 65
namespace stringify {
    const char* RITarjType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NOTHING";
            case 1L: return "RI_TARJ_ACYCLIC";
            case 2L: return "RI_TARJ_INTERVAL";
            case 3L: return "RI_TARJ_IRREDUCIBLE";
            default: return "";
        }
    }

    std::string RITarjType(int64_t i, const std::string &strip) {
        std::string s = RITarjType(i);
        if (s.empty())
            s = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjType(i);
        if (retval.empty()) {
            retval = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjType() {
        return stringify::RITarjType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 67
namespace stringify {
    const char* RITarjEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NORMAL";
            case 1L: return "RI_TARJ_LOOP_ENTRY";
            case 2L: return "RI_TARJ_IRRED_ENTRY";
            case 3L: return "RI_TARJ_ITERATE";
            default: return "";
        }
    }

    std::string RITarjEdgeType(int64_t i, const std::string &strip) {
        std::string s = RITarjEdgeType(i);
        if (s.empty())
            s = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjEdgeType(i);
        if (retval.empty()) {
            retval = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjEdgeType() {
        return stringify::RITarjEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h line 50
namespace stringify { namespace DominatorTreesAndDominanceFrontiers { namespace DominatorTree {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection() {
        return stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/EditDistance/TreeEditDistance.h line 60
namespace stringify { namespace Rose { namespace EditDistance { namespace TreeEditDistance {
    const char* EditType(int64_t i) {
        switch (i) {
            case 0L: return "INSERT";
            case 1L: return "DELETE";
            case 2L: return "SUBSTITUTE";
            default: return "";
        }
    }

    std::string EditType(int64_t i, const std::string &strip) {
        std::string s = EditType(i);
        if (s.empty())
            s = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyEditDistanceTreeEditDistanceEditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::EditDistance::TreeEditDistance::EditType(i);
        if (retval.empty()) {
            retval = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::EditDistance::TreeEditDistance::EditType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEditDistanceTreeEditDistanceEditType() {
        return stringify::Rose::EditDistance::TreeEditDistance::EditType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h line 19
namespace stringify { namespace ssa_unfiltered_cfg { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            case 3L: return "EXTERNAL_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_ssa_unfiltered_cfgReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ssa_unfiltered_cfg::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ssa_unfiltered_cfgReachingDefType() {
        return stringify::ssa_unfiltered_cfg::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/staticSingleAssignment/reachingDef.h line 18
namespace stringify { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReachingDefType() {
        return stringify::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 25
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* running_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_analysis_and_instrument";
            case 1L: return "e_static_counting";
            default: return "";
        }
    }

    std::string running_mode_enum(int64_t i, const std::string &strip) {
        std::string s = running_mode_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& running_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_running_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::running_mode_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::running_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_running_mode_enum() {
        return stringify::ArithmeticIntensityMeasurement::running_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 30
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* fp_operation_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_total";
            case 2L: return "e_plus";
            case 3L: return "e_minus";
            case 4L: return "e_multiply";
            case 5L: return "e_divide";
            default: return "";
        }
    }

    std::string fp_operation_kind_enum(int64_t i, const std::string &strip) {
        std::string s = fp_operation_kind_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fp_operation_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::fp_operation_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum() {
        return stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 319
namespace stringify { namespace Rose { namespace Snippet {
    const char* InsertMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BODY";
            case 1L: return "INSERT_STMTS";
            default: return "";
        }
    }

    std::string InsertMechanism(int64_t i, const std::string &strip) {
        std::string s = InsertMechanism(i);
        if (s.empty())
            s = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetInsertMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::InsertMechanism(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::InsertMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetInsertMechanism() {
        return stringify::Rose::Snippet::InsertMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 329
namespace stringify { namespace Rose { namespace Snippet {
    const char* LocalDeclarationPosition(int64_t i) {
        switch (i) {
            case 0L: return "LOCDECLS_AT_BEGINNING";
            case 1L: return "LOCDECLS_AT_END";
            case 2L: return "LOCDECLS_AT_CURSOR";
            default: return "";
        }
    }

    std::string LocalDeclarationPosition(int64_t i, const std::string &strip) {
        std::string s = LocalDeclarationPosition(i);
        if (s.empty())
            s = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LocalDeclarationPosition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetLocalDeclarationPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::LocalDeclarationPosition(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::LocalDeclarationPosition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetLocalDeclarationPosition() {
        return stringify::Rose::Snippet::LocalDeclarationPosition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 42
namespace stringify { namespace MatchStatus {
    const char* PatternMatchMode(int64_t i) {
        switch (i) {
            case 0L: return "MATCHMODE_SHALLOW";
            case 1L: return "MATCHMODE_DEEP";
            case 2L: return "MATCHMODE_SINGLE";
            default: return "";
        }
    }

    std::string PatternMatchMode(int64_t i, const std::string &strip) {
        std::string s = PatternMatchMode(i);
        if (s.empty())
            s = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternMatchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusPatternMatchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::PatternMatchMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::PatternMatchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusPatternMatchMode() {
        return stringify::MatchStatus::PatternMatchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 43
namespace stringify { namespace MatchStatus {
    const char* CheckNodeMode(int64_t i) {
        switch (i) {
            case 0L: return "NODECHECKMODE_TYPEID";
            case 1L: return "NODECHECKMODE_VARIANT";
            default: return "";
        }
    }

    std::string CheckNodeMode(int64_t i, const std::string &strip) {
        std::string s = CheckNodeMode(i);
        if (s.empty())
            s = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CheckNodeMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusCheckNodeMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::CheckNodeMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::CheckNodeMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusCheckNodeMode() {
        return stringify::MatchStatus::CheckNodeMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/matcherparser.C line 1846
namespace stringify {
    const char* yytokentype(int64_t i) {
        switch (i) {
            case 258L: return "ALTERNATION";
            case 259L: return "NOT";
            case 260L: return "AND";
            case 261L: return "XOR";
            case 262L: return "OR";
            case 263L: return "NEQ";
            case 264L: return "EQ";
            case 265L: return "C_NEQ";
            case 266L: return "C_EQ";
            case 267L: return "WHERE";
            case 268L: return "TRUE";
            case 269L: return "FALSE";
            case 270L: return "IDENT";
            case 271L: return "VARIABLE";
            case 272L: return "INTEGER";
            case 273L: return "SQ_STRING";
            case 274L: return "NULL_NODE";
            case 275L: return "DOTDOT";
            default: return "";
        }
    }

    std::string yytokentype(int64_t i, const std::string &strip) {
        std::string s = yytokentype(i);
        if (s.empty())
            s = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& yytokentype() {
        static const int64_t values[] = {
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_yytokentype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::yytokentype(i);
        if (retval.empty()) {
            retval = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "yytokentype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_yytokentype() {
        return stringify::yytokentype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C line 17
namespace stringify {
    const char* defaultEnumFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_constructor";
            case 2L: return "e_destructor";
            case 3L: return "e_copy_constructor";
            case 4L: return "e_assignment_operator";
            case 5L: return "e_last_type";
            default: return "";
        }
    }

    std::string defaultEnumFunctionType(int64_t i, const std::string &strip) {
        std::string s = defaultEnumFunctionType(i);
        if (s.empty())
            s = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& defaultEnumFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_defaultEnumFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::defaultEnumFunctionType(i);
        if (retval.empty()) {
            retval = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "defaultEnumFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_defaultEnumFunctionType() {
        return stringify::defaultEnumFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_lowering.h line 37
namespace stringify { namespace OmpSupport {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gomp";
            case 1L: return "e_omni";
            case 2L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_rtl_enum() {
        return stringify::OmpSupport::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/xomp.c line 60
namespace stringify {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_undefined";
            case 1L: return "e_gomp";
            case 2L: return "e_omni";
            case 3L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_rtl_enum() {
        return stringify::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h line 40
namespace stringify { namespace FunctionCallInfo {
    const char* InsertionMode(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BEFORE";
            case 1L: return "APPEND_SCOPE";
            case 2L: return "INVALID";
            default: return "";
        }
    }

    std::string InsertionMode(int64_t i, const std::string &strip) {
        std::string s = InsertionMode(i);
        if (s.empty())
            s = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertionMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFunctionCallInfoInsertionMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FunctionCallInfo::InsertionMode(i);
        if (retval.empty()) {
            retval = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FunctionCallInfo::InsertionMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFunctionCallInfoInsertionMode() {
        return stringify::FunctionCallInfo::InsertionMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 133
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclarations";
            case 2L: return "VariableTypes";
            case 3L: return "FunctionDeclarations";
            case 4L: return "MemberFunctionDeclarations";
            case 5L: return "ClassDeclarations";
            case 6L: return "StructDeclarations";
            case 7L: return "UnionDeclarations";
            case 8L: return "Arguments";
            case 9L: return "ClassFields";
            case 10L: return "StructFields";
            case 11L: return "UnionFields";
            case 12L: return "StructDefinitions";
            case 13L: return "TypedefDeclarations";
            case 14L: return "AnonymousTypedefs";
            case 15L: return "AnonymousTypedefClassDeclarations";
            case 16L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeOneParameter() {
        return stringify::NodeQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 154
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "FunctionDeclarationFromDefinition";
            case 2L: return "ClassDeclarationFromName";
            case 3L: return "ClassDeclarationsFromTypeName";
            case 4L: return "PragmaDeclarationFromName";
            case 5L: return "VariableDeclarationFromName";
            case 6L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NodeQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 74
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableNames";
            case 2L: return "VariableTypeNames";
            case 3L: return "FunctionDeclarationNames";
            case 4L: return "MemberFunctionDeclarationNames";
            case 5L: return "ClassDeclarationNames";
            case 6L: return "ArgumentNames";
            case 7L: return "ClassFieldNames";
            case 8L: return "UnionFieldNames";
            case 9L: return "StructFieldNames";
            case 10L: return "FunctionReferenceNames";
            case 11L: return "StructNames";
            case 12L: return "UnionNames";
            case 13L: return "TypedefDeclarationNames";
            case 14L: return "TypeNames";
            case 15L: return "END_OF_NAME_TYPE_LIST";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeOneParameter() {
        return stringify::NameQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 94
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "VariableNamesWithTypeName";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NameQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 10
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "NumberOfArgsInConstructor";
            case 2L: return "NumberOfOperands";
            case 3L: return "NumberOfArgsInScalarIndexingOperator";
            case 4L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeOneParameter() {
        return stringify::NumberQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 19
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "NumberOfArgsInParanthesisOperator";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NumberQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/booleanQuery.h line 43
namespace stringify { namespace BooleanQuery {
    const char* TypeOfQueryType(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclaration";
            case 2L: return "Type";
            case 3L: return "FunctionDeclaration";
            case 4L: return "MemberFunctionDeclaration";
            case 5L: return "ClassDeclaration";
            case 6L: return "Argument";
            case 7L: return "Field";
            case 8L: return "UnionedField";
            case 9L: return "Struct";
            case 10L: return "ContainedInSubtreeOfType";
            case 11L: return "END_OF_BOOLEAN_QUERY_TYPE";
            default: return "";
        }
    }

    std::string TypeOfQueryType(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryType(i);
        if (s.empty())
            s = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyBooleanQueryTypeOfQueryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BooleanQuery::TypeOfQueryType(i);
        if (retval.empty()) {
            retval = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BooleanQuery::TypeOfQueryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBooleanQueryTypeOfQueryType() {
        return stringify::BooleanQuery::TypeOfQueryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/astQuery.h line 96
namespace stringify { namespace AstQueryNamespace {
    const char* QueryDepth(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeQueryDepth";
            case 1L: return "ChildrenOnly";
            case 2L: return "AllNodes";
            case 3L: return "ExtractTypes";
            case 4L: return "END_OF_NODE_TYPE_LIST_QUERY_DEPTH";
            default: return "";
        }
    }

    std::string QueryDepth(int64_t i, const std::string &strip) {
        std::string s = QueryDepth(i);
        if (s.empty())
            s = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QueryDepth() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstQueryNamespaceQueryDepth(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstQueryNamespace::QueryDepth(i);
        if (retval.empty()) {
            retval = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstQueryNamespace::QueryDepth::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstQueryNamespaceQueryDepth() {
        return stringify::AstQueryNamespace::QueryDepth();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRButtons.h line 29
namespace stringify { namespace qrs { namespace QRButtons {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "Toggle";
            case 2L: return "Check";
            case 3L: return "Radio";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRButtonsType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRButtons::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRButtons::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRButtonsType() {
        return stringify::qrs::QRButtons::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRSelect.h line 26
namespace stringify { namespace qrs { namespace QRSelect {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Combo";
            case 1L: return "Box";
            case 2L: return "Check";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSelectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSelect::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSelect::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSelectType() {
        return stringify::qrs::QRSelect::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QREdit.h line 28
namespace stringify { namespace qrs { namespace QREdit {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Line";
            case 1L: return "Box";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQREditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QREdit::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QREdit::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQREditType() {
        return stringify::qrs::QREdit::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 40
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbHighlight";
            case 6L: return "tbLookup";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBoxToolbarIdx() {
        return stringify::qrs::QRTreeBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 107
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* popmenu_nodes_id(int64_t i) {
        switch (i) {
            case 0L: return "pm_set_root";
            case 1L: return "pm_set_default_root";
            case 2L: return "pm_remove";
            case 3L: return "pm_expand";
            case 4L: return "pm_collapse";
            case 5L: return "pm_expand_code";
            default: return "";
        }
    }

    std::string popmenu_nodes_id(int64_t i, const std::string &strip) {
        std::string s = popmenu_nodes_id(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& popmenu_nodes_id() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBox_popmenu_nodes_id(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::popmenu_nodes_id(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::popmenu_nodes_id::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBox_popmenu_nodes_id() {
        return stringify::qrs::QRTreeBox::popmenu_nodes_id();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/QRSourceBox.h line 39
namespace stringify { namespace qrs { namespace QRSourceBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbGoto";
            case 6L: return "tbLookup";
            case 7L: return "tbZoomIn";
            case 8L: return "tbZoomOut";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSourceBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSourceBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSourceBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSourceBoxToolbarIdx() {
        return stringify::qrs::QRSourceBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 37
namespace stringify { namespace qrs { namespace Paren {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Open";
            case 1L: return "Closed";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Paren::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Paren::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenType() {
        return stringify::qrs::Paren::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 48
namespace stringify { namespace qrs { namespace ParenMatcher {
    const char* Selection(int64_t i) {
        switch (i) {
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Selection(int64_t i, const std::string &strip) {
        std::string s = Selection(i);
        if (s.empty())
            s = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Selection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenMatcherSelection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::ParenMatcher::Selection(i);
        if (retval.empty()) {
            retval = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::ParenMatcher::Selection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenMatcherSelection() {
        return stringify::qrs::ParenMatcher::Selection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 122
namespace stringify { namespace qrs { namespace Q3TextStringChar {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Regular";
            case 1L: return "Custom";
            case 2L: return "Anchor";
            case 3L: return "CustomAnchor";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextStringCharType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextStringChar::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextStringChar::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextStringCharType() {
        return stringify::qrs::Q3TextStringChar::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 366
namespace stringify { namespace qrs { namespace Q3TextCursor {
    const char* Operation(int64_t i) {
        switch (i) {
            case 0L: return "EnterBegin";
            case 1L: return "EnterEnd";
            case 2L: return "Next";
            case 3L: return "Prev";
            case 4L: return "Up";
            case 5L: return "Down";
            default: return "";
        }
    }

    std::string Operation(int64_t i, const std::string &strip) {
        std::string s = Operation(i);
        if (s.empty())
            s = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCursorOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCursor::Operation(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCursor::Operation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCursorOperation() {
        return stringify::qrs::Q3TextCursor::Operation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 390
namespace stringify { namespace qrs { namespace Q3TextCommand {
    const char* Commands(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Insert";
            case 2L: return "Delete";
            case 3L: return "Format";
            case 4L: return "Style";
            default: return "";
        }
    }

    std::string Commands(int64_t i, const std::string &strip) {
        std::string s = Commands(i);
        if (s.empty())
            s = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Commands() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCommandCommands(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCommand::Commands(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCommand::Commands::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCommandCommands() {
        return stringify::qrs::Q3TextCommand::Commands();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 451
namespace stringify { namespace qrs { namespace Q3TextCustomItem {
    const char* Placement(int64_t i) {
        switch (i) {
            case 0L: return "PlaceInline";
            case 1L: return "PlaceLeft";
            case 2L: return "PlaceRight";
            default: return "";
        }
    }

    std::string Placement(int64_t i, const std::string &strip) {
        std::string s = Placement(i);
        if (s.empty())
            s = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Placement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCustomItemPlacement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCustomItem::Placement(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCustomItem::Placement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCustomItemPlacement() {
        return stringify::qrs::Q3TextCustomItem::Placement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 724
namespace stringify { namespace qrs { namespace Q3TextDocument {
    const char* SelectionIds(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            case 32000L: return "Temp";
            default: return "";
        }
    }

    std::string SelectionIds(int64_t i, const std::string &strip) {
        std::string s = SelectionIds(i);
        if (s.empty())
            s = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionIds() {
        static const int64_t values[] = {
            0L,
            32000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextDocumentSelectionIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextDocument::SelectionIds(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextDocument::SelectionIds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextDocumentSelectionIds() {
        return stringify::qrs::Q3TextDocument::SelectionIds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1380
namespace stringify { namespace qrs { namespace Q3TextPreProcessor {
    const char* Ids(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            default: return "";
        }
    }

    std::string Ids(int64_t i, const std::string &strip) {
        std::string s = Ids(i);
        if (s.empty())
            s = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ids() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextPreProcessorIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextPreProcessor::Ids(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextPreProcessor::Ids::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextPreProcessorIds() {
        return stringify::qrs::Q3TextPreProcessor::Ids();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1400
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* Flags(int64_t i) {
        switch (i) {
            case 0L: return "NoFlags";
            case 1L: return "Bold";
            case 2L: return "Italic";
            case 4L: return "Underline";
            case 8L: return "Family";
            case 16L: return "Size";
            case 32L: return "Color";
            case 64L: return "Misspelled";
            case 128L: return "VAlign";
            case 256L: return "StrikeOut";
            case 287L: return "Font";
            case 511L: return "Format";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            287L,
            511L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::Flags(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatFlags() {
        return stringify::qrs::Q3TextFormat::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1415
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* VerticalAlignment(int64_t i) {
        switch (i) {
            case 0L: return "AlignNormal";
            case 1L: return "AlignSuperScript";
            case 2L: return "AlignSubScript";
            default: return "";
        }
    }

    std::string VerticalAlignment(int64_t i, const std::string &strip) {
        std::string s = VerticalAlignment(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VerticalAlignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatVerticalAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::VerticalAlignment(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::VerticalAlignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatVerticalAlignment() {
        return stringify::qrs::Q3TextFormat::VerticalAlignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/paragdata.h line 36
namespace stringify { namespace qrs { namespace Symbol {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Left";
            case 1L: return "Right";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Symbol::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Symbol::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsSymbolType() {
        return stringify::qrs::Symbol::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qeditor.h line 65
namespace stringify { namespace qrs { namespace QEditor {
    const char* TypeSel(int64_t i) {
        switch (i) {
            case 1000L: return "sel0";
            case 2000L: return "sel1";
            default: return "";
        }
    }

    std::string TypeSel(int64_t i, const std::string &strip) {
        std::string s = TypeSel(i);
        if (s.empty())
            s = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeSel() {
        static const int64_t values[] = {
            1000L,
            2000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQEditorTypeSel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QEditor::TypeSel(i);
        if (retval.empty()) {
            retval = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QEditor::TypeSel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQEditorTypeSel() {
        return stringify::qrs::QEditor::TypeSel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qsourcecolorizer.h line 257
namespace stringify { namespace qrs { namespace QSourceColorizer {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "PreProcessor";
            case 2L: return "Keyword";
            case 3L: return "BuiltInClass";
            case 4L: return "Operator";
            case 5L: return "Comment";
            case 6L: return "Constant";
            case 7L: return "String";
            case 1000L: return "Custom";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1000L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQSourceColorizerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QSourceColorizer::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QSourceColorizer::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQSourceColorizerType() {
        return stringify::qrs::QSourceColorizer::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_fontdef.h line 63
namespace stringify {
    const char* _HPDF_FontDefType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FONTDEF_TYPE_TYPE1";
            case 1L: return "HPDF_FONTDEF_TYPE_TRUETYPE";
            case 2L: return "HPDF_FONTDEF_TYPE_CID";
            case 3L: return "HPDF_FONTDEF_TYPE_UNINITIALIZED";
            case 4L: return "HPDF_FONTDEF_TYPE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_FontDefType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_FontDefType(i);
        if (s.empty())
            s = "(_HPDF_FontDefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_FontDefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_FontDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_FontDefType(i);
        if (retval.empty()) {
            retval = "(_HPDF_FontDefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_FontDefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_FontDefType() {
        return stringify::_HPDF_FontDefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_streams.h line 33
namespace stringify {
    const char* _HPDF_StreamType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_STREAM_UNKNOWN";
            case 1L: return "HPDF_STREAM_CALLBACK";
            case 2L: return "HPDF_STREAM_FILE";
            case 3L: return "HPDF_STREAM_MEMORY";
            default: return "";
        }
    }

    std::string _HPDF_StreamType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_StreamType(i);
        if (s.empty())
            s = "(_HPDF_StreamType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_StreamType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_StreamType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_StreamType(i);
        if (retval.empty()) {
            retval = "(_HPDF_StreamType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_StreamType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_StreamType() {
        return stringify::_HPDF_StreamType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_streams.h line 46
namespace stringify {
    const char* _HPDF_WhenceMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_SEEK_SET";
            case 1L: return "HPDF_SEEK_CUR";
            case 2L: return "HPDF_SEEK_END";
            default: return "";
        }
    }

    std::string _HPDF_WhenceMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_WhenceMode(i);
        if (s.empty())
            s = "(_HPDF_WhenceMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_WhenceMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_WhenceMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_WhenceMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_WhenceMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_WhenceMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_WhenceMode() {
        return stringify::_HPDF_WhenceMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 128
namespace stringify {
    const char* _HPDF_InfoType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_INFO_CREATION_DATE";
            case 1L: return "HPDF_INFO_MOD_DATE";
            case 2L: return "HPDF_INFO_AUTHOR";
            case 3L: return "HPDF_INFO_CREATOR";
            case 4L: return "HPDF_INFO_PRODUCER";
            case 5L: return "HPDF_INFO_TITLE";
            case 6L: return "HPDF_INFO_SUBJECT";
            case 7L: return "HPDF_INFO_KEYWORDS";
            case 8L: return "HPDF_INFO_EOF";
            default: return "";
        }
    }

    std::string _HPDF_InfoType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_InfoType(i);
        if (s.empty())
            s = "(_HPDF_InfoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_InfoType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_InfoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_InfoType(i);
        if (retval.empty()) {
            retval = "(_HPDF_InfoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_InfoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_InfoType() {
        return stringify::_HPDF_InfoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 144
namespace stringify {
    const char* _HPDF_PdfVer(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_VER_12";
            case 1L: return "HPDF_VER_13";
            case 2L: return "HPDF_VER_14";
            case 3L: return "HPDF_VER_15";
            case 4L: return "HPDF_VER_16";
            case 5L: return "HPDF_VER_17";
            case 6L: return "HPDF_VER_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PdfVer(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PdfVer(i);
        if (s.empty())
            s = "(_HPDF_PdfVer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PdfVer() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PdfVer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PdfVer(i);
        if (retval.empty()) {
            retval = "(_HPDF_PdfVer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PdfVer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PdfVer() {
        return stringify::_HPDF_PdfVer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 154
namespace stringify {
    const char* _HPDF_EncryptMode(int64_t i) {
        switch (i) {
            case 2L: return "HPDF_ENCRYPT_R2";
            case 3L: return "HPDF_ENCRYPT_R3";
            default: return "";
        }
    }

    std::string _HPDF_EncryptMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncryptMode(i);
        if (s.empty())
            s = "(_HPDF_EncryptMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncryptMode() {
        static const int64_t values[] = {
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncryptMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncryptMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncryptMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncryptMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncryptMode() {
        return stringify::_HPDF_EncryptMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 213
namespace stringify {
    const char* _HPDF_ColorSpace(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_CS_DEVICE_GRAY";
            case 1L: return "HPDF_CS_DEVICE_RGB";
            case 2L: return "HPDF_CS_DEVICE_CMYK";
            case 3L: return "HPDF_CS_CAL_GRAY";
            case 4L: return "HPDF_CS_CAL_RGB";
            case 5L: return "HPDF_CS_LAB";
            case 6L: return "HPDF_CS_ICC_BASED";
            case 7L: return "HPDF_CS_SEPARATION";
            case 8L: return "HPDF_CS_DEVICE_N";
            case 9L: return "HPDF_CS_INDEXED";
            case 10L: return "HPDF_CS_PATTERN";
            case 11L: return "HPDF_CS_EOF";
            default: return "";
        }
    }

    std::string _HPDF_ColorSpace(int64_t i, const std::string &strip) {
        std::string s = _HPDF_ColorSpace(i);
        if (s.empty())
            s = "(_HPDF_ColorSpace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_ColorSpace() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_ColorSpace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_ColorSpace(i);
        if (retval.empty()) {
            retval = "(_HPDF_ColorSpace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_ColorSpace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_ColorSpace() {
        return stringify::_HPDF_ColorSpace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 250
namespace stringify {
    const char* _HPDF_LineCap(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BUTT_END";
            case 1L: return "HPDF_ROUND_END";
            case 2L: return "HPDF_PROJECTING_SCUARE_END";
            case 3L: return "HPDF_LINECAP_EOF";
            default: return "";
        }
    }

    std::string _HPDF_LineCap(int64_t i, const std::string &strip) {
        std::string s = _HPDF_LineCap(i);
        if (s.empty())
            s = "(_HPDF_LineCap)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_LineCap() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_LineCap(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_LineCap(i);
        if (retval.empty()) {
            retval = "(_HPDF_LineCap)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_LineCap::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_LineCap() {
        return stringify::_HPDF_LineCap();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 260
namespace stringify {
    const char* _HPDF_LineJoin(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_MITER_JOIN";
            case 1L: return "HPDF_ROUND_JOIN";
            case 2L: return "HPDF_BEVEL_JOIN";
            case 3L: return "HPDF_LINEJOIN_EOF";
            default: return "";
        }
    }

    std::string _HPDF_LineJoin(int64_t i, const std::string &strip) {
        std::string s = _HPDF_LineJoin(i);
        if (s.empty())
            s = "(_HPDF_LineJoin)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_LineJoin() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_LineJoin(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_LineJoin(i);
        if (retval.empty()) {
            retval = "(_HPDF_LineJoin)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_LineJoin::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_LineJoin() {
        return stringify::_HPDF_LineJoin();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 270
namespace stringify {
    const char* _HPDF_TextRenderingMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FILL";
            case 1L: return "HPDF_STROKE";
            case 2L: return "HPDF_FILL_THEN_STROKE";
            case 3L: return "HPDF_INVISIBLE";
            case 4L: return "HPDF_FILL_CLIPPING";
            case 5L: return "HPDF_STROKE_CLIPPING";
            case 6L: return "HPDF_FILL_STROKE_CLIPPING";
            case 7L: return "HPDF_CLIPPING";
            case 8L: return "HPDF_RENDERING_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_TextRenderingMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TextRenderingMode(i);
        if (s.empty())
            s = "(_HPDF_TextRenderingMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TextRenderingMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TextRenderingMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TextRenderingMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_TextRenderingMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TextRenderingMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TextRenderingMode() {
        return stringify::_HPDF_TextRenderingMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 283
namespace stringify {
    const char* _HPDF_WritingMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_WMODE_HORIZONTAL";
            case 1L: return "HPDF_WMODE_VERTICAL";
            case 2L: return "HPDF_WMODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_WritingMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_WritingMode(i);
        if (s.empty())
            s = "(_HPDF_WritingMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_WritingMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_WritingMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_WritingMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_WritingMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_WritingMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_WritingMode() {
        return stringify::_HPDF_WritingMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 290
namespace stringify {
    const char* _HPDF_PageLayout(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_LAYOUT_SINGLE";
            case 1L: return "HPDF_PAGE_LAYOUT_ONE_COLUMN";
            case 2L: return "HPDF_PAGE_LAYOUT_TWO_COLUMN_LEFT";
            case 3L: return "HPDF_PAGE_LAYOUT_TWO_COLUMN_RIGHT";
            case 4L: return "HPDF_PAGE_LAYOUT_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageLayout(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageLayout(i);
        if (s.empty())
            s = "(_HPDF_PageLayout)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageLayout() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageLayout(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageLayout(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageLayout)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageLayout::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageLayout() {
        return stringify::_HPDF_PageLayout();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 299
namespace stringify {
    const char* _HPDF_PageMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_MODE_USE_NONE";
            case 1L: return "HPDF_PAGE_MODE_USE_OUTLINE";
            case 2L: return "HPDF_PAGE_MODE_USE_THUMBS";
            case 3L: return "HPDF_PAGE_MODE_FULL_SCREEN";
            case 4L: return "HPDF_PAGE_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageMode(i);
        if (s.empty())
            s = "(_HPDF_PageMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageMode() {
        return stringify::_HPDF_PageMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 311
namespace stringify {
    const char* _HPDF_PageNumStyle(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_NUM_STYLE_DECIMAL";
            case 1L: return "HPDF_PAGE_NUM_STYLE_UPPER_ROMAN";
            case 2L: return "HPDF_PAGE_NUM_STYLE_LOWER_ROMAN";
            case 3L: return "HPDF_PAGE_NUM_STYLE_UPPER_LETTERS";
            case 4L: return "HPDF_PAGE_NUM_STYLE_LOWER_LETTERS";
            case 5L: return "HPDF_PAGE_NUM_STYLE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageNumStyle(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageNumStyle(i);
        if (s.empty())
            s = "(_HPDF_PageNumStyle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageNumStyle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageNumStyle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageNumStyle(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageNumStyle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageNumStyle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageNumStyle() {
        return stringify::_HPDF_PageNumStyle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 321
namespace stringify {
    const char* _HPDF_DestinationType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_XYZ";
            case 1L: return "HPDF_FIT";
            case 2L: return "HPDF_FIT_H";
            case 3L: return "HPDF_FIT_V";
            case 4L: return "HPDF_FIT_R";
            case 5L: return "HPDF_FIT_B";
            case 6L: return "HPDF_FIT_BH";
            case 7L: return "HPDF_FIT_BV";
            case 8L: return "HPDF_DST_EOF";
            default: return "";
        }
    }

    std::string _HPDF_DestinationType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_DestinationType(i);
        if (s.empty())
            s = "(_HPDF_DestinationType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_DestinationType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_DestinationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_DestinationType(i);
        if (retval.empty()) {
            retval = "(_HPDF_DestinationType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_DestinationType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_DestinationType() {
        return stringify::_HPDF_DestinationType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 334
namespace stringify {
    const char* _HPDF_AnnotType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_TEXT_NOTES";
            case 1L: return "HPDF_ANNOT_LINK";
            case 2L: return "HPDF_ANNOT_SOUND";
            case 3L: return "HPDF_ANNOT_FREE_TEXT";
            case 4L: return "HPDF_ANNOT_STAMP";
            case 5L: return "HPDF_ANNOT_SQUARE";
            case 6L: return "HPDF_ANNOT_CIRCLE";
            case 7L: return "HPDF_ANNOT_STRIKE_OUT";
            case 8L: return "HPDF_ANNOT_HIGHTLIGHT";
            case 9L: return "HPDF_ANNOT_UNDERLINE";
            case 10L: return "HPDF_ANNOT_INK";
            case 11L: return "HPDF_ANNOT_FILE_ATTACHMENT";
            case 12L: return "HPDF_ANNOT_POPUP";
            case 13L: return "HPDF_ANNOT_3D";
            default: return "";
        }
    }

    std::string _HPDF_AnnotType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotType(i);
        if (s.empty())
            s = "(_HPDF_AnnotType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotType(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotType() {
        return stringify::_HPDF_AnnotType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 352
namespace stringify {
    const char* _HPDF_AnnotFlgs(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_INVISIBLE";
            case 1L: return "HPDF_ANNOT_HIDDEN";
            case 2L: return "HPDF_ANNOT_PRINT";
            case 3L: return "HPDF_ANNOT_NOZOOM";
            case 4L: return "HPDF_ANNOT_NOROTATE";
            case 5L: return "HPDF_ANNOT_NOVIEW";
            case 6L: return "HPDF_ANNOT_READONLY";
            default: return "";
        }
    }

    std::string _HPDF_AnnotFlgs(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotFlgs(i);
        if (s.empty())
            s = "(_HPDF_AnnotFlgs)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotFlgs() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotFlgs(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotFlgs(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotFlgs)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotFlgs::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotFlgs() {
        return stringify::_HPDF_AnnotFlgs();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 363
namespace stringify {
    const char* _HPDF_AnnotHighlightMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_NO_HIGHTLIGHT";
            case 1L: return "HPDF_ANNOT_INVERT_BOX";
            case 2L: return "HPDF_ANNOT_INVERT_BORDER";
            case 3L: return "HPDF_ANNOT_DOWN_APPEARANCE";
            case 4L: return "HPDF_ANNOT_HIGHTLIGHT_MODE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_AnnotHighlightMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotHighlightMode(i);
        if (s.empty())
            s = "(_HPDF_AnnotHighlightMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotHighlightMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotHighlightMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotHighlightMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotHighlightMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotHighlightMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotHighlightMode() {
        return stringify::_HPDF_AnnotHighlightMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 372
namespace stringify {
    const char* _HPDF_AnnotIcon(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ANNOT_ICON_COMMENT";
            case 1L: return "HPDF_ANNOT_ICON_KEY";
            case 2L: return "HPDF_ANNOT_ICON_NOTE";
            case 3L: return "HPDF_ANNOT_ICON_HELP";
            case 4L: return "HPDF_ANNOT_ICON_NEW_PARAGRAPH";
            case 5L: return "HPDF_ANNOT_ICON_PARAGRAPH";
            case 6L: return "HPDF_ANNOT_ICON_INSERT";
            case 7L: return "HPDF_ANNOT_ICON_EOF";
            default: return "";
        }
    }

    std::string _HPDF_AnnotIcon(int64_t i, const std::string &strip) {
        std::string s = _HPDF_AnnotIcon(i);
        if (s.empty())
            s = "(_HPDF_AnnotIcon)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_AnnotIcon() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_AnnotIcon(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_AnnotIcon(i);
        if (retval.empty()) {
            retval = "(_HPDF_AnnotIcon)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_AnnotIcon::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_AnnotIcon() {
        return stringify::_HPDF_AnnotIcon();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 388
namespace stringify {
    const char* _HPDF_BSSubtype(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BS_SOLID";
            case 1L: return "HPDF_BS_DASHED";
            case 2L: return "HPDF_BS_BEVELED";
            case 3L: return "HPDF_BS_INSET";
            case 4L: return "HPDF_BS_UNDERLINED";
            default: return "";
        }
    }

    std::string _HPDF_BSSubtype(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BSSubtype(i);
        if (s.empty())
            s = "(_HPDF_BSSubtype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BSSubtype() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BSSubtype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BSSubtype(i);
        if (retval.empty()) {
            retval = "(_HPDF_BSSubtype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BSSubtype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BSSubtype() {
        return stringify::_HPDF_BSSubtype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 399
namespace stringify {
    const char* _HPDF_BlendMode(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BM_NORMAL";
            case 1L: return "HPDF_BM_MULTIPLY";
            case 2L: return "HPDF_BM_SCREEN";
            case 3L: return "HPDF_BM_OVERLAY";
            case 4L: return "HPDF_BM_DARKEN";
            case 5L: return "HPDF_BM_LIGHTEN";
            case 6L: return "HPDF_BM_COLOR_DODGE";
            case 7L: return "HPDF_BM_COLOR_BUM";
            case 8L: return "HPDF_BM_HARD_LIGHT";
            case 9L: return "HPDF_BM_SOFT_LIGHT";
            case 10L: return "HPDF_BM_DIFFERENCE";
            case 11L: return "HPDF_BM_EXCLUSHON";
            case 12L: return "HPDF_BM_EOF";
            default: return "";
        }
    }

    std::string _HPDF_BlendMode(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BlendMode(i);
        if (s.empty())
            s = "(_HPDF_BlendMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BlendMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BlendMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BlendMode(i);
        if (retval.empty()) {
            retval = "(_HPDF_BlendMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BlendMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BlendMode() {
        return stringify::_HPDF_BlendMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 417
namespace stringify {
    const char* _HPDF_TransitionStyle(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_TS_WIPE_RIGHT";
            case 1L: return "HPDF_TS_WIPE_UP";
            case 2L: return "HPDF_TS_WIPE_LEFT";
            case 3L: return "HPDF_TS_WIPE_DOWN";
            case 4L: return "HPDF_TS_BARN_DOORS_HORIZONTAL_OUT";
            case 5L: return "HPDF_TS_BARN_DOORS_HORIZONTAL_IN";
            case 6L: return "HPDF_TS_BARN_DOORS_VERTICAL_OUT";
            case 7L: return "HPDF_TS_BARN_DOORS_VERTICAL_IN";
            case 8L: return "HPDF_TS_BOX_OUT";
            case 9L: return "HPDF_TS_BOX_IN";
            case 10L: return "HPDF_TS_BLINDS_HORIZONTAL";
            case 11L: return "HPDF_TS_BLINDS_VERTICAL";
            case 12L: return "HPDF_TS_DISSOLVE";
            case 13L: return "HPDF_TS_GLITTER_RIGHT";
            case 14L: return "HPDF_TS_GLITTER_DOWN";
            case 15L: return "HPDF_TS_GLITTER_TOP_LEFT_TO_BOTTOM_RIGHT";
            case 16L: return "HPDF_TS_REPLACE";
            case 17L: return "HPDF_TS_EOF";
            default: return "";
        }
    }

    std::string _HPDF_TransitionStyle(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TransitionStyle(i);
        if (s.empty())
            s = "(_HPDF_TransitionStyle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TransitionStyle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TransitionStyle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TransitionStyle(i);
        if (retval.empty()) {
            retval = "(_HPDF_TransitionStyle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TransitionStyle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TransitionStyle() {
        return stringify::_HPDF_TransitionStyle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 440
namespace stringify {
    const char* _HPDF_PageSizes(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_SIZE_LETTER";
            case 1L: return "HPDF_PAGE_SIZE_LEGAL";
            case 2L: return "HPDF_PAGE_SIZE_A3";
            case 3L: return "HPDF_PAGE_SIZE_A4";
            case 4L: return "HPDF_PAGE_SIZE_A5";
            case 5L: return "HPDF_PAGE_SIZE_B4";
            case 6L: return "HPDF_PAGE_SIZE_B5";
            case 7L: return "HPDF_PAGE_SIZE_EXECUTIVE";
            case 8L: return "HPDF_PAGE_SIZE_US4x6";
            case 9L: return "HPDF_PAGE_SIZE_US4x8";
            case 10L: return "HPDF_PAGE_SIZE_US5x7";
            case 11L: return "HPDF_PAGE_SIZE_COMM10";
            case 12L: return "HPDF_PAGE_SIZE_EOF";
            default: return "";
        }
    }

    std::string _HPDF_PageSizes(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageSizes(i);
        if (s.empty())
            s = "(_HPDF_PageSizes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageSizes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageSizes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageSizes(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageSizes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageSizes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageSizes() {
        return stringify::_HPDF_PageSizes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 457
namespace stringify {
    const char* _HPDF_PageDirection(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_PAGE_PORTRAIT";
            case 1L: return "HPDF_PAGE_LANDSCAPE";
            default: return "";
        }
    }

    std::string _HPDF_PageDirection(int64_t i, const std::string &strip) {
        std::string s = _HPDF_PageDirection(i);
        if (s.empty())
            s = "(_HPDF_PageDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_PageDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_PageDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_PageDirection(i);
        if (retval.empty()) {
            retval = "(_HPDF_PageDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_PageDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_PageDirection() {
        return stringify::_HPDF_PageDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 463
namespace stringify {
    const char* _HPDF_EncoderType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_ENCODER_TYPE_SINGLE_BYTE";
            case 1L: return "HPDF_ENCODER_TYPE_DOUBLE_BYTE";
            case 2L: return "HPDF_ENCODER_TYPE_UNINITIALIZED";
            case 3L: return "HPDF_ENCODER_UNKNOWN";
            default: return "";
        }
    }

    std::string _HPDF_EncoderType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncoderType(i);
        if (s.empty())
            s = "(_HPDF_EncoderType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncoderType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncoderType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncoderType(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncoderType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncoderType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncoderType() {
        return stringify::_HPDF_EncoderType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 471
namespace stringify {
    const char* _HPDF_ByteType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BYTE_TYPE_SINGLE";
            case 1L: return "HPDF_BYTE_TYPE_LEAD";
            case 2L: return "HPDF_BYTE_TYPE_TRIAL";
            case 3L: return "HPDF_BYTE_TYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string _HPDF_ByteType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_ByteType(i);
        if (s.empty())
            s = "(_HPDF_ByteType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_ByteType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_ByteType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_ByteType(i);
        if (retval.empty()) {
            retval = "(_HPDF_ByteType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_ByteType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_ByteType() {
        return stringify::_HPDF_ByteType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_types.h line 479
namespace stringify {
    const char* _HPDF_TextAlignment(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_TALIGN_LEFT";
            case 1L: return "HPDF_TALIGN_RIGHT";
            case 2L: return "HPDF_TALIGN_CENTER";
            case 3L: return "HPDF_TALIGN_JUSTIFY";
            default: return "";
        }
    }

    std::string _HPDF_TextAlignment(int64_t i, const std::string &strip) {
        std::string s = _HPDF_TextAlignment(i);
        if (s.empty())
            s = "(_HPDF_TextAlignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_TextAlignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_TextAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_TextAlignment(i);
        if (retval.empty()) {
            retval = "(_HPDF_TextAlignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_TextAlignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_TextAlignment() {
        return stringify::_HPDF_TextAlignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_encoder.h line 69
namespace stringify {
    const char* _HPDF_EncodingType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_STANDARD_ENCODING";
            case 1L: return "HPDF_MAC_ROMAN_ENCODING";
            case 2L: return "HPDF_WIN_ANSI_ENCODING";
            case 3L: return "HPDF_FONT_SPECIFIC";
            case 4L: return "HPDF_ENCODING_EOF";
            default: return "";
        }
    }

    std::string _HPDF_EncodingType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_EncodingType(i);
        if (s.empty())
            s = "(_HPDF_EncodingType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_EncodingType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_EncodingType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_EncodingType(i);
        if (retval.empty()) {
            retval = "(_HPDF_EncodingType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_EncodingType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_EncodingType() {
        return stringify::_HPDF_EncodingType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_encoder.h line 130
namespace stringify {
    const char* _HPDF_BaseEncodings(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_BASE_ENCODING_STANDARD";
            case 1L: return "HPDF_BASE_ENCODING_WIN_ANSI";
            case 2L: return "HPDF_BASE_ENCODING_MAC_ROMAN";
            case 3L: return "HPDF_BASE_ENCODING_FONT_SPECIFIC";
            case 4L: return "HPDF_BASE_ENCODING_EOF";
            default: return "";
        }
    }

    std::string _HPDF_BaseEncodings(int64_t i, const std::string &strip) {
        std::string s = _HPDF_BaseEncodings(i);
        if (s.empty())
            s = "(_HPDF_BaseEncodings)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_BaseEncodings() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_BaseEncodings(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_BaseEncodings(i);
        if (retval.empty()) {
            retval = "(_HPDF_BaseEncodings)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_BaseEncodings::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_BaseEncodings() {
        return stringify::_HPDF_BaseEncodings();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/libharu-2.1.0/include/hpdf_font.h line 31
namespace stringify {
    const char* _HPDF_FontType(int64_t i) {
        switch (i) {
            case 0L: return "HPDF_FONT_TYPE1";
            case 1L: return "HPDF_FONT_TRUETYPE";
            case 2L: return "HPDF_FONT_TYPE3";
            case 3L: return "HPDF_FONT_TYPE0_CID";
            case 4L: return "HPDF_FONT_TYPE0_TT";
            case 5L: return "HPDF_FONT_CID_TYPE0";
            case 6L: return "HPDF_FONT_CID_TYPE2";
            case 7L: return "HPDF_FONT_MMTYPE1";
            default: return "";
        }
    }

    std::string _HPDF_FontType(int64_t i, const std::string &strip) {
        std::string s = _HPDF_FontType(i);
        if (s.empty())
            s = "(_HPDF_FontType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _HPDF_FontType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_HPDF_FontType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_HPDF_FontType(i);
        if (retval.empty()) {
            retval = "(_HPDF_FontType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_HPDF_FontType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_HPDF_FontType() {
        return stringify::_HPDF_FontType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/MSTL/DOTGeneration.h line 48
namespace stringify { namespace DOTGeneration {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "PREORDER";
            case 1L: return "POSTORDER";
            case 2L: return "TOPDOWN";
            case 3L: return "BOTTOMUP";
            case 4L: return "TOPDOWNBOTTOMUP";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGeneration_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGeneration::traversalType(i);
        if (retval.empty()) {
            retval = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGeneration::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGeneration_traversalType() {
        return stringify::DOTGeneration::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/transformationSupport.h line 37
namespace stringify { namespace TransformationSupport {
    const char* operatorCodeType(int64_t i) {
        switch (i) {
            case 0L: return "FUNCTION_CALL_OPERATOR_CODE";
            case 1L: return "ADD_OPERATOR_CODE";
            case 2L: return "SUBT_OPERATOR_CODE";
            case 3L: return "MULT_OPERATOR_CODE";
            case 4L: return "DIV_OPERATOR_CODE";
            case 5L: return "INTEGER_DIV_OPERATOR_CODE";
            case 6L: return "MOD_OPERATOR_CODE";
            case 7L: return "AND_OPERATOR_CODE";
            case 8L: return "OR_OPERATOR_CODE";
            case 9L: return "BITXOR_OPERATOR_CODE";
            case 10L: return "BITAND_OPERATOR_CODE";
            case 11L: return "BITOR_OPERATOR_CODE";
            case 12L: return "EQ_OPERATOR_CODE";
            case 13L: return "LT_OPERATOR_CODE";
            case 14L: return "GT_OPERATOR_CODE";
            case 15L: return "NE_OPERATOR_CODE";
            case 16L: return "LE_OPERATOR_CODE";
            case 17L: return "GE_OPERATOR_CODE";
            case 18L: return "ASSIGN_OPERATOR_CODE";
            case 19L: return "PLUS_ASSIGN_OPERATOR_CODE";
            case 20L: return "MINUS_ASSIGN_OPERATOR_CODE";
            case 21L: return "AND_ASSIGN_OPERATOR_CODE";
            case 22L: return "IOR_ASSIGN_OPERATOR_CODE";
            case 23L: return "MULT_ASSIGN_OPERATOR_CODE";
            case 24L: return "DIV_ASSIGN_OPERATOR_CODE";
            case 25L: return "MOD_ASSIGN_OPERATOR_CODE";
            case 26L: return "XOR_ASSIGN_OPERATOR_CODE";
            case 27L: return "PARENTHESIS_OPERATOR_CODE";
            case 28L: return "BRACKET_OPERATOR_CODE";
            case 29L: return "NOT_OPERATOR_CODE";
            case 30L: return "DEREFERENCE_OPERATOR_CODE";
            case 31L: return "ADDRESS_OPERATOR_CODE";
            case 32L: return "LSHIFT_OPERATOR_CODE";
            case 33L: return "RSHIFT_OPERATOR_CODE";
            case 34L: return "LSHIFT_ASSIGN_OPERATOR_CODE";
            case 35L: return "RSHIFT_ASSIGN_OPERATOR_CODE";
            case 36L: return "PREFIX_PLUSPLUS_OPERATOR_CODE";
            case 37L: return "POSTFIX_PLUSPLUS_OPERATOR_CODE";
            case 38L: return "PREFIX_MINUSMINUS_OPERATOR_CODE";
            case 39L: return "POSTFIX_MINUSMINUS_OPERATOR_CODE";
            case 99L: return "OPERATOR_CODE_LAST_TAG";
            default: return "";
        }
    }

    std::string operatorCodeType(int64_t i, const std::string &strip) {
        std::string s = operatorCodeType(i);
        if (s.empty())
            s = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& operatorCodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTransformationSupport_operatorCodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TransformationSupport::operatorCodeType(i);
        if (retval.empty()) {
            retval = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TransformationSupport::operatorCodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTransformationSupport_operatorCodeType() {
        return stringify::TransformationSupport::operatorCodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/callbacks.h line 12
namespace stringify { namespace ROSE_Callbacks {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(ROSE_Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_CallbacksDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Callbacks::Direction(i);
        if (retval.empty()) {
            retval = "(ROSE_Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Callbacks::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_CallbacksDirection() {
        return stringify::ROSE_Callbacks::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/utility_functions.C line 801
namespace stringify {
    const char* language_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_c";
            case 2L: return "e_cxx";
            case 3L: return "e_fortran";
            case 4L: return "e_last_language";
            default: return "";
        }
    }

    std::string language_enum(int64_t i, const std::string &strip) {
        std::string s = language_enum(i);
        if (s.empty())
            s = "(language_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& language_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_language_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::language_enum(i);
        if (retval.empty()) {
            retval = "(language_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "language_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_language_enum() {
        return stringify::language_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/CommandLine.C line 19
namespace stringify { namespace Rose { namespace CommandLine { namespace FailedAssertionBehaviorAdjuster {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "ABORT_ON_FAILURE";
            case 1L: return "EXIT_ON_FAILURE";
            case 2L: return "THROW_ON_FAILURE";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior() {
        return stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/SqlDatabase.h line 121
namespace stringify { namespace SqlDatabase {
    const char* Driver(int64_t i) {
        switch (i) {
            case 0L: return "NO_DRIVER";
            case 1L: return "SQLITE3";
            case 2L: return "POSTGRESQL";
            default: return "";
        }
    }

    std::string Driver(int64_t i, const std::string &strip) {
        std::string s = Driver(i);
        if (s.empty())
            s = "(SqlDatabase::Driver)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Driver() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySqlDatabaseDriver(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SqlDatabase::Driver(i);
        if (retval.empty()) {
            retval = "(SqlDatabase::Driver)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SqlDatabase::Driver::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySqlDatabaseDriver() {
        return stringify::SqlDatabase::Driver();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 25
namespace stringify { namespace Rose { namespace StringUtility {
    const char* OSType(int64_t i) {
        switch (i) {
            case 0L: return "OS_TYPE_UNKNOWN";
            case 1L: return "OS_TYPE_LINUX";
            case 2L: return "OS_TYPE_OSX";
            case 3L: return "OS_TYPE_WINDOWS";
            case 4L: return "OS_TPYE_WINDOWSXP";
            default: return "";
        }
    }

    std::string OSType(int64_t i, const std::string &strip) {
        std::string s = OSType(i);
        if (s.empty())
            s = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OSType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityOSType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::OSType(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::OSType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityOSType() {
        return stringify::Rose::StringUtility::OSType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 150
namespace stringify { namespace Rose { namespace StringUtility {
    const char* FileNameLocation(int64_t i) {
        switch (i) {
            case 0L: return "FILENAME_LOCATION_UNKNOWN";
            case 1L: return "FILENAME_LOCATION_USER";
            case 2L: return "FILENAME_LOCATION_LIBRARY";
            case 3L: return "FILENAME_LOCATION_NOT_EXIST";
            default: return "";
        }
    }

    std::string FileNameLocation(int64_t i, const std::string &strip) {
        std::string s = FileNameLocation(i);
        if (s.empty())
            s = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FileNameLocation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityFileNameLocation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::FileNameLocation(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::FileNameLocation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityFileNameLocation() {
        return stringify::Rose::StringUtility::FileNameLocation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/GraphTraversal.h line 39
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "NO_EVENT";
            case 1L: return "ENTER_VERTEX";
            case 2L: return "ENTER_EDGE";
            case 4L: return "DISCOVER_VERTEX";
            case 8L: return "LEAVE_EDGE";
            case 16L: return "LEAVE_VERTEX";
            case 32L: return "FOLLOW_EDGE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmTraversalEvent() {
        return stringify::Sawyer::Container::Algorithm::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 170
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SortOrder(int64_t i) {
        switch (i) {
            case 0L: return "INSERTION_ORDER";
            case 1L: return "DOCKEY_ORDER";
            default: return "";
        }
    }

    std::string SortOrder(int64_t i, const std::string &strip) {
        std::string s = SortOrder(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SortOrder() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSortOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SortOrder(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SortOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSortOrder() {
        return stringify::Sawyer::CommandLine::SortOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 183
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* Canonical(int64_t i) {
        switch (i) {
            case 0L: return "CANONICAL";
            case 1L: return "NONCANONICAL";
            case 2L: return "ALL_STRINGS";
            default: return "";
        }
    }

    std::string Canonical(int64_t i, const std::string &strip) {
        std::string s = Canonical(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Canonical() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineCanonical(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Canonical(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Canonical::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineCanonical() {
        return stringify::Sawyer::CommandLine::Canonical();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 191
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* ShowGroupName(int64_t i) {
        switch (i) {
            case 0L: return "SHOW_GROUP_OPTIONAL";
            case 1L: return "SHOW_GROUP_REQUIRED";
            case 2L: return "SHOW_GROUP_NONE";
            case 3L: return "SHOW_GROUP_INHERIT";
            default: return "";
        }
    }

    std::string ShowGroupName(int64_t i, const std::string &strip) {
        std::string s = ShowGroupName(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowGroupName() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineShowGroupName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::ShowGroupName(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::ShowGroupName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineShowGroupName() {
        return stringify::Sawyer::CommandLine::ShowGroupName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 199
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SwitchSkipping(int64_t i) {
        switch (i) {
            case 0L: return "SKIP_NEVER";
            case 1L: return "SKIP_WEAK";
            case 2L: return "SKIP_STRONG";
            default: return "";
        }
    }

    std::string SwitchSkipping(int64_t i, const std::string &strip) {
        std::string s = SwitchSkipping(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SwitchSkipping() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSwitchSkipping(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SwitchSkipping(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SwitchSkipping::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSwitchSkipping() {
        return stringify::Sawyer::CommandLine::SwitchSkipping();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 1963
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* WhichValue(int64_t i) {
        switch (i) {
            case 0L: return "SAVE_NONE";
            case 1L: return "SAVE_ONE";
            case 2L: return "SAVE_LAST";
            case 3L: return "SAVE_FIRST";
            case 4L: return "SAVE_ALL";
            case 5L: return "SAVE_AUGMENTED";
            default: return "";
        }
    }

    std::string WhichValue(int64_t i, const std::string &strip) {
        std::string s = WhichValue(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhichValue() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineWhichValue(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::WhichValue(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::WhichValue::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineWhichValue() {
        return stringify::Sawyer::CommandLine::WhichValue();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/CommandLine.h line 2996
namespace stringify { namespace Sawyer { namespace CommandLine { namespace Parser {
    const char* GroupingFlags(int64_t i) {
        switch (i) {
            case 0L: return "DEFAULT_GROUPING";
            case 1L: return "PROHIBIT_EMPTY_GROUPS";
            case 2L: return "SPLIT_SINGLE_GROUP";
            default: return "";
        }
    }

    std::string GroupingFlags(int64_t i, const std::string &strip) {
        std::string s = GroupingFlags(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GroupingFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerCommandLineParserGroupingFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Parser::GroupingFlags(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Parser::GroupingFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineParserGroupingFlags() {
        return stringify::Sawyer::CommandLine::Parser::GroupingFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 119
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 1L: return "ENTER";
            case 2L: return "LEAVE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalEvent() {
        return stringify::Sawyer::Tree::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 125
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalAction(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE";
            case 1L: return "SKIP_CHILDREN";
            case 2L: return "ABORT";
            default: return "";
        }
    }

    std::string TraversalAction(int64_t i, const std::string &strip) {
        std::string s = TraversalAction(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalAction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalAction() {
        return stringify::Sawyer::Tree::TraversalAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Tree.h line 481
namespace stringify { namespace Sawyer { namespace Tree { namespace Node {
    const char* TraversalDirection(int64_t i) {
        switch (i) {
            case 0L: return "TRAVERSE_UPWARD";
            case 1L: return "TRAVERSE_DOWNWARD";
            default: return "";
        }
    }

    std::string TraversalDirection(int64_t i, const std::string &strip) {
        std::string s = TraversalDirection(i);
        if (s.empty())
            s = "(Sawyer::Tree::Node::TraversalDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerTreeNodeTraversalDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::Node::TraversalDirection(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::Node::TraversalDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::Node::TraversalDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeNodeTraversalDirection() {
        return stringify::Sawyer::Tree::Node::TraversalDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 310
namespace stringify { namespace Sawyer { namespace Message {
    const char* Importance(int64_t i) {
        switch (i) {
            case 0L: return "DEBUG";
            case 1L: return "TRACE";
            case 2L: return "WHERE";
            case 3L: return "MARCH";
            case 4L: return "INFO";
            case 5L: return "WARN";
            case 6L: return "ERROR";
            case 7L: return "FATAL";
            case 8L: return "N_IMPORTANCE";
            default: return "";
        }
    }

    std::string Importance(int64_t i, const std::string &strip) {
        std::string s = Importance(i);
        if (s.empty())
            s = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Importance() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageImportance(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Importance(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Importance::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageImportance() {
        return stringify::Sawyer::Message::Importance();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 340
namespace stringify { namespace Sawyer { namespace Message {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "COLOR_BLACK";
            case 1L: return "COLOR_RED";
            case 2L: return "COLOR_GREEN";
            case 3L: return "COLOR_YELLOW";
            case 4L: return "COLOR_BLUE";
            case 5L: return "COLOR_MAGENTA";
            case 6L: return "COLOR_CYAN";
            case 7L: return "COLOR_WHITE";
            case 8L: return "COLOR_DEFAULT";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageAnsiColor() {
        return stringify::Sawyer::Message::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Message.h line 988
namespace stringify { namespace Sawyer { namespace Message { namespace Prefix {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "SOMETIMES";
            case 2L: return "ALWAYS";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerMessagePrefixWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Prefix::When(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Prefix::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessagePrefixWhen() {
        return stringify::Sawyer::Message::Prefix::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/GraphAlgorithm.h line 373
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* CsiNextAction(int64_t i) {
        switch (i) {
            case 0L: return "CSI_CONTINUE";
            case 1L: return "CSI_ABORT";
            default: return "";
        }
    }

    std::string CsiNextAction(int64_t i, const std::string &strip) {
        std::string s = CsiNextAction(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CsiNextAction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmCsiNextAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::CsiNextAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::CsiNextAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmCsiNextAction() {
        return stringify::Sawyer::Container::Algorithm::CsiNextAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Graph.h line 636
namespace stringify { namespace Sawyer { namespace Container { namespace Graph {
    const char* EdgePhase(int64_t i) {
        switch (i) {
            case 0L: return "IN_EDGES";
            case 1L: return "OUT_EDGES";
            case 2L: return "N_PHASES";
            default: return "";
        }
    }

    std::string EdgePhase(int64_t i, const std::string &strip) {
        std::string s = EdgePhase(i);
        if (s.empty())
            s = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgePhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerGraphEdgePhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Graph::EdgePhase(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerGraphEdgePhase() {
        return stringify::Sawyer::Container::Graph::EdgePhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Clexer.h line 25
namespace stringify { namespace Sawyer { namespace Language { namespace Clexer {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_CHAR";
            case 4L: return "TOK_STRING";
            case 5L: return "TOK_NUMBER";
            case 6L: return "TOK_WORD";
            case 7L: return "TOK_CPP";
            case 8L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerLanguageClexerTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Language::Clexer::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Language::Clexer::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerLanguageClexerTokenType() {
        return stringify::Sawyer::Language::Clexer::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/Access.h line 19
namespace stringify { namespace Sawyer { namespace Access {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "EXECUTABLE";
            case 2L: return "WRITABLE";
            case 4L: return "READABLE";
            case 8L: return "IMMUTABLE";
            case 16L: return "PRIVATE";
            case 255L: return "RESERVED_MASK";
            case 4294967040L: return "USERDEF_MASK";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            255L,
            4294967040L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerAccessAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Access::Access(i);
        if (retval.empty()) {
            retval = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Access::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerAccessAccess() {
        return stringify::Sawyer::Access::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Sawyer/DocumentMarkup.h line 42
namespace stringify { namespace Sawyer { namespace Document { namespace Markup {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_DATA";
            case 1L: return "TOK_FUNCTION";
            case 2L: return "TOK_LEFT";
            case 3L: return "TOK_RIGHT";
            case 4L: return "TOK_BLANK_LINE";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDocumentMarkupTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Document::Markup::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Document::Markup::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDocumentMarkupTokenType() {
        return stringify::Sawyer::Document::Markup::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/Color.h line 236
namespace stringify { namespace Rose { namespace Color {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "ANSI_CLEAR";
            case 1L: return "ANSI_RED";
            case 2L: return "ANSI_GREEN";
            case 3L: return "ANSI_YELLOW";
            case 4L: return "ANSI_BLUE";
            case 5L: return "ANSI_MAGENTA";
            case 6L: return "ANSI_CYAN";
            case 7L: return "ANSI_GRAY";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorAnsiColor() {
        return stringify::Rose::Color::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 17
namespace stringify {
    const char* Cxx_GrammarVariants(int64_t i) {
        switch (i) {
            case 1L: return "AccessModifierTag";
            case 2L: return "ACTUAL_ARGUMENT_EXPRESSION";
            case 3L: return "ADD_OP";
            case 4L: return "ADDRESS_OP";
            case 5L: return "AGGREGATE_INIT";
            case 6L: return "ALIAS_SYMBOL";
            case 7L: return "TEMP_Allocate_Statement";
            case 8L: return "AND_ASSIGN_OP";
            case 9L: return "AND_OP";
            case 10L: return "TEMP_Arithmetic_If_Statement";
            case 11L: return "T_ARRAY";
            case 12L: return "POINTST_OP";
            case 13L: return "ARROWSTAR_OP";
            case 14L: return "AsmArmInstructionTag";
            case 15L: return "AsmBasicStringTag";
            case 16L: return "AsmBinaryAddTag";
            case 17L: return "AsmBinaryAddPostupdateTag";
            case 18L: return "AsmBinaryAddPreupdateTag";
            case 19L: return "AsmBinaryAsrTag";
            case 20L: return "AsmBinaryDivideTag";
            case 21L: return "AsmBinaryExpressionTag";
            case 22L: return "AsmBinaryLslTag";
            case 23L: return "AsmBinaryLsrTag";
            case 24L: return "AsmBinaryModTag";
            case 25L: return "AsmBinaryMultiplyTag";
            case 26L: return "AsmBinaryRorTag";
            case 27L: return "AsmBinarySubtractTag";
            case 28L: return "AsmBinarySubtractPostupdateTag";
            case 29L: return "AsmBinarySubtractPreupdateTag";
            case 30L: return "AsmBlockTag";
            case 31L: return "AsmCoffStrtabTag";
            case 32L: return "AsmCoffSymbolTag";
            case 33L: return "AsmCoffSymbolListTag";
            case 34L: return "AsmCoffSymbolTableTag";
            case 35L: return "AsmCommonSubExpressionTag";
            case 36L: return "AsmControlFlagsExpressionTag";
            case 37L: return "AsmConstantExpressionTag";
            case 38L: return "AsmDOSExtendedHeaderTag";
            case 39L: return "AsmDOSFileHeaderTag";
            case 40L: return "AsmSynthesizedDataStructureDeclarationTag";
            case 41L: return "AsmSynthesizedDeclarationTag";
            case 42L: return "AsmDirectRegisterExpressionTag";
            case 43L: return "AsmDwarfAccessDeclarationTag";
            case 44L: return "AsmDwarfArrayTypeTag";
            case 45L: return "AsmDwarfBaseTypeTag";
            case 46L: return "AsmDwarfCatchBlockTag";
            case 47L: return "AsmDwarfClassTemplateTag";
            case 48L: return "AsmDwarfClassTypeTag";
            case 49L: return "AsmDwarfCommonBlockTag";
            case 50L: return "AsmDwarfCommonInclusionTag";
            case 51L: return "AsmDwarfCompilationUnitTag";
            case 52L: return "AsmDwarfCompilationUnitListTag";
            case 53L: return "AsmDwarfConditionTag";
            case 54L: return "AsmDwarfConstTypeTag";
            case 55L: return "AsmDwarfConstantTag";
            case 56L: return "AsmDwarfConstructTag";
            case 57L: return "AsmDwarfConstructListTag";
            case 58L: return "AsmDwarfDwarfProcedureTag";
            case 59L: return "AsmDwarfEntryPointTag";
            case 60L: return "AsmDwarfEnumerationTypeTag";
            case 61L: return "AsmDwarfEnumeratorTag";
            case 62L: return "AsmDwarfFileTypeTag";
            case 63L: return "AsmDwarfFormalParameterTag";
            case 64L: return "AsmDwarfFormatLabelTag";
            case 65L: return "AsmDwarfFriendTag";
            case 66L: return "AsmDwarfFunctionTemplateTag";
            case 67L: return "AsmDwarfImportedDeclarationTag";
            case 68L: return "AsmDwarfImportedModuleTag";
            case 69L: return "AsmDwarfImportedUnitTag";
            case 70L: return "AsmDwarfInformationTag";
            case 71L: return "AsmDwarfInheritanceTag";
            case 72L: return "AsmDwarfInlinedSubroutineTag";
            case 73L: return "AsmDwarfInterfaceTypeTag";
            case 74L: return "AsmDwarfLabelTag";
            case 75L: return "AsmDwarfLexicalBlockTag";
            case 76L: return "AsmDwarfLineTag";
            case 77L: return "AsmDwarfLineListTag";
            case 78L: return "AsmDwarfMacroTag";
            case 79L: return "AsmDwarfMacroListTag";
            case 80L: return "AsmDwarfMemberTag";
            case 81L: return "AsmDwarfModuleTag";
            case 82L: return "AsmDwarfMutableTypeTag";
            case 83L: return "AsmDwarfNamelistTag";
            case 84L: return "AsmDwarfNamelistItemTag";
            case 85L: return "AsmDwarfNamespaceTag";
            case 86L: return "AsmDwarfPackedTypeTag";
            case 87L: return "AsmDwarfPartialUnitTag";
            case 88L: return "AsmDwarfPointerTypeTag";
            case 89L: return "AsmDwarfPtrToMemberTypeTag";
            case 90L: return "AsmDwarfReferenceTypeTag";
            case 91L: return "AsmDwarfRestrictTypeTag";
            case 92L: return "AsmDwarfSetTypeTag";
            case 93L: return "AsmDwarfSharedTypeTag";
            case 94L: return "AsmDwarfStringTypeTag";
            case 95L: return "AsmDwarfStructureTypeTag";
            case 96L: return "AsmDwarfSubprogramTag";
            case 97L: return "AsmDwarfSubrangeTypeTag";
            case 98L: return "AsmDwarfSubroutineTypeTag";
            case 99L: return "AsmDwarfTemplateTypeParameterTag";
            case 100L: return "AsmDwarfTemplateValueParameterTag";
            case 101L: return "AsmDwarfThrownTypeTag";
            case 102L: return "AsmDwarfTryBlockTag";
            case 103L: return "AsmDwarfTypedefTag";
            case 104L: return "AsmDwarfUnionTypeTag";
            case 105L: return "AsmDwarfUnknownConstructTag";
            case 106L: return "AsmDwarfUnspecifiedParametersTag";
            case 107L: return "AsmDwarfUnspecifiedTypeTag";
            case 108L: return "AsmDwarfUpcRelaxedTypeTag";
            case 109L: return "AsmDwarfUpcSharedTypeTag";
            case 110L: return "AsmDwarfUpcStrictTypeTag";
            case 111L: return "AsmDwarfVariableTag";
            case 112L: return "AsmDwarfVariantTag";
            case 113L: return "AsmDwarfVariantPartTag";
            case 114L: return "AsmDwarfVolatileTypeTag";
            case 115L: return "AsmDwarfWithStmtTag";
            case 116L: return "AsmElfDynamicEntryTag";
            case 117L: return "AsmElfDynamicEntryListTag";
            case 118L: return "AsmElfDynamicSectionTag";
            case 119L: return "AsmElfEHFrameEntryCITag";
            case 120L: return "AsmElfEHFrameEntryCIListTag";
            case 121L: return "AsmElfEHFrameEntryFDTag";
            case 122L: return "AsmElfEHFrameEntryFDListTag";
            case 123L: return "AsmElfEHFrameSectionTag";
            case 124L: return "AsmElfFileHeaderTag";
            case 125L: return "AsmElfNoteEntryTag";
            case 126L: return "AsmElfNoteEntryListTag";
            case 127L: return "AsmElfNoteSectionTag";
            case 128L: return "AsmElfRelocEntryTag";
            case 129L: return "AsmElfRelocEntryListTag";
            case 130L: return "AsmElfRelocSectionTag";
            case 131L: return "AsmElfSectionTag";
            case 132L: return "AsmElfSectionTableTag";
            case 133L: return "AsmElfSectionTableEntryTag";
            case 134L: return "AsmElfSegmentTableTag";
            case 135L: return "AsmElfSegmentTableEntryTag";
            case 136L: return "AsmElfSegmentTableEntryListTag";
            case 137L: return "AsmElfStringSectionTag";
            case 138L: return "AsmElfStrtabTag";
            case 139L: return "AsmElfSymbolTag";
            case 140L: return "AsmElfSymbolListTag";
            case 141L: return "AsmElfSymbolSectionTag";
            case 142L: return "AsmElfSymverDefinedAuxTag";
            case 143L: return "AsmElfSymverDefinedAuxListTag";
            case 144L: return "AsmElfSymverDefinedEntryTag";
            case 145L: return "AsmElfSymverDefinedEntryListTag";
            case 146L: return "AsmElfSymverDefinedSectionTag";
            case 147L: return "AsmElfSymverEntryTag";
            case 148L: return "AsmElfSymverEntryListTag";
            case 149L: return "AsmElfSymverNeededAuxTag";
            case 150L: return "AsmElfSymverNeededAuxListTag";
            case 151L: return "AsmElfSymverNeededEntryTag";
            case 152L: return "AsmElfSymverNeededEntryListTag";
            case 153L: return "AsmElfSymverNeededSectionTag";
            case 154L: return "AsmElfSymverSectionTag";
            case 155L: return "AsmExecutableFileFormatTag";
            case 156L: return "AsmExprListExpTag";
            case 157L: return "AsmExpressionTag";
            case 158L: return "AsmSynthesizedFieldDeclarationTag";
            case 159L: return "AsmFloatTypeTag";
            case 160L: return "AsmFloatValueExpressionTag";
            case 161L: return "AsmFunctionTag";
            case 162L: return "AsmGenericDLLTag";
            case 163L: return "AsmGenericDLLListTag";
            case 164L: return "AsmGenericFileTag";
            case 165L: return "AsmGenericFileListTag";
            case 166L: return "AsmGenericFormatTag";
            case 167L: return "AsmGenericHeaderTag";
            case 168L: return "AsmGenericHeaderListTag";
            case 169L: return "AsmGenericSectionTag";
            case 170L: return "AsmGenericSectionListTag";
            case 171L: return "AsmGenericStringTag";
            case 172L: return "AsmGenericStrtabTag";
            case 173L: return "AsmGenericSymbolTag";
            case 174L: return "AsmGenericSymbolListTag";
            case 175L: return "AsmIndirectRegisterExpressionTag";
            case 176L: return "AsmInstructionTag";
            case 177L: return "AsmIntegerValueExpressionTag";
            case 178L: return "AsmIntegerTypeTag";
            case 179L: return "AsmInterpretationTag";
            case 180L: return "AsmInterpretationListTag";
            case 181L: return "AsmLEEntryPointTag";
            case 182L: return "AsmLEEntryTableTag";
            case 183L: return "AsmLEFileHeaderTag";
            case 184L: return "AsmLENameTableTag";
            case 185L: return "AsmLEPageTableTag";
            case 186L: return "AsmLEPageTableEntryTag";
            case 187L: return "AsmLERelocTableTag";
            case 188L: return "AsmLESectionTag";
            case 189L: return "AsmLESectionTableTag";
            case 190L: return "AsmLESectionTableEntryTag";
            case 191L: return "AsmM68kInstructionTag";
            case 192L: return "AsmMemoryReferenceExpressionTag";
            case 193L: return "AsmMipsInstructionTag";
            case 194L: return "AsmNEEntryPointTag";
            case 195L: return "AsmNEEntryTableTag";
            case 196L: return "AsmNEFileHeaderTag";
            case 197L: return "AsmNEModuleTableTag";
            case 198L: return "AsmNENameTableTag";
            case 199L: return "AsmNERelocEntryTag";
            case 200L: return "AsmNERelocTableTag";
            case 201L: return "AsmNESectionTag";
            case 202L: return "AsmNESectionTableTag";
            case 203L: return "AsmNESectionTableEntryTag";
            case 204L: return "AsmNEStringTableTag";
            case 205L: return "AsmNodeTag";
            case 206L: return "ASM_OP";
            case 207L: return "AsmOperandListTag";
            case 208L: return "AsmPEExportDirectoryTag";
            case 209L: return "AsmPEExportEntryTag";
            case 210L: return "AsmPEExportEntryListTag";
            case 211L: return "AsmPEExportSectionTag";
            case 212L: return "AsmPEFileHeaderTag";
            case 213L: return "AsmPEImportDirectoryTag";
            case 214L: return "AsmPEImportDirectoryListTag";
            case 215L: return "AsmPEImportItemTag";
            case 216L: return "AsmPEImportItemListTag";
            case 217L: return "AsmPEImportSectionTag";
            case 218L: return "AsmPERVASizePairTag";
            case 219L: return "AsmPERVASizePairListTag";
            case 220L: return "AsmPESectionTag";
            case 221L: return "AsmPESectionTableTag";
            case 222L: return "AsmPESectionTableEntryTag";
            case 223L: return "AsmPEStringSectionTag";
            case 224L: return "AsmPowerpcInstructionTag";
            case 225L: return "AsmRegisterNamesTag";
            case 226L: return "AsmRegisterReferenceExpressionTag";
            case 227L: return "AsmRiscOperationTag";
            case 228L: return "AsmScalarTypeTag";
            case 229L: return "AsmStatementTag";
            case 230L: return "AsmStaticDataTag";
            case 231L: return "ASM_STMT";
            case 232L: return "AsmStoredStringTag";
            case 233L: return "AsmStringStorageTag";
            case 234L: return "AsmTypeTag";
            case 235L: return "AsmUnaryArmSpecialRegisterListTag";
            case 236L: return "AsmUnaryExpressionTag";
            case 237L: return "AsmUnaryMinusTag";
            case 238L: return "AsmUnaryPlusTag";
            case 239L: return "AsmUnaryRrxTag";
            case 240L: return "AsmValueExpressionTag";
            case 241L: return "AsmVectorTypeTag";
            case 242L: return "AsmX86InstructionTag";
            case 243L: return "BINARY_ADDRESS_SYMBOL";
            case 244L: return "BINARY_DATA_SYMBOL";
            case 245L: return "ASSERT_STMT";
            case 246L: return "ASSIGN_INIT";
            case 247L: return "ASSIGN_OP";
            case 248L: return "TEMP_Assign_Statement";
            case 249L: return "TEMP_Assigned_Goto_Statement";
            case 250L: return "TEMP_Associate_Statement";
            case 251L: return "TEMP_AsteriskShapeExp";
            case 252L: return "AttributeTag";
            case 253L: return "TEMP_Attribute_Specification_Statement";
            case 254L: return "T_AUTO";
            case 255L: return "BACKSPACE_STATEMENT";
            case 256L: return "BaseClassTag";
            case 257L: return "ExpBaseClassTag";
            case 258L: return "BaseClassModifierTag";
            case 259L: return "BASIC_BLOCK_STMT";
            case 260L: return "BidirectionalGraphTag";
            case 261L: return "BinaryCompositeTag";
            case 262L: return "BINARY_EXPRESSION";
            case 263L: return "BITAND_OP";
            case 264L: return "BitAttributeTag";
            case 265L: return "BIT_COMPLEMENT_OP";
            case 266L: return "BITOR_OP";
            case 267L: return "BITXOR_OP";
            case 268L: return "TEMP_Block_Data_Statement";
            case 269L: return "BOOL_VAL";
            case 270L: return "BREAK_STMT";
            case 271L: return "BRACED_INIT";
            case 272L: return "CPP_DIRECTIVE_STMT";
            case 273L: return "CASE_STMT";
            case 274L: return "CAST_OP";
            case 275L: return "CATCH_STMT";
            case 276L: return "CATCH_STATEMENT_SEQ";
            case 277L: return "CHAR_VAL";
            case 278L: return "CHAR16_VAL";
            case 279L: return "CHAR32_VAL";
            case 280L: return "ClassDecl_attrTag";
            case 281L: return "CLASS_DECL_STMT";
            case 282L: return "CLASS_DEFN_STMT";
            case 283L: return "CLASSNAME_REF";
            case 284L: return "CLASS_NAME";
            case 285L: return "T_CLASS";
            case 286L: return "C_LINKAGE_DECLARATION_STMT";
            case 287L: return "C_LINKAGE_END_STMT";
            case 288L: return "C_LINKAGE_START_STMT";
            case 289L: return "CLOSE_STATEMENT";
            case 290L: return "TEMP_ColonShapeExp";
            case 291L: return "COMMA_OP";
            case 292L: return "COMMON_BLOCK";
            case 293L: return "TEMP_CommonBlockObject";
            case 294L: return "COMMON_SYMBOL";
            case 295L: return "COMPLEX_VAL";
            case 296L: return "COMPREHENSION";
            case 298L: return "COMPOUND_ASSIGN_OP";
            case 299L: return "COMPOUND_INIT";
            case 300L: return "COMPOUND_LITERAL";
            case 301L: return "TEMP_Computed_Goto_Statement";
            case 302L: return "CONCATENATION_OP";
            case 303L: return "EXPR_CONDITIONAL";
            case 304L: return "CONJUGATE_OP";
            case 305L: return "ConstVolatileModifierTag";
            case 306L: return "CONSTRUCTOR_INIT";
            case 307L: return "TEMP_Contains_Statement";
            case 308L: return "CONTINUE_STMT";
            case 309L: return "CTOR_INITIALIZER_LIST";
            case 310L: return "TEMP_DataStatementGroup";
            case 311L: return "TEMP_DataStatementObject";
            case 312L: return "TEMP_DataStatementValue";
            case 313L: return "DEAD_IF_DIRECTIVE_STMT";
            case 314L: return "TEMP_Deallocate_Statement";
            case 315L: return "DeclarationModifierTag";
            case 316L: return "DECLARATION_SCOPE";
            case 317L: return "DECL_STMT";
            case 318L: return "T_DECLTYPE";
            case 319L: return "DEFAULT_STMT";
            case 320L: return "DEFAULT_NAME";
            case 321L: return "DEFINE_DIRECTIVE_STMT";
            case 322L: return "DELETE_OP";
            case 323L: return "TEMP_Derived_Type_Statement";
            case 324L: return "DESIGNATED_INITIALIZER";
            case 325L: return "DICTIONARY_COMPREHENSION";
            case 326L: return "DICT_EXP";
            case 327L: return "TEMP_DimensionObject";
            case 329L: return "DirectedGraphEdgeTag";
            case 331L: return "DirectoryTag";
            case 332L: return "DirectoryListTag";
            case 333L: return "DIV_ASSIGN_OP";
            case 334L: return "DIV_OP";
            case 335L: return "DO_WHILE_STMT";
            case 336L: return "RECORD_REF";
            case 337L: return "DOTSTAR_OP";
            case 338L: return "DOUBLE_VAL";
            case 339L: return "ElaboratedTypeModifierTag";
            case 340L: return "ELEMENT_WISE_OP";
            case 341L: return "ELEMENT_ADD_OP";
            case 342L: return "ELEMENT_DIVIDE_OP";
            case 343L: return "ELEMENT_LEFT_DIVIDE_OP";
            case 344L: return "ELEMENT_MULT_OP";
            case 345L: return "ELEMENT_POWER_OP";
            case 346L: return "ELEMENT_SUBTRACT_OP";
            case 347L: return "ELSE_DIRECTIVE_STMT";
            case 348L: return "TEMP_Else_Where_Statement";
            case 349L: return "ELSEIF_DIRECTIVE_STMT";
            case 350L: return "EMPTY_DECLARATION_STMT";
            case 351L: return "EMPTY_DIRECTIVE_STMT";
            case 352L: return "ENDFILE_STATEMENT";
            case 353L: return "ENDIF_DIRECTIVE_STMT";
            case 354L: return "ENTRY_STMT";
            case 355L: return "ENUM_DECL_STMT";
            case 356L: return "FIELD_NAME";
            case 357L: return "ENUM_NAME";
            case 358L: return "T_ENUM";
            case 359L: return "ENUM_VAL";
            case 360L: return "EQ_OP";
            case 361L: return "TEMP_Equivalence_Statement";
            case 362L: return "ERROR_DIRECTIVE_STMT";
            case 363L: return "EXEC_STMT";
            case 364L: return "EXPONENTIATION_OP";
            case 365L: return "EXP_ASSIGN_OP";
            case 366L: return "EXPR_LIST";
            case 367L: return "EXPR_STMT";
            case 368L: return "ExpressionTag";
            case 369L: return "EXPRESSION_ROOT";
            case 370L: return "FileTag";
            case 371L: return "FileListTag";
            case 372L: return "FLOAT_VAL";
            case 373L: return "FLOAT_128_VAL";
            case 374L: return "FLOAT_80_VAL";
            case 375L: return "FLUSH_STATEMENT";
            case 376L: return "FOR_ALL_STMT";
            case 377L: return "FOR_INIT_STMT";
            case 378L: return "FOR_STMT";
            case 379L: return "TEMP_FormatItem";
            case 380L: return "TEMP_FormatItemList";
            case 381L: return "FORMAT_STATEMENT";
            case 382L: return "FORTRAN_DO";
            case 383L: return "TEMP_Fortran_Include_Line";
            case 384L: return "FORTRAN_NONBLOCKED_DO";
            case 385L: return "FuncDecl_attrTag";
            case 386L: return "FUNC_CALL";
            case 387L: return "FUNC_DECL_STMT";
            case 388L: return "FUNC_DEFN_STMT";
            case 389L: return "FUNCTION_PARAMETER_SCOPE";
            case 390L: return "FunctionModifierTag";
            case 391L: return "FUNCTION_PARAMETER_LIST";
            case 392L: return "FUNCTION_PARAMETER_REF_EXP";
            case 393L: return "T_FUNCTION_PARAMETER_TYPE_LIST";
            case 394L: return "FUNCTION_REF";
            case 395L: return "FUNCTION_NAME";
            case 396L: return "T_FUNCTION";
            case 397L: return "FUNCTYPE_NAME";
            case 398L: return "FUNC_TBL_STMT";
            case 399L: return "TYPE_TABLE";
            case 400L: return "GLOBAL_STMT";
            case 401L: return "GOTO_STMT";
            case 402L: return "GraphTag";
            case 403L: return "GraphEdgeTag";
            case 404L: return "GraphEdgeListTag";
            case 405L: return "GraphNodeTag";
            case 406L: return "GraphNodeListTag";
            case 407L: return "GE_OP";
            case 408L: return "GT_OP";
            case 409L: return "IO_ITEM_EXPR";
            case 410L: return "IO_STATEMENT";
            case 411L: return "IDENT_DIRECTIVE_STMT";
            case 412L: return "IF_DIRECTIVE_STMT";
            case 413L: return "IF_STMT";
            case 414L: return "IFDEF_DIRECTIVE_STMT";
            case 415L: return "IFNDEF_DIRECTIVE_STMT";
            case 416L: return "IMAGE_CONTROL_STATEMENT";
            case 417L: return "IMAG_PART_OP";
            case 418L: return "TEMP_Implicit_Statement";
            case 419L: return "IMPLIED_DO";
            case 420L: return "TEMP_Import_Statement";
            case 421L: return "IncidenceDirectedGraphTag";
            case 422L: return "IncidenceUndirectedGraphTag";
            case 423L: return "INCLUDE_DIRECTIVE_STMT";
            case 424L: return "IncludeFileTag";
            case 425L: return "INCLUDE_NEXT_DIRECTIVE_STMT";
            case 426L: return "InitializedNameTag";
            case 427L: return "EXPR_INIT";
            case 428L: return "INQUIRE_STATEMENT";
            case 429L: return "IntKeyedBidirectionalGraphTag";
            case 430L: return "INT_VAL";
            case 431L: return "INTEGER_DIV_OP";
            case 432L: return "IDIV_ASSIGN_OP";
            case 433L: return "TEMP_Interface_Body";
            case 434L: return "TEMP_Header_File_Body";
            case 435L: return "HeaderFileReportTag";
            case 436L: return "INTERFACE_STATEMENT";
            case 437L: return "INTERFACE_SYMBOL";
            case 438L: return "INTRINSIC_SYMBOL";
            case 439L: return "IS_OP";
            case 440L: return "IS_NOT_OP";
            case 441L: return "IOR_ASSIGN_OP";
            case 442L: return "JOVIAL_COMPOOL_STATEMENT";
            case 443L: return "JOVIAL_FOR_THEN_STATEMENT";
            case 444L: return "JOVIAL_DEFINE_DECLARATION";
            case 445L: return "JOVIAL_DIRECTIVE_STATEMENT";
            case 446L: return "TEMP_Jovia_Table_Statement";
            case 447L: return "KEY_DATUM_PAIR";
            case 448L: return "EXEC_CONF";
            case 449L: return "KERN_CALL";
            case 450L: return "LABEL_REF";
            case 451L: return "LABEL_STMT";
            case 452L: return "JAVA_LABEL_STMT";
            case 453L: return "LABEL_NAME";
            case 454L: return "JAVA_LABEL_NAME";
            case 455L: return "LambdaCaptureTag";
            case 456L: return "LambdaCaptureListTag";
            case 457L: return "LAMBDA_EXP";
            case 458L: return "LAMBDA_REF_EXP";
            case 459L: return "LEFT_DIVIDE_OP";
            case 460L: return "LE_OP";
            case 461L: return "LT_OP";
            case 462L: return "LINE_DIRECTIVE_STMT";
            case 463L: return "LINEMARKER_DIRECTIVE_STMT";
            case 464L: return "LinkageModifierTag";
            case 465L: return "LIST_COMPREHENSION";
            case 466L: return "LIST_EXP";
            case 467L: return "LocatedNodeTag";
            case 468L: return "LocatedNodeSupportTag";
            case 469L: return "LONG_DOUBLE_VAL";
            case 470L: return "LONG_INT_VAL";
            case 471L: return "LONG_LONG_INT_VAL";
            case 472L: return "LSHIFT_ASSIGN_OP";
            case 473L: return "LSHIFT_OP";
            case 474L: return "MAGIC_COLON_EXP";
            case 475L: return "MATRIX_EXP";
            case 476L: return "MATRIX_TRANSPOSE_OP";
            case 477L: return "MATLAB_FOR_STATEMENT";
            case 478L: return "MFUNC_DECL_STMT";
            case 479L: return "MEMBER_FUNCTION_REF";
            case 480L: return "MEMBER_FUNC_NAME";
            case 481L: return "T_MEMBERFUNCTION";
            case 482L: return "MEMBERSHIP_OP";
            case 483L: return "MS_ATTRIBUTE_DECL_STMT";
            case 484L: return "MINUS_ASSIGN_OP";
            case 485L: return "MINUSMINUS_OP";
            case 486L: return "UNARY_MINUS_OP";
            case 487L: return "MOD_ASSIGN_OP";
            case 488L: return "MOD_OP";
            case 489L: return "ModifierTag";
            case 490L: return "ModifierNodesTag";
            case 491L: return "T_MODIFIER";
            case 492L: return "MODULE_STATEMENT";
            case 493L: return "MODULE_SYMBOL";
            case 494L: return "MULT_ASSIGN_OP";
            case 495L: return "MULT_OP";
            case 496L: return "NameTag";
            case 497L: return "TEMP_Name_Group";
            case 498L: return "T_NAME";
            case 499L: return "TEMP_Namelist_Statement";
            case 500L: return "NAMESPACE_ALIAS_DECLARATION_STMT";
            case 501L: return "NAMESPACE_DECLARATION_STMT";
            case 502L: return "NAMESPACE_DEFINITION_STMT";
            case 503L: return "NAMESPACE_NAME";
            case 504L: return "NARY_EXPRESSION";
            case 505L: return "NARY_BOOLEAN_OP";
            case 506L: return "NARY_COMPARISON_OP";
            case 507L: return "NEW_OP";
            case 508L: return "NodeTag";
            case 509L: return "NOEXCEPT_OP";
            case 510L: return "NE_OP";
            case 511L: return "NOT_OP";
            case 512L: return "NON_MEMBERSHIP_OP";
            case 513L: return "NONREAL_DECL";
            case 514L: return "NONREAL_REF";
            case 515L: return "NONREAL_SYMBOL";
            case 516L: return "T_NONREAL";
            case 517L: return "NonrealBaseClassTag";
            case 518L: return "NULL_EXPR";
            case 519L: return "NULLPTR_VAL";
            case 520L: return "NULL_STMT";
            case 521L: return "TEMP_Nullify_Statement";
            case 522L: return "OMP_ATOMIC_STMT";
            case 523L: return "OMP_BARRIER_STMT";
            case 524L: return "OMP_CRITICAL_STMT";
            case 525L: return "OMP_CLAUSEBODY_STMT";
            case 526L: return "OMP_BODY_STMT";
            case 527L: return "OMP_DO_STMT";
            case 528L: return "OMP_FLUSH_STMT";
            case 529L: return "OMP_DECLARE_SIMD_STMT";
            case 530L: return "OMP_FOR_STMT";
            case 531L: return "OMP_FOR_SIMD_STMT";
            case 532L: return "OMP_MASTER_STMT";
            case 533L: return "OMP_ORDERED_STMT";
            case 534L: return "OMP_PARALLEL_STMT";
            case 535L: return "OMP_SECTION_STMT";
            case 536L: return "OMP_SECTIONS_STMT";
            case 537L: return "OMP_SINGLE_STMT";
            case 538L: return "OMP_TASK_STMT";
            case 539L: return "OMP_TASKWAIT_STMT";
            case 540L: return "OMP_THREADPRIVATE_STMT";
            case 541L: return "OMP_WORKSHARE_STMT";
            case 542L: return "OMP_TARGET_STMT";
            case 543L: return "OMP_TARGET_DATA_STMT";
            case 544L: return "OMP_SIMD_STMT";
            case 545L: return "OmpClauseTag";
            case 546L: return "OmpBeginClauseTag";
            case 547L: return "OmpCollapseClauseTag";
            case 548L: return "OmpCopyinClauseTag";
            case 549L: return "OmpCopyprivateClauseTag";
            case 550L: return "OmpDefaultClauseTag";
            case 551L: return "OmpEndClauseTag";
            case 552L: return "OmpExpressionClauseTag";
            case 553L: return "OmpFirstprivateClauseTag";
            case 554L: return "OmpIfClauseTag";
            case 555L: return "OmpFinalClauseTag";
            case 556L: return "OmpPriorityClauseTag";
            case 557L: return "OmpIfDeviceTag";
            case 558L: return "OmpLastprivateClauseTag";
            case 559L: return "OmpNowaitClauseTag";
            case 560L: return "OmpNumThreadsClauseTag";
            case 561L: return "OmpOrderedClauseTag";
            case 562L: return "OmpPrivateClauseTag";
            case 563L: return "OmpReductionClauseTag";
            case 564L: return "OmpScheduleClauseTag";
            case 565L: return "OmpSharedClauseTag";
            case 566L: return "OmpUntiedClauseTag";
            case 567L: return "OmpMergeableClauseTag";
            case 568L: return "OmpVariablesClauseTag";
            case 569L: return "OmpMapClauseTag";
            case 570L: return "OmpSafelenTag";
            case 571L: return "OmpSimdlenTag";
            case 572L: return "OmpLinearClauseTag";
            case 573L: return "OmpUniformClauseTag";
            case 574L: return "OmpAlignedClauseTag";
            case 575L: return "OmpProcBindClauseTag";
            case 576L: return "OmpAtomicClauseTag";
            case 577L: return "OmpInbranchClauseTag";
            case 578L: return "OmpNotinbranchClauseTag";
            case 579L: return "OmpDependClauseTag";
            case 580L: return "OPENCL_ACCESS_MODE";
            case 581L: return "OPEN_STATEMENT";
            case 582L: return "OptionsTag";
            case 583L: return "OR_OP";
            case 584L: return "PARAMETER_STATEMENT";
            case 585L: return "T_PARTIAL_FUNCTION_MODIFIER";
            case 586L: return "T_PARTIAL_FUNCTION";
            case 587L: return "PASS_STATEMENT";
            case 588L: return "PLUS_ASSIGN_OP";
            case 589L: return "PLUSPLUS_OP";
            case 590L: return "ARRAY_OP";
            case 591L: return "POINTER_ASSIGN_OP";
            case 592L: return "DEREF_OP";
            case 593L: return "T_MEMBER_POINTER";
            case 594L: return "T_POINTER";
            case 595L: return "POWER_OP";
            case 596L: return "PragmaTag";
            case 597L: return "PRAGMA_DECL";
            case 598L: return "PRINT_STATEMENT";
            case 599L: return "PROCEDURE_HEADER_STMT";
            case 600L: return "PROGRAM_HEADER_STMT";
            case 601L: return "ProjectTag";
            case 602L: return "PSEUDO_DESTRUCTOR_REF";
            case 603L: return "PYTHON_GLOBAL_STMT";
            case 604L: return "PYTHON_PRINT_STMT";
            case 605L: return "QualifiedNameTag";
            case 606L: return "T_QUALIFIED_NAME";
            case 607L: return "RANGE_EXP";
            case 608L: return "RANGE_BASED_FOR_STMT";
            case 609L: return "READ_STATEMENT";
            case 610L: return "REAL_PART_OP";
            case 611L: return "TYPE_REF";
            case 612L: return "T_REFERENCE";
            case 613L: return "TEMP_Rename_Pair";
            case 614L: return "RENAME_SYMBOL";
            case 615L: return "RETURN_STMT";
            case 616L: return "REWIND_STATEMENT";
            case 617L: return "RSHIFT_ASSIGN_OP";
            case 618L: return "RSHIFT_OP";
            case 619L: return "T_RVALUE_REFERENCE";
            case 620L: return "JAVA_UNSIGNED_RSHIFT_ASSIGN_OP";
            case 621L: return "JAVA_UNSIGNED_RSHIFT_OP";
            case 622L: return "SCOPE_OP";
            case 623L: return "SCOPE_STMT";
            case 624L: return "TEMP_Sequence_Statement";
            case 625L: return "SET_COMPREHENSION";
            case 626L: return "SHORT_VAL";
            case 627L: return "SIZEOF_OP";
            case 628L: return "ALIGNOF_OP";
            case 629L: return "JAVA_INSTANCEOF_OP";
            case 630L: return "SourceFileTag";
            case 631L: return "SPAWN_STMT";
            case 632L: return "SYNC_ALL_STATEMENT";
            case 633L: return "SYNC_IMAGES_STATEMENT";
            case 634L: return "SYNC_MEMORY_STATEMENT";
            case 635L: return "SYNC_TEAM_STATEMENT";
            case 636L: return "LOCK_STATEMENT";
            case 637L: return "UNLOCK_STATEMENT";
            case 638L: return "JAVE_THROW_STMT";
            case 639L: return "JAVA_FOREACH_STMT";
            case 640L: return "JAVA_SYNC_STMT";
            case 641L: return "T_JAVA_PARAM";
            case 642L: return "T_JAVA_WILD";
            case 643L: return "SpecialFunctionModifierTag";
            case 644L: return "StatementTag";
            case 645L: return "STATIC_ASSERTION_DECLARATION";
            case 646L: return "STMT_DECL_STMT";
            case 647L: return "STMT_EXPR";
            case 648L: return "TEMP_Statement_Function_Statement";
            case 649L: return "STOP_OR_PAUSE_STATEMENT";
            case 650L: return "StorageModifierTag";
            case 651L: return "STR_CONV";
            case 652L: return "StringKeyedBidirectionalGraphTag";
            case 653L: return "STRING_VAL";
            case 654L: return "SUBSCRIPT_EXPR";
            case 655L: return "SUBT_OP";
            case 656L: return "SupportTag";
            case 657L: return "SWITCH_STMT";
            case 658L: return "SymbolTag";
            case 659L: return "SymbolTableTag";
            case 660L: return "TemplateArgumentTag";
            case 661L: return "TemplateArgumentListTag";
            case 662L: return "TEMPLATE_DECL_STMT";
            case 663L: return "TEMPLATE_CLASS_DECL_STMT";
            case 664L: return "TEMPLATE_CLASS_NAME";
            case 665L: return "TEMPLATE_FUNCTION_DECL_STMT";
            case 666L: return "TEMPLATE_FUNCTION_REF";
            case 667L: return "TEMPLATE_FUNC_NAME";
            case 668L: return "TEMPLATE_MEMBER_FUNCTION_DECL_STMT";
            case 669L: return "TEMPLATE_MEMBER_FUNCTION_REF";
            case 670L: return "TEMPLATE_MEMBER_FUNC_NAME";
            case 671L: return "TEMPLATE_TYPEDEF_DECL_STMT";
            case 672L: return "TEMPLATE_TYPEDEF_NAME";
            case 673L: return "TEMPLATE_VARIABLE_DECL_STMT";
            case 674L: return "TEMPLATE_VARIABLE_NAME";
            case 675L: return "TEMPLATE_CLASS_DEF_STMT";
            case 676L: return "TEMPLATE_FUNCTION_DEF_STMT";
            case 677L: return "TEMPLATE_INST_DECL_STMT";
            case 678L: return "TEMPLATE_INST_DEFN_STMT";
            case 679L: return "TEMPLATE_INST_DIRECTIVE_STMT";
            case 680L: return "TEMPLATE_INST_FUNCTION_DECL_STMT";
            case 681L: return "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT";
            case 682L: return "TEMPLATE_INST_TYPEDEF_DECL_STMT";
            case 683L: return "TemplateParameterTag";
            case 684L: return "TEMPLATE_PARAMETER_VAL";
            case 685L: return "TemplateParameterListTag";
            case 686L: return "TEMPLATE_NAME";
            case 687L: return "T_TEMPLATE";
            case 688L: return "THIS_NODE";
            case 689L: return "TYPE_TRAIT_BUILTIN_OPERATOR";
            case 690L: return "SUPER_NODE";
            case 691L: return "THROW_OP";
            case 692L: return "TOKEN";
            case 693L: return "TRY_STMT";
            case 694L: return "TUPLE_EXP";
            case 695L: return "TypeTag";
            case 696L: return "T_BOOL";
            case 697L: return "T_CHAR";
            case 698L: return "T_CHAR16";
            case 699L: return "T_CHAR32";
            case 700L: return "T_COMPLEX";
            case 701L: return "T_DEFAULT";
            case 702L: return "TYPE_EXPRESSION";
            case 703L: return "T_LABEL";
            case 704L: return "T_DOUBLE";
            case 705L: return "T_ELLIPSE";
            case 706L: return "T_FLOAT";
            case 707L: return "T_FLOAT128";
            case 708L: return "T_FLOAT80";
            case 709L: return "T_GLOBAL_VOID";
            case 710L: return "TYPEID_OP";
            case 711L: return "T_IMAGINARY";
            case 712L: return "T_INT";
            case 713L: return "T_LONG";
            case 714L: return "T_LONG_DOUBLE";
            case 715L: return "T_LONG_LONG";
            case 716L: return "TypeModifierTag";
            case 717L: return "T_MATRIX";
            case 718L: return "T_TUPLE";
            case 719L: return "T_NULLPTR";
            case 720L: return "T_TYPEOF_TYPE";
            case 721L: return "T_SHORT";
            case 722L: return "T_SIGNED_128BIT_INTEGER";
            case 723L: return "T_SIGNED_CHAR";
            case 724L: return "T_SIGNED_INT";
            case 725L: return "T_SIGNED_LONG";
            case 726L: return "T_SIGNED_LONG_LONG";
            case 727L: return "T_SIGNED_SHORT";
            case 728L: return "T_STRING";
            case 729L: return "T_UNKNOWN";
            case 730L: return "T_UNSIGNED_128BIT_INTEGER";
            case 731L: return "T_UNSIGNED_CHAR";
            case 732L: return "T_UNSIGNED_INT";
            case 733L: return "T_UNSIGNED_LONG";
            case 734L: return "T_UNSIGNED_LONG_LONG";
            case 735L: return "T_UNSIGNED_SHORT";
            case 736L: return "T_VOID";
            case 737L: return "T_WCHAR";
            case 738L: return "TYPEDEF_STMT";
            case 739L: return "T_TYPEDEF_SEQ";
            case 740L: return "TYPEDEF_NAME";
            case 741L: return "T_TYPEDEF";
            case 742L: return "UPC_AccessModifierTag";
            case 743L: return "UNARY_ADD_OP";
            case 744L: return "UNARY_EXPRESSION";
            case 745L: return "UNDEF_DIRECTIVE_STMT";
            case 746L: return "UndirectedGraphEdgeTag";
            case 747L: return "TEMP_UnknownArrayOrFunctionReference";
            case 748L: return "UnknownFileTag";
            case 750L: return "Unparse_InfoTag";
            case 751L: return "UNSIGNED_CHAR_VAL";
            case 752L: return "UNSIGNED_INT_VAL";
            case 753L: return "UNSIGNED_LONG_LONG_INT_VAL";
            case 754L: return "UNSIGNED_LONG_INT_VAL";
            case 755L: return "UNSIGNED_SHORT_VAL";
            case 756L: return "UntypedNodeTag";
            case 757L: return "UntypedExpressionTag";
            case 758L: return "TEMP_UntypedUnaryOperator";
            case 759L: return "TEMP_UntypedBinaryOperator";
            case 760L: return "TEMP_UntypedValueExpression";
            case 761L: return "TEMP_UntypedArrayReferenceExpression";
            case 762L: return "TEMP_UntypedSubscriptExpression";
            case 763L: return "TEMP_UntypedOtherExpression";
            case 764L: return "TEMP_UntypedNamedExpression";
            case 765L: return "TEMP_UntypedNullExpression";
            case 766L: return "TEMP_UntypedExprListExpression";
            case 767L: return "TEMP_UntypedFunctionCallOrArrayReferenceExpression";
            case 768L: return "UntypedStatementTag";
            case 769L: return "TEMP_UntypedLabelStatement";
            case 770L: return "TEMP_UntypedNamedStatement";
            case 771L: return "TEMP_UntypedAssignmentStatement";
            case 772L: return "TEMP_UntypedBlockStatement";
            case 773L: return "TEMP_UntypedExpressionStatement";
            case 774L: return "TEMP_UntypedForAllStatement";
            case 775L: return "TEMP_UntypedFunctionCallStatement";
            case 776L: return "TEMP_UntypedImageControlStatement";
            case 777L: return "TEMP_UntypedOtherStatement";
            case 778L: return "TEMP_UntypedUseStatement";
            case 779L: return "UntypedDeclarationStatementTag";
            case 780L: return "TEMP_UntypedDirectiveDeclaration";
            case 781L: return "TEMP_UntypedEnumDeclaration";
            case 782L: return "TEMP_UntypedInitializedName";
            case 783L: return "TEMP_UntypedName";
            case 784L: return "TEMP_UntypedNameListDeclaration";
            case 785L: return "TEMP_UntypedInitializedNameListDeclaration";
            case 786L: return "TEMP_UntypedImplicitDeclaration";
            case 787L: return "TEMP_UntypedVariableDeclaration";
            case 788L: return "TEMP_UntypedTypedefDeclaration";
            case 789L: return "TEMP_UntypedProgramHeaderDeclaration";
            case 790L: return "UntypedFunctionDeclarationTag";
            case 791L: return "TEMP_UntypedSubroutineDeclaration";
            case 792L: return "TEMP_UntypedInterfaceDeclaration";
            case 793L: return "TEMP_UntypedNullDeclaration";
            case 794L: return "TEMP_UntypedNullStatement";
            case 795L: return "TEMP_UntypedIfStatement";
            case 796L: return "TEMP_UntypedCaseStatement";
            case 797L: return "TEMP_UntypedLoopStatement";
            case 798L: return "TEMP_UntypedWhileStatement";
            case 799L: return "TEMP_UntypedForStatement";
            case 800L: return "TEMP_UntypedExitStatement";
            case 801L: return "TEMP_UntypedGotoStatement";
            case 802L: return "TEMP_UntypedProcedureCallStatement";
            case 803L: return "TEMP_UntypedReturnStatement";
            case 804L: return "TEMP_UntypedExtendedReturnStatement";
            case 805L: return "TEMP_UntypedStopStatement";
            case 806L: return "TEMP_UntypedAcceptStatement";
            case 807L: return "TEMP_UntypedEntryCallStatement";
            case 808L: return "TEMP_UntypedRequeueStatement";
            case 809L: return "TEMP_UntypedDelayUntilStatement";
            case 810L: return "TEMP_UntypedDelayRelativeStatement";
            case 811L: return "TEMP_UntypedTerminateAlternativeStatement";
            case 812L: return "TEMP_UntypedSelectiveAcceptStatement";
            case 813L: return "TEMP_UntypedTimedEntryCallStatement";
            case 814L: return "TEMP_UntypedConditionalEntryCallStatement";
            case 815L: return "TEMP_UntypedAsynchronousSelectStatement";
            case 816L: return "TEMP_UntypedAbortStatement";
            case 817L: return "TEMP_UntypedRaiseStatement";
            case 818L: return "TEMP_UntypedCodeStatement";
            case 819L: return "TEMP_UntypedReferenceExpression";
            case 820L: return "TEMP_UntypedToken";
            case 821L: return "TEMP_UntypedTokenPair";
            case 822L: return "UntypedTypeTag";
            case 823L: return "TEMP_UntypedArrayType";
            case 824L: return "TEMP_UntypedTableType";
            case 825L: return "TEMP_UntypedAttribute";
            case 826L: return "TEMP_UntypedFile";
            case 827L: return "UntypedScopeTag";
            case 828L: return "TEMP_UntypedFunctionScope";
            case 829L: return "TEMP_UntypedModuleScope";
            case 830L: return "TEMP_UntypedGlobalScope";
            case 831L: return "TEMP_UntypedModuleDeclaration";
            case 832L: return "TEMP_UntypedSubmoduleDeclaration";
            case 833L: return "TEMP_UntypedBlockDataDeclaration";
            case 834L: return "TEMP_UntypedStructureDeclaration";
            case 835L: return "TEMP_UntypedStructureDefinition";
            case 836L: return "TEMP_UntypedPackageDeclaration";
            case 837L: return "TEMP_UntypedExceptionDeclaration";
            case 838L: return "TEMP_UntypedExceptionHandlerDeclaration";
            case 839L: return "TEMP_UntypedTaskDeclaration";
            case 840L: return "TEMP_UntypedUnitDeclaration";
            case 841L: return "TEMP_UntypedStatementList";
            case 842L: return "TEMP_UntypedDeclarationStatementList";
            case 843L: return "TEMP_UntypedFunctionDeclarationList";
            case 844L: return "TEMP_UntypedInitializedNameList";
            case 845L: return "TEMP_UntypedNameList";
            case 846L: return "TEMP_UntypedTokenList";
            case 847L: return "TEMP_UntypedTokenPairList";
            case 848L: return "UPC_BARRIER_STMT";
            case 849L: return "UPC_BLOCK_SIZEOF_EXPR";
            case 850L: return "UPC_ELEM_SIZEOF_EXPR";
            case 851L: return "UPC_FENCE_STMT";
            case 852L: return "UPC_FORALL_STMT";
            case 853L: return "UPC_LOCAL_SIZEOF_EXPR";
            case 854L: return "UPC_MYTHREAD";
            case 855L: return "UPC_NOTIFY_STMT";
            case 856L: return "UPC_THREADS";
            case 857L: return "UPC_WAIT_STMT";
            case 858L: return "USE_STATEMENT";
            case 859L: return "USER_DEFINED_BINARY_OP";
            case 860L: return "USER_DEFINED_UNARY_OP";
            case 861L: return "USING_DECLARATION_STMT";
            case 862L: return "USING_DIRECTIVE_STMT";
            case 863L: return "ValueExpTag";
            case 864L: return "VA_COPY_OP";
            case 865L: return "VA_END_OP";
            case 866L: return "VA_OP";
            case 867L: return "VA_START_ONE_OPERAND_OP";
            case 868L: return "VA_START_OP";
            case 869L: return "VAR_REF";
            case 870L: return "VAR_DECL_STMT";
            case 871L: return "VAR_DEFN_STMT";
            case 872L: return "VARIABLE_NAME";
            case 873L: return "VARIANT_EXPR";
            case 874L: return "VARIANT_STMT";
            case 875L: return "VOID_VAL";
            case 876L: return "WAIT_STATEMENT";
            case 877L: return "WARNING_DIRECTIVE_STMT";
            case 878L: return "WITH_STATEMENT";
            case 879L: return "WCHAR_VAL";
            case 880L: return "TEMP_Where_Statement";
            case 881L: return "WHILE_STMT";
            case 882L: return "WRITE_STATEMENT";
            case 883L: return "XOR_ASSIGN_OP";
            case 884L: return "YIELD_EXP";
            case 885L: return "_File_InfoTag";
            case 886L: return "T_CAFTEAM";
            case 887L: return "WITHTEAM_STMT";
            case 888L: return "COARRAY_REF_EXPR";
            case 889L: return "CALL_EXPRESSION";
            case 890L: return "T_CRAY_POINTER";
            case 891L: return "TEMP_JavaImportStatement";
            case 892L: return "TEMP_JavaPackageDeclaration";
            case 893L: return "TEMP_JavaPackageStatement";
            case 894L: return "JavaImportStatementListTag";
            case 895L: return "JavaClassDeclarationListTag";
            case 896L: return "JavaMemberValuePairTag";
            case 897L: return "JAVA_ANNOTATION";
            case 898L: return "JAVA_MARKER_ANNOTATION";
            case 899L: return "JAVA_SINGLE_MEMBER_ANNOTATION";
            case 900L: return "JAVA_NORMAL_ANNOTATION";
            case 901L: return "JAVA_TYPE_EXPRESSION";
            case 902L: return "T_JAVA_QUALIFIED";
            case 903L: return "CLASS_NODE";
            case 904L: return "T_JAVA_UNION";
            case 905L: return "T_JAVA_PARAMETER";
            case 906L: return "T_JOVIAL_TABLE";
            case 907L: return "ASYNC_STMT";
            case 908L: return "FINISH_STMT";
            case 909L: return "AT_STMT";
            case 910L: return "ATOMIC_STMT";
            case 912L: return "WHEN_STMT";
            case 913L: return "ATEXP_NODE";
            case 914L: return "FINISHEXP_NODE";
            case 915L: return "HERE_NODE";
            case 916L: return "DOTDOT_NODE";
            case 918L: return "Cxx_Grammar_UNKNOWN_GRAMMAR";
            case 919L: return "Cxx_Grammar_LAST_TAG";
            default: return "";
        }
    }

    std::string Cxx_GrammarVariants(int64_t i, const std::string &strip) {
        std::string s = Cxx_GrammarVariants(i);
        if (s.empty())
            s = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Cxx_GrammarVariants() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            329L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            912L,
            913L,
            914L,
            915L,
            916L,
            918L,
            919L
        };
        static const std::vector<int64_t> retval(values, values + 913);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCxx_GrammarVariants(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cxx_GrammarVariants(i);
        if (retval.empty()) {
            retval = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cxx_GrammarVariants::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCxx_GrammarVariants() {
        return stringify::Cxx_GrammarVariants();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 934
namespace stringify {
    const char* VariantT(int64_t i) {
        switch (i) {
            case 1L: return "V_SgAccessModifier";
            case 2L: return "V_SgActualArgumentExpression";
            case 3L: return "V_SgAddOp";
            case 4L: return "V_SgAddressOfOp";
            case 5L: return "V_SgAggregateInitializer";
            case 6L: return "V_SgAliasSymbol";
            case 7L: return "V_SgAllocateStatement";
            case 8L: return "V_SgAndAssignOp";
            case 9L: return "V_SgAndOp";
            case 10L: return "V_SgArithmeticIfStatement";
            case 11L: return "V_SgArrayType";
            case 12L: return "V_SgArrowExp";
            case 13L: return "V_SgArrowStarOp";
            case 14L: return "V_SgAsmArmInstruction";
            case 15L: return "V_SgAsmBasicString";
            case 16L: return "V_SgAsmBinaryAdd";
            case 17L: return "V_SgAsmBinaryAddPostupdate";
            case 18L: return "V_SgAsmBinaryAddPreupdate";
            case 19L: return "V_SgAsmBinaryAsr";
            case 20L: return "V_SgAsmBinaryDivide";
            case 21L: return "V_SgAsmBinaryExpression";
            case 22L: return "V_SgAsmBinaryLsl";
            case 23L: return "V_SgAsmBinaryLsr";
            case 24L: return "V_SgAsmBinaryMod";
            case 25L: return "V_SgAsmBinaryMultiply";
            case 26L: return "V_SgAsmBinaryRor";
            case 27L: return "V_SgAsmBinarySubtract";
            case 28L: return "V_SgAsmBinarySubtractPostupdate";
            case 29L: return "V_SgAsmBinarySubtractPreupdate";
            case 30L: return "V_SgAsmBlock";
            case 31L: return "V_SgAsmCoffStrtab";
            case 32L: return "V_SgAsmCoffSymbol";
            case 33L: return "V_SgAsmCoffSymbolList";
            case 34L: return "V_SgAsmCoffSymbolTable";
            case 35L: return "V_SgAsmCommonSubExpression";
            case 36L: return "V_SgAsmControlFlagsExpression";
            case 37L: return "V_SgAsmConstantExpression";
            case 38L: return "V_SgAsmDOSExtendedHeader";
            case 39L: return "V_SgAsmDOSFileHeader";
            case 40L: return "V_SgAsmSynthesizedDataStructureDeclaration";
            case 41L: return "V_SgAsmSynthesizedDeclaration";
            case 42L: return "V_SgAsmDirectRegisterExpression";
            case 43L: return "V_SgAsmDwarfAccessDeclaration";
            case 44L: return "V_SgAsmDwarfArrayType";
            case 45L: return "V_SgAsmDwarfBaseType";
            case 46L: return "V_SgAsmDwarfCatchBlock";
            case 47L: return "V_SgAsmDwarfClassTemplate";
            case 48L: return "V_SgAsmDwarfClassType";
            case 49L: return "V_SgAsmDwarfCommonBlock";
            case 50L: return "V_SgAsmDwarfCommonInclusion";
            case 51L: return "V_SgAsmDwarfCompilationUnit";
            case 52L: return "V_SgAsmDwarfCompilationUnitList";
            case 53L: return "V_SgAsmDwarfCondition";
            case 54L: return "V_SgAsmDwarfConstType";
            case 55L: return "V_SgAsmDwarfConstant";
            case 56L: return "V_SgAsmDwarfConstruct";
            case 57L: return "V_SgAsmDwarfConstructList";
            case 58L: return "V_SgAsmDwarfDwarfProcedure";
            case 59L: return "V_SgAsmDwarfEntryPoint";
            case 60L: return "V_SgAsmDwarfEnumerationType";
            case 61L: return "V_SgAsmDwarfEnumerator";
            case 62L: return "V_SgAsmDwarfFileType";
            case 63L: return "V_SgAsmDwarfFormalParameter";
            case 64L: return "V_SgAsmDwarfFormatLabel";
            case 65L: return "V_SgAsmDwarfFriend";
            case 66L: return "V_SgAsmDwarfFunctionTemplate";
            case 67L: return "V_SgAsmDwarfImportedDeclaration";
            case 68L: return "V_SgAsmDwarfImportedModule";
            case 69L: return "V_SgAsmDwarfImportedUnit";
            case 70L: return "V_SgAsmDwarfInformation";
            case 71L: return "V_SgAsmDwarfInheritance";
            case 72L: return "V_SgAsmDwarfInlinedSubroutine";
            case 73L: return "V_SgAsmDwarfInterfaceType";
            case 74L: return "V_SgAsmDwarfLabel";
            case 75L: return "V_SgAsmDwarfLexicalBlock";
            case 76L: return "V_SgAsmDwarfLine";
            case 77L: return "V_SgAsmDwarfLineList";
            case 78L: return "V_SgAsmDwarfMacro";
            case 79L: return "V_SgAsmDwarfMacroList";
            case 80L: return "V_SgAsmDwarfMember";
            case 81L: return "V_SgAsmDwarfModule";
            case 82L: return "V_SgAsmDwarfMutableType";
            case 83L: return "V_SgAsmDwarfNamelist";
            case 84L: return "V_SgAsmDwarfNamelistItem";
            case 85L: return "V_SgAsmDwarfNamespace";
            case 86L: return "V_SgAsmDwarfPackedType";
            case 87L: return "V_SgAsmDwarfPartialUnit";
            case 88L: return "V_SgAsmDwarfPointerType";
            case 89L: return "V_SgAsmDwarfPtrToMemberType";
            case 90L: return "V_SgAsmDwarfReferenceType";
            case 91L: return "V_SgAsmDwarfRestrictType";
            case 92L: return "V_SgAsmDwarfSetType";
            case 93L: return "V_SgAsmDwarfSharedType";
            case 94L: return "V_SgAsmDwarfStringType";
            case 95L: return "V_SgAsmDwarfStructureType";
            case 96L: return "V_SgAsmDwarfSubprogram";
            case 97L: return "V_SgAsmDwarfSubrangeType";
            case 98L: return "V_SgAsmDwarfSubroutineType";
            case 99L: return "V_SgAsmDwarfTemplateTypeParameter";
            case 100L: return "V_SgAsmDwarfTemplateValueParameter";
            case 101L: return "V_SgAsmDwarfThrownType";
            case 102L: return "V_SgAsmDwarfTryBlock";
            case 103L: return "V_SgAsmDwarfTypedef";
            case 104L: return "V_SgAsmDwarfUnionType";
            case 105L: return "V_SgAsmDwarfUnknownConstruct";
            case 106L: return "V_SgAsmDwarfUnspecifiedParameters";
            case 107L: return "V_SgAsmDwarfUnspecifiedType";
            case 108L: return "V_SgAsmDwarfUpcRelaxedType";
            case 109L: return "V_SgAsmDwarfUpcSharedType";
            case 110L: return "V_SgAsmDwarfUpcStrictType";
            case 111L: return "V_SgAsmDwarfVariable";
            case 112L: return "V_SgAsmDwarfVariant";
            case 113L: return "V_SgAsmDwarfVariantPart";
            case 114L: return "V_SgAsmDwarfVolatileType";
            case 115L: return "V_SgAsmDwarfWithStmt";
            case 116L: return "V_SgAsmElfDynamicEntry";
            case 117L: return "V_SgAsmElfDynamicEntryList";
            case 118L: return "V_SgAsmElfDynamicSection";
            case 119L: return "V_SgAsmElfEHFrameEntryCI";
            case 120L: return "V_SgAsmElfEHFrameEntryCIList";
            case 121L: return "V_SgAsmElfEHFrameEntryFD";
            case 122L: return "V_SgAsmElfEHFrameEntryFDList";
            case 123L: return "V_SgAsmElfEHFrameSection";
            case 124L: return "V_SgAsmElfFileHeader";
            case 125L: return "V_SgAsmElfNoteEntry";
            case 126L: return "V_SgAsmElfNoteEntryList";
            case 127L: return "V_SgAsmElfNoteSection";
            case 128L: return "V_SgAsmElfRelocEntry";
            case 129L: return "V_SgAsmElfRelocEntryList";
            case 130L: return "V_SgAsmElfRelocSection";
            case 131L: return "V_SgAsmElfSection";
            case 132L: return "V_SgAsmElfSectionTable";
            case 133L: return "V_SgAsmElfSectionTableEntry";
            case 134L: return "V_SgAsmElfSegmentTable";
            case 135L: return "V_SgAsmElfSegmentTableEntry";
            case 136L: return "V_SgAsmElfSegmentTableEntryList";
            case 137L: return "V_SgAsmElfStringSection";
            case 138L: return "V_SgAsmElfStrtab";
            case 139L: return "V_SgAsmElfSymbol";
            case 140L: return "V_SgAsmElfSymbolList";
            case 141L: return "V_SgAsmElfSymbolSection";
            case 142L: return "V_SgAsmElfSymverDefinedAux";
            case 143L: return "V_SgAsmElfSymverDefinedAuxList";
            case 144L: return "V_SgAsmElfSymverDefinedEntry";
            case 145L: return "V_SgAsmElfSymverDefinedEntryList";
            case 146L: return "V_SgAsmElfSymverDefinedSection";
            case 147L: return "V_SgAsmElfSymverEntry";
            case 148L: return "V_SgAsmElfSymverEntryList";
            case 149L: return "V_SgAsmElfSymverNeededAux";
            case 150L: return "V_SgAsmElfSymverNeededAuxList";
            case 151L: return "V_SgAsmElfSymverNeededEntry";
            case 152L: return "V_SgAsmElfSymverNeededEntryList";
            case 153L: return "V_SgAsmElfSymverNeededSection";
            case 154L: return "V_SgAsmElfSymverSection";
            case 155L: return "V_SgAsmExecutableFileFormat";
            case 156L: return "V_SgAsmExprListExp";
            case 157L: return "V_SgAsmExpression";
            case 158L: return "V_SgAsmSynthesizedFieldDeclaration";
            case 159L: return "V_SgAsmFloatType";
            case 160L: return "V_SgAsmFloatValueExpression";
            case 161L: return "V_SgAsmFunction";
            case 162L: return "V_SgAsmGenericDLL";
            case 163L: return "V_SgAsmGenericDLLList";
            case 164L: return "V_SgAsmGenericFile";
            case 165L: return "V_SgAsmGenericFileList";
            case 166L: return "V_SgAsmGenericFormat";
            case 167L: return "V_SgAsmGenericHeader";
            case 168L: return "V_SgAsmGenericHeaderList";
            case 169L: return "V_SgAsmGenericSection";
            case 170L: return "V_SgAsmGenericSectionList";
            case 171L: return "V_SgAsmGenericString";
            case 172L: return "V_SgAsmGenericStrtab";
            case 173L: return "V_SgAsmGenericSymbol";
            case 174L: return "V_SgAsmGenericSymbolList";
            case 175L: return "V_SgAsmIndirectRegisterExpression";
            case 176L: return "V_SgAsmInstruction";
            case 177L: return "V_SgAsmIntegerValueExpression";
            case 178L: return "V_SgAsmIntegerType";
            case 179L: return "V_SgAsmInterpretation";
            case 180L: return "V_SgAsmInterpretationList";
            case 181L: return "V_SgAsmLEEntryPoint";
            case 182L: return "V_SgAsmLEEntryTable";
            case 183L: return "V_SgAsmLEFileHeader";
            case 184L: return "V_SgAsmLENameTable";
            case 185L: return "V_SgAsmLEPageTable";
            case 186L: return "V_SgAsmLEPageTableEntry";
            case 187L: return "V_SgAsmLERelocTable";
            case 188L: return "V_SgAsmLESection";
            case 189L: return "V_SgAsmLESectionTable";
            case 190L: return "V_SgAsmLESectionTableEntry";
            case 191L: return "V_SgAsmM68kInstruction";
            case 192L: return "V_SgAsmMemoryReferenceExpression";
            case 193L: return "V_SgAsmMipsInstruction";
            case 194L: return "V_SgAsmNEEntryPoint";
            case 195L: return "V_SgAsmNEEntryTable";
            case 196L: return "V_SgAsmNEFileHeader";
            case 197L: return "V_SgAsmNEModuleTable";
            case 198L: return "V_SgAsmNENameTable";
            case 199L: return "V_SgAsmNERelocEntry";
            case 200L: return "V_SgAsmNERelocTable";
            case 201L: return "V_SgAsmNESection";
            case 202L: return "V_SgAsmNESectionTable";
            case 203L: return "V_SgAsmNESectionTableEntry";
            case 204L: return "V_SgAsmNEStringTable";
            case 205L: return "V_SgAsmNode";
            case 206L: return "V_SgAsmOp";
            case 207L: return "V_SgAsmOperandList";
            case 208L: return "V_SgAsmPEExportDirectory";
            case 209L: return "V_SgAsmPEExportEntry";
            case 210L: return "V_SgAsmPEExportEntryList";
            case 211L: return "V_SgAsmPEExportSection";
            case 212L: return "V_SgAsmPEFileHeader";
            case 213L: return "V_SgAsmPEImportDirectory";
            case 214L: return "V_SgAsmPEImportDirectoryList";
            case 215L: return "V_SgAsmPEImportItem";
            case 216L: return "V_SgAsmPEImportItemList";
            case 217L: return "V_SgAsmPEImportSection";
            case 218L: return "V_SgAsmPERVASizePair";
            case 219L: return "V_SgAsmPERVASizePairList";
            case 220L: return "V_SgAsmPESection";
            case 221L: return "V_SgAsmPESectionTable";
            case 222L: return "V_SgAsmPESectionTableEntry";
            case 223L: return "V_SgAsmPEStringSection";
            case 224L: return "V_SgAsmPowerpcInstruction";
            case 225L: return "V_SgAsmRegisterNames";
            case 226L: return "V_SgAsmRegisterReferenceExpression";
            case 227L: return "V_SgAsmRiscOperation";
            case 228L: return "V_SgAsmScalarType";
            case 229L: return "V_SgAsmStatement";
            case 230L: return "V_SgAsmStaticData";
            case 231L: return "V_SgAsmStmt";
            case 232L: return "V_SgAsmStoredString";
            case 233L: return "V_SgAsmStringStorage";
            case 234L: return "V_SgAsmType";
            case 235L: return "V_SgAsmUnaryArmSpecialRegisterList";
            case 236L: return "V_SgAsmUnaryExpression";
            case 237L: return "V_SgAsmUnaryMinus";
            case 238L: return "V_SgAsmUnaryPlus";
            case 239L: return "V_SgAsmUnaryRrx";
            case 240L: return "V_SgAsmValueExpression";
            case 241L: return "V_SgAsmVectorType";
            case 242L: return "V_SgAsmX86Instruction";
            case 243L: return "V_SgAsmBinaryAddressSymbol";
            case 244L: return "V_SgAsmBinaryDataSymbol";
            case 245L: return "V_SgAssertStmt";
            case 246L: return "V_SgAssignInitializer";
            case 247L: return "V_SgAssignOp";
            case 248L: return "V_SgAssignStatement";
            case 249L: return "V_SgAssignedGotoStatement";
            case 250L: return "V_SgAssociateStatement";
            case 251L: return "V_SgAsteriskShapeExp";
            case 252L: return "V_SgAttribute";
            case 253L: return "V_SgAttributeSpecificationStatement";
            case 254L: return "V_SgAutoType";
            case 255L: return "V_SgBackspaceStatement";
            case 256L: return "V_SgBaseClass";
            case 257L: return "V_SgExpBaseClass";
            case 258L: return "V_SgBaseClassModifier";
            case 259L: return "V_SgBasicBlock";
            case 260L: return "V_SgBidirectionalGraph";
            case 261L: return "V_SgBinaryComposite";
            case 262L: return "V_SgBinaryOp";
            case 263L: return "V_SgBitAndOp";
            case 264L: return "V_SgBitAttribute";
            case 265L: return "V_SgBitComplementOp";
            case 266L: return "V_SgBitOrOp";
            case 267L: return "V_SgBitXorOp";
            case 268L: return "V_SgBlockDataStatement";
            case 269L: return "V_SgBoolValExp";
            case 270L: return "V_SgBreakStmt";
            case 271L: return "V_SgBracedInitializer";
            case 272L: return "V_SgC_PreprocessorDirectiveStatement";
            case 273L: return "V_SgCaseOptionStmt";
            case 274L: return "V_SgCastExp";
            case 275L: return "V_SgCatchOptionStmt";
            case 276L: return "V_SgCatchStatementSeq";
            case 277L: return "V_SgCharVal";
            case 278L: return "V_SgChar16Val";
            case 279L: return "V_SgChar32Val";
            case 280L: return "V_SgClassDecl_attr";
            case 281L: return "V_SgClassDeclaration";
            case 282L: return "V_SgClassDefinition";
            case 283L: return "V_SgClassNameRefExp";
            case 284L: return "V_SgClassSymbol";
            case 285L: return "V_SgClassType";
            case 286L: return "V_SgClinkageDeclarationStatement";
            case 287L: return "V_SgClinkageEndStatement";
            case 288L: return "V_SgClinkageStartStatement";
            case 289L: return "V_SgCloseStatement";
            case 290L: return "V_SgColonShapeExp";
            case 291L: return "V_SgCommaOpExp";
            case 292L: return "V_SgCommonBlock";
            case 293L: return "V_SgCommonBlockObject";
            case 294L: return "V_SgCommonSymbol";
            case 295L: return "V_SgComplexVal";
            case 296L: return "V_SgComprehension";
            case 298L: return "V_SgCompoundAssignOp";
            case 299L: return "V_SgCompoundInitializer";
            case 300L: return "V_SgCompoundLiteralExp";
            case 301L: return "V_SgComputedGotoStatement";
            case 302L: return "V_SgConcatenationOp";
            case 303L: return "V_SgConditionalExp";
            case 304L: return "V_SgConjugateOp";
            case 305L: return "V_SgConstVolatileModifier";
            case 306L: return "V_SgConstructorInitializer";
            case 307L: return "V_SgContainsStatement";
            case 308L: return "V_SgContinueStmt";
            case 309L: return "V_SgCtorInitializerList";
            case 310L: return "V_SgDataStatementGroup";
            case 311L: return "V_SgDataStatementObject";
            case 312L: return "V_SgDataStatementValue";
            case 313L: return "V_SgDeadIfDirectiveStatement";
            case 314L: return "V_SgDeallocateStatement";
            case 315L: return "V_SgDeclarationModifier";
            case 316L: return "V_SgDeclarationScope";
            case 317L: return "V_SgDeclarationStatement";
            case 318L: return "V_SgDeclType";
            case 319L: return "V_SgDefaultOptionStmt";
            case 320L: return "V_SgDefaultSymbol";
            case 321L: return "V_SgDefineDirectiveStatement";
            case 322L: return "V_SgDeleteExp";
            case 323L: return "V_SgDerivedTypeStatement";
            case 324L: return "V_SgDesignatedInitializer";
            case 325L: return "V_SgDictionaryComprehension";
            case 326L: return "V_SgDictionaryExp";
            case 327L: return "V_SgDimensionObject";
            case 329L: return "V_SgDirectedGraphEdge";
            case 331L: return "V_SgDirectory";
            case 332L: return "V_SgDirectoryList";
            case 333L: return "V_SgDivAssignOp";
            case 334L: return "V_SgDivideOp";
            case 335L: return "V_SgDoWhileStmt";
            case 336L: return "V_SgDotExp";
            case 337L: return "V_SgDotStarOp";
            case 338L: return "V_SgDoubleVal";
            case 339L: return "V_SgElaboratedTypeModifier";
            case 340L: return "V_SgElementwiseOp";
            case 341L: return "V_SgElementwiseAddOp";
            case 342L: return "V_SgElementwiseDivideOp";
            case 343L: return "V_SgElementwiseLeftDivideOp";
            case 344L: return "V_SgElementwiseMultiplyOp";
            case 345L: return "V_SgElementwisePowerOp";
            case 346L: return "V_SgElementwiseSubtractOp";
            case 347L: return "V_SgElseDirectiveStatement";
            case 348L: return "V_SgElseWhereStatement";
            case 349L: return "V_SgElseifDirectiveStatement";
            case 350L: return "V_SgEmptyDeclaration";
            case 351L: return "V_SgEmptyDirectiveStatement";
            case 352L: return "V_SgEndfileStatement";
            case 353L: return "V_SgEndifDirectiveStatement";
            case 354L: return "V_SgEntryStatement";
            case 355L: return "V_SgEnumDeclaration";
            case 356L: return "V_SgEnumFieldSymbol";
            case 357L: return "V_SgEnumSymbol";
            case 358L: return "V_SgEnumType";
            case 359L: return "V_SgEnumVal";
            case 360L: return "V_SgEqualityOp";
            case 361L: return "V_SgEquivalenceStatement";
            case 362L: return "V_SgErrorDirectiveStatement";
            case 363L: return "V_SgExecStatement";
            case 364L: return "V_SgExponentiationOp";
            case 365L: return "V_SgExponentiationAssignOp";
            case 366L: return "V_SgExprListExp";
            case 367L: return "V_SgExprStatement";
            case 368L: return "V_SgExpression";
            case 369L: return "V_SgExpressionRoot";
            case 370L: return "V_SgFile";
            case 371L: return "V_SgFileList";
            case 372L: return "V_SgFloatVal";
            case 373L: return "V_SgFloat128Val";
            case 374L: return "V_SgFloat80Val";
            case 375L: return "V_SgFlushStatement";
            case 376L: return "V_SgForAllStatement";
            case 377L: return "V_SgForInitStatement";
            case 378L: return "V_SgForStatement";
            case 379L: return "V_SgFormatItem";
            case 380L: return "V_SgFormatItemList";
            case 381L: return "V_SgFormatStatement";
            case 382L: return "V_SgFortranDo";
            case 383L: return "V_SgFortranIncludeLine";
            case 384L: return "V_SgFortranNonblockedDo";
            case 385L: return "V_SgFuncDecl_attr";
            case 386L: return "V_SgFunctionCallExp";
            case 387L: return "V_SgFunctionDeclaration";
            case 388L: return "V_SgFunctionDefinition";
            case 389L: return "V_SgFunctionParameterScope";
            case 390L: return "V_SgFunctionModifier";
            case 391L: return "V_SgFunctionParameterList";
            case 392L: return "V_SgFunctionParameterRefExp";
            case 393L: return "V_SgFunctionParameterTypeList";
            case 394L: return "V_SgFunctionRefExp";
            case 395L: return "V_SgFunctionSymbol";
            case 396L: return "V_SgFunctionType";
            case 397L: return "V_SgFunctionTypeSymbol";
            case 398L: return "V_SgFunctionTypeTable";
            case 399L: return "V_SgTypeTable";
            case 400L: return "V_SgGlobal";
            case 401L: return "V_SgGotoStatement";
            case 402L: return "V_SgGraph";
            case 403L: return "V_SgGraphEdge";
            case 404L: return "V_SgGraphEdgeList";
            case 405L: return "V_SgGraphNode";
            case 406L: return "V_SgGraphNodeList";
            case 407L: return "V_SgGreaterOrEqualOp";
            case 408L: return "V_SgGreaterThanOp";
            case 409L: return "V_SgIOItemExpression";
            case 410L: return "V_SgIOStatement";
            case 411L: return "V_SgIdentDirectiveStatement";
            case 412L: return "V_SgIfDirectiveStatement";
            case 413L: return "V_SgIfStmt";
            case 414L: return "V_SgIfdefDirectiveStatement";
            case 415L: return "V_SgIfndefDirectiveStatement";
            case 416L: return "V_SgImageControlStatement";
            case 417L: return "V_SgImagPartOp";
            case 418L: return "V_SgImplicitStatement";
            case 419L: return "V_SgImpliedDo";
            case 420L: return "V_SgImportStatement";
            case 421L: return "V_SgIncidenceDirectedGraph";
            case 422L: return "V_SgIncidenceUndirectedGraph";
            case 423L: return "V_SgIncludeDirectiveStatement";
            case 424L: return "V_SgIncludeFile";
            case 425L: return "V_SgIncludeNextDirectiveStatement";
            case 426L: return "V_SgInitializedName";
            case 427L: return "V_SgInitializer";
            case 428L: return "V_SgInquireStatement";
            case 429L: return "V_SgIntKeyedBidirectionalGraph";
            case 430L: return "V_SgIntVal";
            case 431L: return "V_SgIntegerDivideOp";
            case 432L: return "V_SgIntegerDivideAssignOp";
            case 433L: return "V_SgInterfaceBody";
            case 434L: return "V_SgHeaderFileBody";
            case 435L: return "V_SgHeaderFileReport";
            case 436L: return "V_SgInterfaceStatement";
            case 437L: return "V_SgInterfaceSymbol";
            case 438L: return "V_SgIntrinsicSymbol";
            case 439L: return "V_SgIsOp";
            case 440L: return "V_SgIsNotOp";
            case 441L: return "V_SgIorAssignOp";
            case 442L: return "V_SgJovialCompoolStatement";
            case 443L: return "V_SgJovialForThenStatement";
            case 444L: return "V_SgJovialDefineDeclaration";
            case 445L: return "V_SgJovialDirectiveStatement";
            case 446L: return "V_SgJovialTableStatement";
            case 447L: return "V_SgKeyDatumPair";
            case 448L: return "V_SgCudaKernelExecConfig";
            case 449L: return "V_SgCudaKernelCallExp";
            case 450L: return "V_SgLabelRefExp";
            case 451L: return "V_SgLabelStatement";
            case 452L: return "V_SgJavaLabelStatement";
            case 453L: return "V_SgLabelSymbol";
            case 454L: return "V_SgJavaLabelSymbol";
            case 455L: return "V_SgLambdaCapture";
            case 456L: return "V_SgLambdaCaptureList";
            case 457L: return "V_SgLambdaExp";
            case 458L: return "V_SgLambdaRefExp";
            case 459L: return "V_SgLeftDivideOp";
            case 460L: return "V_SgLessOrEqualOp";
            case 461L: return "V_SgLessThanOp";
            case 462L: return "V_SgLineDirectiveStatement";
            case 463L: return "V_SgLinemarkerDirectiveStatement";
            case 464L: return "V_SgLinkageModifier";
            case 465L: return "V_SgListComprehension";
            case 466L: return "V_SgListExp";
            case 467L: return "V_SgLocatedNode";
            case 468L: return "V_SgLocatedNodeSupport";
            case 469L: return "V_SgLongDoubleVal";
            case 470L: return "V_SgLongIntVal";
            case 471L: return "V_SgLongLongIntVal";
            case 472L: return "V_SgLshiftAssignOp";
            case 473L: return "V_SgLshiftOp";
            case 474L: return "V_SgMagicColonExp";
            case 475L: return "V_SgMatrixExp";
            case 476L: return "V_SgMatrixTransposeOp";
            case 477L: return "V_SgMatlabForStatement";
            case 478L: return "V_SgMemberFunctionDeclaration";
            case 479L: return "V_SgMemberFunctionRefExp";
            case 480L: return "V_SgMemberFunctionSymbol";
            case 481L: return "V_SgMemberFunctionType";
            case 482L: return "V_SgMembershipOp";
            case 483L: return "V_SgMicrosoftAttributeDeclaration";
            case 484L: return "V_SgMinusAssignOp";
            case 485L: return "V_SgMinusMinusOp";
            case 486L: return "V_SgMinusOp";
            case 487L: return "V_SgModAssignOp";
            case 488L: return "V_SgModOp";
            case 489L: return "V_SgModifier";
            case 490L: return "V_SgModifierNodes";
            case 491L: return "V_SgModifierType";
            case 492L: return "V_SgModuleStatement";
            case 493L: return "V_SgModuleSymbol";
            case 494L: return "V_SgMultAssignOp";
            case 495L: return "V_SgMultiplyOp";
            case 496L: return "V_SgName";
            case 497L: return "V_SgNameGroup";
            case 498L: return "V_SgNamedType";
            case 499L: return "V_SgNamelistStatement";
            case 500L: return "V_SgNamespaceAliasDeclarationStatement";
            case 501L: return "V_SgNamespaceDeclarationStatement";
            case 502L: return "V_SgNamespaceDefinitionStatement";
            case 503L: return "V_SgNamespaceSymbol";
            case 504L: return "V_SgNaryOp";
            case 505L: return "V_SgNaryBooleanOp";
            case 506L: return "V_SgNaryComparisonOp";
            case 507L: return "V_SgNewExp";
            case 508L: return "V_SgNode";
            case 509L: return "V_SgNoexceptOp";
            case 510L: return "V_SgNotEqualOp";
            case 511L: return "V_SgNotOp";
            case 512L: return "V_SgNonMembershipOp";
            case 513L: return "V_SgNonrealDecl";
            case 514L: return "V_SgNonrealRefExp";
            case 515L: return "V_SgNonrealSymbol";
            case 516L: return "V_SgNonrealType";
            case 517L: return "V_SgNonrealBaseClass";
            case 518L: return "V_SgNullExpression";
            case 519L: return "V_SgNullptrValExp";
            case 520L: return "V_SgNullStatement";
            case 521L: return "V_SgNullifyStatement";
            case 522L: return "V_SgOmpAtomicStatement";
            case 523L: return "V_SgOmpBarrierStatement";
            case 524L: return "V_SgOmpCriticalStatement";
            case 525L: return "V_SgOmpClauseBodyStatement";
            case 526L: return "V_SgOmpBodyStatement";
            case 527L: return "V_SgOmpDoStatement";
            case 528L: return "V_SgOmpFlushStatement";
            case 529L: return "V_SgOmpDeclareSimdStatement";
            case 530L: return "V_SgOmpForStatement";
            case 531L: return "V_SgOmpForSimdStatement";
            case 532L: return "V_SgOmpMasterStatement";
            case 533L: return "V_SgOmpOrderedStatement";
            case 534L: return "V_SgOmpParallelStatement";
            case 535L: return "V_SgOmpSectionStatement";
            case 536L: return "V_SgOmpSectionsStatement";
            case 537L: return "V_SgOmpSingleStatement";
            case 538L: return "V_SgOmpTaskStatement";
            case 539L: return "V_SgOmpTaskwaitStatement";
            case 540L: return "V_SgOmpThreadprivateStatement";
            case 541L: return "V_SgOmpWorkshareStatement";
            case 542L: return "V_SgOmpTargetStatement";
            case 543L: return "V_SgOmpTargetDataStatement";
            case 544L: return "V_SgOmpSimdStatement";
            case 545L: return "V_SgOmpClause";
            case 546L: return "V_SgOmpBeginClause";
            case 547L: return "V_SgOmpCollapseClause";
            case 548L: return "V_SgOmpCopyinClause";
            case 549L: return "V_SgOmpCopyprivateClause";
            case 550L: return "V_SgOmpDefaultClause";
            case 551L: return "V_SgOmpEndClause";
            case 552L: return "V_SgOmpExpressionClause";
            case 553L: return "V_SgOmpFirstprivateClause";
            case 554L: return "V_SgOmpIfClause";
            case 555L: return "V_SgOmpFinalClause";
            case 556L: return "V_SgOmpPriorityClause";
            case 557L: return "V_SgOmpDeviceClause";
            case 558L: return "V_SgOmpLastprivateClause";
            case 559L: return "V_SgOmpNowaitClause";
            case 560L: return "V_SgOmpNumThreadsClause";
            case 561L: return "V_SgOmpOrderedClause";
            case 562L: return "V_SgOmpPrivateClause";
            case 563L: return "V_SgOmpReductionClause";
            case 564L: return "V_SgOmpScheduleClause";
            case 565L: return "V_SgOmpSharedClause";
            case 566L: return "V_SgOmpUntiedClause";
            case 567L: return "V_SgOmpMergeableClause";
            case 568L: return "V_SgOmpVariablesClause";
            case 569L: return "V_SgOmpMapClause";
            case 570L: return "V_SgOmpSafelenClause";
            case 571L: return "V_SgOmpSimdlenClause";
            case 572L: return "V_SgOmpLinearClause";
            case 573L: return "V_SgOmpUniformClause";
            case 574L: return "V_SgOmpAlignedClause";
            case 575L: return "V_SgOmpProcBindClause";
            case 576L: return "V_SgOmpAtomicClause";
            case 577L: return "V_SgOmpInbranchClause";
            case 578L: return "V_SgOmpNotinbranchClause";
            case 579L: return "V_SgOmpDependClause";
            case 580L: return "V_SgOpenclAccessModeModifier";
            case 581L: return "V_SgOpenStatement";
            case 582L: return "V_SgOptions";
            case 583L: return "V_SgOrOp";
            case 584L: return "V_SgParameterStatement";
            case 585L: return "V_SgPartialFunctionModifierType";
            case 586L: return "V_SgPartialFunctionType";
            case 587L: return "V_SgPassStatement";
            case 588L: return "V_SgPlusAssignOp";
            case 589L: return "V_SgPlusPlusOp";
            case 590L: return "V_SgPntrArrRefExp";
            case 591L: return "V_SgPointerAssignOp";
            case 592L: return "V_SgPointerDerefExp";
            case 593L: return "V_SgPointerMemberType";
            case 594L: return "V_SgPointerType";
            case 595L: return "V_SgPowerOp";
            case 596L: return "V_SgPragma";
            case 597L: return "V_SgPragmaDeclaration";
            case 598L: return "V_SgPrintStatement";
            case 599L: return "V_SgProcedureHeaderStatement";
            case 600L: return "V_SgProgramHeaderStatement";
            case 601L: return "V_SgProject";
            case 602L: return "V_SgPseudoDestructorRefExp";
            case 603L: return "V_SgPythonGlobalStmt";
            case 604L: return "V_SgPythonPrintStmt";
            case 605L: return "V_SgQualifiedName";
            case 606L: return "V_SgQualifiedNameType";
            case 607L: return "V_SgRangeExp";
            case 608L: return "V_SgRangeBasedForStatement";
            case 609L: return "V_SgReadStatement";
            case 610L: return "V_SgRealPartOp";
            case 611L: return "V_SgRefExp";
            case 612L: return "V_SgReferenceType";
            case 613L: return "V_SgRenamePair";
            case 614L: return "V_SgRenameSymbol";
            case 615L: return "V_SgReturnStmt";
            case 616L: return "V_SgRewindStatement";
            case 617L: return "V_SgRshiftAssignOp";
            case 618L: return "V_SgRshiftOp";
            case 619L: return "V_SgRvalueReferenceType";
            case 620L: return "V_SgJavaUnsignedRshiftAssignOp";
            case 621L: return "V_SgJavaUnsignedRshiftOp";
            case 622L: return "V_SgScopeOp";
            case 623L: return "V_SgScopeStatement";
            case 624L: return "V_SgSequenceStatement";
            case 625L: return "V_SgSetComprehension";
            case 626L: return "V_SgShortVal";
            case 627L: return "V_SgSizeOfOp";
            case 628L: return "V_SgAlignOfOp";
            case 629L: return "V_SgJavaInstanceOfOp";
            case 630L: return "V_SgSourceFile";
            case 631L: return "V_SgSpawnStmt";
            case 632L: return "V_SgSyncAllStatement";
            case 633L: return "V_SgSyncImagesStatement";
            case 634L: return "V_SgSyncMemoryStatement";
            case 635L: return "V_SgSyncTeamStatement";
            case 636L: return "V_SgLockStatement";
            case 637L: return "V_SgUnlockStatement";
            case 638L: return "V_SgJavaThrowStatement";
            case 639L: return "V_SgJavaForEachStatement";
            case 640L: return "V_SgJavaSynchronizedStatement";
            case 641L: return "V_SgJavaParameterizedType";
            case 642L: return "V_SgJavaWildcardType";
            case 643L: return "V_SgSpecialFunctionModifier";
            case 644L: return "V_SgStatement";
            case 645L: return "V_SgStaticAssertionDeclaration";
            case 646L: return "V_SgStmtDeclarationStatement";
            case 647L: return "V_SgStatementExpression";
            case 648L: return "V_SgStatementFunctionStatement";
            case 649L: return "V_SgStopOrPauseStatement";
            case 650L: return "V_SgStorageModifier";
            case 651L: return "V_SgStringConversion";
            case 652L: return "V_SgStringKeyedBidirectionalGraph";
            case 653L: return "V_SgStringVal";
            case 654L: return "V_SgSubscriptExpression";
            case 655L: return "V_SgSubtractOp";
            case 656L: return "V_SgSupport";
            case 657L: return "V_SgSwitchStatement";
            case 658L: return "V_SgSymbol";
            case 659L: return "V_SgSymbolTable";
            case 660L: return "V_SgTemplateArgument";
            case 661L: return "V_SgTemplateArgumentList";
            case 662L: return "V_SgTemplateDeclaration";
            case 663L: return "V_SgTemplateClassDeclaration";
            case 664L: return "V_SgTemplateClassSymbol";
            case 665L: return "V_SgTemplateFunctionDeclaration";
            case 666L: return "V_SgTemplateFunctionRefExp";
            case 667L: return "V_SgTemplateFunctionSymbol";
            case 668L: return "V_SgTemplateMemberFunctionDeclaration";
            case 669L: return "V_SgTemplateMemberFunctionRefExp";
            case 670L: return "V_SgTemplateMemberFunctionSymbol";
            case 671L: return "V_SgTemplateTypedefDeclaration";
            case 672L: return "V_SgTemplateTypedefSymbol";
            case 673L: return "V_SgTemplateVariableDeclaration";
            case 674L: return "V_SgTemplateVariableSymbol";
            case 675L: return "V_SgTemplateClassDefinition";
            case 676L: return "V_SgTemplateFunctionDefinition";
            case 677L: return "V_SgTemplateInstantiationDecl";
            case 678L: return "V_SgTemplateInstantiationDefn";
            case 679L: return "V_SgTemplateInstantiationDirectiveStatement";
            case 680L: return "V_SgTemplateInstantiationFunctionDecl";
            case 681L: return "V_SgTemplateInstantiationMemberFunctionDecl";
            case 682L: return "V_SgTemplateInstantiationTypedefDeclaration";
            case 683L: return "V_SgTemplateParameter";
            case 684L: return "V_SgTemplateParameterVal";
            case 685L: return "V_SgTemplateParameterList";
            case 686L: return "V_SgTemplateSymbol";
            case 687L: return "V_SgTemplateType";
            case 688L: return "V_SgThisExp";
            case 689L: return "V_SgTypeTraitBuiltinOperator";
            case 690L: return "V_SgSuperExp";
            case 691L: return "V_SgThrowOp";
            case 692L: return "V_SgToken";
            case 693L: return "V_SgTryStmt";
            case 694L: return "V_SgTupleExp";
            case 695L: return "V_SgType";
            case 696L: return "V_SgTypeBool";
            case 697L: return "V_SgTypeChar";
            case 698L: return "V_SgTypeChar16";
            case 699L: return "V_SgTypeChar32";
            case 700L: return "V_SgTypeComplex";
            case 701L: return "V_SgTypeDefault";
            case 702L: return "V_SgTypeExpression";
            case 703L: return "V_SgTypeLabel";
            case 704L: return "V_SgTypeDouble";
            case 705L: return "V_SgTypeEllipse";
            case 706L: return "V_SgTypeFloat";
            case 707L: return "V_SgTypeFloat128";
            case 708L: return "V_SgTypeFloat80";
            case 709L: return "V_SgTypeGlobalVoid";
            case 710L: return "V_SgTypeIdOp";
            case 711L: return "V_SgTypeImaginary";
            case 712L: return "V_SgTypeInt";
            case 713L: return "V_SgTypeLong";
            case 714L: return "V_SgTypeLongDouble";
            case 715L: return "V_SgTypeLongLong";
            case 716L: return "V_SgTypeModifier";
            case 717L: return "V_SgTypeMatrix";
            case 718L: return "V_SgTypeTuple";
            case 719L: return "V_SgTypeNullptr";
            case 720L: return "V_SgTypeOfType";
            case 721L: return "V_SgTypeShort";
            case 722L: return "V_SgTypeSigned128bitInteger";
            case 723L: return "V_SgTypeSignedChar";
            case 724L: return "V_SgTypeSignedInt";
            case 725L: return "V_SgTypeSignedLong";
            case 726L: return "V_SgTypeSignedLongLong";
            case 727L: return "V_SgTypeSignedShort";
            case 728L: return "V_SgTypeString";
            case 729L: return "V_SgTypeUnknown";
            case 730L: return "V_SgTypeUnsigned128bitInteger";
            case 731L: return "V_SgTypeUnsignedChar";
            case 732L: return "V_SgTypeUnsignedInt";
            case 733L: return "V_SgTypeUnsignedLong";
            case 734L: return "V_SgTypeUnsignedLongLong";
            case 735L: return "V_SgTypeUnsignedShort";
            case 736L: return "V_SgTypeVoid";
            case 737L: return "V_SgTypeWchar";
            case 738L: return "V_SgTypedefDeclaration";
            case 739L: return "V_SgTypedefSeq";
            case 740L: return "V_SgTypedefSymbol";
            case 741L: return "V_SgTypedefType";
            case 742L: return "V_SgUPC_AccessModifier";
            case 743L: return "V_SgUnaryAddOp";
            case 744L: return "V_SgUnaryOp";
            case 745L: return "V_SgUndefDirectiveStatement";
            case 746L: return "V_SgUndirectedGraphEdge";
            case 747L: return "V_SgUnknownArrayOrFunctionReference";
            case 748L: return "V_SgUnknownFile";
            case 750L: return "V_SgUnparse_Info";
            case 751L: return "V_SgUnsignedCharVal";
            case 752L: return "V_SgUnsignedIntVal";
            case 753L: return "V_SgUnsignedLongLongIntVal";
            case 754L: return "V_SgUnsignedLongVal";
            case 755L: return "V_SgUnsignedShortVal";
            case 756L: return "V_SgUntypedNode";
            case 757L: return "V_SgUntypedExpression";
            case 758L: return "V_SgUntypedUnaryOperator";
            case 759L: return "V_SgUntypedBinaryOperator";
            case 760L: return "V_SgUntypedValueExpression";
            case 761L: return "V_SgUntypedArrayReferenceExpression";
            case 762L: return "V_SgUntypedSubscriptExpression";
            case 763L: return "V_SgUntypedOtherExpression";
            case 764L: return "V_SgUntypedNamedExpression";
            case 765L: return "V_SgUntypedNullExpression";
            case 766L: return "V_SgUntypedExprListExpression";
            case 767L: return "V_SgUntypedFunctionCallOrArrayReferenceExpression";
            case 768L: return "V_SgUntypedStatement";
            case 769L: return "V_SgUntypedLabelStatement";
            case 770L: return "V_SgUntypedNamedStatement";
            case 771L: return "V_SgUntypedAssignmentStatement";
            case 772L: return "V_SgUntypedBlockStatement";
            case 773L: return "V_SgUntypedExpressionStatement";
            case 774L: return "V_SgUntypedForAllStatement";
            case 775L: return "V_SgUntypedFunctionCallStatement";
            case 776L: return "V_SgUntypedImageControlStatement";
            case 777L: return "V_SgUntypedOtherStatement";
            case 778L: return "V_SgUntypedUseStatement";
            case 779L: return "V_SgUntypedDeclarationStatement";
            case 780L: return "V_SgUntypedDirectiveDeclaration";
            case 781L: return "V_SgUntypedEnumDeclaration";
            case 782L: return "V_SgUntypedInitializedName";
            case 783L: return "V_SgUntypedName";
            case 784L: return "V_SgUntypedNameListDeclaration";
            case 785L: return "V_SgUntypedInitializedNameListDeclaration";
            case 786L: return "V_SgUntypedImplicitDeclaration";
            case 787L: return "V_SgUntypedVariableDeclaration";
            case 788L: return "V_SgUntypedTypedefDeclaration";
            case 789L: return "V_SgUntypedProgramHeaderDeclaration";
            case 790L: return "V_SgUntypedFunctionDeclaration";
            case 791L: return "V_SgUntypedSubroutineDeclaration";
            case 792L: return "V_SgUntypedInterfaceDeclaration";
            case 793L: return "V_SgUntypedNullDeclaration";
            case 794L: return "V_SgUntypedNullStatement";
            case 795L: return "V_SgUntypedIfStatement";
            case 796L: return "V_SgUntypedCaseStatement";
            case 797L: return "V_SgUntypedLoopStatement";
            case 798L: return "V_SgUntypedWhileStatement";
            case 799L: return "V_SgUntypedForStatement";
            case 800L: return "V_SgUntypedExitStatement";
            case 801L: return "V_SgUntypedGotoStatement";
            case 802L: return "V_SgUntypedProcedureCallStatement";
            case 803L: return "V_SgUntypedReturnStatement";
            case 804L: return "V_SgUntypedExtendedReturnStatement";
            case 805L: return "V_SgUntypedStopStatement";
            case 806L: return "V_SgUntypedAcceptStatement";
            case 807L: return "V_SgUntypedEntryCallStatement";
            case 808L: return "V_SgUntypedRequeueStatement";
            case 809L: return "V_SgUntypedDelayUntilStatement";
            case 810L: return "V_SgUntypedDelayRelativeStatement";
            case 811L: return "V_SgUntypedTerminateAlternativeStatement";
            case 812L: return "V_SgUntypedSelectiveAcceptStatement";
            case 813L: return "V_SgUntypedTimedEntryCallStatement";
            case 814L: return "V_SgUntypedConditionalEntryCallStatement";
            case 815L: return "V_SgUntypedAsynchronousSelectStatement";
            case 816L: return "V_SgUntypedAbortStatement";
            case 817L: return "V_SgUntypedRaiseStatement";
            case 818L: return "V_SgUntypedCodeStatement";
            case 819L: return "V_SgUntypedReferenceExpression";
            case 820L: return "V_SgUntypedToken";
            case 821L: return "V_SgUntypedTokenPair";
            case 822L: return "V_SgUntypedType";
            case 823L: return "V_SgUntypedArrayType";
            case 824L: return "V_SgUntypedTableType";
            case 825L: return "V_SgUntypedAttribute";
            case 826L: return "V_SgUntypedFile";
            case 827L: return "V_SgUntypedScope";
            case 828L: return "V_SgUntypedFunctionScope";
            case 829L: return "V_SgUntypedModuleScope";
            case 830L: return "V_SgUntypedGlobalScope";
            case 831L: return "V_SgUntypedModuleDeclaration";
            case 832L: return "V_SgUntypedSubmoduleDeclaration";
            case 833L: return "V_SgUntypedBlockDataDeclaration";
            case 834L: return "V_SgUntypedStructureDeclaration";
            case 835L: return "V_SgUntypedStructureDefinition";
            case 836L: return "V_SgUntypedPackageDeclaration";
            case 837L: return "V_SgUntypedExceptionDeclaration";
            case 838L: return "V_SgUntypedExceptionHandlerDeclaration";
            case 839L: return "V_SgUntypedTaskDeclaration";
            case 840L: return "V_SgUntypedUnitDeclaration";
            case 841L: return "V_SgUntypedStatementList";
            case 842L: return "V_SgUntypedDeclarationStatementList";
            case 843L: return "V_SgUntypedFunctionDeclarationList";
            case 844L: return "V_SgUntypedInitializedNameList";
            case 845L: return "V_SgUntypedNameList";
            case 846L: return "V_SgUntypedTokenList";
            case 847L: return "V_SgUntypedTokenPairList";
            case 848L: return "V_SgUpcBarrierStatement";
            case 849L: return "V_SgUpcBlocksizeofExpression";
            case 850L: return "V_SgUpcElemsizeofExpression";
            case 851L: return "V_SgUpcFenceStatement";
            case 852L: return "V_SgUpcForAllStatement";
            case 853L: return "V_SgUpcLocalsizeofExpression";
            case 854L: return "V_SgUpcMythread";
            case 855L: return "V_SgUpcNotifyStatement";
            case 856L: return "V_SgUpcThreads";
            case 857L: return "V_SgUpcWaitStatement";
            case 858L: return "V_SgUseStatement";
            case 859L: return "V_SgUserDefinedBinaryOp";
            case 860L: return "V_SgUserDefinedUnaryOp";
            case 861L: return "V_SgUsingDeclarationStatement";
            case 862L: return "V_SgUsingDirectiveStatement";
            case 863L: return "V_SgValueExp";
            case 864L: return "V_SgVarArgCopyOp";
            case 865L: return "V_SgVarArgEndOp";
            case 866L: return "V_SgVarArgOp";
            case 867L: return "V_SgVarArgStartOneOperandOp";
            case 868L: return "V_SgVarArgStartOp";
            case 869L: return "V_SgVarRefExp";
            case 870L: return "V_SgVariableDeclaration";
            case 871L: return "V_SgVariableDefinition";
            case 872L: return "V_SgVariableSymbol";
            case 873L: return "V_SgVariantExpression";
            case 874L: return "V_SgVariantStatement";
            case 875L: return "V_SgVoidVal";
            case 876L: return "V_SgWaitStatement";
            case 877L: return "V_SgWarningDirectiveStatement";
            case 878L: return "V_SgWithStatement";
            case 879L: return "V_SgWcharVal";
            case 880L: return "V_SgWhereStatement";
            case 881L: return "V_SgWhileStmt";
            case 882L: return "V_SgWriteStatement";
            case 883L: return "V_SgXorAssignOp";
            case 884L: return "V_SgYieldExpression";
            case 885L: return "V_Sg_File_Info";
            case 886L: return "V_SgTypeCAFTeam";
            case 887L: return "V_SgCAFWithTeamStatement";
            case 888L: return "V_SgCAFCoExpression";
            case 889L: return "V_SgCallExpression";
            case 890L: return "V_SgTypeCrayPointer";
            case 891L: return "V_SgJavaImportStatement";
            case 892L: return "V_SgJavaPackageDeclaration";
            case 893L: return "V_SgJavaPackageStatement";
            case 894L: return "V_SgJavaImportStatementList";
            case 895L: return "V_SgJavaClassDeclarationList";
            case 896L: return "V_SgJavaMemberValuePair";
            case 897L: return "V_SgJavaAnnotation";
            case 898L: return "V_SgJavaMarkerAnnotation";
            case 899L: return "V_SgJavaSingleMemberAnnotation";
            case 900L: return "V_SgJavaNormalAnnotation";
            case 901L: return "V_SgJavaTypeExpression";
            case 902L: return "V_SgJavaQualifiedType";
            case 903L: return "V_SgClassExp";
            case 904L: return "V_SgJavaUnionType";
            case 905L: return "V_SgJavaParameterType";
            case 906L: return "V_SgJovialTableType";
            case 907L: return "V_SgAsyncStmt";
            case 908L: return "V_SgFinishStmt";
            case 909L: return "V_SgAtStmt";
            case 910L: return "V_SgAtomicStmt";
            case 912L: return "V_SgWhenStmt";
            case 913L: return "V_SgAtExp";
            case 914L: return "V_SgFinishExp";
            case 915L: return "V_SgHereExp";
            case 916L: return "V_SgDotDotExp";
            case 918L: return "V_SgNumVariants";
            default: return "";
        }
    }

    std::string VariantT(int64_t i, const std::string &strip) {
        std::string s = VariantT(i);
        if (s.empty())
            s = "(VariantT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariantT() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            329L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            912L,
            913L,
            914L,
            915L,
            916L,
            918L
        };
        static const std::vector<int64_t> retval(values, values + 912);
        return retval;
    }

}

namespace Rose {
    std::string stringifyVariantT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VariantT(i);
        if (retval.empty()) {
            retval = "(VariantT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VariantT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVariantT() {
        return stringify::VariantT();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 11432
namespace stringify { namespace SgConstVolatileModifier {
    const char* cv_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_const";
            case 3L: return "e_volatile";
            case 4L: return "e_const_volatile";
            case 5L: return "e_java_transient";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string cv_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = cv_modifier_enum(i);
        if (s.empty())
            s = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cv_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgConstVolatileModifier_cv_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgConstVolatileModifier::cv_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgConstVolatileModifier_cv_modifier_enum() {
        return stringify::SgConstVolatileModifier::cv_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 11981
namespace stringify { namespace SgStorageModifier {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_extern";
            case 3L: return "e_static";
            case 4L: return "e_auto";
            case 5L: return "e_unspecified";
            case 6L: return "e_register";
            case 7L: return "e_mutable";
            case 8L: return "e_typedef";
            case 9L: return "e_asm";
            case 10L: return "e_local";
            case 11L: return "e_common";
            case 12L: return "e_associated";
            case 13L: return "e_intrinsic";
            case 14L: return "e_pointer_based";
            case 15L: return "e_contiguous";
            case 16L: return "e_cuda_global";
            case 17L: return "e_cuda_constant";
            case 18L: return "e_cuda_shared";
            case 19L: return "e_cuda_dynamic_shared";
            case 20L: return "e_cuda_device_memory";
            case 21L: return "e_cuda_managed";
            case 22L: return "e_cuda_pinned";
            case 23L: return "e_cuda_texture";
            case 24L: return "e_jovial_def";
            case 25L: return "e_jovial_ref";
            case 26L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L
        };
        static const std::vector<int64_t> retval(values, values + 27);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStorageModifier_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStorageModifier::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStorageModifier::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStorageModifier_storage_modifier_enum() {
        return stringify::SgStorageModifier::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 12630
namespace stringify { namespace SgAccessModifier {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 4L: return "e_undefined";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAccessModifier_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAccessModifier::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAccessModifier::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAccessModifier_access_modifier_enum() {
        return stringify::SgAccessModifier::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 13162
namespace stringify { namespace SgFunctionModifier {
    const char* function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_inline";
            case 3L: return "e_virtual";
            case 4L: return "e_pure_virtual";
            case 5L: return "e_explicit";
            case 7L: return "e_pure";
            case 8L: return "e_elemental";
            case 9L: return "e_recursive";
            case 10L: return "e_gnu_attribute__constructor__";
            case 11L: return "e_gnu_attribute__destructor__";
            case 12L: return "e_gnu_attribute__pure__";
            case 13L: return "e_gnu_attribute__weak__";
            case 14L: return "e_gnu_attribute__unused__";
            case 15L: return "e_gnu_attribute__used__";
            case 16L: return "e_gnu_attribute__deprecated__";
            case 17L: return "e_gnu_attribute__malloc__";
            case 18L: return "e_gnu_attribute__naked__";
            case 19L: return "e_gnu_attribute__no_instrument_function__";
            case 20L: return "e_gnu_attribute__no_check_memory_usage__";
            case 21L: return "e_gnu_attribute__noinline__";
            case 22L: return "e_gnu_attribute__always_inline__";
            case 23L: return "e_gnu_attribute__nothrow__";
            case 24L: return "e_gnu_attribute__weakref__";
            case 25L: return "e_cuda_device";
            case 26L: return "e_cuda_kernel";
            case 27L: return "e_cuda_host";
            case 28L: return "e_cuda_global_function";
            case 29L: return "e_cuda_grid_global";
            case 30L: return "e_opencl_kernel";
            case 31L: return "e_opencl_vec_type_hint";
            case 32L: return "e_opencl_work_group_size_hint";
            case 33L: return "e_opencl_work_group_size_req";
            case 34L: return "e_java_native";
            case 35L: return "e_java_synchronized";
            case 36L: return "e_java_strictfp";
            case 37L: return "e_java_initializer";
            case 38L: return "e_marked_default";
            case 39L: return "e_marked_delete";
            case 40L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = function_modifier_enum(i);
        if (s.empty())
            s = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L
        };
        static const std::vector<int64_t> retval(values, values + 40);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFunctionModifier_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFunctionModifier::function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFunctionModifier::function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFunctionModifier_function_modifier_enum() {
        return stringify::SgFunctionModifier::function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 13949
namespace stringify { namespace SgUPC_AccessModifier {
    const char* upc_access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_upc_strict";
            case 3L: return "e_upc_relaxed";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string upc_access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = upc_access_modifier_enum(i);
        if (s.empty())
            s = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& upc_access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUPC_AccessModifier_upc_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUPC_AccessModifier::upc_access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUPC_AccessModifier_upc_access_modifier_enum() {
        return stringify::SgUPC_AccessModifier::upc_access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 14496
namespace stringify { namespace SgSpecialFunctionModifier {
    const char* special_function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_constructor";
            case 3L: return "e_destructor";
            case 4L: return "e_conversion";
            case 5L: return "e_operator";
            case 6L: return "e_uld_operator";
            case 7L: return "e_lambda_entry_point";
            case 8L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string special_function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = special_function_modifier_enum(i);
        if (s.empty())
            s = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& special_function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgSpecialFunctionModifier_special_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgSpecialFunctionModifier::special_function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgSpecialFunctionModifier_special_function_modifier_enum() {
        return stringify::SgSpecialFunctionModifier::special_function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 15050
namespace stringify { namespace SgElaboratedTypeModifier {
    const char* elaborated_type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_class";
            case 3L: return "e_struct";
            case 4L: return "e_union";
            case 5L: return "e_enum";
            case 6L: return "e_typename";
            case 7L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string elaborated_type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = elaborated_type_modifier_enum(i);
        if (s.empty())
            s = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& elaborated_type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum() {
        return stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 15589
namespace stringify { namespace SgLinkageModifier {
    const char* linkage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_linkage";
            case 3L: return "e_Cpp_linkage";
            case 4L: return "e_fortran_linkage";
            case 5L: return "e_fortran90_linkage";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string linkage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = linkage_modifier_enum(i);
        if (s.empty())
            s = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& linkage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLinkageModifier_linkage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLinkageModifier::linkage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLinkageModifier_linkage_modifier_enum() {
        return stringify::SgLinkageModifier::linkage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 16119
namespace stringify { namespace SgBaseClassModifier {
    const char* baseclass_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_virtual";
            case 3L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string baseclass_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = baseclass_modifier_enum(i);
        if (s.empty())
            s = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& baseclass_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgBaseClassModifier_baseclass_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgBaseClassModifier::baseclass_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgBaseClassModifier_baseclass_modifier_enum() {
        return stringify::SgBaseClassModifier::baseclass_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 16653
namespace stringify { namespace SgTypeModifier {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_restrict";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent_in";
            case 9L: return "e_intent_out";
            case 10L: return "e_intent_inout";
            case 11L: return "e_intrinsic";
            case 12L: return "e_optional";
            case 13L: return "e_extends";
            case 14L: return "e_abstract";
            case 15L: return "e_save";
            case 16L: return "e_target";
            case 17L: return "e_value";
            case 18L: return "e_gnu_attribute__unused__";
            case 19L: return "e_gnu_attribute__packed__";
            case 20L: return "e_gnu_attribute__deprecated__";
            case 21L: return "e_gnu_attribute__transparent_union__";
            case 22L: return "e_gnu_attribute__noreturn__";
            case 23L: return "e_gnu_attribute__const__";
            case 24L: return "e_gnu_attribute__cdecl__";
            case 25L: return "e_gnu_attribute__stdcall__";
            case 26L: return "e_gnu_attribute__warn_unused_result__";
            case 27L: return "e_gnu_attribute__nonnull__";
            case 28L: return "e_gnu_attribute__sentinel__";
            case 29L: return "e_address_space__";
            case 30L: return "e_ocl_global__";
            case 31L: return "e_ocl_local__";
            case 32L: return "e_ocl_constant__";
            case 33L: return "e_vector_type__";
            case 34L: return "e_gnu_attribute__device__";
            case 35L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L
        };
        static const std::vector<int64_t> retval(values, values + 36);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_type_modifier_enum() {
        return stringify::SgTypeModifier::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 16737
namespace stringify { namespace SgTypeModifier {
    const char* gnu_extension_machine_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_extension_machine_mode_unknown";
            case 1L: return "e_gnu_extension_machine_mode_unspecified";
            case 2L: return "e_gnu_extension_machine_mode_BImode";
            case 3L: return "e_gnu_extension_machine_mode_QImode";
            case 4L: return "e_gnu_extension_machine_mode_HImode";
            case 5L: return "e_gnu_extension_machine_mode_PSImode";
            case 6L: return "e_gnu_extension_machine_mode_SImode";
            case 7L: return "e_gnu_extension_machine_mode_PDImode";
            case 8L: return "e_gnu_extension_machine_mode_DImode";
            case 9L: return "e_gnu_extension_machine_mode_TImode";
            case 10L: return "e_gnu_extension_machine_mode_OImode";
            case 11L: return "e_gnu_extension_machine_mode_QFmode";
            case 12L: return "e_gnu_extension_machine_mode_HFmode";
            case 13L: return "e_gnu_extension_machine_mode_TQFmode";
            case 14L: return "e_gnu_extension_machine_mode_SFmode";
            case 15L: return "e_gnu_extension_machine_mode_DFmode";
            case 16L: return "e_gnu_extension_machine_mode_XFmode";
            case 17L: return "e_gnu_extension_machine_mode_SDmode";
            case 18L: return "e_gnu_extension_machine_mode_DDmode";
            case 19L: return "e_gnu_extension_machine_mode_TDmode";
            case 20L: return "e_gnu_extension_machine_mode_TFmode";
            case 21L: return "e_gnu_extension_machine_mode_QQmode";
            case 22L: return "e_gnu_extension_machine_mode_HQmode";
            case 23L: return "e_gnu_extension_machine_mode_SQmode";
            case 24L: return "e_gnu_extension_machine_mode_DQmode";
            case 25L: return "e_gnu_extension_machine_mode_TQmode";
            case 26L: return "e_gnu_extension_machine_mode_UQQmode";
            case 27L: return "e_gnu_extension_machine_mode_UHQmode";
            case 28L: return "e_gnu_extension_machine_mode_USQmode";
            case 29L: return "e_gnu_extension_machine_mode_UDQmode";
            case 30L: return "e_gnu_extension_machine_mode_UTQmode";
            case 31L: return "e_gnu_extension_machine_mode_HAmode";
            case 32L: return "e_gnu_extension_machine_mode_SAmode";
            case 33L: return "e_gnu_extension_machine_mode_DAmode";
            case 34L: return "e_gnu_extension_machine_mode_TAmode";
            case 35L: return "e_gnu_extension_machine_mode_UHAmode";
            case 36L: return "e_gnu_extension_machine_mode_USAmode";
            case 37L: return "e_gnu_extension_machine_mode_UDAmode";
            case 38L: return "e_gnu_extension_machine_mode_UTAmode";
            case 39L: return "e_gnu_extension_machine_mode_CCmode";
            case 40L: return "e_gnu_extension_machine_mode_BLKmode";
            case 41L: return "e_gnu_extension_machine_mode_VOIDmode";
            case 42L: return "e_gnu_extension_machine_mode_QCmode";
            case 43L: return "e_gnu_extension_machine_mode_HCmode";
            case 44L: return "e_gnu_extension_machine_mode_SCmode";
            case 45L: return "e_gnu_extension_machine_mode_DCmode";
            case 46L: return "e_gnu_extension_machine_mode_XCmode";
            case 47L: return "e_gnu_extension_machine_mode_TCmode";
            case 48L: return "e_gnu_extension_machine_mode_CQImode";
            case 49L: return "e_gnu_extension_machine_mode_CHImode";
            case 50L: return "e_gnu_extension_machine_mode_CSImode";
            case 51L: return "e_gnu_extension_machine_mode_CDImode";
            case 52L: return "e_gnu_extension_machine_mode_CTImode";
            case 53L: return "e_gnu_extension_machine_mode_COImode";
            case 54L: return "e_last_machine_mode";
            default: return "";
        }
    }

    std::string gnu_extension_machine_mode_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_machine_mode_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_machine_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_gnu_extension_machine_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::gnu_extension_machine_mode_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_gnu_extension_machine_mode_enum() {
        return stringify::SgTypeModifier::gnu_extension_machine_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 17523
namespace stringify { namespace SgDeclarationModifier {
    const char* declaration_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_friend";
            case 3L: return "e_typedef";
            case 4L: return "e_export";
            case 5L: return "e_throw";
            case 6L: return "e_bind";
            case 7L: return "e_final";
            case 8L: return "e_override";
            case 9L: return "e_java_abstract";
            case 10L: return "e_ms_declspec_align";
            case 11L: return "e_ms_declspec_allocate";
            case 12L: return "e_ms_declspec_appdomain";
            case 13L: return "e_ms_declspec_code_seg";
            case 14L: return "e_ms_declspec_deprecated";
            case 15L: return "e_ms_declspec_dllimport";
            case 16L: return "e_ms_declspec_dllexport";
            case 17L: return "e_ms_declspec_jitintrinsic";
            case 18L: return "e_ms_declspec_naked";
            case 19L: return "e_ms_declspec_noalias";
            case 20L: return "e_ms_declspec_noinline";
            case 21L: return "e_ms_declspec_noreturn";
            case 22L: return "e_ms_declspec_nothrow";
            case 23L: return "e_ms_declspec_novtable";
            case 24L: return "e_ms_declspec_process";
            case 25L: return "e_ms_declspec_property";
            case 26L: return "e_ms_declspec_restrict";
            case 27L: return "e_ms_declspec_safebuffers";
            case 28L: return "e_ms_declspec_selectany";
            case 29L: return "e_ms_declspec_thread";
            case 30L: return "e_ms_declspec_uuid";
            case 31L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string declaration_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = declaration_modifier_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& declaration_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 32);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_declaration_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::declaration_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_declaration_modifier_enum() {
        return stringify::SgDeclarationModifier::declaration_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 17570
namespace stringify { namespace SgDeclarationModifier {
    const char* gnu_declaration_visability_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_visibility";
            case 1L: return "e_error_visibility";
            case 2L: return "e_unspecified_visibility";
            case 3L: return "e_hidden_visibility";
            case 4L: return "e_protected_visibility";
            case 5L: return "e_internal_visibility";
            case 6L: return "e_default_visibility";
            case 7L: return "e_last_visibility_attribute";
            default: return "";
        }
    }

    std::string gnu_declaration_visability_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_declaration_visability_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_declaration_visability_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_gnu_declaration_visability_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::gnu_declaration_visability_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_gnu_declaration_visability_enum() {
        return stringify::SgDeclarationModifier::gnu_declaration_visability_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 18292
namespace stringify { namespace SgOpenclAccessModeModifier {
    const char* access_mode_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_read_only";
            case 3L: return "e_write_only";
            case 4L: return "e_read_write";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_mode_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_mode_modifier_enum(i);
        if (s.empty())
            s = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_mode_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOpenclAccessModeModifier_access_mode_modifier_enum() {
        return stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 22941
namespace stringify { namespace Sg_File_Info {
    const char* classifier(int64_t i) {
        switch (i) {
            case 1L: return "e_transformation";
            case 2L: return "e_compiler_generated";
            case 4L: return "e_output_in_code_generation";
            case 8L: return "e_shared";
            case 16L: return "e_frontend_specific";
            case 32L: return "e_source_position_unavailable_in_frontend";
            case 64L: return "e_comment_or_directive";
            case 128L: return "e_token";
            case 256L: return "e_default_argument";
            case 512L: return "e_implicit_cast";
            default: return "";
        }
    }

    std::string classifier(int64_t i, const std::string &strip) {
        std::string s = classifier(i);
        if (s.empty())
            s = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& classifier() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_classifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::classifier(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::classifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_classifier() {
        return stringify::Sg_File_Info::classifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 23206
namespace stringify { namespace Sg_File_Info {
    const char* p_fileflags(int64_t i) {
        switch (i) {
            case -6L: return "BAD_FILE_ID";
            case -5L: return "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID";
            case -4L: return "COMPILER_GENERATED_FILE_ID";
            case -3L: return "TRANSFORMATION_FILE_ID";
            case -2L: return "NULL_FILE_ID";
            case -1L: return "COPY_FILE_ID";
            default: return "";
        }
    }

    std::string p_fileflags(int64_t i, const std::string &strip) {
        std::string s = p_fileflags(i);
        if (s.empty())
            s = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& p_fileflags() {
        static const int64_t values[] = {
            -6L,
            -5L,
            -4L,
            -3L,
            -2L,
            -1L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_p_fileflags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::p_fileflags(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::p_fileflags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_p_fileflags() {
        return stringify::Sg_File_Info::p_fileflags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 23795
namespace stringify { namespace SgFile {
    const char* outputFormatOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_output_format";
            case 1L: return "e_fixed_form_output_format";
            case 2L: return "e_free_form_output_format";
            default: return "";
        }
    }

    std::string outputFormatOption_enum(int64_t i, const std::string &strip) {
        std::string s = outputFormatOption_enum(i);
        if (s.empty())
            s = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& outputFormatOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_outputFormatOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::outputFormatOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::outputFormatOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_outputFormatOption_enum() {
        return stringify::SgFile::outputFormatOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 23810
namespace stringify { namespace SgFile {
    const char* languageOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_language";
            case 1L: return "e_default_language";
            case 2L: return "e_C_language";
            case 3L: return "e_Cxx_language";
            case 4L: return "e_Binary_language";
            case 5L: return "e_Fortran_language";
            case 6L: return "e_Java_language";
            case 7L: return "e_X10_language";
            case 8L: return "e_Promela_language";
            case 9L: return "e_PHP_language";
            case 10L: return "e_Python_language";
            case 11L: return "e_Csharp_language";
            case 12L: return "e_Ada_language";
            case 13L: return "e_Jovial_language";
            case 14L: return "e_Cobol_language";
            case 15L: return "e_last_language";
            default: return "";
        }
    }

    std::string languageOption_enum(int64_t i, const std::string &strip) {
        std::string s = languageOption_enum(i);
        if (s.empty())
            s = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_languageOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::languageOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::languageOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_languageOption_enum() {
        return stringify::SgFile::languageOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 23831
namespace stringify { namespace SgFile {
    const char* standard_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default_standard";
            case 1L: return "e_c89_standard";
            case 2L: return "e_c90_standard";
            case 3L: return "e_c99_standard";
            case 4L: return "e_c11_standard";
            case 5L: return "e_c14_standard";
            case 6L: return "e_c18_standard";
            case 7L: return "e_upc_standard";
            case 8L: return "e_cxx98_standard";
            case 9L: return "e_cxx03_standard";
            case 10L: return "e_cxx11_standard";
            case 11L: return "e_cxx14_standard";
            case 12L: return "e_cxx17_standard";
            case 13L: return "e_cxx20_standard";
            case 14L: return "e_upcxx_standard";
            case 15L: return "e_f77_standard";
            case 16L: return "e_f90_standard";
            case 17L: return "e_f95_standard";
            case 18L: return "e_f03_standard";
            case 19L: return "e_f08_standard";
            case 20L: return "e_f18_standard";
            default: return "";
        }
    }

    std::string standard_enum(int64_t i, const std::string &strip) {
        std::string s = standard_enum(i);
        if (s.empty())
            s = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& standard_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_standard_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::standard_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::standard_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_standard_enum() {
        return stringify::SgFile::standard_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 27409
namespace stringify { namespace SgProject {
    const char* template_instantiation_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_none";
            case 3L: return "e_used";
            case 4L: return "e_all";
            case 5L: return "e_local";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string template_instantiation_enum(int64_t i, const std::string &strip) {
        std::string s = template_instantiation_enum(i);
        if (s.empty())
            s = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_instantiation_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProject_template_instantiation_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProject::template_instantiation_enum(i);
        if (retval.empty()) {
            retval = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProject::template_instantiation_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProject_template_instantiation_enum() {
        return stringify::SgProject::template_instantiation_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 29382
namespace stringify { namespace SgUnparse_Info {
    const char* unparse_type_num(int64_t i) {
        switch (i) {
            case 0L: return "b_enum_defaultValue";
            case 1L: return "b_isPointerToSomething";
            case 2L: return "b_isReferenceToSomething";
            case 3L: return "b_inVarDecl";
            case 4L: return "b_inArgList";
            case 5L: return "b_SkipSemiColon";
            case 6L: return "b_inEnumDecl";
            case 7L: return "b_inTemplateList";
            case 8L: return "b_SkipBaseType";
            case 9L: return "b_inAggregateInitializer";
            case 10L: return "b_isWithType";
            case 11L: return "b_inConditional";
            case 12L: return "b_SkipDefinition";
            case 13L: return "b_SkipClassSpecifier";
            case 14L: return "b_inEmbeddedDecl";
            case 15L: return "b_SkipGlobal";
            case 16L: return "b_SkipAtomic";
            case 17L: return "b_PrintName";
            case 18L: return "b_CheckAccess";
            case 19L: return "b_SkipFunctionQualifier";
            case 20L: return "b_isArrayType";
            case 21L: return "b_inRhsExpr";
            case 22L: return "b_SkipParen";
            case 23L: return "b_isTypeSecondPart";
            case 24L: return "b_isTypeFirstPart";
            case 25L: return "b_SkipInitializer";
            case 26L: return "b_SkipComments";
            case 27L: return "b_SkipCPPDirectives";
            case 28L: return "b_SkipEnumDefinition";
            case 29L: return "b_SkipFunctionDefinition";
            case 30L: return "b_SkipClassDefinition";
            case 31L: return "b_AddSemiColonAfterDeclaration";
            case 32L: return "b_SkipWhitespaces";
            case 33L: return "b_SkipBasicBlock";
            case 34L: return "b_outputClassTemplateName";
            case 35L: return "b_outputCompilerGeneratedStatements";
            case 36L: return "b_SkipConstantFoldedExpressions";
            case 37L: return "b_forceQualifiedNames";
            case 38L: return "b_SkipQualifiedNames";
            case 39L: return "b_skipCheckAccess";
            case 40L: return "b_requiresGlobalNameQualification";
            case 41L: return "b_useTypeAttributes";
            case 42L: return "b_SkipFormatting";
            case 43L: return "b_outputFortranModFile";
            case 44L: return "b_supressStrippedTypeName";
            case 45L: return "b_prefixOperator";
            case 46L: return "b_supressArrayBound";
            case 47L: return "b_supressImplicitThisOperator";
            case 48L: return "b_unparsedPartiallyUsingTokenStream";
            case 49L: return "b_skipCompilerGeneratedSubExpressions";
            case 50L: return "b_parentStatementListBeingUnparsedUsingPartialTokenSequence";
            case 51L: return "b_cxx11_initialization_list";
            case 52L: return "b_inTypedefDecl";
            case 53L: return "b_SkipNameQualification";
            case 54L: return "UNPARSE_TYPE_LAST";
            default: return "";
        }
    }

    std::string unparse_type_num(int64_t i, const std::string &strip) {
        std::string s = unparse_type_num(i);
        if (s.empty())
            s = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparse_type_num() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_unparse_type_num(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::unparse_type_num(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::unparse_type_num::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_unparse_type_num() {
        return stringify::SgUnparse_Info::unparse_type_num();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 29550
namespace stringify { namespace SgUnparse_Info {
    const char* access_attr_enum(int64_t i) {
        switch (i) {
            case 1L: return "a_unset_access";
            case 2L: return "a_private_access";
            case 3L: return "a_protected_access";
            case 4L: return "a_public_access";
            default: return "";
        }
    }

    std::string access_attr_enum(int64_t i, const std::string &strip) {
        std::string s = access_attr_enum(i);
        if (s.empty())
            s = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_attr_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_access_attr_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::access_attr_enum(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::access_attr_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_access_attr_enum() {
        return stringify::SgUnparse_Info::access_attr_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 32583
namespace stringify { namespace SgTemplateParameter {
    const char* template_parameter_enum(int64_t i) {
        switch (i) {
            case 0L: return "parameter_undefined";
            case 1L: return "type_parameter";
            case 2L: return "nontype_parameter";
            case 3L: return "template_parameter";
            default: return "";
        }
    }

    std::string template_parameter_enum(int64_t i, const std::string &strip) {
        std::string s = template_parameter_enum(i);
        if (s.empty())
            s = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_parameter_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateParameter_template_parameter_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateParameter::template_parameter_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateParameter::template_parameter_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateParameter_template_parameter_enum() {
        return stringify::SgTemplateParameter::template_parameter_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 33148
namespace stringify { namespace SgTemplateArgument {
    const char* template_argument_enum(int64_t i) {
        switch (i) {
            case 0L: return "argument_undefined";
            case 1L: return "type_argument";
            case 2L: return "nontype_argument";
            case 3L: return "template_template_argument";
            case 4L: return "start_of_pack_expansion_argument";
            default: return "";
        }
    }

    std::string template_argument_enum(int64_t i, const std::string &strip) {
        std::string s = template_argument_enum(i);
        if (s.empty())
            s = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_argument_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateArgument_template_argument_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateArgument::template_argument_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateArgument::template_argument_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateArgument_template_argument_enum() {
        return stringify::SgTemplateArgument::template_argument_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 37393
namespace stringify { namespace SgGraph {
    const char* GraphEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "e_type_error";
            case 1L: return "none";
            case 2L: return "cfg";
            case 3L: return "usage";
            case 4L: return "e_last_type";
            default: return "";
        }
    }

    std::string GraphEdgeType(int64_t i, const std::string &strip) {
        std::string s = GraphEdgeType(i);
        if (s.empty())
            s = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphEdgeType(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphEdgeType() {
        return stringify::SgGraph::GraphEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 37407
namespace stringify { namespace SgGraph {
    const char* GraphProperties(int64_t i) {
        switch (i) {
            case 0L: return "e_property_error";
            case 1L: return "name";
            case 2L: return "type";
            case 3L: return "nodest_jmp";
            case 4L: return "itself_call";
            case 5L: return "nodest_call";
            case 6L: return "interrupt";
            case 7L: return "eval";
            case 8L: return "regs";
            case 9L: return "done";
            case 10L: return "dfa_standard";
            case 11L: return "dfa_resolved_func";
            case 12L: return "dfa_unresolved_func";
            case 13L: return "dfa_variable";
            case 14L: return "dfa_conditional_def";
            case 15L: return "edgeLabel";
            case 16L: return "visitedCounter";
            case 17L: return "variable";
            case 18L: return "dfa_bufferoverflow";
            case 19L: return "e_last_property";
            default: return "";
        }
    }

    std::string GraphProperties(int64_t i, const std::string &strip) {
        std::string s = GraphProperties(i);
        if (s.empty())
            s = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphProperties() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphProperties(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphProperties(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphProperties::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphProperties() {
        return stringify::SgGraph::GraphProperties();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 47696
namespace stringify { namespace SgDataStatementValue {
    const char* data_statement_value_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_explict_list";
            case 3L: return "e_implicit_list";
            case 4L: return "e_implied_do";
            case 5L: return "e_last_initializer_form";
            default: return "";
        }
    }

    std::string data_statement_value_enum(int64_t i, const std::string &strip) {
        std::string s = data_statement_value_enum(i);
        if (s.empty())
            s = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& data_statement_value_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDataStatementValue_data_statement_value_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDataStatementValue::data_statement_value_enum(i);
        if (retval.empty()) {
            retval = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDataStatementValue_data_statement_value_enum() {
        return stringify::SgDataStatementValue::data_statement_value_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 49817
namespace stringify { namespace SgType {
    const char* useWithinDeclarationEnum(int64_t i) {
        switch (i) {
            case 1L: return "e_first_declaration";
            case 2L: return "e_autonomous_tag_declaration";
            default: return "";
        }
    }

    std::string useWithinDeclarationEnum(int64_t i, const std::string &strip) {
        std::string s = useWithinDeclarationEnum(i);
        if (s.empty())
            s = "(SgType::useWithinDeclarationEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& useWithinDeclarationEnum() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_useWithinDeclarationEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::useWithinDeclarationEnum(i);
        if (retval.empty()) {
            retval = "(SgType::useWithinDeclarationEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::useWithinDeclarationEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_useWithinDeclarationEnum() {
        return stringify::SgType::useWithinDeclarationEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 49835
namespace stringify { namespace SgType {
    const char* fortran_attribute_specifiers_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_specifier";
            case 1L: return "e_public_access";
            case 2L: return "e_private_access";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent";
            case 9L: return "e_optional";
            case 10L: return "e_parameter";
            case 11L: return "e_pointer";
            case 12L: return "e_protected";
            case 13L: return "e_save";
            case 14L: return "e_target";
            case 15L: return "e_value";
            case 16L: return "e_volatile";
            case 17L: return "e_last_attribute_specifier";
            default: return "";
        }
    }

    std::string fortran_attribute_specifiers_enum(int64_t i, const std::string &strip) {
        std::string s = fortran_attribute_specifiers_enum(i);
        if (s.empty())
            s = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fortran_attribute_specifiers_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_fortran_attribute_specifiers_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::fortran_attribute_specifiers_enum(i);
        if (retval.empty()) {
            retval = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_fortran_attribute_specifiers_enum() {
        return stringify::SgType::fortran_attribute_specifiers_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 71260
namespace stringify { namespace SgModifierType {
    const char* modifiers(int64_t i) {
        switch (i) {
            case 1L: return "m_volatile";
            case 2L: return "m_global";
            case 4L: return "m_sync";
            case 8L: return "m_const";
            case 16L: return "m_restrict";
            case 32L: return "m_shared";
            case 64L: return "m_strict";
            case 128L: return "m_relaxed";
            default: return "";
        }
    }

    std::string modifiers(int64_t i, const std::string &strip) {
        std::string s = modifiers(i);
        if (s.empty())
            s = "(SgModifierType::modifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& modifiers() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_modifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::modifiers(i);
        if (retval.empty()) {
            retval = "(SgModifierType::modifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::modifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_modifiers() {
        return stringify::SgModifierType::modifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 71314
namespace stringify { namespace SgModifierType {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            case 8L: return "e_unaligned";
            case 16L: return "e_near";
            case 32L: return "e_far";
            case 64L: return "e_upc_shared";
            case 128L: return "e_upc_strict";
            case 256L: return "e_upc_relaxed";
            case 512L: return "e_last_type_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_type_modifier_enum() {
        return stringify::SgModifierType::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 71331
namespace stringify { namespace SgModifierType {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_storage";
            case 1L: return "e_extern";
            case 2L: return "e_static";
            case 3L: return "e_auto";
            case 4L: return "e_unspecified";
            case 5L: return "e_typedef";
            case 6L: return "e_register";
            case 7L: return "e_asm";
            case 8L: return "e_local";
            case 9L: return "e_common";
            case 10L: return "e_associated";
            case 11L: return "e_intrinsic";
            case 12L: return "e_pointer_based";
            case 13L: return "e_last_storage_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_storage_modifier_enum() {
        return stringify::SgModifierType::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 71353
namespace stringify { namespace SgModifierType {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_access";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 4L: return "e_virtual";
            case 5L: return "e_last_access_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgModifierType::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgModifierType_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgModifierType::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgModifierType::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgModifierType::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgModifierType_access_modifier_enum() {
        return stringify::SgModifierType::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 72598
namespace stringify { namespace SgMemberFunctionType {
    const char* mfunc_specifier_enum(int64_t i) {
        switch (i) {
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            default: return "";
        }
    }

    std::string mfunc_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = mfunc_specifier_enum(i);
        if (s.empty())
            s = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& mfunc_specifier_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgMemberFunctionType_mfunc_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgMemberFunctionType::mfunc_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgMemberFunctionType_mfunc_specifier_enum() {
        return stringify::SgMemberFunctionType::mfunc_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 85079
namespace stringify { namespace SgLocatedNode {
    const char* PositionOfPreprocessingInfoInListType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "prependPreprocessingInfoToList";
            case 2L: return "appendPreprocessingInfoToList";
            default: return "";
        }
    }

    std::string PositionOfPreprocessingInfoInListType(int64_t i, const std::string &strip) {
        std::string s = PositionOfPreprocessingInfoInListType(i);
        if (s.empty())
            s = "(SgLocatedNode::PositionOfPreprocessingInfoInListType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PositionOfPreprocessingInfoInListType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLocatedNodePositionOfPreprocessingInfoInListType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLocatedNode::PositionOfPreprocessingInfoInListType(i);
        if (retval.empty()) {
            retval = "(SgLocatedNode::PositionOfPreprocessingInfoInListType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLocatedNode::PositionOfPreprocessingInfoInListType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLocatedNodePositionOfPreprocessingInfoInListType() {
        return stringify::SgLocatedNode::PositionOfPreprocessingInfoInListType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 85844
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            case 126L: return "FORTRAN_END_PROGRAM";
            case 127L: return "FORTRAN_END_FUNCTION";
            case 128L: return "FORTRAN_END_SUBROUTINE";
            case 129L: return "FORTRAN_END_MODULE";
            case 130L: return "FORTRAN_END_BLOCK_DATA";
            case 131L: return "FORTRAN_SUBMODULE";
            case 132L: return "FORTRAN_END_SUBMODULE";
            case 133L: return "FORTRAN_DOUBLE_COMPLEX";
            case 134L: return "FORTRAN_TYPE";
            case 135L: return "FORTRAN_ABSTRACT_INTERFACE";
            case 136L: return "FORTRAN_ERROR_STOP";
            case 137L: return "FORTRAN_CONTIGUOUS";
            case 138L: return "FORTRAN_PUBLIC";
            case 139L: return "FORTRAN_ELEMENTAL";
            case 140L: return "FORTRAN_IMPURE";
            case 141L: return "FORTRAN_PURE";
            case 142L: return "FORTRAN_RECURSIVE";
            case 143L: return "FORTRAN_INTENT_IN";
            case 144L: return "FORTRAN_INTENT_OUT";
            case 145L: return "FORTRAN_INTENT_INOUT";
            case 146L: return "FORTRAN_ASSIGNMENT";
            case 147L: return "FORTRAN_OPERATOR";
            case 148L: return "FORTRAN_READ_FORMATTED";
            case 149L: return "FORTRAN_READ_UNFORMATTED";
            case 150L: return "FORTRAN_WRITE_FORMATTED";
            case 151L: return "FORTRAN_WRITE_UNFORMATTED";
            case 152L: return "FORTRAN_UNKNOWN";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L
        };
        static const std::vector<int64_t> retval(values, values + 153);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Keywords() {
        return stringify::SgToken::ROSE_Fortran_Keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 86011
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_keywords() {
        return stringify::SgToken::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 86080
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Operators() {
        return stringify::SgToken::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 86107
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_Operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_Operators() {
        return stringify::SgToken::ROSE_C_CXX_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 86187
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Additional_Info() {
        return stringify::SgToken::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 87660
namespace stringify { namespace SgInitializedName {
    const char* preinitialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_preinitialization";
            case 1L: return "e_virtual_base_class";
            case 2L: return "e_nonvirtual_base_class";
            case 3L: return "e_data_member";
            case 4L: return "e_delegation_constructor";
            case 5L: return "e_last_preinitialization";
            default: return "";
        }
    }

    std::string preinitialization_enum(int64_t i, const std::string &strip) {
        std::string s = preinitialization_enum(i);
        if (s.empty())
            s = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& preinitialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_preinitialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::preinitialization_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::preinitialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_preinitialization_enum() {
        return stringify::SgInitializedName::preinitialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 87675
namespace stringify { namespace SgInitializedName {
    const char* asm_register_name_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid_register";
            case 1L: return "e_memory_register";
            case 2L: return "e_register_a";
            case 3L: return "e_register_b";
            case 4L: return "e_register_c";
            case 5L: return "e_register_d";
            case 6L: return "e_register_si";
            case 7L: return "e_register_di";
            case 8L: return "e_register_bp";
            case 9L: return "e_register_sp";
            case 10L: return "e_register_r8";
            case 11L: return "e_register_r9";
            case 12L: return "e_register_r10";
            case 13L: return "e_register_r11";
            case 14L: return "e_register_r12";
            case 15L: return "e_register_r13";
            case 16L: return "e_register_r14";
            case 17L: return "e_register_r15";
            case 18L: return "e_register_st0";
            case 19L: return "e_register_st1";
            case 20L: return "e_register_st2";
            case 21L: return "e_register_st3";
            case 22L: return "e_register_st4";
            case 23L: return "e_register_st5";
            case 24L: return "e_register_st6";
            case 25L: return "e_register_st7";
            case 26L: return "e_register_mm0";
            case 27L: return "e_register_mm1";
            case 28L: return "e_register_mm2";
            case 29L: return "e_register_mm3";
            case 30L: return "e_register_mm4";
            case 31L: return "e_register_mm5";
            case 32L: return "e_register_mm6";
            case 33L: return "e_register_mm7";
            case 34L: return "e_register_f0";
            case 35L: return "e_register_f1";
            case 36L: return "e_register_f2";
            case 37L: return "e_register_f3";
            case 38L: return "e_register_f4";
            case 39L: return "e_register_f5";
            case 40L: return "e_register_f6";
            case 41L: return "e_register_f7";
            case 42L: return "e_register_f8";
            case 43L: return "e_register_f9";
            case 44L: return "e_register_f10";
            case 45L: return "e_register_f11";
            case 46L: return "e_register_f12";
            case 47L: return "e_register_f13";
            case 48L: return "e_register_f14";
            case 49L: return "e_register_f15";
            case 50L: return "e_register_flags";
            case 51L: return "e_register_fpsr";
            case 52L: return "e_register_dirflag";
            case 53L: return "e_unrecognized_register";
            case 54L: return "e_last_register";
            default: return "";
        }
    }

    std::string asm_register_name_enum(int64_t i, const std::string &strip) {
        std::string s = asm_register_name_enum(i);
        if (s.empty())
            s = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_register_name_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_asm_register_name_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::asm_register_name_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::asm_register_name_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_asm_register_name_enum() {
        return stringify::SgInitializedName::asm_register_name_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 87737
namespace stringify { namespace SgInitializedName {
    const char* gnu_variable_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute__weak__";
            case 1L: return "e_gnu_attribute__unused__";
            case 2L: return "e_gnu_attribute__used__";
            case 3L: return "e_gnu_attribute__deprecated__";
            case 4L: return "e_gnu_attribute__nocommon__";
            case 5L: return "e_gnu_attribute__transparent_union__";
            case 6L: return "e_gnu_attribute__weakref__";
            case 7L: return "e_gnu_attribute__packed__";
            case 8L: return "e_gnu_attribute__noreturn__";
            case 9L: return "e_ms_declspec_parameter_appdomain";
            case 10L: return "e_ms_declspec_parameter_deprecated";
            case 11L: return "e_ms_declspec_parameter_dllimport";
            case 12L: return "e_ms_declspec_parameter_dllexport";
            case 13L: return "e_ms_declspec_parameter_novtable";
            case 14L: return "e_ms_declspec_parameter_process";
            case 15L: return "e_ms_declspec_parameter_property";
            case 16L: return "e_ms_declspec_parameter_restrict";
            case 18L: return "e_ms_declspec_parameter_selectany";
            case 19L: return "e_ms_declspec_parameter_thread";
            case 20L: return "e_ms_declspec_parameter_uuid";
            case 21L: return "e_last_gnu_variable_attribute";
            default: return "";
        }
    }

    std::string gnu_variable_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_variable_attribute_enum(i);
        if (s.empty())
            s = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_variable_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_gnu_variable_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::gnu_variable_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_gnu_variable_attribute_enum() {
        return stringify::SgInitializedName::gnu_variable_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 87771
namespace stringify { namespace SgInitializedName {
    const char* excess_specifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_excess_specifier_none";
            case 1L: return "e_excess_specifier_positionals";
            case 2L: return "e_excess_specifier_keywords";
            case 3L: return "e_excess_specifier_last";
            default: return "";
        }
    }

    std::string excess_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = excess_specifier_enum(i);
        if (s.empty())
            s = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& excess_specifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_excess_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::excess_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::excess_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_excess_specifier_enum() {
        return stringify::SgInitializedName::excess_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90834
namespace stringify { namespace SgOmpClause {
    const char* omp_default_option_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_default_unknown";
            case 1L: return "e_omp_default_none";
            case 2L: return "e_omp_default_shared";
            case 3L: return "e_omp_default_private";
            case 4L: return "e_omp_default_firstprivate";
            case 5L: return "e_omp_default_last";
            default: return "";
        }
    }

    std::string omp_default_option_enum(int64_t i, const std::string &strip) {
        std::string s = omp_default_option_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_default_option_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_default_option_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_default_option_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_default_option_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_default_option_enum() {
        return stringify::SgOmpClause::omp_default_option_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90846
namespace stringify { namespace SgOmpClause {
    const char* omp_schedule_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_schedule_unknown";
            case 1L: return "e_omp_schedule_static";
            case 2L: return "e_omp_schedule_dynamic";
            case 3L: return "e_omp_schedule_guided";
            case 4L: return "e_omp_schedule_auto";
            case 5L: return "e_omp_schedule_runtime";
            case 6L: return "e_omp_schedule_last";
            default: return "";
        }
    }

    std::string omp_schedule_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_schedule_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_schedule_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_schedule_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_schedule_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_schedule_kind_enum() {
        return stringify::SgOmpClause::omp_schedule_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90856
namespace stringify { namespace SgOmpClause {
    const char* omp_reduction_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_reduction_unknown";
            case 1L: return "e_omp_reduction_plus";
            case 2L: return "e_omp_reduction_mul";
            case 3L: return "e_omp_reduction_minus";
            case 4L: return "e_omp_reduction_bitand";
            case 5L: return "e_omp_reduction_bitor";
            case 6L: return "e_omp_reduction_bitxor";
            case 7L: return "e_omp_reduction_logand";
            case 8L: return "e_omp_reduction_logor";
            case 9L: return "e_omp_reduction_and";
            case 10L: return "e_omp_reduction_or";
            case 11L: return "e_omp_reduction_eqv";
            case 12L: return "e_omp_reduction_neqv";
            case 13L: return "e_omp_reduction_max";
            case 14L: return "e_omp_reduction_min";
            case 15L: return "e_omp_reduction_iand";
            case 16L: return "e_omp_reduction_ior";
            case 17L: return "e_omp_reduction_ieor";
            case 18L: return "e_omp_reduction_last";
            default: return "";
        }
    }

    std::string omp_reduction_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_reduction_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_reduction_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_reduction_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_reduction_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_reduction_operator_enum() {
        return stringify::SgOmpClause::omp_reduction_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90884
namespace stringify { namespace SgOmpClause {
    const char* omp_dependence_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depend_unknown";
            case 1L: return "e_omp_depend_in";
            case 2L: return "e_omp_depend_out";
            case 3L: return "e_omp_depend_inout";
            case 4L: return "e_omp_depend_last";
            default: return "";
        }
    }

    std::string omp_dependence_type_enum(int64_t i, const std::string &strip) {
        std::string s = omp_dependence_type_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_dependence_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_dependence_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_dependence_type_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_dependence_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_dependence_type_enum() {
        return stringify::SgOmpClause::omp_dependence_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90894
namespace stringify { namespace SgOmpClause {
    const char* omp_map_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_unknown";
            case 1L: return "e_omp_map_alloc";
            case 2L: return "e_omp_map_to";
            case 3L: return "e_omp_map_from";
            case 4L: return "e_omp_map_tofrom";
            case 5L: return "e_omp_map_last";
            default: return "";
        }
    }

    std::string omp_map_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_operator_enum() {
        return stringify::SgOmpClause::omp_map_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90905
namespace stringify { namespace SgOmpClause {
    const char* omp_map_dist_data_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_dist_data_unknown";
            case 1L: return "e_omp_map_dist_data_duplicate";
            case 2L: return "e_omp_map_dist_data_block";
            case 3L: return "e_omp_map_dist_data_cyclic";
            case 4L: return "e_omp_map_dist_data_last";
            default: return "";
        }
    }

    std::string omp_map_dist_data_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_dist_data_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_dist_data_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_dist_data_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_dist_data_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_dist_data_enum() {
        return stringify::SgOmpClause::omp_map_dist_data_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90915
namespace stringify { namespace SgOmpClause {
    const char* omp_proc_bind_policy_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_proc_bind_policy_unknown";
            case 1L: return "e_omp_proc_bind_policy_master";
            case 2L: return "e_omp_proc_bind_policy_close";
            case 3L: return "e_omp_proc_bind_policy_spread";
            case 4L: return "e_omp_proc_bind_policy_last";
            default: return "";
        }
    }

    std::string omp_proc_bind_policy_enum(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_policy_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_policy_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_proc_bind_policy_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_proc_bind_policy_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_proc_bind_policy_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_proc_bind_policy_enum() {
        return stringify::SgOmpClause::omp_proc_bind_policy_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 90924
namespace stringify { namespace SgOmpClause {
    const char* omp_atomic_clause_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_atomic_clause_unknown";
            case 1L: return "e_omp_atomic_clause_read";
            case 2L: return "e_omp_atomic_clause_write";
            case 3L: return "e_omp_atomic_clause_update";
            case 4L: return "e_omp_atomic_clause_capture";
            default: return "";
        }
    }

    std::string omp_atomic_clause_enum(int64_t i, const std::string &strip) {
        std::string s = omp_atomic_clause_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_atomic_clause_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_atomic_clause_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_atomic_clause_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_atomic_clause_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_atomic_clause_enum() {
        return stringify::SgOmpClause::omp_atomic_clause_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 145810
namespace stringify { namespace SgUntypedType {
    const char* type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_implicit";
            case 2L: return "e_void";
            case 3L: return "e_int";
            case 4L: return "e_uint";
            case 5L: return "e_float";
            case 6L: return "e_double";
            case 7L: return "e_complex";
            case 8L: return "e_double_complex";
            case 9L: return "e_bool";
            case 10L: return "e_char";
            case 11L: return "e_string";
            case 12L: return "e_bit";
            case 13L: return "e_fixed";
            case 14L: return "e_ptr";
            case 15L: return "e_status";
            case 16L: return "e_table";
            case 17L: return "e_block";
            case 18L: return "e_user_defined";
            case 19L: return "e_last";
            default: return "";
        }
    }

    std::string type_enum(int64_t i, const std::string &strip) {
        std::string s = type_enum(i);
        if (s.empty())
            s = "(SgUntypedType::type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUntypedType_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUntypedType::type_enum(i);
        if (retval.empty()) {
            retval = "(SgUntypedType::type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUntypedType::type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUntypedType_type_enum() {
        return stringify::SgUntypedType::type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 164653
namespace stringify { namespace SgForAllStatement {
    const char* forall_statement_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_forall_statement";
            case 2L: return "e_do_concurrent_statement";
            case 3L: return "e_last_forall_statement_kind";
            default: return "";
        }
    }

    std::string forall_statement_kind_enum(int64_t i, const std::string &strip) {
        std::string s = forall_statement_kind_enum(i);
        if (s.empty())
            s = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& forall_statement_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgForAllStatement_forall_statement_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgForAllStatement::forall_statement_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgForAllStatement::forall_statement_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgForAllStatement_forall_statement_kind_enum() {
        return stringify::SgForAllStatement::forall_statement_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 170375
namespace stringify { namespace SgDeclarationStatement {
    const char* template_specialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_no_specialization";
            case 2L: return "e_partial_specialization";
            case 3L: return "e_specialization";
            case 4L: return "e_template_specialization_last";
            default: return "";
        }
    }

    std::string template_specialization_enum(int64_t i, const std::string &strip) {
        std::string s = template_specialization_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_specialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_template_specialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::template_specialization_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_template_specialization_enum() {
        return stringify::SgDeclarationStatement::template_specialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 170390
namespace stringify { namespace SgDeclarationStatement {
    const char* gnu_extension_visability_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_visability_unknown";
            case 1L: return "e_gnu_attribute_visability_unspecified";
            case 2L: return "e_gnu_attribute_visability_hidden";
            case 3L: return "e_gnu_attribute_visability_protected";
            case 4L: return "e_gnu_attribute_visability_internal";
            case 5L: return "e_last_gnu_visability_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_visability_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_visability_attribute_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_visability_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum() {
        return stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 171855
namespace stringify { namespace SgVariableDeclaration {
    const char* gnu_extension_declaration_attributes_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_unknown";
            case 1L: return "e_gnu_attribute_unspecified";
            case 2L: return "e_gnu_attribute__weak__";
            case 3L: return "e_gnu_attribute__unused__";
            case 4L: return "e_gnu_attribute__deprecated__";
            case 5L: return "e_gnu_attribute__nocommon__";
            case 6L: return "e_gnu_attribute__transparent_union__";
            case 7L: return "e_last_gnu_declaration_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_declaration_attributes_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_declaration_attributes_enum(i);
        if (s.empty())
            s = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_declaration_attributes_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum(i);
        if (retval.empty()) {
            retval = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum() {
        return stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 176335
namespace stringify { namespace SgAttributeSpecificationStatement {
    const char* attribute_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_spec";
            case 1L: return "e_accessStatement_private";
            case 2L: return "e_accessStatement_public";
            case 3L: return "e_allocatableStatement";
            case 4L: return "e_asynchronousStatement";
            case 5L: return "e_bindStatement";
            case 6L: return "e_dataStatement";
            case 7L: return "e_dimensionStatement";
            case 8L: return "e_externalStatement";
            case 9L: return "e_intentStatement";
            case 10L: return "e_intrinsicStatement";
            case 11L: return "e_optionalStatement";
            case 12L: return "e_parameterStatement";
            case 13L: return "e_pointerStatement";
            case 14L: return "e_protectedStatement";
            case 15L: return "e_saveStatement";
            case 16L: return "e_targetStatement";
            case 17L: return "e_valueStatement";
            case 18L: return "e_volatileStatement";
            case 19L: return "e_last_attribute_spec";
            default: return "";
        }
    }

    std::string attribute_spec_enum(int64_t i, const std::string &strip) {
        std::string s = attribute_spec_enum(i);
        if (s.empty())
            s = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attribute_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAttributeSpecificationStatement_attribute_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAttributeSpecificationStatement::attribute_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAttributeSpecificationStatement_attribute_spec_enum() {
        return stringify::SgAttributeSpecificationStatement::attribute_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 177403
namespace stringify { namespace SgTemplateDeclaration {
    const char* template_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_template_none";
            case 1L: return "e_template_class";
            case 2L: return "e_template_m_class";
            case 3L: return "e_template_function";
            case 4L: return "e_template_m_function";
            case 5L: return "e_template_m_data";
            default: return "";
        }
    }

    std::string template_type_enum(int64_t i, const std::string &strip) {
        std::string s = template_type_enum(i);
        if (s.empty())
            s = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateDeclaration_template_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateDeclaration::template_type_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateDeclaration::template_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateDeclaration_template_type_enum() {
        return stringify::SgTemplateDeclaration::template_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 180513
namespace stringify { namespace SgInterfaceStatement {
    const char* generic_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_interface_type";
            case 1L: return "e_default_interface_type";
            case 2L: return "e_unnamed_interface_type";
            case 3L: return "e_named_interface_type";
            case 4L: return "e_operator_interface_type";
            case 5L: return "e_assignment_interface_type";
            case 6L: return "e_last_interface_type";
            default: return "";
        }
    }

    std::string generic_spec_enum(int64_t i, const std::string &strip) {
        std::string s = generic_spec_enum(i);
        if (s.empty())
            s = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& generic_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInterfaceStatement_generic_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInterfaceStatement::generic_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInterfaceStatement_generic_spec_enum() {
        return stringify::SgInterfaceStatement::generic_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 185841
namespace stringify { namespace SgClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            case 4L: return "e_java_interface";
            case 5L: return "e_java_enum";
            case 6L: return "e_java_parameter";
            case 7L: return "e_jovial_block";
            case 8L: return "e_jovial_table";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgClassDeclaration_class_types() {
        return stringify::SgClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 186542
namespace stringify { namespace SgTemplateClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateClassDeclaration_class_types() {
        return stringify::SgTemplateClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 195747
namespace stringify { namespace SgProcedureHeaderStatement {
    const char* subprogram_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_kind";
            case 1L: return "e_function_subprogram_kind";
            case 2L: return "e_subroutine_subprogram_kind";
            case 3L: return "e_block_data_subprogram_kind";
            case 4L: return "e_last_subprogram_kind";
            default: return "";
        }
    }

    std::string subprogram_kind_enum(int64_t i, const std::string &strip) {
        std::string s = subprogram_kind_enum(i);
        if (s.empty())
            s = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& subprogram_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcedureHeaderStatement_subprogram_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcedureHeaderStatement::subprogram_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcedureHeaderStatement_subprogram_kind_enum() {
        return stringify::SgProcedureHeaderStatement::subprogram_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 210284
namespace stringify { namespace SgJovialDirectiveStatement {
    const char* directive_types(int64_t i) {
        switch (i) {
            case 0L: return "e_compool";
            case 1L: return "e_copy";
            case 2L: return "e_skip";
            case 3L: return "e_begin";
            case 4L: return "e_end";
            case 5L: return "e_linkage";
            case 6L: return "e_trace";
            case 7L: return "e_interference";
            case 8L: return "e_reducible";
            case 9L: return "e_nolist";
            case 10L: return "e_list";
            case 11L: return "e_eject";
            case 12L: return "e_listinv";
            case 13L: return "e_listexp";
            case 14L: return "e_base";
            case 15L: return "e_isbase";
            case 16L: return "e_drop";
            case 17L: return "e_left_right";
            case 18L: return "e_rearrange";
            case 19L: return "e_initialize";
            case 20L: return "e_order";
            default: return "";
        }
    }

    std::string directive_types(int64_t i, const std::string &strip) {
        std::string s = directive_types(i);
        if (s.empty())
            s = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& directive_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialDirectiveStatement_directive_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialDirectiveStatement::directive_types(i);
        if (retval.empty()) {
            retval = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialDirectiveStatement::directive_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialDirectiveStatement_directive_types() {
        return stringify::SgJovialDirectiveStatement::directive_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 219587
namespace stringify { namespace SgStopOrPauseStatement {
    const char* stop_or_pause_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_abort";
            case 2L: return "e_stop";
            case 3L: return "e_error_stop";
            case 4L: return "e_exit";
            case 5L: return "e_pause";
            default: return "";
        }
    }

    std::string stop_or_pause_enum(int64_t i, const std::string &strip) {
        std::string s = stop_or_pause_enum(i);
        if (s.empty())
            s = "(SgStopOrPauseStatement::stop_or_pause_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& stop_or_pause_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStopOrPauseStatement_stop_or_pause_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStopOrPauseStatement::stop_or_pause_enum(i);
        if (retval.empty()) {
            retval = "(SgStopOrPauseStatement::stop_or_pause_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStopOrPauseStatement::stop_or_pause_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStopOrPauseStatement_stop_or_pause_enum() {
        return stringify::SgStopOrPauseStatement::stop_or_pause_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 220103
namespace stringify { namespace SgIOStatement {
    const char* io_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_read";
            case 2L: return "e_print";
            case 3L: return "e_write";
            case 4L: return "e_open";
            case 5L: return "e_close";
            case 6L: return "e_inquire";
            case 7L: return "e_backspace";
            case 8L: return "e_endfile";
            case 9L: return "e_rewind";
            case 10L: return "e_last_io_statment_kind";
            default: return "";
        }
    }

    std::string io_statement_enum(int64_t i, const std::string &strip) {
        std::string s = io_statement_enum(i);
        if (s.empty())
            s = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& io_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgIOStatement_io_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgIOStatement::io_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgIOStatement::io_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgIOStatement_io_statement_enum() {
        return stringify::SgIOStatement::io_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 249958
namespace stringify { namespace SgImageControlStatement {
    const char* image_control_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_sync_all";
            case 2L: return "e_sync_images";
            case 3L: return "e_sync_memory";
            case 4L: return "e_sync_team";
            case 5L: return "e_change_team";
            case 6L: return "e_critical";
            case 7L: return "e_event_post";
            case 8L: return "e_event_wait";
            case 9L: return "e_form_team";
            case 10L: return "e_lock";
            case 11L: return "e_unlock";
            case 12L: return "e_last_image_control_statement";
            default: return "";
        }
    }

    std::string image_control_statement_enum(int64_t i, const std::string &strip) {
        std::string s = image_control_statement_enum(i);
        if (s.empty())
            s = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& image_control_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImageControlStatement_image_control_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImageControlStatement::image_control_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImageControlStatement::image_control_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImageControlStatement_image_control_statement_enum() {
        return stringify::SgImageControlStatement::image_control_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 254103
namespace stringify { namespace SgUnaryOp {
    const char* Sgop_mode(int64_t i) {
        switch (i) {
            case 0L: return "prefix";
            case 1L: return "postfix";
            default: return "";
        }
    }

    std::string Sgop_mode(int64_t i, const std::string &strip) {
        std::string s = Sgop_mode(i);
        if (s.empty())
            s = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Sgop_mode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnaryOpSgop_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnaryOp::Sgop_mode(i);
        if (retval.empty()) {
            retval = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnaryOp::Sgop_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnaryOpSgop_mode() {
        return stringify::SgUnaryOp::Sgop_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 259030
namespace stringify { namespace SgCastExp {
    const char* cast_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_style_cast";
            case 3L: return "e_const_cast";
            case 4L: return "e_static_cast";
            case 5L: return "e_dynamic_cast";
            case 6L: return "e_reinterpret_cast";
            case 8L: return "e_safe_cast";
            case 9L: return "e_last_cast";
            default: return "";
        }
    }

    std::string cast_type_enum(int64_t i, const std::string &strip) {
        std::string s = cast_type_enum(i);
        if (s.empty())
            s = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cast_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgCastExp_cast_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgCastExp::cast_type_enum(i);
        if (retval.empty()) {
            retval = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgCastExp::cast_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgCastExp_cast_type_enum() {
        return stringify::SgCastExp::cast_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 259637
namespace stringify { namespace SgThrowOp {
    const char* e_throw_kind(int64_t i) {
        switch (i) {
            case 0L: return "unknown_throw";
            case 1L: return "throw_expression";
            case 2L: return "rethrow";
            default: return "";
        }
    }

    std::string e_throw_kind(int64_t i, const std::string &strip) {
        std::string s = e_throw_kind(i);
        if (s.empty())
            s = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& e_throw_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgThrowOp_e_throw_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgThrowOp::e_throw_kind(i);
        if (retval.empty()) {
            retval = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgThrowOp::e_throw_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgThrowOp_e_throw_kind() {
        return stringify::SgThrowOp::e_throw_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 328874
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_input";
            case 2L: return "e_output";
            case 3L: return "e_modify";
            case 4L: return "e_earlyclobber";
            case 8L: return "e_commutative";
            case 16L: return "e_ignore_next";
            case 32L: return "e_ignore_till_comma";
            case 64L: return "e_poor_choice";
            case 128L: return "e_bad_choice";
            default: return "";
        }
    }

    std::string asm_operand_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_modifier_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_modifier_enum() {
        return stringify::SgAsmOp::asm_operand_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 328893
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_constraint_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid";
            case 1L: return "e_any";
            case 2L: return "e_general";
            case 3L: return "e_match_0";
            case 4L: return "aoc_match_1";
            case 5L: return "aoc_match_2";
            case 6L: return "aoc_match_3";
            case 7L: return "aoc_match_4";
            case 8L: return "e_match_5";
            case 9L: return "aoc_match_6";
            case 10L: return "aoc_match_7";
            case 11L: return "aoc_match_8";
            case 12L: return "aoc_match_9";
            case 13L: return "e_reg_integer";
            case 14L: return "e_reg_float";
            case 15L: return "e_mem_any";
            case 16L: return "e_mem_offset";
            case 17L: return "e_mem_nonoffset";
            case 18L: return "e_mem_autoinc";
            case 19L: return "e_mem_autodec";
            case 20L: return "e_imm_int";
            case 21L: return "e_imm_number";
            case 22L: return "e_imm_symbol";
            case 23L: return "e_imm_float";
            case 24L: return "e_reg_a";
            case 25L: return "e_reg_b";
            case 26L: return "e_reg_c";
            case 27L: return "e_reg_d";
            case 28L: return "e_reg_si";
            case 29L: return "e_reg_di";
            case 30L: return "e_reg_legacy";
            case 31L: return "e_reg_q";
            case 32L: return "e_reg_ad";
            case 33L: return "e_reg_float_tos";
            case 34L: return "e_reg_float_second";
            case 35L: return "e_reg_sse";
            case 36L: return "e_reg_sse2";
            case 37L: return "e_reg_mmx";
            case 38L: return "e_imm_short_shift";
            case 39L: return "e_imm_long_shift";
            case 40L: return "e_imm_lea_shift";
            case 41L: return "e_imm_signed8";
            case 42L: return "e_imm_unsigned8";
            case 43L: return "e_imm_and_zext";
            case 44L: return "e_imm_80387";
            case 45L: return "e_imm_sse";
            case 46L: return "e_imm_sext32";
            case 47L: return "e_imm_zext32";
            case 48L: return "e_last";
            default: return "";
        }
    }

    std::string asm_operand_constraint_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_constraint_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_constraint_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L
        };
        static const std::vector<int64_t> retval(values, values + 49);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_constraint_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_constraint_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_constraint_enum() {
        return stringify::SgAsmOp::asm_operand_constraint_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 357656
namespace stringify { namespace SgLabelSymbol {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_label_type";
            case 1L: return "e_non_numeric_label_type";
            case 2L: return "e_start_label_type";
            case 3L: return "e_else_label_type";
            case 4L: return "e_end_label_type";
            case 5L: return "e_alternative_return_type";
            case 6L: return "e_last_label_type";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelSymbol_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelSymbol::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelSymbol::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelSymbol_label_type_enum() {
        return stringify::SgLabelSymbol::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 397694
namespace stringify { namespace SgAsmLEFileHeader {
    const char* LEFileHeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_MODTYPE_PROG";
            case 4L: return "HF_PROC_LIB_INIT";
            case 16L: return "HF_IFIXUPS_APPLIED";
            case 32L: return "HF_EFIXUPS_APPLIED";
            case 256L: return "HF_PM_WINDOW_NO";
            case 512L: return "HF_PM_WINDOW_OK";
            case 768L: return "HF_PM_WINDOW_USE";
            case 8192L: return "HF_NOT_LOADABLE";
            case 32768L: return "HF_MODTYPE_LIB";
            case 98304L: return "HF_MODTYPE_PLIB";
            case 131072L: return "HF_MODTYPE_PDEV";
            case 163840L: return "HF_MODTYPE_VDEV";
            case 229376L: return "HF_MODTYPE_MASK";
            case 1073741824L: return "HF_PROC_LIB_TERM";
            case 3220987083L: return "HF_RESERVED";
            default: return "";
        }
    }

    std::string LEFileHeaderFlags(int64_t i, const std::string &strip) {
        std::string s = LEFileHeaderFlags(i);
        if (s.empty())
            s = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LEFileHeaderFlags() {
        static const int64_t values[] = {
            0L,
            4L,
            16L,
            32L,
            256L,
            512L,
            768L,
            8192L,
            32768L,
            98304L,
            131072L,
            163840L,
            229376L,
            1073741824L,
            3220987083L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLEFileHeaderLEFileHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLEFileHeader::LEFileHeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLEFileHeaderLEFileHeaderFlags() {
        return stringify::SgAsmLEFileHeader::LEFileHeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 398681
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags1(int64_t i) {
        switch (i) {
            case 0L: return "HF1_NO_DATA";
            case 1L: return "HF1_SINGLE_DATA";
            case 2L: return "HF1_MULTIPLE_DATA";
            case 2048L: return "HF1_LOADER_SEGMENT";
            case 8192L: return "HF1_FATAL_ERRORS";
            case 22516L: return "HF1_RESERVED";
            case 32768L: return "HF1_LIBRARY";
            default: return "";
        }
    }

    std::string HeaderFlags1(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags1(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags1() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            2048L,
            8192L,
            22516L,
            32768L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags1(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags1(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags1() {
        return stringify::SgAsmNEFileHeader::HeaderFlags1();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 398692
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags2(int64_t i) {
        switch (i) {
            case 2L: return "HF2_PROTECTED_MODE";
            case 4L: return "HF2_PFONTS";
            case 8L: return "HF2_FASTLOAD";
            case 241L: return "HF2_RESERVED";
            default: return "";
        }
    }

    std::string HeaderFlags2(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags2(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags2() {
        static const int64_t values[] = {
            2L,
            4L,
            8L,
            241L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags2(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags2(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags2() {
        return stringify::SgAsmNEFileHeader::HeaderFlags2();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 440732
namespace stringify { namespace SgAsmNEEntryPoint {
    const char* NEEntryFlags(int64_t i) {
        switch (i) {
            case 0L: return "EF_ZERO";
            case 1L: return "EF_EXPORTED";
            case 2L: return "EF_GLOBAL";
            case 252L: return "EF_RESERVED";
            default: return "";
        }
    }

    std::string NEEntryFlags(int64_t i, const std::string &strip) {
        std::string s = NEEntryFlags(i);
        if (s.empty())
            s = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NEEntryFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            252L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEEntryPointNEEntryFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEEntryPoint::NEEntryFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEEntryPointNEEntryFlags() {
        return stringify::SgAsmNEEntryPoint::NEEntryFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 441257
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocSrcType(int64_t i) {
        switch (i) {
            case 0L: return "RF_SRCTYPE_8OFF";
            case 2L: return "RF_SRCTYPE_WORDSEG";
            case 3L: return "RF_SRCTYPE_16PTR";
            case 5L: return "RF_SRCTYPE_16OFF";
            case 6L: return "RF_SRCTYPE_32PTR";
            case 7L: return "RF_SRCTYPE_32OFF";
            case 8L: return "RF_SRCTYPE_NEARCALL";
            case 11L: return "RF_SRCTYPE_48PTR";
            case 13L: return "RF_SRCTYPE_32OFF_b";
            default: return "";
        }
    }

    std::string NERelocSrcType(int64_t i, const std::string &strip) {
        std::string s = NERelocSrcType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocSrcType() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            5L,
            6L,
            7L,
            8L,
            11L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocSrcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocSrcType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocSrcType() {
        return stringify::SgAsmNERelocEntry::NERelocSrcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 441269
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocTgtType(int64_t i) {
        switch (i) {
            case 0L: return "RF_TGTTYPE_IREF";
            case 1L: return "RF_TGTTYPE_IORD";
            case 2L: return "RF_TGTTYPE_INAME";
            case 3L: return "RF_TGTTYPE_OSFIXUP";
            default: return "";
        }
    }

    std::string NERelocTgtType(int64_t i, const std::string &strip) {
        std::string s = NERelocTgtType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocTgtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocTgtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocTgtType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocTgtType() {
        return stringify::SgAsmNERelocEntry::NERelocTgtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 441276
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocModifiers(int64_t i) {
        switch (i) {
            case 1L: return "RF_MODIFIER_SINGLE";
            case 3L: return "RF_MODIFIER_MULTI";
            default: return "";
        }
    }

    std::string NERelocModifiers(int64_t i, const std::string &strip) {
        std::string s = NERelocModifiers(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocModifiers() {
        static const int64_t values[] = {
            1L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocModifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocModifiers(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocModifiers() {
        return stringify::SgAsmNERelocEntry::NERelocModifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 441281
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocFlags(int64_t i) {
        switch (i) {
            case 1L: return "RF_ADDITIVE";
            case 2L: return "RF_RESERVED";
            case 4L: return "RF_2EXTRA";
            case 8L: return "RF_32ADD";
            case 16L: return "RF_16SECTION";
            case 32L: return "RF_8ORDINAL";
            default: return "";
        }
    }

    std::string NERelocFlags(int64_t i, const std::string &strip) {
        std::string s = NERelocFlags(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocFlags() {
        return stringify::SgAsmNERelocEntry::NERelocFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 441918
namespace stringify { namespace SgAsmNESectionTableEntry {
    const char* NESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_CODE";
            case 1L: return "SF_DATA";
            case 2L: return "SF_ALLOC";
            case 4L: return "SF_LOAD";
            case 7L: return "SF_TYPE_MASK";
            case 16L: return "SF_MOVABLE";
            case 32L: return "SF_PURE";
            case 64L: return "SF_PRELOAD";
            case 128L: return "SF_NOT_WRITABLE";
            case 256L: return "SF_RELOCINFO";
            case 3592L: return "SF_RESERVED";
            case 4096L: return "SF_DISCARDABLE";
            case 61440L: return "SF_DISCARD";
            default: return "";
        }
    }

    std::string NESectionFlags(int64_t i, const std::string &strip) {
        std::string s = NESectionFlags(i);
        if (s.empty())
            s = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L,
            16L,
            32L,
            64L,
            128L,
            256L,
            3592L,
            4096L,
            61440L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNESectionTableEntryNESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNESectionTableEntry::NESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNESectionTableEntryNESectionFlags() {
        return stringify::SgAsmNESectionTableEntry::NESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 444054
namespace stringify { namespace SgAsmLESectionTableEntry {
    const char* LESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_TYPE_NORMAL";
            case 1L: return "SF_READABLE";
            case 2L: return "SF_WRITABLE";
            case 4L: return "SF_EXECUTABLE";
            case 8L: return "SF_RESOURCE";
            case 16L: return "SF_DISCARDABLE";
            case 32L: return "SF_SHARED";
            case 64L: return "SF_PRELOAD_PAGES";
            case 128L: return "SF_INVALID_PAGES";
            case 256L: return "SF_TYPE_ZERO";
            case 512L: return "SF_TYPE_RESIDENT";
            case 768L: return "SF_TYPE_RESCONT";
            case 1024L: return "SF_RES_LONG_LOCK";
            case 4096L: return "SF_1616_ALIAS";
            case 8192L: return "SF_BIG_BIT";
            case 16384L: return "SF_CODE_CONFORM";
            case 32768L: return "SF_IO_PRIV";
            case 4294903808L: return "SF_RESERVED";
            default: return "";
        }
    }

    std::string LESectionFlags(int64_t i, const std::string &strip) {
        std::string s = LESectionFlags(i);
        if (s.empty())
            s = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            16384L,
            32768L,
            4294903808L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLESectionTableEntryLESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLESectionTableEntry::LESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLESectionTableEntryLESectionFlags() {
        return stringify::SgAsmLESectionTableEntry::LESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 3
namespace stringify {
    const char* E_SgSourceFile(int64_t i) {
        switch (i) {
            case 0L: return "SgSourceFile_globalScope";
            case 1L: return "SgSourceFile_package";
            case 2L: return "SgSourceFile_import_list";
            case 3L: return "SgSourceFile_class_list";
            default: return "";
        }
    }

    std::string E_SgSourceFile(int64_t i, const std::string &strip) {
        std::string s = E_SgSourceFile(i);
        if (s.empty())
            s = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSourceFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSourceFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSourceFile(i);
        if (retval.empty()) {
            retval = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSourceFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSourceFile() {
        return stringify::E_SgSourceFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 6
namespace stringify {
    const char* E_SgBinaryComposite(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryComposite_genericFileList";
            case 1L: return "SgBinaryComposite_interpretations";
            default: return "";
        }
    }

    std::string E_SgBinaryComposite(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryComposite(i);
        if (s.empty())
            s = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryComposite() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryComposite(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryComposite(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryComposite::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryComposite() {
        return stringify::E_SgBinaryComposite();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 9
namespace stringify {
    const char* E_SgUnknownFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownFile_globalScope";
            default: return "";
        }
    }

    std::string E_SgUnknownFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownFile(i);
        if (s.empty())
            s = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownFile(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownFile() {
        return stringify::E_SgUnknownFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 12
namespace stringify {
    const char* E_SgProject(int64_t i) {
        switch (i) {
            case 0L: return "SgProject_fileList_ptr";
            default: return "";
        }
    }

    std::string E_SgProject(int64_t i, const std::string &strip) {
        std::string s = E_SgProject(i);
        if (s.empty())
            s = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProject(i);
        if (retval.empty()) {
            retval = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProject() {
        return stringify::E_SgProject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 15
namespace stringify {
    const char* E_SgExpBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgExpBaseClass_base_class";
            case 1L: return "SgExpBaseClass_base_class_exp";
            default: return "";
        }
    }

    std::string E_SgExpBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgExpBaseClass(i);
        if (s.empty())
            s = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpBaseClass() {
        return stringify::E_SgExpBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 18
namespace stringify {
    const char* E_SgNonrealBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealBaseClass_base_class";
            case 1L: return "SgNonrealBaseClass_base_class_nonreal";
            default: return "";
        }
    }

    std::string E_SgNonrealBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealBaseClass(i);
        if (s.empty())
            s = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealBaseClass() {
        return stringify::E_SgNonrealBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 21
namespace stringify {
    const char* E_SgBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgBaseClass_base_class";
            default: return "";
        }
    }

    std::string E_SgBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgBaseClass(i);
        if (s.empty())
            s = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBaseClass() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBaseClass() {
        return stringify::E_SgBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 24
namespace stringify {
    const char* E_SgTemplateParameter(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameter_expression";
            case 1L: return "SgTemplateParameter_defaultExpressionParameter";
            case 2L: return "SgTemplateParameter_templateDeclaration";
            case 3L: return "SgTemplateParameter_defaultTemplateDeclarationParameter";
            case 4L: return "SgTemplateParameter_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateParameter(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameter(i);
        if (s.empty())
            s = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameter(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameter() {
        return stringify::E_SgTemplateParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 27
namespace stringify {
    const char* E_SgTemplateArgument(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgument_expression";
            case 1L: return "SgTemplateArgument_templateDeclaration";
            case 2L: return "SgTemplateArgument_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateArgument(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgument(i);
        if (s.empty())
            s = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgument() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgument(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgument(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgument::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgument() {
        return stringify::E_SgTemplateArgument();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 30
namespace stringify {
    const char* E_SgDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectory_fileList";
            case 1L: return "SgDirectory_directoryList";
            default: return "";
        }
    }

    std::string E_SgDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectory(i);
        if (s.empty())
            s = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectory() {
        return stringify::E_SgDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 33
namespace stringify {
    const char* E_SgFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgFileList_listOfFiles";
            default: return "";
        }
    }

    std::string E_SgFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgFileList(i);
        if (s.empty())
            s = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFileList(i);
        if (retval.empty()) {
            retval = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFileList() {
        return stringify::E_SgFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 36
namespace stringify {
    const char* E_SgDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectoryList_listOfDirectories";
            default: return "";
        }
    }

    std::string E_SgDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectoryList(i);
        if (s.empty())
            s = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectoryList() {
        return stringify::E_SgDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 39
namespace stringify {
    const char* E_SgTemplateArgumentList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgumentList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateArgumentList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgumentList(i);
        if (s.empty())
            s = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgumentList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgumentList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgumentList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgumentList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgumentList() {
        return stringify::E_SgTemplateArgumentList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 42
namespace stringify {
    const char* E_SgTemplateParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameterList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameterList(i);
        if (s.empty())
            s = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameterList() {
        return stringify::E_SgTemplateParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 45
namespace stringify {
    const char* E_SgIncludeFile(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeFile_include_file_list";
            default: return "";
        }
    }

    std::string E_SgIncludeFile(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeFile(i);
        if (s.empty())
            s = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeFile(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeFile() {
        return stringify::E_SgIncludeFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 48
namespace stringify {
    const char* E_SgJavaImportStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaImportStatementList_java_import_list";
            default: return "";
        }
    }

    std::string E_SgJavaImportStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaImportStatementList(i);
        if (s.empty())
            s = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaImportStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaImportStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaImportStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaImportStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaImportStatementList() {
        return stringify::E_SgJavaImportStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 51
namespace stringify {
    const char* E_SgJavaClassDeclarationList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaClassDeclarationList_java_class_list";
            default: return "";
        }
    }

    std::string E_SgJavaClassDeclarationList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaClassDeclarationList(i);
        if (s.empty())
            s = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaClassDeclarationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaClassDeclarationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaClassDeclarationList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaClassDeclarationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaClassDeclarationList() {
        return stringify::E_SgJavaClassDeclarationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 54
namespace stringify {
    const char* E_SgTypeUnknown(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnknown_type_kind";
            case 1L: return "SgTypeUnknown_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnknown(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnknown(i);
        if (s.empty())
            s = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnknown() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnknown(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnknown(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnknown::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnknown() {
        return stringify::E_SgTypeUnknown();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 57
namespace stringify {
    const char* E_SgTypeChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar_type_kind";
            case 1L: return "SgTypeChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar(i);
        if (s.empty())
            s = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar() {
        return stringify::E_SgTypeChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 60
namespace stringify {
    const char* E_SgTypeSignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedChar_type_kind";
            case 1L: return "SgTypeSignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedChar(i);
        if (s.empty())
            s = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedChar() {
        return stringify::E_SgTypeSignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 63
namespace stringify {
    const char* E_SgTypeUnsignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedChar_type_kind";
            case 1L: return "SgTypeUnsignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedChar(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedChar() {
        return stringify::E_SgTypeUnsignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 66
namespace stringify {
    const char* E_SgTypeShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeShort_type_kind";
            case 1L: return "SgTypeShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeShort(i);
        if (s.empty())
            s = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeShort() {
        return stringify::E_SgTypeShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 69
namespace stringify {
    const char* E_SgTypeSignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedShort_type_kind";
            case 1L: return "SgTypeSignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedShort(i);
        if (s.empty())
            s = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedShort() {
        return stringify::E_SgTypeSignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 72
namespace stringify {
    const char* E_SgTypeUnsignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedShort_type_kind";
            case 1L: return "SgTypeUnsignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedShort(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedShort() {
        return stringify::E_SgTypeUnsignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 75
namespace stringify {
    const char* E_SgTypeInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeInt_type_kind";
            case 1L: return "SgTypeInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeInt(i);
        if (s.empty())
            s = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeInt() {
        return stringify::E_SgTypeInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 78
namespace stringify {
    const char* E_SgTypeSignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedInt_type_kind";
            case 1L: return "SgTypeSignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedInt(i);
        if (s.empty())
            s = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedInt() {
        return stringify::E_SgTypeSignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 81
namespace stringify {
    const char* E_SgTypeUnsignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedInt_type_kind";
            case 1L: return "SgTypeUnsignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedInt(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedInt() {
        return stringify::E_SgTypeUnsignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 84
namespace stringify {
    const char* E_SgTypeLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLong_type_kind";
            case 1L: return "SgTypeLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLong(i);
        if (s.empty())
            s = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLong() {
        return stringify::E_SgTypeLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 87
namespace stringify {
    const char* E_SgTypeSignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLong_type_kind";
            case 1L: return "SgTypeSignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLong() {
        return stringify::E_SgTypeSignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 90
namespace stringify {
    const char* E_SgTypeUnsignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLong_type_kind";
            case 1L: return "SgTypeUnsignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLong() {
        return stringify::E_SgTypeUnsignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 93
namespace stringify {
    const char* E_SgTypeVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeVoid_type_kind";
            case 1L: return "SgTypeVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeVoid(i);
        if (s.empty())
            s = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeVoid() {
        return stringify::E_SgTypeVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 96
namespace stringify {
    const char* E_SgTypeGlobalVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeGlobalVoid_type_kind";
            case 1L: return "SgTypeGlobalVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeGlobalVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeGlobalVoid(i);
        if (s.empty())
            s = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeGlobalVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeGlobalVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeGlobalVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeGlobalVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeGlobalVoid() {
        return stringify::E_SgTypeGlobalVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 99
namespace stringify {
    const char* E_SgTypeWchar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeWchar_type_kind";
            case 1L: return "SgTypeWchar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeWchar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeWchar(i);
        if (s.empty())
            s = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeWchar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeWchar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeWchar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeWchar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeWchar() {
        return stringify::E_SgTypeWchar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 102
namespace stringify {
    const char* E_SgTypeFloat(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat_type_kind";
            case 1L: return "SgTypeFloat_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat(i);
        if (s.empty())
            s = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat() {
        return stringify::E_SgTypeFloat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 105
namespace stringify {
    const char* E_SgTypeDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDouble_type_kind";
            case 1L: return "SgTypeDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDouble(i);
        if (s.empty())
            s = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDouble() {
        return stringify::E_SgTypeDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 108
namespace stringify {
    const char* E_SgTypeLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongLong_type_kind";
            case 1L: return "SgTypeLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongLong(i);
        if (s.empty())
            s = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongLong() {
        return stringify::E_SgTypeLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 111
namespace stringify {
    const char* E_SgTypeSignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLongLong_type_kind";
            case 1L: return "SgTypeSignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLongLong() {
        return stringify::E_SgTypeSignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 114
namespace stringify {
    const char* E_SgTypeUnsignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLongLong_type_kind";
            case 1L: return "SgTypeUnsignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLongLong() {
        return stringify::E_SgTypeUnsignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 117
namespace stringify {
    const char* E_SgTypeSigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSigned128bitInteger_type_kind";
            case 1L: return "SgTypeSigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSigned128bitInteger() {
        return stringify::E_SgTypeSigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 120
namespace stringify {
    const char* E_SgTypeUnsigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsigned128bitInteger_type_kind";
            case 1L: return "SgTypeUnsigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsigned128bitInteger() {
        return stringify::E_SgTypeUnsigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 123
namespace stringify {
    const char* E_SgTypeFloat80(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat80_type_kind";
            case 1L: return "SgTypeFloat80_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat80(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat80(i);
        if (s.empty())
            s = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat80() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat80(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat80(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat80::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat80() {
        return stringify::E_SgTypeFloat80();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 126
namespace stringify {
    const char* E_SgTypeLongDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongDouble_type_kind";
            case 1L: return "SgTypeLongDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongDouble(i);
        if (s.empty())
            s = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongDouble() {
        return stringify::E_SgTypeLongDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 129
namespace stringify {
    const char* E_SgTypeString(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeString_type_kind";
            case 1L: return "SgTypeString_lengthExpression";
            default: return "";
        }
    }

    std::string E_SgTypeString(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeString(i);
        if (s.empty())
            s = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeString() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeString(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeString(i);
        if (retval.empty()) {
            retval = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeString::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeString() {
        return stringify::E_SgTypeString();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 132
namespace stringify {
    const char* E_SgTypeBool(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeBool_type_kind";
            case 1L: return "SgTypeBool_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeBool(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeBool(i);
        if (s.empty())
            s = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeBool() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeBool(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeBool(i);
        if (retval.empty()) {
            retval = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeBool::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeBool() {
        return stringify::E_SgTypeBool();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 135
namespace stringify {
    const char* E_SgPointerMemberType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerMemberType_type_kind";
            case 1L: return "SgPointerMemberType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerMemberType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerMemberType(i);
        if (s.empty())
            s = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerMemberType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerMemberType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerMemberType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerMemberType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerMemberType() {
        return stringify::E_SgPointerMemberType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 138
namespace stringify {
    const char* E_SgPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerType_type_kind";
            case 1L: return "SgPointerType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerType(i);
        if (s.empty())
            s = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerType() {
        return stringify::E_SgPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 141
namespace stringify {
    const char* E_SgReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgReferenceType(i);
        if (s.empty())
            s = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReferenceType() {
        return stringify::E_SgReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 144
namespace stringify {
    const char* E_SgJavaParameterType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterType_type_kind";
            case 1L: return "SgJavaParameterType_builtin_type";
            case 2L: return "SgJavaParameterType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterType(i);
        if (s.empty())
            s = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterType() {
        return stringify::E_SgJavaParameterType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 147
namespace stringify {
    const char* E_SgJovialTableType(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableType_type_kind";
            case 1L: return "SgJovialTableType_builtin_type";
            case 2L: return "SgJovialTableType_declaration";
            case 3L: return "SgJovialTableType_dim_info";
            default: return "";
        }
    }

    std::string E_SgJovialTableType(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableType(i);
        if (s.empty())
            s = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableType(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableType() {
        return stringify::E_SgJovialTableType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 150
namespace stringify {
    const char* E_SgClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgClassType_type_kind";
            case 1L: return "SgClassType_builtin_type";
            case 2L: return "SgClassType_declaration";
            default: return "";
        }
    }

    std::string E_SgClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgClassType(i);
        if (s.empty())
            s = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassType(i);
        if (retval.empty()) {
            retval = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassType() {
        return stringify::E_SgClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 153
namespace stringify {
    const char* E_SgEnumType(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumType_type_kind";
            case 1L: return "SgEnumType_builtin_type";
            case 2L: return "SgEnumType_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumType(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumType(i);
        if (s.empty())
            s = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumType(i);
        if (retval.empty()) {
            retval = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumType() {
        return stringify::E_SgEnumType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 156
namespace stringify {
    const char* E_SgTypedefType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefType_type_kind";
            case 1L: return "SgTypedefType_builtin_type";
            case 2L: return "SgTypedefType_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefType(i);
        if (s.empty())
            s = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefType(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefType() {
        return stringify::E_SgTypedefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 159
namespace stringify {
    const char* E_SgNonrealType(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealType_type_kind";
            case 1L: return "SgNonrealType_builtin_type";
            case 2L: return "SgNonrealType_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealType(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealType(i);
        if (s.empty())
            s = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealType(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealType() {
        return stringify::E_SgNonrealType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 162
namespace stringify {
    const char* E_SgJavaParameterizedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterizedType_type_kind";
            case 1L: return "SgJavaParameterizedType_builtin_type";
            case 2L: return "SgJavaParameterizedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterizedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterizedType(i);
        if (s.empty())
            s = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterizedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterizedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterizedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterizedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterizedType() {
        return stringify::E_SgJavaParameterizedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 165
namespace stringify {
    const char* E_SgJavaQualifiedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaQualifiedType_type_kind";
            case 1L: return "SgJavaQualifiedType_builtin_type";
            case 2L: return "SgJavaQualifiedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaQualifiedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaQualifiedType(i);
        if (s.empty())
            s = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaQualifiedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaQualifiedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaQualifiedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaQualifiedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaQualifiedType() {
        return stringify::E_SgJavaQualifiedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 168
namespace stringify {
    const char* E_SgJavaWildcardType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaWildcardType_type_kind";
            case 1L: return "SgJavaWildcardType_builtin_type";
            case 2L: return "SgJavaWildcardType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaWildcardType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaWildcardType(i);
        if (s.empty())
            s = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaWildcardType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaWildcardType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaWildcardType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaWildcardType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaWildcardType() {
        return stringify::E_SgJavaWildcardType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 171
namespace stringify {
    const char* E_SgNamedType(int64_t i) {
        switch (i) {
            case 0L: return "SgNamedType_type_kind";
            case 1L: return "SgNamedType_builtin_type";
            case 2L: return "SgNamedType_declaration";
            default: return "";
        }
    }

    std::string E_SgNamedType(int64_t i, const std::string &strip) {
        std::string s = E_SgNamedType(i);
        if (s.empty())
            s = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamedType(i);
        if (retval.empty()) {
            retval = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamedType() {
        return stringify::E_SgNamedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 174
namespace stringify {
    const char* E_SgModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgModifierType_type_kind";
            case 1L: return "SgModifierType_base_type";
            default: return "";
        }
    }

    std::string E_SgModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgModifierType(i);
        if (s.empty())
            s = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModifierType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModifierType() {
        return stringify::E_SgModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 177
namespace stringify {
    const char* E_SgPartialFunctionModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionModifierType_type_kind";
            case 1L: return "SgPartialFunctionModifierType_return_type";
            case 2L: return "SgPartialFunctionModifierType_orig_return_type";
            case 3L: return "SgPartialFunctionModifierType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionModifierType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionModifierType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionModifierType() {
        return stringify::E_SgPartialFunctionModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 180
namespace stringify {
    const char* E_SgPartialFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionType_type_kind";
            case 1L: return "SgPartialFunctionType_return_type";
            case 2L: return "SgPartialFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionType() {
        return stringify::E_SgPartialFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 183
namespace stringify {
    const char* E_SgMemberFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionType_type_kind";
            case 1L: return "SgMemberFunctionType_return_type";
            case 2L: return "SgMemberFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionType(i);
        if (s.empty())
            s = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionType() {
        return stringify::E_SgMemberFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 186
namespace stringify {
    const char* E_SgFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionType_type_kind";
            case 1L: return "SgFunctionType_return_type";
            case 2L: return "SgFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionType(i);
        if (s.empty())
            s = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionType() {
        return stringify::E_SgFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 189
namespace stringify {
    const char* E_SgArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgArrayType_type_kind";
            case 1L: return "SgArrayType_index";
            case 2L: return "SgArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgArrayType(i);
        if (s.empty())
            s = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrayType() {
        return stringify::E_SgArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 192
namespace stringify {
    const char* E_SgTypeEllipse(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeEllipse_type_kind";
            case 1L: return "SgTypeEllipse_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeEllipse(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeEllipse(i);
        if (s.empty())
            s = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeEllipse() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeEllipse(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeEllipse(i);
        if (retval.empty()) {
            retval = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeEllipse::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeEllipse() {
        return stringify::E_SgTypeEllipse();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 195
namespace stringify {
    const char* E_SgTemplateType(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateType_type_kind";
            case 1L: return "SgTemplateType_class_type";
            case 2L: return "SgTemplateType_parent_class_type";
            case 3L: return "SgTemplateType_template_parameter";
            default: return "";
        }
    }

    std::string E_SgTemplateType(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateType(i);
        if (s.empty())
            s = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateType(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateType() {
        return stringify::E_SgTemplateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 198
namespace stringify {
    const char* E_SgQualifiedNameType(int64_t i) {
        switch (i) {
            case 0L: return "SgQualifiedNameType_type_kind";
            default: return "";
        }
    }

    std::string E_SgQualifiedNameType(int64_t i, const std::string &strip) {
        std::string s = E_SgQualifiedNameType(i);
        if (s.empty())
            s = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgQualifiedNameType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgQualifiedNameType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgQualifiedNameType(i);
        if (retval.empty()) {
            retval = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgQualifiedNameType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgQualifiedNameType() {
        return stringify::E_SgQualifiedNameType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 201
namespace stringify {
    const char* E_SgTypeComplex(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeComplex_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeComplex(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeComplex(i);
        if (s.empty())
            s = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeComplex() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeComplex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeComplex(i);
        if (retval.empty()) {
            retval = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeComplex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeComplex() {
        return stringify::E_SgTypeComplex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 204
namespace stringify {
    const char* E_SgTypeImaginary(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeImaginary_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeImaginary(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeImaginary(i);
        if (s.empty())
            s = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeImaginary() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeImaginary(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeImaginary(i);
        if (retval.empty()) {
            retval = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeImaginary::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeImaginary() {
        return stringify::E_SgTypeImaginary();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 207
namespace stringify {
    const char* E_SgTypeDefault(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDefault_type_kind";
            case 1L: return "SgTypeDefault_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDefault(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDefault(i);
        if (s.empty())
            s = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDefault() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDefault(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDefault(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDefault::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDefault() {
        return stringify::E_SgTypeDefault();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 210
namespace stringify {
    const char* E_SgTypeCAFTeam(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCAFTeam_type_kind";
            case 1L: return "SgTypeCAFTeam_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCAFTeam(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCAFTeam(i);
        if (s.empty())
            s = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCAFTeam() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCAFTeam(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCAFTeam(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCAFTeam::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCAFTeam() {
        return stringify::E_SgTypeCAFTeam();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 213
namespace stringify {
    const char* E_SgTypeCrayPointer(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCrayPointer_type_kind";
            case 1L: return "SgTypeCrayPointer_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCrayPointer(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCrayPointer(i);
        if (s.empty())
            s = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCrayPointer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCrayPointer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCrayPointer(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCrayPointer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCrayPointer() {
        return stringify::E_SgTypeCrayPointer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 216
namespace stringify {
    const char* E_SgTypeLabel(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLabel_type_kind";
            case 1L: return "SgTypeLabel_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLabel(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLabel(i);
        if (s.empty())
            s = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLabel() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLabel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLabel(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLabel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLabel() {
        return stringify::E_SgTypeLabel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 219
namespace stringify {
    const char* E_SgJavaUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnionType_type_kind";
            default: return "";
        }
    }

    std::string E_SgJavaUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnionType(i);
        if (s.empty())
            s = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnionType() {
        return stringify::E_SgJavaUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 222
namespace stringify {
    const char* E_SgRvalueReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgRvalueReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRvalueReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgRvalueReferenceType(i);
        if (s.empty())
            s = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRvalueReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRvalueReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRvalueReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRvalueReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRvalueReferenceType() {
        return stringify::E_SgRvalueReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 225
namespace stringify {
    const char* E_SgTypeNullptr(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeNullptr_type_kind";
            case 1L: return "SgTypeNullptr_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeNullptr(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeNullptr(i);
        if (s.empty())
            s = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeNullptr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeNullptr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeNullptr(i);
        if (retval.empty()) {
            retval = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeNullptr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeNullptr() {
        return stringify::E_SgTypeNullptr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 228
namespace stringify {
    const char* E_SgDeclType(int64_t i) {
        switch (i) {
            case 0L: return "SgDeclType_type_kind";
            default: return "";
        }
    }

    std::string E_SgDeclType(int64_t i, const std::string &strip) {
        std::string s = E_SgDeclType(i);
        if (s.empty())
            s = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeclType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeclType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeclType(i);
        if (retval.empty()) {
            retval = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeclType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeclType() {
        return stringify::E_SgDeclType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 231
namespace stringify {
    const char* E_SgTypeOfType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeOfType_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeOfType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeOfType(i);
        if (s.empty())
            s = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeOfType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeOfType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeOfType(i);
        if (retval.empty()) {
            retval = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeOfType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeOfType() {
        return stringify::E_SgTypeOfType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 234
namespace stringify {
    const char* E_SgTypeMatrix(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeMatrix_type_kind";
            case 1L: return "SgTypeMatrix_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeMatrix(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeMatrix(i);
        if (s.empty())
            s = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeMatrix() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeMatrix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeMatrix(i);
        if (retval.empty()) {
            retval = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeMatrix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeMatrix() {
        return stringify::E_SgTypeMatrix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 237
namespace stringify {
    const char* E_SgTypeTuple(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeTuple_type_kind";
            case 1L: return "SgTypeTuple_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeTuple(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeTuple(i);
        if (s.empty())
            s = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeTuple() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeTuple(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeTuple(i);
        if (retval.empty()) {
            retval = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeTuple::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeTuple() {
        return stringify::E_SgTypeTuple();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 240
namespace stringify {
    const char* E_SgTypeChar16(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar16_type_kind";
            case 1L: return "SgTypeChar16_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar16(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar16(i);
        if (s.empty())
            s = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar16() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar16(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar16(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar16::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar16() {
        return stringify::E_SgTypeChar16();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 243
namespace stringify {
    const char* E_SgTypeChar32(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar32_type_kind";
            case 1L: return "SgTypeChar32_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar32(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar32(i);
        if (s.empty())
            s = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar32() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar32(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar32(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar32::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar32() {
        return stringify::E_SgTypeChar32();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 246
namespace stringify {
    const char* E_SgTypeFloat128(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat128_type_kind";
            case 1L: return "SgTypeFloat128_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat128(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat128(i);
        if (s.empty())
            s = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat128() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat128(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat128(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat128::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat128() {
        return stringify::E_SgTypeFloat128();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 249
namespace stringify {
    const char* E_SgAutoType(int64_t i) {
        switch (i) {
            case 0L: return "SgAutoType_type_kind";
            default: return "";
        }
    }

    std::string E_SgAutoType(int64_t i, const std::string &strip) {
        std::string s = E_SgAutoType(i);
        if (s.empty())
            s = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAutoType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAutoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAutoType(i);
        if (retval.empty()) {
            retval = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAutoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAutoType() {
        return stringify::E_SgAutoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 252
namespace stringify {
    const char* E_SgType(int64_t i) {
        switch (i) {
            case 0L: return "SgType_type_kind";
            default: return "";
        }
    }

    std::string E_SgType(int64_t i, const std::string &strip) {
        std::string s = E_SgType(i);
        if (s.empty())
            s = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgType(i);
        if (retval.empty()) {
            retval = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgType() {
        return stringify::E_SgType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 255
namespace stringify {
    const char* E_SgCommonBlockObject(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlockObject_variable_reference_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlockObject(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlockObject(i);
        if (s.empty())
            s = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlockObject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlockObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlockObject(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlockObject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlockObject() {
        return stringify::E_SgCommonBlockObject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 258
namespace stringify {
    const char* E_SgInitializedName(int64_t i) {
        switch (i) {
            case 0L: return "SgInitializedName_initptr";
            default: return "";
        }
    }

    std::string E_SgInitializedName(int64_t i, const std::string &strip) {
        std::string s = E_SgInitializedName(i);
        if (s.empty())
            s = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInitializedName() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInitializedName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInitializedName(i);
        if (retval.empty()) {
            retval = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInitializedName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInitializedName() {
        return stringify::E_SgInitializedName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 261
namespace stringify {
    const char* E_SgJavaMemberValuePair(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaMemberValuePair_value";
            default: return "";
        }
    }

    std::string E_SgJavaMemberValuePair(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaMemberValuePair(i);
        if (s.empty())
            s = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaMemberValuePair() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaMemberValuePair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaMemberValuePair(i);
        if (retval.empty()) {
            retval = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaMemberValuePair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaMemberValuePair() {
        return stringify::E_SgJavaMemberValuePair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 264
namespace stringify {
    const char* E_SgOmpOrderedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedClause(i);
        if (s.empty())
            s = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedClause() {
        return stringify::E_SgOmpOrderedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 267
namespace stringify {
    const char* E_SgOmpCollapseClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCollapseClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpCollapseClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCollapseClause(i);
        if (s.empty())
            s = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCollapseClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCollapseClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCollapseClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCollapseClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCollapseClause() {
        return stringify::E_SgOmpCollapseClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 270
namespace stringify {
    const char* E_SgOmpIfClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpIfClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpIfClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpIfClause(i);
        if (s.empty())
            s = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpIfClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpIfClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpIfClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpIfClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpIfClause() {
        return stringify::E_SgOmpIfClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 273
namespace stringify {
    const char* E_SgOmpNumThreadsClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumThreadsClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumThreadsClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumThreadsClause(i);
        if (s.empty())
            s = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumThreadsClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumThreadsClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumThreadsClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumThreadsClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumThreadsClause() {
        return stringify::E_SgOmpNumThreadsClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 276
namespace stringify {
    const char* E_SgOmpDeviceClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeviceClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpDeviceClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeviceClause(i);
        if (s.empty())
            s = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeviceClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeviceClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeviceClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeviceClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeviceClause() {
        return stringify::E_SgOmpDeviceClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 279
namespace stringify {
    const char* E_SgOmpSafelenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSafelenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSafelenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSafelenClause(i);
        if (s.empty())
            s = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSafelenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSafelenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSafelenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSafelenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSafelenClause() {
        return stringify::E_SgOmpSafelenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 282
namespace stringify {
    const char* E_SgOmpSimdlenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdlenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSimdlenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdlenClause(i);
        if (s.empty())
            s = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdlenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdlenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdlenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdlenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdlenClause() {
        return stringify::E_SgOmpSimdlenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 285
namespace stringify {
    const char* E_SgOmpFinalClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFinalClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpFinalClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFinalClause(i);
        if (s.empty())
            s = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFinalClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFinalClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFinalClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFinalClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFinalClause() {
        return stringify::E_SgOmpFinalClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 288
namespace stringify {
    const char* E_SgOmpPriorityClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPriorityClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpPriorityClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPriorityClause(i);
        if (s.empty())
            s = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPriorityClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPriorityClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPriorityClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPriorityClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPriorityClause() {
        return stringify::E_SgOmpPriorityClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 291
namespace stringify {
    const char* E_SgOmpExpressionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpExpressionClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpExpressionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpExpressionClause(i);
        if (s.empty())
            s = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpExpressionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpExpressionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpExpressionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpExpressionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpExpressionClause() {
        return stringify::E_SgOmpExpressionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 294
namespace stringify {
    const char* E_SgOmpCopyprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyprivateClause() {
        return stringify::E_SgOmpCopyprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 297
namespace stringify {
    const char* E_SgOmpPrivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPrivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpPrivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPrivateClause(i);
        if (s.empty())
            s = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPrivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPrivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPrivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPrivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPrivateClause() {
        return stringify::E_SgOmpPrivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 300
namespace stringify {
    const char* E_SgOmpFirstprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFirstprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFirstprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFirstprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFirstprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFirstprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFirstprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFirstprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFirstprivateClause() {
        return stringify::E_SgOmpFirstprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 303
namespace stringify {
    const char* E_SgOmpSharedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSharedClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpSharedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSharedClause(i);
        if (s.empty())
            s = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSharedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSharedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSharedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSharedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSharedClause() {
        return stringify::E_SgOmpSharedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 306
namespace stringify {
    const char* E_SgOmpCopyinClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyinClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyinClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyinClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyinClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyinClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyinClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyinClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyinClause() {
        return stringify::E_SgOmpCopyinClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 309
namespace stringify {
    const char* E_SgOmpLastprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLastprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpLastprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLastprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLastprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLastprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLastprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLastprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLastprivateClause() {
        return stringify::E_SgOmpLastprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 312
namespace stringify {
    const char* E_SgOmpReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpReductionClause() {
        return stringify::E_SgOmpReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 315
namespace stringify {
    const char* E_SgOmpMapClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMapClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpMapClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMapClause(i);
        if (s.empty())
            s = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMapClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMapClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMapClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMapClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMapClause() {
        return stringify::E_SgOmpMapClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 318
namespace stringify {
    const char* E_SgOmpUniformClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUniformClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUniformClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUniformClause(i);
        if (s.empty())
            s = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUniformClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUniformClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUniformClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUniformClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUniformClause() {
        return stringify::E_SgOmpUniformClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 321
namespace stringify {
    const char* E_SgOmpAlignedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAlignedClause_variables";
            case 1L: return "SgOmpAlignedClause_alignment";
            default: return "";
        }
    }

    std::string E_SgOmpAlignedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAlignedClause(i);
        if (s.empty())
            s = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAlignedClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAlignedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAlignedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAlignedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAlignedClause() {
        return stringify::E_SgOmpAlignedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 324
namespace stringify {
    const char* E_SgOmpLinearClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLinearClause_variables";
            case 1L: return "SgOmpLinearClause_step";
            default: return "";
        }
    }

    std::string E_SgOmpLinearClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLinearClause(i);
        if (s.empty())
            s = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLinearClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLinearClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLinearClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLinearClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLinearClause() {
        return stringify::E_SgOmpLinearClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 327
namespace stringify {
    const char* E_SgOmpDependClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDependClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpDependClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDependClause(i);
        if (s.empty())
            s = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDependClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDependClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDependClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDependClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDependClause() {
        return stringify::E_SgOmpDependClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 330
namespace stringify {
    const char* E_SgOmpVariablesClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpVariablesClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpVariablesClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpVariablesClause(i);
        if (s.empty())
            s = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpVariablesClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpVariablesClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpVariablesClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpVariablesClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpVariablesClause() {
        return stringify::E_SgOmpVariablesClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 333
namespace stringify {
    const char* E_SgOmpScheduleClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpScheduleClause_chunk_size";
            default: return "";
        }
    }

    std::string E_SgOmpScheduleClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpScheduleClause(i);
        if (s.empty())
            s = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpScheduleClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpScheduleClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpScheduleClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpScheduleClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpScheduleClause() {
        return stringify::E_SgOmpScheduleClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 336
namespace stringify {
    const char* E_SgUntypedUnaryOperator(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUnaryOperator_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedUnaryOperator(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUnaryOperator(i);
        if (s.empty())
            s = "(E_SgUntypedUnaryOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUnaryOperator() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUnaryOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUnaryOperator(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUnaryOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUnaryOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUnaryOperator() {
        return stringify::E_SgUntypedUnaryOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 339
namespace stringify {
    const char* E_SgUntypedBinaryOperator(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBinaryOperator_lhs_operand";
            case 1L: return "SgUntypedBinaryOperator_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedBinaryOperator(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBinaryOperator(i);
        if (s.empty())
            s = "(E_SgUntypedBinaryOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBinaryOperator() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBinaryOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBinaryOperator(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBinaryOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBinaryOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBinaryOperator() {
        return stringify::E_SgUntypedBinaryOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 342
namespace stringify {
    const char* E_SgUntypedExprListExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExprListExpression_expressions";
            default: return "";
        }
    }

    std::string E_SgUntypedExprListExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExprListExpression(i);
        if (s.empty())
            s = "(E_SgUntypedExprListExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExprListExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExprListExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExprListExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExprListExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExprListExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExprListExpression() {
        return stringify::E_SgUntypedExprListExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 345
namespace stringify {
    const char* E_SgUntypedArrayReferenceExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedArrayReferenceExpression_array_subscripts";
            case 1L: return "SgUntypedArrayReferenceExpression_coarray_subscripts";
            default: return "";
        }
    }

    std::string E_SgUntypedArrayReferenceExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedArrayReferenceExpression(i);
        if (s.empty())
            s = "(E_SgUntypedArrayReferenceExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedArrayReferenceExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedArrayReferenceExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedArrayReferenceExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedArrayReferenceExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedArrayReferenceExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedArrayReferenceExpression() {
        return stringify::E_SgUntypedArrayReferenceExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 348
namespace stringify {
    const char* E_SgUntypedSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubscriptExpression_lower_bound";
            case 1L: return "SgUntypedSubscriptExpression_upper_bound";
            case 2L: return "SgUntypedSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgUntypedSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgUntypedSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubscriptExpression() {
        return stringify::E_SgUntypedSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 351
namespace stringify {
    const char* E_SgUntypedNamedExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNamedExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedNamedExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNamedExpression(i);
        if (s.empty())
            s = "(E_SgUntypedNamedExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNamedExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNamedExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNamedExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNamedExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNamedExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNamedExpression() {
        return stringify::E_SgUntypedNamedExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 354
namespace stringify {
    const char* E_SgUntypedNameListDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNameListDeclaration_names";
            default: return "";
        }
    }

    std::string E_SgUntypedNameListDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNameListDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNameListDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNameListDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNameListDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNameListDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNameListDeclaration() {
        return stringify::E_SgUntypedNameListDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 357
namespace stringify {
    const char* E_SgUntypedUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUntypedUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUseStatement(i);
        if (s.empty())
            s = "(E_SgUntypedUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUseStatement() {
        return stringify::E_SgUntypedUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 360
namespace stringify {
    const char* E_SgUntypedVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedVariableDeclaration_base_type_declaration";
            case 1L: return "SgUntypedVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgUntypedVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedVariableDeclaration() {
        return stringify::E_SgUntypedVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 363
namespace stringify {
    const char* E_SgUntypedProgramHeaderDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedProgramHeaderDeclaration_parameters";
            case 1L: return "SgUntypedProgramHeaderDeclaration_scope";
            case 2L: return "SgUntypedProgramHeaderDeclaration_modifiers";
            case 3L: return "SgUntypedProgramHeaderDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedProgramHeaderDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedProgramHeaderDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedProgramHeaderDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedProgramHeaderDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedProgramHeaderDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedProgramHeaderDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedProgramHeaderDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedProgramHeaderDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedProgramHeaderDeclaration() {
        return stringify::E_SgUntypedProgramHeaderDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 366
namespace stringify {
    const char* E_SgUntypedSubroutineDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubroutineDeclaration_parameters";
            case 1L: return "SgUntypedSubroutineDeclaration_scope";
            case 2L: return "SgUntypedSubroutineDeclaration_modifiers";
            case 3L: return "SgUntypedSubroutineDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedSubroutineDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubroutineDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedSubroutineDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubroutineDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubroutineDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubroutineDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubroutineDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubroutineDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubroutineDeclaration() {
        return stringify::E_SgUntypedSubroutineDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 369
namespace stringify {
    const char* E_SgUntypedInterfaceDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInterfaceDeclaration_parameters";
            case 1L: return "SgUntypedInterfaceDeclaration_scope";
            case 2L: return "SgUntypedInterfaceDeclaration_modifiers";
            case 3L: return "SgUntypedInterfaceDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedInterfaceDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInterfaceDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedInterfaceDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInterfaceDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInterfaceDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInterfaceDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInterfaceDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInterfaceDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInterfaceDeclaration() {
        return stringify::E_SgUntypedInterfaceDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 372
namespace stringify {
    const char* E_SgUntypedFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionDeclaration_parameters";
            case 1L: return "SgUntypedFunctionDeclaration_scope";
            case 2L: return "SgUntypedFunctionDeclaration_modifiers";
            case 3L: return "SgUntypedFunctionDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionDeclaration() {
        return stringify::E_SgUntypedFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 375
namespace stringify {
    const char* E_SgUntypedModuleDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedModuleDeclaration_scope";
            case 1L: return "SgUntypedModuleDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedModuleDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedModuleDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedModuleDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedModuleDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedModuleDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedModuleDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedModuleDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedModuleDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedModuleDeclaration() {
        return stringify::E_SgUntypedModuleDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 378
namespace stringify {
    const char* E_SgUntypedSubmoduleDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedSubmoduleDeclaration_scope";
            case 1L: return "SgUntypedSubmoduleDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedSubmoduleDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedSubmoduleDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedSubmoduleDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedSubmoduleDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedSubmoduleDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedSubmoduleDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedSubmoduleDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedSubmoduleDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedSubmoduleDeclaration() {
        return stringify::E_SgUntypedSubmoduleDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 381
namespace stringify {
    const char* E_SgUntypedBlockDataDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBlockDataDeclaration_declaration_list";
            case 1L: return "SgUntypedBlockDataDeclaration_end_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedBlockDataDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBlockDataDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedBlockDataDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBlockDataDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBlockDataDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBlockDataDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBlockDataDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBlockDataDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBlockDataDeclaration() {
        return stringify::E_SgUntypedBlockDataDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 384
namespace stringify {
    const char* E_SgUntypedPackageDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedPackageDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedPackageDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedPackageDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedPackageDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedPackageDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedPackageDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedPackageDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedPackageDeclaration() {
        return stringify::E_SgUntypedPackageDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 387
namespace stringify {
    const char* E_SgUntypedStructureDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStructureDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgUntypedStructureDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStructureDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedStructureDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStructureDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStructureDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStructureDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStructureDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStructureDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStructureDeclaration() {
        return stringify::E_SgUntypedStructureDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 390
namespace stringify {
    const char* E_SgUntypedExceptionHandlerDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExceptionHandlerDeclaration_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedExceptionHandlerDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExceptionHandlerDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedExceptionHandlerDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExceptionHandlerDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExceptionHandlerDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExceptionHandlerDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExceptionHandlerDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExceptionHandlerDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExceptionHandlerDeclaration() {
        return stringify::E_SgUntypedExceptionHandlerDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 393
namespace stringify {
    const char* E_SgUntypedExceptionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExceptionDeclaration_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedExceptionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExceptionDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedExceptionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExceptionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExceptionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExceptionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExceptionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExceptionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExceptionDeclaration() {
        return stringify::E_SgUntypedExceptionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 396
namespace stringify {
    const char* E_SgUntypedTaskDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTaskDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedTaskDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTaskDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedTaskDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTaskDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTaskDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTaskDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTaskDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTaskDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTaskDeclaration() {
        return stringify::E_SgUntypedTaskDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 399
namespace stringify {
    const char* E_SgUntypedUnitDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedUnitDeclaration_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedUnitDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedUnitDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedUnitDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedUnitDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedUnitDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedUnitDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedUnitDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedUnitDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedUnitDeclaration() {
        return stringify::E_SgUntypedUnitDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 402
namespace stringify {
    const char* E_SgUntypedEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgUntypedEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedEnumDeclaration() {
        return stringify::E_SgUntypedEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 405
namespace stringify {
    const char* E_SgUntypedInitializedNameListDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInitializedNameListDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgUntypedInitializedNameListDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInitializedNameListDeclaration(i);
        if (s.empty())
            s = "(E_SgUntypedInitializedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInitializedNameListDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInitializedNameListDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInitializedNameListDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInitializedNameListDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInitializedNameListDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInitializedNameListDeclaration() {
        return stringify::E_SgUntypedInitializedNameListDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 408
namespace stringify {
    const char* E_SgUntypedAssignmentStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedAssignmentStatement_lhs_operand";
            case 1L: return "SgUntypedAssignmentStatement_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgUntypedAssignmentStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedAssignmentStatement(i);
        if (s.empty())
            s = "(E_SgUntypedAssignmentStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedAssignmentStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedAssignmentStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedAssignmentStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedAssignmentStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedAssignmentStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedAssignmentStatement() {
        return stringify::E_SgUntypedAssignmentStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 411
namespace stringify {
    const char* E_SgUntypedBlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedBlockStatement_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedBlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedBlockStatement(i);
        if (s.empty())
            s = "(E_SgUntypedBlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedBlockStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedBlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedBlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedBlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedBlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedBlockStatement() {
        return stringify::E_SgUntypedBlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 414
namespace stringify {
    const char* E_SgUntypedExpressionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedExpressionStatement_statement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedExpressionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedExpressionStatement(i);
        if (s.empty())
            s = "(E_SgUntypedExpressionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedExpressionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedExpressionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedExpressionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedExpressionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedExpressionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedExpressionStatement() {
        return stringify::E_SgUntypedExpressionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 417
namespace stringify {
    const char* E_SgUntypedFunctionCallStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionCallStatement_function";
            case 1L: return "SgUntypedFunctionCallStatement_args";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionCallStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionCallStatement(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionCallStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionCallStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionCallStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionCallStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionCallStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionCallStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionCallStatement() {
        return stringify::E_SgUntypedFunctionCallStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 420
namespace stringify {
    const char* E_SgUntypedImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedImageControlStatement_variable";
            case 1L: return "SgUntypedImageControlStatement_expression";
            case 2L: return "SgUntypedImageControlStatement_status_list";
            default: return "";
        }
    }

    std::string E_SgUntypedImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedImageControlStatement(i);
        if (s.empty())
            s = "(E_SgUntypedImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedImageControlStatement() {
        return stringify::E_SgUntypedImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 423
namespace stringify {
    const char* E_SgUntypedFunctionScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionScope_declaration_list";
            case 1L: return "SgUntypedFunctionScope_statement_list";
            case 2L: return "SgUntypedFunctionScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionScope(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionScope() {
        return stringify::E_SgUntypedFunctionScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 426
namespace stringify {
    const char* E_SgUntypedModuleScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedModuleScope_declaration_list";
            case 1L: return "SgUntypedModuleScope_statement_list";
            case 2L: return "SgUntypedModuleScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedModuleScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedModuleScope(i);
        if (s.empty())
            s = "(E_SgUntypedModuleScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedModuleScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedModuleScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedModuleScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedModuleScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedModuleScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedModuleScope() {
        return stringify::E_SgUntypedModuleScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 429
namespace stringify {
    const char* E_SgUntypedGlobalScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedGlobalScope_declaration_list";
            case 1L: return "SgUntypedGlobalScope_statement_list";
            case 2L: return "SgUntypedGlobalScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedGlobalScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedGlobalScope(i);
        if (s.empty())
            s = "(E_SgUntypedGlobalScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedGlobalScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedGlobalScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedGlobalScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedGlobalScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedGlobalScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedGlobalScope() {
        return stringify::E_SgUntypedGlobalScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 432
namespace stringify {
    const char* E_SgUntypedStructureDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStructureDefinition_declaration_list";
            case 1L: return "SgUntypedStructureDefinition_statement_list";
            case 2L: return "SgUntypedStructureDefinition_function_list";
            case 3L: return "SgUntypedStructureDefinition_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedStructureDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStructureDefinition(i);
        if (s.empty())
            s = "(E_SgUntypedStructureDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStructureDefinition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStructureDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStructureDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStructureDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStructureDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStructureDefinition() {
        return stringify::E_SgUntypedStructureDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 435
namespace stringify {
    const char* E_SgUntypedScope(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedScope_declaration_list";
            case 1L: return "SgUntypedScope_statement_list";
            case 2L: return "SgUntypedScope_function_list";
            default: return "";
        }
    }

    std::string E_SgUntypedScope(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedScope(i);
        if (s.empty())
            s = "(E_SgUntypedScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedScope(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedScope() {
        return stringify::E_SgUntypedScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 438
namespace stringify {
    const char* E_SgUntypedIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedIfStatement_conditional";
            case 1L: return "SgUntypedIfStatement_true_body";
            case 2L: return "SgUntypedIfStatement_false_body";
            default: return "";
        }
    }

    std::string E_SgUntypedIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedIfStatement(i);
        if (s.empty())
            s = "(E_SgUntypedIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedIfStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedIfStatement() {
        return stringify::E_SgUntypedIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 441
namespace stringify {
    const char* E_SgUntypedCaseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedCaseStatement_expression";
            case 1L: return "SgUntypedCaseStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedCaseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedCaseStatement(i);
        if (s.empty())
            s = "(E_SgUntypedCaseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedCaseStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedCaseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedCaseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedCaseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedCaseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedCaseStatement() {
        return stringify::E_SgUntypedCaseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 444
namespace stringify {
    const char* E_SgUntypedLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgUntypedLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedLabelStatement(i);
        if (s.empty())
            s = "(E_SgUntypedLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedLabelStatement() {
        return stringify::E_SgUntypedLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 447
namespace stringify {
    const char* E_SgUntypedWhileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedWhileStatement_condition";
            case 1L: return "SgUntypedWhileStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedWhileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedWhileStatement(i);
        if (s.empty())
            s = "(E_SgUntypedWhileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedWhileStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedWhileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedWhileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedWhileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedWhileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedWhileStatement() {
        return stringify::E_SgUntypedWhileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 450
namespace stringify {
    const char* E_SgUntypedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedForStatement_initialization";
            case 1L: return "SgUntypedForStatement_bound";
            case 2L: return "SgUntypedForStatement_increment";
            case 3L: return "SgUntypedForStatement_body";
            default: return "";
        }
    }

    std::string E_SgUntypedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedForStatement(i);
        if (s.empty())
            s = "(E_SgUntypedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedForStatement() {
        return stringify::E_SgUntypedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 453
namespace stringify {
    const char* E_SgUntypedReturnStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedReturnStatement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedReturnStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedReturnStatement(i);
        if (s.empty())
            s = "(E_SgUntypedReturnStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedReturnStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedReturnStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedReturnStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedReturnStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedReturnStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedReturnStatement() {
        return stringify::E_SgUntypedReturnStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 456
namespace stringify {
    const char* E_SgUntypedStopStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStopStatement_expression";
            default: return "";
        }
    }

    std::string E_SgUntypedStopStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStopStatement(i);
        if (s.empty())
            s = "(E_SgUntypedStopStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStopStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStopStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStopStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStopStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStopStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStopStatement() {
        return stringify::E_SgUntypedStopStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 459
namespace stringify {
    const char* E_SgUntypedForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedForAllStatement_iterates";
            case 1L: return "SgUntypedForAllStatement_local";
            case 2L: return "SgUntypedForAllStatement_mask";
            default: return "";
        }
    }

    std::string E_SgUntypedForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedForAllStatement(i);
        if (s.empty())
            s = "(E_SgUntypedForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedForAllStatement() {
        return stringify::E_SgUntypedForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 462
namespace stringify {
    const char* E_SgUntypedArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedArrayType_type_kind";
            case 1L: return "SgUntypedArrayType_modifiers";
            case 2L: return "SgUntypedArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgUntypedArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedArrayType(i);
        if (s.empty())
            s = "(E_SgUntypedArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedArrayType() {
        return stringify::E_SgUntypedArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 465
namespace stringify {
    const char* E_SgUntypedTableType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTableType_type_kind";
            case 1L: return "SgUntypedTableType_modifiers";
            case 2L: return "SgUntypedTableType_dim_info";
            default: return "";
        }
    }

    std::string E_SgUntypedTableType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTableType(i);
        if (s.empty())
            s = "(E_SgUntypedTableType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTableType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTableType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTableType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTableType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTableType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTableType() {
        return stringify::E_SgUntypedTableType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 468
namespace stringify {
    const char* E_SgUntypedType(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedType_type_kind";
            case 1L: return "SgUntypedType_modifiers";
            default: return "";
        }
    }

    std::string E_SgUntypedType(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedType(i);
        if (s.empty())
            s = "(E_SgUntypedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedType(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedType() {
        return stringify::E_SgUntypedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 471
namespace stringify {
    const char* E_SgUntypedFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFile_scope";
            default: return "";
        }
    }

    std::string E_SgUntypedFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFile(i);
        if (s.empty())
            s = "(E_SgUntypedFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFile(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFile() {
        return stringify::E_SgUntypedFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 474
namespace stringify {
    const char* E_SgUntypedStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedStatementList_stmt_list";
            default: return "";
        }
    }

    std::string E_SgUntypedStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedStatementList(i);
        if (s.empty())
            s = "(E_SgUntypedStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedStatementList() {
        return stringify::E_SgUntypedStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 477
namespace stringify {
    const char* E_SgUntypedDeclarationStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedDeclarationStatementList_decl_list";
            default: return "";
        }
    }

    std::string E_SgUntypedDeclarationStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedDeclarationStatementList(i);
        if (s.empty())
            s = "(E_SgUntypedDeclarationStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedDeclarationStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedDeclarationStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedDeclarationStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedDeclarationStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedDeclarationStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedDeclarationStatementList() {
        return stringify::E_SgUntypedDeclarationStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 480
namespace stringify {
    const char* E_SgUntypedFunctionDeclarationList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedFunctionDeclarationList_func_list";
            default: return "";
        }
    }

    std::string E_SgUntypedFunctionDeclarationList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedFunctionDeclarationList(i);
        if (s.empty())
            s = "(E_SgUntypedFunctionDeclarationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedFunctionDeclarationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedFunctionDeclarationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedFunctionDeclarationList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedFunctionDeclarationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedFunctionDeclarationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedFunctionDeclarationList() {
        return stringify::E_SgUntypedFunctionDeclarationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 483
namespace stringify {
    const char* E_SgUntypedInitializedNameList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedInitializedNameList_name_list";
            default: return "";
        }
    }

    std::string E_SgUntypedInitializedNameList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedInitializedNameList(i);
        if (s.empty())
            s = "(E_SgUntypedInitializedNameList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedInitializedNameList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedInitializedNameList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedInitializedNameList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedInitializedNameList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedInitializedNameList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedInitializedNameList() {
        return stringify::E_SgUntypedInitializedNameList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 486
namespace stringify {
    const char* E_SgUntypedNameList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedNameList_name_list";
            default: return "";
        }
    }

    std::string E_SgUntypedNameList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedNameList(i);
        if (s.empty())
            s = "(E_SgUntypedNameList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedNameList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedNameList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedNameList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedNameList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedNameList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedNameList() {
        return stringify::E_SgUntypedNameList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 489
namespace stringify {
    const char* E_SgUntypedTokenList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTokenList_token_list";
            default: return "";
        }
    }

    std::string E_SgUntypedTokenList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTokenList(i);
        if (s.empty())
            s = "(E_SgUntypedTokenList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTokenList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTokenList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTokenList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTokenList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTokenList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTokenList() {
        return stringify::E_SgUntypedTokenList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 492
namespace stringify {
    const char* E_SgUntypedTokenPairList(int64_t i) {
        switch (i) {
            case 0L: return "SgUntypedTokenPairList_token_pair_list";
            default: return "";
        }
    }

    std::string E_SgUntypedTokenPairList(int64_t i, const std::string &strip) {
        std::string s = E_SgUntypedTokenPairList(i);
        if (s.empty())
            s = "(E_SgUntypedTokenPairList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUntypedTokenPairList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUntypedTokenPairList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUntypedTokenPairList(i);
        if (retval.empty()) {
            retval = "(E_SgUntypedTokenPairList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUntypedTokenPairList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUntypedTokenPairList() {
        return stringify::E_SgUntypedTokenPairList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 495
namespace stringify {
    const char* E_SgLambdaCapture(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCapture_capture_variable";
            case 1L: return "SgLambdaCapture_source_closure_variable";
            case 2L: return "SgLambdaCapture_closure_variable";
            default: return "";
        }
    }

    std::string E_SgLambdaCapture(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCapture(i);
        if (s.empty())
            s = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCapture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCapture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCapture(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCapture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCapture() {
        return stringify::E_SgLambdaCapture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 498
namespace stringify {
    const char* E_SgLambdaCaptureList(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCaptureList_capture_list";
            default: return "";
        }
    }

    std::string E_SgLambdaCaptureList(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCaptureList(i);
        if (s.empty())
            s = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCaptureList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCaptureList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCaptureList(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCaptureList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCaptureList() {
        return stringify::E_SgLambdaCaptureList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 501
namespace stringify {
    const char* E_SgGlobal(int64_t i) {
        switch (i) {
            case 0L: return "SgGlobal_declarations";
            default: return "";
        }
    }

    std::string E_SgGlobal(int64_t i, const std::string &strip) {
        std::string s = E_SgGlobal(i);
        if (s.empty())
            s = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGlobal() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGlobal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGlobal(i);
        if (retval.empty()) {
            retval = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGlobal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGlobal() {
        return stringify::E_SgGlobal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 504
namespace stringify {
    const char* E_SgBasicBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgBasicBlock_statements";
            default: return "";
        }
    }

    std::string E_SgBasicBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgBasicBlock(i);
        if (s.empty())
            s = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBasicBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBasicBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBasicBlock(i);
        if (retval.empty()) {
            retval = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBasicBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBasicBlock() {
        return stringify::E_SgBasicBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 507
namespace stringify {
    const char* E_SgIfStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgIfStmt_conditional";
            case 1L: return "SgIfStmt_true_body";
            case 2L: return "SgIfStmt_false_body";
            default: return "";
        }
    }

    std::string E_SgIfStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgIfStmt(i);
        if (s.empty())
            s = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIfStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIfStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIfStmt(i);
        if (retval.empty()) {
            retval = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIfStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIfStmt() {
        return stringify::E_SgIfStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 510
namespace stringify {
    const char* E_SgForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForStatement_for_init_stmt";
            case 1L: return "SgForStatement_test";
            case 2L: return "SgForStatement_increment";
            case 3L: return "SgForStatement_loop_body";
            case 4L: return "SgForStatement_else_body";
            default: return "";
        }
    }

    std::string E_SgForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForStatement(i);
        if (s.empty())
            s = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForStatement() {
        return stringify::E_SgForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 513
namespace stringify {
    const char* E_SgTemplateFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDefinition() {
        return stringify::E_SgTemplateFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 516
namespace stringify {
    const char* E_SgFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDefinition() {
        return stringify::E_SgFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 519
namespace stringify {
    const char* E_SgTemplateInstantiationDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDefn_members";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDefn(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDefn(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDefn() {
        return stringify::E_SgTemplateInstantiationDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 522
namespace stringify {
    const char* E_SgTemplateClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDefinition() {
        return stringify::E_SgTemplateClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 525
namespace stringify {
    const char* E_SgClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDefinition(i);
        if (s.empty())
            s = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDefinition() {
        return stringify::E_SgClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 528
namespace stringify {
    const char* E_SgWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhileStmt_condition";
            case 1L: return "SgWhileStmt_body";
            case 2L: return "SgWhileStmt_else_body";
            default: return "";
        }
    }

    std::string E_SgWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhileStmt(i);
        if (s.empty())
            s = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhileStmt() {
        return stringify::E_SgWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 531
namespace stringify {
    const char* E_SgDoWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDoWhileStmt_body";
            case 1L: return "SgDoWhileStmt_condition";
            default: return "";
        }
    }

    std::string E_SgDoWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDoWhileStmt(i);
        if (s.empty())
            s = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDoWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDoWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDoWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDoWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDoWhileStmt() {
        return stringify::E_SgDoWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 534
namespace stringify {
    const char* E_SgSwitchStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSwitchStatement_item_selector";
            case 1L: return "SgSwitchStatement_body";
            default: return "";
        }
    }

    std::string E_SgSwitchStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSwitchStatement(i);
        if (s.empty())
            s = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSwitchStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSwitchStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSwitchStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSwitchStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSwitchStatement() {
        return stringify::E_SgSwitchStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 537
namespace stringify {
    const char* E_SgCatchOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchOptionStmt_condition";
            case 1L: return "SgCatchOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgCatchOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchOptionStmt(i);
        if (s.empty())
            s = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchOptionStmt() {
        return stringify::E_SgCatchOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 540
namespace stringify {
    const char* E_SgNamespaceDefinitionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDefinitionStatement_declarations";
            default: return "";
        }
    }

    std::string E_SgNamespaceDefinitionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDefinitionStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDefinitionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDefinitionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDefinitionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDefinitionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDefinitionStatement() {
        return stringify::E_SgNamespaceDefinitionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 543
namespace stringify {
    const char* E_SgAssociateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssociateStatement_body";
            default: return "";
        }
    }

    std::string E_SgAssociateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssociateStatement(i);
        if (s.empty())
            s = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssociateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssociateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssociateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssociateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssociateStatement() {
        return stringify::E_SgAssociateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 546
namespace stringify {
    const char* E_SgFortranNonblockedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranNonblockedDo_initialization";
            case 1L: return "SgFortranNonblockedDo_bound";
            case 2L: return "SgFortranNonblockedDo_increment";
            case 3L: return "SgFortranNonblockedDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranNonblockedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranNonblockedDo(i);
        if (s.empty())
            s = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranNonblockedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranNonblockedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranNonblockedDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranNonblockedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranNonblockedDo() {
        return stringify::E_SgFortranNonblockedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 549
namespace stringify {
    const char* E_SgFortranDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranDo_initialization";
            case 1L: return "SgFortranDo_bound";
            case 2L: return "SgFortranDo_increment";
            case 3L: return "SgFortranDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranDo(i);
        if (s.empty())
            s = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranDo() {
        return stringify::E_SgFortranDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 552
namespace stringify {
    const char* E_SgForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForAllStatement_forall_header";
            case 1L: return "SgForAllStatement_body";
            default: return "";
        }
    }

    std::string E_SgForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForAllStatement(i);
        if (s.empty())
            s = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForAllStatement() {
        return stringify::E_SgForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 555
namespace stringify {
    const char* E_SgUpcForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcForAllStatement_for_init_stmt";
            case 1L: return "SgUpcForAllStatement_test";
            case 2L: return "SgUpcForAllStatement_increment";
            case 3L: return "SgUpcForAllStatement_affinity";
            case 4L: return "SgUpcForAllStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgUpcForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcForAllStatement(i);
        if (s.empty())
            s = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcForAllStatement() {
        return stringify::E_SgUpcForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 558
namespace stringify {
    const char* E_SgCAFWithTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFWithTeamStatement_body";
            default: return "";
        }
    }

    std::string E_SgCAFWithTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFWithTeamStatement(i);
        if (s.empty())
            s = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFWithTeamStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFWithTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFWithTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFWithTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFWithTeamStatement() {
        return stringify::E_SgCAFWithTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 561
namespace stringify {
    const char* E_SgJavaForEachStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaForEachStatement_element";
            case 1L: return "SgJavaForEachStatement_collection";
            case 2L: return "SgJavaForEachStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJavaForEachStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaForEachStatement(i);
        if (s.empty())
            s = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaForEachStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaForEachStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaForEachStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaForEachStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaForEachStatement() {
        return stringify::E_SgJavaForEachStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 564
namespace stringify {
    const char* E_SgJavaLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgJavaLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelStatement(i);
        if (s.empty())
            s = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelStatement() {
        return stringify::E_SgJavaLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 567
namespace stringify {
    const char* E_SgMatlabForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgMatlabForStatement_index";
            case 1L: return "SgMatlabForStatement_range";
            case 2L: return "SgMatlabForStatement_body";
            default: return "";
        }
    }

    std::string E_SgMatlabForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgMatlabForStatement(i);
        if (s.empty())
            s = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatlabForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatlabForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatlabForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatlabForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatlabForStatement() {
        return stringify::E_SgMatlabForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 570
namespace stringify {
    const char* E_SgRangeBasedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeBasedForStatement_iterator_declaration";
            case 1L: return "SgRangeBasedForStatement_range_declaration";
            case 2L: return "SgRangeBasedForStatement_begin_declaration";
            case 3L: return "SgRangeBasedForStatement_end_declaration";
            case 4L: return "SgRangeBasedForStatement_not_equal_expression";
            case 5L: return "SgRangeBasedForStatement_increment_expression";
            case 6L: return "SgRangeBasedForStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgRangeBasedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeBasedForStatement(i);
        if (s.empty())
            s = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeBasedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeBasedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeBasedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeBasedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeBasedForStatement() {
        return stringify::E_SgRangeBasedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 573
namespace stringify {
    const char* E_SgJovialForThenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialForThenStatement_initialization";
            case 1L: return "SgJovialForThenStatement_then_expression";
            case 2L: return "SgJovialForThenStatement_while_expression";
            case 3L: return "SgJovialForThenStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJovialForThenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialForThenStatement(i);
        if (s.empty())
            s = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialForThenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialForThenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialForThenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialForThenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialForThenStatement() {
        return stringify::E_SgJovialForThenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 576
namespace stringify {
    const char* E_SgFunctionParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterList_args";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterList(i);
        if (s.empty())
            s = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterList() {
        return stringify::E_SgFunctionParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 579
namespace stringify {
    const char* E_SgTemplateVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgTemplateVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgTemplateVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateVariableDeclaration() {
        return stringify::E_SgTemplateVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 582
namespace stringify {
    const char* E_SgVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDeclaration() {
        return stringify::E_SgVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 585
namespace stringify {
    const char* E_SgVariableDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDefinition_vardefn";
            case 1L: return "SgVariableDefinition_bitfield";
            default: return "";
        }
    }

    std::string E_SgVariableDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDefinition(i);
        if (s.empty())
            s = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDefinition() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDefinition() {
        return stringify::E_SgVariableDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 588
namespace stringify {
    const char* E_SgEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumDeclaration() {
        return stringify::E_SgEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 591
namespace stringify {
    const char* E_SgAsmStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmStmt_operands";
            default: return "";
        }
    }

    std::string E_SgAsmStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmStmt(i);
        if (s.empty())
            s = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmStmt() {
        return stringify::E_SgAsmStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 594
namespace stringify {
    const char* E_SgTemplateInstantiationDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDirectiveStatement_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDirectiveStatement() {
        return stringify::E_SgTemplateInstantiationDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 597
namespace stringify {
    const char* E_SgUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUseStatement(i);
        if (s.empty())
            s = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUseStatement() {
        return stringify::E_SgUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 600
namespace stringify {
    const char* E_SgNamespaceDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDeclarationStatement_definition";
            default: return "";
        }
    }

    std::string E_SgNamespaceDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDeclarationStatement() {
        return stringify::E_SgNamespaceDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 603
namespace stringify {
    const char* E_SgInterfaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInterfaceStatement_interface_body_list";
            default: return "";
        }
    }

    std::string E_SgInterfaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInterfaceStatement(i);
        if (s.empty())
            s = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInterfaceStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInterfaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInterfaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInterfaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInterfaceStatement() {
        return stringify::E_SgInterfaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 606
namespace stringify {
    const char* E_SgCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlock_block_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlock(i);
        if (s.empty())
            s = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlock() {
        return stringify::E_SgCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 609
namespace stringify {
    const char* E_SgTemplateTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefDeclaration() {
        return stringify::E_SgTemplateTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 612
namespace stringify {
    const char* E_SgTemplateInstantiationTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationTypedefDeclaration() {
        return stringify::E_SgTemplateInstantiationTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 615
namespace stringify {
    const char* E_SgTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefDeclaration() {
        return stringify::E_SgTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 618
namespace stringify {
    const char* E_SgStatementFunctionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementFunctionStatement_function";
            case 1L: return "SgStatementFunctionStatement_expression";
            default: return "";
        }
    }

    std::string E_SgStatementFunctionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementFunctionStatement(i);
        if (s.empty())
            s = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementFunctionStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementFunctionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementFunctionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementFunctionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementFunctionStatement() {
        return stringify::E_SgStatementFunctionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 621
namespace stringify {
    const char* E_SgCtorInitializerList(int64_t i) {
        switch (i) {
            case 0L: return "SgCtorInitializerList_ctors";
            default: return "";
        }
    }

    std::string E_SgCtorInitializerList(int64_t i, const std::string &strip) {
        std::string s = E_SgCtorInitializerList(i);
        if (s.empty())
            s = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCtorInitializerList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCtorInitializerList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCtorInitializerList(i);
        if (retval.empty()) {
            retval = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCtorInitializerList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCtorInitializerList() {
        return stringify::E_SgCtorInitializerList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 624
namespace stringify {
    const char* E_SgPragmaDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgPragmaDeclaration_pragma";
            default: return "";
        }
    }

    std::string E_SgPragmaDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgPragmaDeclaration(i);
        if (s.empty())
            s = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPragmaDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPragmaDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPragmaDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPragmaDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPragmaDeclaration() {
        return stringify::E_SgPragmaDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 627
namespace stringify {
    const char* E_SgTemplateClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDeclaration_definition";
            case 1L: return "SgTemplateClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDeclaration() {
        return stringify::E_SgTemplateClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 630
namespace stringify {
    const char* E_SgTemplateInstantiationDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDecl_definition";
            case 1L: return "SgTemplateInstantiationDecl_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDecl() {
        return stringify::E_SgTemplateInstantiationDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 633
namespace stringify {
    const char* E_SgDerivedTypeStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDerivedTypeStatement_definition";
            case 1L: return "SgDerivedTypeStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgDerivedTypeStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDerivedTypeStatement(i);
        if (s.empty())
            s = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDerivedTypeStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDerivedTypeStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDerivedTypeStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDerivedTypeStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDerivedTypeStatement() {
        return stringify::E_SgDerivedTypeStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 636
namespace stringify {
    const char* E_SgModuleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleStatement_definition";
            case 1L: return "SgModuleStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgModuleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleStatement(i);
        if (s.empty())
            s = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleStatement() {
        return stringify::E_SgModuleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 639
namespace stringify {
    const char* E_SgJavaPackageDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaPackageDeclaration_definition";
            case 1L: return "SgJavaPackageDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJavaPackageDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaPackageDeclaration(i);
        if (s.empty())
            s = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaPackageDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaPackageDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaPackageDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaPackageDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaPackageDeclaration() {
        return stringify::E_SgJavaPackageDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 642
namespace stringify {
    const char* E_SgJovialTableStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableStatement_definition";
            case 1L: return "SgJovialTableStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJovialTableStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableStatement(i);
        if (s.empty())
            s = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableStatement() {
        return stringify::E_SgJovialTableStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 645
namespace stringify {
    const char* E_SgClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDeclaration_definition";
            case 1L: return "SgClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDeclaration(i);
        if (s.empty())
            s = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDeclaration() {
        return stringify::E_SgClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 648
namespace stringify {
    const char* E_SgImplicitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImplicitStatement_variables";
            default: return "";
        }
    }

    std::string E_SgImplicitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImplicitStatement(i);
        if (s.empty())
            s = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImplicitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImplicitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImplicitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImplicitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImplicitStatement() {
        return stringify::E_SgImplicitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 651
namespace stringify {
    const char* E_SgTemplateFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDeclaration() {
        return stringify::E_SgTemplateFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 654
namespace stringify {
    const char* E_SgTemplateMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateMemberFunctionDeclaration_definition";
            case 3L: return "SgTemplateMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionDeclaration() {
        return stringify::E_SgTemplateMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 657
namespace stringify {
    const char* E_SgTemplateInstantiationMemberFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationMemberFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationMemberFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationMemberFunctionDecl_definition";
            case 3L: return "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationMemberFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationMemberFunctionDecl() {
        return stringify::E_SgTemplateInstantiationMemberFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 660
namespace stringify {
    const char* E_SgMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionDeclaration_parameterList";
            case 1L: return "SgMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgMemberFunctionDeclaration_definition";
            case 3L: return "SgMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionDeclaration() {
        return stringify::E_SgMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 663
namespace stringify {
    const char* E_SgTemplateInstantiationFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationFunctionDecl_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationFunctionDecl() {
        return stringify::E_SgTemplateInstantiationFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 666
namespace stringify {
    const char* E_SgProgramHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProgramHeaderStatement_parameterList";
            case 1L: return "SgProgramHeaderStatement_decoratorList";
            case 2L: return "SgProgramHeaderStatement_definition";
            default: return "";
        }
    }

    std::string E_SgProgramHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProgramHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProgramHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProgramHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProgramHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProgramHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProgramHeaderStatement() {
        return stringify::E_SgProgramHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 669
namespace stringify {
    const char* E_SgProcedureHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcedureHeaderStatement_parameterList";
            case 1L: return "SgProcedureHeaderStatement_decoratorList";
            case 2L: return "SgProcedureHeaderStatement_definition";
            case 3L: return "SgProcedureHeaderStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgProcedureHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcedureHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcedureHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcedureHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcedureHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcedureHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcedureHeaderStatement() {
        return stringify::E_SgProcedureHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 672
namespace stringify {
    const char* E_SgEntryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEntryStatement_parameterList";
            case 1L: return "SgEntryStatement_decoratorList";
            case 2L: return "SgEntryStatement_definition";
            case 3L: return "SgEntryStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgEntryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEntryStatement(i);
        if (s.empty())
            s = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEntryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEntryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEntryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEntryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEntryStatement() {
        return stringify::E_SgEntryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 675
namespace stringify {
    const char* E_SgFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDeclaration_parameterList";
            case 1L: return "SgFunctionDeclaration_decoratorList";
            case 2L: return "SgFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDeclaration() {
        return stringify::E_SgFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 678
namespace stringify {
    const char* E_SgIncludeDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeDirectiveStatement_headerFileBody";
            default: return "";
        }
    }

    std::string E_SgIncludeDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeDirectiveStatement() {
        return stringify::E_SgIncludeDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 681
namespace stringify {
    const char* E_SgOmpThreadprivateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpThreadprivateStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpThreadprivateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpThreadprivateStatement(i);
        if (s.empty())
            s = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpThreadprivateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpThreadprivateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpThreadprivateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpThreadprivateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpThreadprivateStatement() {
        return stringify::E_SgOmpThreadprivateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 684
namespace stringify {
    const char* E_SgStmtDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStmtDeclarationStatement_statement";
            default: return "";
        }
    }

    std::string E_SgStmtDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStmtDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStmtDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStmtDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStmtDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStmtDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStmtDeclarationStatement() {
        return stringify::E_SgStmtDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 687
namespace stringify {
    const char* E_SgStaticAssertionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgStaticAssertionDeclaration_condition";
            default: return "";
        }
    }

    std::string E_SgStaticAssertionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgStaticAssertionDeclaration(i);
        if (s.empty())
            s = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStaticAssertionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStaticAssertionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStaticAssertionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStaticAssertionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStaticAssertionDeclaration() {
        return stringify::E_SgStaticAssertionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 690
namespace stringify {
    const char* E_SgOmpDeclareSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeclareSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDeclareSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeclareSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeclareSimdStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeclareSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeclareSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeclareSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeclareSimdStatement() {
        return stringify::E_SgOmpDeclareSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 693
namespace stringify {
    const char* E_SgExprStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExprStatement_expression";
            default: return "";
        }
    }

    std::string E_SgExprStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExprStatement(i);
        if (s.empty())
            s = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprStatement() {
        return stringify::E_SgExprStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 696
namespace stringify {
    const char* E_SgLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelStatement(i);
        if (s.empty())
            s = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelStatement() {
        return stringify::E_SgLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 699
namespace stringify {
    const char* E_SgCaseOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCaseOptionStmt_key";
            case 1L: return "SgCaseOptionStmt_body";
            case 2L: return "SgCaseOptionStmt_key_range_end";
            default: return "";
        }
    }

    std::string E_SgCaseOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCaseOptionStmt(i);
        if (s.empty())
            s = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCaseOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCaseOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCaseOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCaseOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCaseOptionStmt() {
        return stringify::E_SgCaseOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 702
namespace stringify {
    const char* E_SgTryStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgTryStmt_body";
            case 1L: return "SgTryStmt_catch_statement_seq_root";
            case 2L: return "SgTryStmt_else_body";
            case 3L: return "SgTryStmt_finally_body";
            default: return "";
        }
    }

    std::string E_SgTryStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgTryStmt(i);
        if (s.empty())
            s = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTryStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTryStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTryStmt(i);
        if (retval.empty()) {
            retval = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTryStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTryStmt() {
        return stringify::E_SgTryStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 705
namespace stringify {
    const char* E_SgDefaultOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDefaultOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgDefaultOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDefaultOptionStmt(i);
        if (s.empty())
            s = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDefaultOptionStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDefaultOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDefaultOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDefaultOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDefaultOptionStmt() {
        return stringify::E_SgDefaultOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 708
namespace stringify {
    const char* E_SgReturnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgReturnStmt_expression";
            default: return "";
        }
    }

    std::string E_SgReturnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgReturnStmt(i);
        if (s.empty())
            s = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReturnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReturnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReturnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReturnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReturnStmt() {
        return stringify::E_SgReturnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 711
namespace stringify {
    const char* E_SgSpawnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgSpawnStmt_the_func";
            default: return "";
        }
    }

    std::string E_SgSpawnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgSpawnStmt(i);
        if (s.empty())
            s = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpawnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpawnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpawnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpawnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpawnStmt() {
        return stringify::E_SgSpawnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 714
namespace stringify {
    const char* E_SgForInitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForInitStatement_init_stmt";
            default: return "";
        }
    }

    std::string E_SgForInitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForInitStatement(i);
        if (s.empty())
            s = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForInitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForInitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForInitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForInitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForInitStatement() {
        return stringify::E_SgForInitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 717
namespace stringify {
    const char* E_SgCatchStatementSeq(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchStatementSeq_catch_statement_seq";
            default: return "";
        }
    }

    std::string E_SgCatchStatementSeq(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchStatementSeq(i);
        if (s.empty())
            s = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchStatementSeq() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchStatementSeq(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchStatementSeq(i);
        if (retval.empty()) {
            retval = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchStatementSeq::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchStatementSeq() {
        return stringify::E_SgCatchStatementSeq();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 720
namespace stringify {
    const char* E_SgPrintStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgPrintStatement_io_stmt_list";
            case 1L: return "SgPrintStatement_unit";
            case 2L: return "SgPrintStatement_iostat";
            case 3L: return "SgPrintStatement_err";
            case 4L: return "SgPrintStatement_iomsg";
            case 5L: return "SgPrintStatement_format";
            default: return "";
        }
    }

    std::string E_SgPrintStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgPrintStatement(i);
        if (s.empty())
            s = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPrintStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPrintStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPrintStatement(i);
        if (retval.empty()) {
            retval = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPrintStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPrintStatement() {
        return stringify::E_SgPrintStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 723
namespace stringify {
    const char* E_SgReadStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgReadStatement_io_stmt_list";
            case 1L: return "SgReadStatement_unit";
            case 2L: return "SgReadStatement_iostat";
            case 3L: return "SgReadStatement_err";
            case 4L: return "SgReadStatement_iomsg";
            case 5L: return "SgReadStatement_format";
            case 6L: return "SgReadStatement_namelist";
            case 7L: return "SgReadStatement_advance";
            case 8L: return "SgReadStatement_asynchronous";
            case 9L: return "SgReadStatement_blank";
            case 10L: return "SgReadStatement_decimal";
            case 11L: return "SgReadStatement_delim";
            case 12L: return "SgReadStatement_end";
            case 13L: return "SgReadStatement_eor";
            case 14L: return "SgReadStatement_id";
            case 15L: return "SgReadStatement_pad";
            case 16L: return "SgReadStatement_pos";
            case 17L: return "SgReadStatement_rec";
            case 18L: return "SgReadStatement_round";
            case 19L: return "SgReadStatement_sign";
            case 20L: return "SgReadStatement_size";
            default: return "";
        }
    }

    std::string E_SgReadStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgReadStatement(i);
        if (s.empty())
            s = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReadStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReadStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReadStatement(i);
        if (retval.empty()) {
            retval = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReadStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReadStatement() {
        return stringify::E_SgReadStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 726
namespace stringify {
    const char* E_SgWriteStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWriteStatement_io_stmt_list";
            case 1L: return "SgWriteStatement_unit";
            case 2L: return "SgWriteStatement_iostat";
            case 3L: return "SgWriteStatement_err";
            case 4L: return "SgWriteStatement_iomsg";
            case 5L: return "SgWriteStatement_format";
            case 6L: return "SgWriteStatement_namelist";
            case 7L: return "SgWriteStatement_advance";
            case 8L: return "SgWriteStatement_asynchronous";
            case 9L: return "SgWriteStatement_blank";
            case 10L: return "SgWriteStatement_decimal";
            case 11L: return "SgWriteStatement_delim";
            case 12L: return "SgWriteStatement_end";
            case 13L: return "SgWriteStatement_eor";
            case 14L: return "SgWriteStatement_id";
            case 15L: return "SgWriteStatement_pad";
            case 16L: return "SgWriteStatement_pos";
            case 17L: return "SgWriteStatement_rec";
            case 18L: return "SgWriteStatement_round";
            case 19L: return "SgWriteStatement_sign";
            case 20L: return "SgWriteStatement_size";
            default: return "";
        }
    }

    std::string E_SgWriteStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWriteStatement(i);
        if (s.empty())
            s = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWriteStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWriteStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWriteStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWriteStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWriteStatement() {
        return stringify::E_SgWriteStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 729
namespace stringify {
    const char* E_SgOpenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOpenStatement_io_stmt_list";
            case 1L: return "SgOpenStatement_unit";
            case 2L: return "SgOpenStatement_iostat";
            case 3L: return "SgOpenStatement_err";
            case 4L: return "SgOpenStatement_iomsg";
            case 5L: return "SgOpenStatement_file";
            case 6L: return "SgOpenStatement_status";
            case 7L: return "SgOpenStatement_access";
            case 8L: return "SgOpenStatement_form";
            case 9L: return "SgOpenStatement_recl";
            case 10L: return "SgOpenStatement_blank";
            case 11L: return "SgOpenStatement_position";
            case 12L: return "SgOpenStatement_action";
            case 13L: return "SgOpenStatement_delim";
            case 14L: return "SgOpenStatement_pad";
            case 15L: return "SgOpenStatement_round";
            case 16L: return "SgOpenStatement_sign";
            case 17L: return "SgOpenStatement_asynchronous";
            default: return "";
        }
    }

    std::string E_SgOpenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOpenStatement(i);
        if (s.empty())
            s = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOpenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOpenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOpenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOpenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOpenStatement() {
        return stringify::E_SgOpenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 732
namespace stringify {
    const char* E_SgCloseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCloseStatement_io_stmt_list";
            case 1L: return "SgCloseStatement_unit";
            case 2L: return "SgCloseStatement_iostat";
            case 3L: return "SgCloseStatement_err";
            case 4L: return "SgCloseStatement_iomsg";
            case 5L: return "SgCloseStatement_status";
            default: return "";
        }
    }

    std::string E_SgCloseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCloseStatement(i);
        if (s.empty())
            s = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCloseStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCloseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCloseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCloseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCloseStatement() {
        return stringify::E_SgCloseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 735
namespace stringify {
    const char* E_SgInquireStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInquireStatement_io_stmt_list";
            case 1L: return "SgInquireStatement_unit";
            case 2L: return "SgInquireStatement_iostat";
            case 3L: return "SgInquireStatement_err";
            case 4L: return "SgInquireStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgInquireStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInquireStatement(i);
        if (s.empty())
            s = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInquireStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInquireStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInquireStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInquireStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInquireStatement() {
        return stringify::E_SgInquireStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 738
namespace stringify {
    const char* E_SgFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgFlushStatement_io_stmt_list";
            case 1L: return "SgFlushStatement_unit";
            case 2L: return "SgFlushStatement_iostat";
            case 3L: return "SgFlushStatement_err";
            case 4L: return "SgFlushStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgFlushStatement(i);
        if (s.empty())
            s = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFlushStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFlushStatement() {
        return stringify::E_SgFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 741
namespace stringify {
    const char* E_SgBackspaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgBackspaceStatement_io_stmt_list";
            case 1L: return "SgBackspaceStatement_unit";
            case 2L: return "SgBackspaceStatement_iostat";
            case 3L: return "SgBackspaceStatement_err";
            case 4L: return "SgBackspaceStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgBackspaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgBackspaceStatement(i);
        if (s.empty())
            s = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBackspaceStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBackspaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBackspaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBackspaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBackspaceStatement() {
        return stringify::E_SgBackspaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 744
namespace stringify {
    const char* E_SgRewindStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRewindStatement_io_stmt_list";
            case 1L: return "SgRewindStatement_unit";
            case 2L: return "SgRewindStatement_iostat";
            case 3L: return "SgRewindStatement_err";
            case 4L: return "SgRewindStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgRewindStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRewindStatement(i);
        if (s.empty())
            s = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRewindStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRewindStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRewindStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRewindStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRewindStatement() {
        return stringify::E_SgRewindStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 747
namespace stringify {
    const char* E_SgEndfileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEndfileStatement_io_stmt_list";
            case 1L: return "SgEndfileStatement_unit";
            case 2L: return "SgEndfileStatement_iostat";
            case 3L: return "SgEndfileStatement_err";
            case 4L: return "SgEndfileStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgEndfileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEndfileStatement(i);
        if (s.empty())
            s = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEndfileStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEndfileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEndfileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEndfileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEndfileStatement() {
        return stringify::E_SgEndfileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 750
namespace stringify {
    const char* E_SgWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWaitStatement_io_stmt_list";
            case 1L: return "SgWaitStatement_unit";
            case 2L: return "SgWaitStatement_iostat";
            case 3L: return "SgWaitStatement_err";
            case 4L: return "SgWaitStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWaitStatement(i);
        if (s.empty())
            s = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWaitStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWaitStatement() {
        return stringify::E_SgWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 753
namespace stringify {
    const char* E_SgIOStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIOStatement_io_stmt_list";
            case 1L: return "SgIOStatement_unit";
            case 2L: return "SgIOStatement_iostat";
            case 3L: return "SgIOStatement_err";
            case 4L: return "SgIOStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgIOStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIOStatement(i);
        if (s.empty())
            s = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOStatement() {
        return stringify::E_SgIOStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 756
namespace stringify {
    const char* E_SgWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWhereStatement_condition";
            case 1L: return "SgWhereStatement_body";
            case 2L: return "SgWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWhereStatement(i);
        if (s.empty())
            s = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhereStatement() {
        return stringify::E_SgWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 759
namespace stringify {
    const char* E_SgElseWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgElseWhereStatement_condition";
            case 1L: return "SgElseWhereStatement_body";
            case 2L: return "SgElseWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgElseWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgElseWhereStatement(i);
        if (s.empty())
            s = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElseWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElseWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElseWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElseWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElseWhereStatement() {
        return stringify::E_SgElseWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 762
namespace stringify {
    const char* E_SgNullifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNullifyStatement_pointer_list";
            default: return "";
        }
    }

    std::string E_SgNullifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNullifyStatement(i);
        if (s.empty())
            s = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNullifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNullifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNullifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNullifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNullifyStatement() {
        return stringify::E_SgNullifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 765
namespace stringify {
    const char* E_SgArithmeticIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgArithmeticIfStatement_conditional";
            default: return "";
        }
    }

    std::string E_SgArithmeticIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgArithmeticIfStatement(i);
        if (s.empty())
            s = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArithmeticIfStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArithmeticIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArithmeticIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArithmeticIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArithmeticIfStatement() {
        return stringify::E_SgArithmeticIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 768
namespace stringify {
    const char* E_SgAssignStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignStatement_value";
            default: return "";
        }
    }

    std::string E_SgAssignStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignStatement(i);
        if (s.empty())
            s = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignStatement() {
        return stringify::E_SgAssignStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 771
namespace stringify {
    const char* E_SgComputedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgComputedGotoStatement_labelList";
            case 1L: return "SgComputedGotoStatement_label_index";
            default: return "";
        }
    }

    std::string E_SgComputedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgComputedGotoStatement(i);
        if (s.empty())
            s = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComputedGotoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComputedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComputedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComputedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComputedGotoStatement() {
        return stringify::E_SgComputedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 774
namespace stringify {
    const char* E_SgAssignedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignedGotoStatement_targets";
            default: return "";
        }
    }

    std::string E_SgAssignedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignedGotoStatement(i);
        if (s.empty())
            s = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignedGotoStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignedGotoStatement() {
        return stringify::E_SgAssignedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 777
namespace stringify {
    const char* E_SgAllocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAllocateStatement_expr_list";
            case 1L: return "SgAllocateStatement_stat_expression";
            case 2L: return "SgAllocateStatement_errmsg_expression";
            case 3L: return "SgAllocateStatement_source_expression";
            default: return "";
        }
    }

    std::string E_SgAllocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAllocateStatement(i);
        if (s.empty())
            s = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAllocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAllocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAllocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAllocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAllocateStatement() {
        return stringify::E_SgAllocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 780
namespace stringify {
    const char* E_SgDeallocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDeallocateStatement_expr_list";
            case 1L: return "SgDeallocateStatement_stat_expression";
            case 2L: return "SgDeallocateStatement_errmsg_expression";
            default: return "";
        }
    }

    std::string E_SgDeallocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDeallocateStatement(i);
        if (s.empty())
            s = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeallocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeallocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeallocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeallocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeallocateStatement() {
        return stringify::E_SgDeallocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 783
namespace stringify {
    const char* E_SgUpcNotifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcNotifyStatement_notify_expression";
            default: return "";
        }
    }

    std::string E_SgUpcNotifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcNotifyStatement(i);
        if (s.empty())
            s = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcNotifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcNotifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcNotifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcNotifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcNotifyStatement() {
        return stringify::E_SgUpcNotifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 786
namespace stringify {
    const char* E_SgUpcWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcWaitStatement_wait_expression";
            default: return "";
        }
    }

    std::string E_SgUpcWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcWaitStatement(i);
        if (s.empty())
            s = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcWaitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcWaitStatement() {
        return stringify::E_SgUpcWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 789
namespace stringify {
    const char* E_SgUpcBarrierStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBarrierStatement_barrier_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBarrierStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBarrierStatement(i);
        if (s.empty())
            s = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBarrierStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBarrierStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBarrierStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBarrierStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBarrierStatement() {
        return stringify::E_SgUpcBarrierStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 792
namespace stringify {
    const char* E_SgOmpFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFlushStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFlushStatement(i);
        if (s.empty())
            s = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFlushStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFlushStatement() {
        return stringify::E_SgOmpFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 795
namespace stringify {
    const char* E_SgOmpMasterStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMasterStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpMasterStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMasterStatement(i);
        if (s.empty())
            s = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMasterStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMasterStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMasterStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMasterStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMasterStatement() {
        return stringify::E_SgOmpMasterStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 798
namespace stringify {
    const char* E_SgOmpOrderedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedStatement(i);
        if (s.empty())
            s = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedStatement() {
        return stringify::E_SgOmpOrderedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 801
namespace stringify {
    const char* E_SgOmpCriticalStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCriticalStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpCriticalStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCriticalStatement(i);
        if (s.empty())
            s = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCriticalStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCriticalStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCriticalStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCriticalStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCriticalStatement() {
        return stringify::E_SgOmpCriticalStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 804
namespace stringify {
    const char* E_SgOmpSectionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpSectionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionStatement() {
        return stringify::E_SgOmpSectionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 807
namespace stringify {
    const char* E_SgOmpWorkshareStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpWorkshareStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpWorkshareStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpWorkshareStatement(i);
        if (s.empty())
            s = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpWorkshareStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpWorkshareStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpWorkshareStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpWorkshareStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpWorkshareStatement() {
        return stringify::E_SgOmpWorkshareStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 810
namespace stringify {
    const char* E_SgOmpParallelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpParallelStatement_body";
            case 1L: return "SgOmpParallelStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpParallelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpParallelStatement(i);
        if (s.empty())
            s = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpParallelStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpParallelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpParallelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpParallelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpParallelStatement() {
        return stringify::E_SgOmpParallelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 813
namespace stringify {
    const char* E_SgOmpSingleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSingleStatement_body";
            case 1L: return "SgOmpSingleStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSingleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSingleStatement(i);
        if (s.empty())
            s = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSingleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSingleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSingleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSingleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSingleStatement() {
        return stringify::E_SgOmpSingleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 816
namespace stringify {
    const char* E_SgOmpAtomicStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAtomicStatement_body";
            case 1L: return "SgOmpAtomicStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpAtomicStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAtomicStatement(i);
        if (s.empty())
            s = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAtomicStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAtomicStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAtomicStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAtomicStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAtomicStatement() {
        return stringify::E_SgOmpAtomicStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 819
namespace stringify {
    const char* E_SgOmpTaskStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskStatement_body";
            case 1L: return "SgOmpTaskStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskStatement() {
        return stringify::E_SgOmpTaskStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 822
namespace stringify {
    const char* E_SgOmpForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForStatement_body";
            case 1L: return "SgOmpForStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForStatement(i);
        if (s.empty())
            s = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForStatement() {
        return stringify::E_SgOmpForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 825
namespace stringify {
    const char* E_SgOmpDoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDoStatement_body";
            case 1L: return "SgOmpDoStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDoStatement(i);
        if (s.empty())
            s = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDoStatement() {
        return stringify::E_SgOmpDoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 828
namespace stringify {
    const char* E_SgOmpSectionsStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionsStatement_body";
            case 1L: return "SgOmpSectionsStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSectionsStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionsStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionsStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionsStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionsStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionsStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionsStatement() {
        return stringify::E_SgOmpSectionsStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 831
namespace stringify {
    const char* E_SgOmpTargetStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetStatement_body";
            case 1L: return "SgOmpTargetStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetStatement() {
        return stringify::E_SgOmpTargetStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 834
namespace stringify {
    const char* E_SgOmpTargetDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetDataStatement_body";
            case 1L: return "SgOmpTargetDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetDataStatement() {
        return stringify::E_SgOmpTargetDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 837
namespace stringify {
    const char* E_SgOmpSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdStatement_body";
            case 1L: return "SgOmpSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdStatement() {
        return stringify::E_SgOmpSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 840
namespace stringify {
    const char* E_SgOmpForSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForSimdStatement_body";
            case 1L: return "SgOmpForSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForSimdStatement() {
        return stringify::E_SgOmpForSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 843
namespace stringify {
    const char* E_SgOmpClauseBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpClauseBodyStatement_body";
            case 1L: return "SgOmpClauseBodyStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpClauseBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpClauseBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpClauseBodyStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpClauseBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpClauseBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpClauseBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpClauseBodyStatement() {
        return stringify::E_SgOmpClauseBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 846
namespace stringify {
    const char* E_SgOmpBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpBodyStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpBodyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpBodyStatement() {
        return stringify::E_SgOmpBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 849
namespace stringify {
    const char* E_SgWithStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWithStatement_expression";
            case 1L: return "SgWithStatement_body";
            default: return "";
        }
    }

    std::string E_SgWithStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWithStatement(i);
        if (s.empty())
            s = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWithStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWithStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWithStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWithStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWithStatement() {
        return stringify::E_SgWithStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 852
namespace stringify {
    const char* E_SgPythonPrintStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonPrintStmt_destination";
            case 1L: return "SgPythonPrintStmt_values";
            default: return "";
        }
    }

    std::string E_SgPythonPrintStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonPrintStmt(i);
        if (s.empty())
            s = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonPrintStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonPrintStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonPrintStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonPrintStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonPrintStmt() {
        return stringify::E_SgPythonPrintStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 855
namespace stringify {
    const char* E_SgAssertStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAssertStmt_test";
            case 1L: return "SgAssertStmt_exception_argument";
            default: return "";
        }
    }

    std::string E_SgAssertStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAssertStmt(i);
        if (s.empty())
            s = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssertStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssertStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssertStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssertStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssertStmt() {
        return stringify::E_SgAssertStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 858
namespace stringify {
    const char* E_SgExecStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExecStatement_executable";
            case 1L: return "SgExecStatement_globals";
            case 2L: return "SgExecStatement_locals";
            default: return "";
        }
    }

    std::string E_SgExecStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExecStatement(i);
        if (s.empty())
            s = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExecStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExecStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExecStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExecStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExecStatement() {
        return stringify::E_SgExecStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 861
namespace stringify {
    const char* E_SgPythonGlobalStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonGlobalStmt_names";
            default: return "";
        }
    }

    std::string E_SgPythonGlobalStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonGlobalStmt(i);
        if (s.empty())
            s = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonGlobalStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonGlobalStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonGlobalStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonGlobalStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonGlobalStmt() {
        return stringify::E_SgPythonGlobalStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 864
namespace stringify {
    const char* E_SgJavaSynchronizedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSynchronizedStatement_expression";
            case 1L: return "SgJavaSynchronizedStatement_body";
            default: return "";
        }
    }

    std::string E_SgJavaSynchronizedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSynchronizedStatement(i);
        if (s.empty())
            s = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSynchronizedStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSynchronizedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSynchronizedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSynchronizedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSynchronizedStatement() {
        return stringify::E_SgJavaSynchronizedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 867
namespace stringify {
    const char* E_SgAsyncStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsyncStmt_body";
            default: return "";
        }
    }

    std::string E_SgAsyncStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsyncStmt(i);
        if (s.empty())
            s = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsyncStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsyncStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsyncStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsyncStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsyncStmt() {
        return stringify::E_SgAsyncStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 870
namespace stringify {
    const char* E_SgFinishStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishStmt_body";
            default: return "";
        }
    }

    std::string E_SgFinishStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishStmt(i);
        if (s.empty())
            s = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishStmt(i);
        if (retval.empty()) {
            retval = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishStmt() {
        return stringify::E_SgFinishStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 873
namespace stringify {
    const char* E_SgAtStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtStmt_expression";
            case 1L: return "SgAtStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtStmt(i);
        if (s.empty())
            s = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtStmt() {
        return stringify::E_SgAtStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 876
namespace stringify {
    const char* E_SgAtomicStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtomicStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtomicStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtomicStmt(i);
        if (s.empty())
            s = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtomicStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtomicStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtomicStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtomicStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtomicStmt() {
        return stringify::E_SgAtomicStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 879
namespace stringify {
    const char* E_SgWhenStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhenStmt_expression";
            case 1L: return "SgWhenStmt_body";
            default: return "";
        }
    }

    std::string E_SgWhenStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhenStmt(i);
        if (s.empty())
            s = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhenStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhenStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhenStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhenStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhenStmt() {
        return stringify::E_SgWhenStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 882
namespace stringify {
    const char* E_SgSyncAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncAllStatement_stat";
            case 1L: return "SgSyncAllStatement_err_msg";
            case 2L: return "SgSyncAllStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncAllStatement(i);
        if (s.empty())
            s = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncAllStatement() {
        return stringify::E_SgSyncAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 885
namespace stringify {
    const char* E_SgSyncImagesStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncImagesStatement_stat";
            case 1L: return "SgSyncImagesStatement_err_msg";
            case 2L: return "SgSyncImagesStatement_acquired_lock";
            case 3L: return "SgSyncImagesStatement_image_set";
            default: return "";
        }
    }

    std::string E_SgSyncImagesStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncImagesStatement(i);
        if (s.empty())
            s = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncImagesStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncImagesStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncImagesStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncImagesStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncImagesStatement() {
        return stringify::E_SgSyncImagesStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 888
namespace stringify {
    const char* E_SgSyncMemoryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncMemoryStatement_stat";
            case 1L: return "SgSyncMemoryStatement_err_msg";
            case 2L: return "SgSyncMemoryStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncMemoryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncMemoryStatement(i);
        if (s.empty())
            s = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncMemoryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncMemoryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncMemoryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncMemoryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncMemoryStatement() {
        return stringify::E_SgSyncMemoryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 891
namespace stringify {
    const char* E_SgSyncTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncTeamStatement_stat";
            case 1L: return "SgSyncTeamStatement_err_msg";
            case 2L: return "SgSyncTeamStatement_acquired_lock";
            case 3L: return "SgSyncTeamStatement_team_value";
            default: return "";
        }
    }

    std::string E_SgSyncTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncTeamStatement(i);
        if (s.empty())
            s = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncTeamStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncTeamStatement() {
        return stringify::E_SgSyncTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 894
namespace stringify {
    const char* E_SgLockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLockStatement_stat";
            case 1L: return "SgLockStatement_err_msg";
            case 2L: return "SgLockStatement_acquired_lock";
            case 3L: return "SgLockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgLockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLockStatement(i);
        if (s.empty())
            s = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLockStatement() {
        return stringify::E_SgLockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 897
namespace stringify {
    const char* E_SgUnlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUnlockStatement_stat";
            case 1L: return "SgUnlockStatement_err_msg";
            case 2L: return "SgUnlockStatement_acquired_lock";
            case 3L: return "SgUnlockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgUnlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUnlockStatement(i);
        if (s.empty())
            s = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnlockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnlockStatement() {
        return stringify::E_SgUnlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 900
namespace stringify {
    const char* E_SgImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImageControlStatement_stat";
            case 1L: return "SgImageControlStatement_err_msg";
            case 2L: return "SgImageControlStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImageControlStatement(i);
        if (s.empty())
            s = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImageControlStatement() {
        return stringify::E_SgImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 903
namespace stringify {
    const char* E_SgExpressionRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgExpressionRoot_operand_i";
            default: return "";
        }
    }

    std::string E_SgExpressionRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgExpressionRoot(i);
        if (s.empty())
            s = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpressionRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpressionRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpressionRoot(i);
        if (retval.empty()) {
            retval = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpressionRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpressionRoot() {
        return stringify::E_SgExpressionRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 906
namespace stringify {
    const char* E_SgMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusOp() {
        return stringify::E_SgMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 909
namespace stringify {
    const char* E_SgUnaryAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryAddOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryAddOp(i);
        if (s.empty())
            s = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryAddOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryAddOp() {
        return stringify::E_SgUnaryAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 912
namespace stringify {
    const char* E_SgNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotOp(i);
        if (s.empty())
            s = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotOp() {
        return stringify::E_SgNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 915
namespace stringify {
    const char* E_SgPointerDerefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerDerefExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerDerefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerDerefExp(i);
        if (s.empty())
            s = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerDerefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerDerefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerDerefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerDerefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerDerefExp() {
        return stringify::E_SgPointerDerefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 918
namespace stringify {
    const char* E_SgAddressOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddressOfOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddressOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddressOfOp(i);
        if (s.empty())
            s = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddressOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddressOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddressOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddressOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddressOfOp() {
        return stringify::E_SgAddressOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 921
namespace stringify {
    const char* E_SgMinusMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusMinusOp() {
        return stringify::E_SgMinusMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 924
namespace stringify {
    const char* E_SgPlusPlusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusPlusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusPlusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusPlusOp(i);
        if (s.empty())
            s = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusPlusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusPlusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusPlusOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusPlusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusPlusOp() {
        return stringify::E_SgPlusPlusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 927
namespace stringify {
    const char* E_SgBitComplementOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitComplementOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitComplementOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitComplementOp(i);
        if (s.empty())
            s = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitComplementOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitComplementOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitComplementOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitComplementOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitComplementOp() {
        return stringify::E_SgBitComplementOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 930
namespace stringify {
    const char* E_SgCastExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCastExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgCastExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCastExp(i);
        if (s.empty())
            s = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCastExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCastExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCastExp(i);
        if (retval.empty()) {
            retval = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCastExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCastExp() {
        return stringify::E_SgCastExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 933
namespace stringify {
    const char* E_SgThrowOp(int64_t i) {
        switch (i) {
            case 0L: return "SgThrowOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgThrowOp(int64_t i, const std::string &strip) {
        std::string s = E_SgThrowOp(i);
        if (s.empty())
            s = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgThrowOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgThrowOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgThrowOp(i);
        if (retval.empty()) {
            retval = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgThrowOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgThrowOp() {
        return stringify::E_SgThrowOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 936
namespace stringify {
    const char* E_SgRealPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRealPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgRealPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRealPartOp(i);
        if (s.empty())
            s = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRealPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRealPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRealPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRealPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRealPartOp() {
        return stringify::E_SgRealPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 939
namespace stringify {
    const char* E_SgImagPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgImagPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgImagPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgImagPartOp(i);
        if (s.empty())
            s = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImagPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImagPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImagPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImagPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImagPartOp() {
        return stringify::E_SgImagPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 942
namespace stringify {
    const char* E_SgConjugateOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConjugateOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgConjugateOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConjugateOp(i);
        if (s.empty())
            s = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConjugateOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConjugateOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConjugateOp(i);
        if (retval.empty()) {
            retval = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConjugateOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConjugateOp() {
        return stringify::E_SgConjugateOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 945
namespace stringify {
    const char* E_SgUserDefinedUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedUnaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedUnaryOp() {
        return stringify::E_SgUserDefinedUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 948
namespace stringify {
    const char* E_SgMatrixTransposeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixTransposeOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMatrixTransposeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixTransposeOp(i);
        if (s.empty())
            s = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixTransposeOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixTransposeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixTransposeOp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixTransposeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixTransposeOp() {
        return stringify::E_SgMatrixTransposeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 951
namespace stringify {
    const char* E_SgUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryOp(i);
        if (s.empty())
            s = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryOp() {
        return stringify::E_SgUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 954
namespace stringify {
    const char* E_SgArrowExp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowExp_lhs_operand_i";
            case 1L: return "SgArrowExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowExp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowExp(i);
        if (s.empty())
            s = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowExp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowExp() {
        return stringify::E_SgArrowExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 957
namespace stringify {
    const char* E_SgDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotExp_lhs_operand_i";
            case 1L: return "SgDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotExp(i);
        if (s.empty())
            s = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotExp() {
        return stringify::E_SgDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 960
namespace stringify {
    const char* E_SgDotStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotStarOp_lhs_operand_i";
            case 1L: return "SgDotStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotStarOp(i);
        if (s.empty())
            s = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotStarOp() {
        return stringify::E_SgDotStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 963
namespace stringify {
    const char* E_SgArrowStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowStarOp_lhs_operand_i";
            case 1L: return "SgArrowStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowStarOp(i);
        if (s.empty())
            s = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowStarOp() {
        return stringify::E_SgArrowStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 966
namespace stringify {
    const char* E_SgEqualityOp(int64_t i) {
        switch (i) {
            case 0L: return "SgEqualityOp_lhs_operand_i";
            case 1L: return "SgEqualityOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgEqualityOp(int64_t i, const std::string &strip) {
        std::string s = E_SgEqualityOp(i);
        if (s.empty())
            s = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEqualityOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEqualityOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEqualityOp(i);
        if (retval.empty()) {
            retval = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEqualityOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEqualityOp() {
        return stringify::E_SgEqualityOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 969
namespace stringify {
    const char* E_SgLessThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessThanOp_lhs_operand_i";
            case 1L: return "SgLessThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessThanOp(i);
        if (s.empty())
            s = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessThanOp() {
        return stringify::E_SgLessThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 972
namespace stringify {
    const char* E_SgGreaterThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterThanOp_lhs_operand_i";
            case 1L: return "SgGreaterThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterThanOp(i);
        if (s.empty())
            s = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterThanOp() {
        return stringify::E_SgGreaterThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 975
namespace stringify {
    const char* E_SgNotEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotEqualOp_lhs_operand_i";
            case 1L: return "SgNotEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotEqualOp(i);
        if (s.empty())
            s = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotEqualOp() {
        return stringify::E_SgNotEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 978
namespace stringify {
    const char* E_SgLessOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessOrEqualOp_lhs_operand_i";
            case 1L: return "SgLessOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessOrEqualOp(i);
        if (s.empty())
            s = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessOrEqualOp() {
        return stringify::E_SgLessOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 981
namespace stringify {
    const char* E_SgGreaterOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterOrEqualOp_lhs_operand_i";
            case 1L: return "SgGreaterOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterOrEqualOp(i);
        if (s.empty())
            s = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterOrEqualOp() {
        return stringify::E_SgGreaterOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 984
namespace stringify {
    const char* E_SgAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddOp_lhs_operand_i";
            case 1L: return "SgAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddOp(i);
        if (s.empty())
            s = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddOp() {
        return stringify::E_SgAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 987
namespace stringify {
    const char* E_SgSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSubtractOp_lhs_operand_i";
            case 1L: return "SgSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSubtractOp(i);
        if (s.empty())
            s = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubtractOp() {
        return stringify::E_SgSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 990
namespace stringify {
    const char* E_SgMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultiplyOp_lhs_operand_i";
            case 1L: return "SgMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultiplyOp(i);
        if (s.empty())
            s = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultiplyOp() {
        return stringify::E_SgMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 993
namespace stringify {
    const char* E_SgDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivideOp_lhs_operand_i";
            case 1L: return "SgDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivideOp(i);
        if (s.empty())
            s = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivideOp() {
        return stringify::E_SgDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 996
namespace stringify {
    const char* E_SgIntegerDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideOp() {
        return stringify::E_SgIntegerDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 999
namespace stringify {
    const char* E_SgModOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModOp_lhs_operand_i";
            case 1L: return "SgModOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModOp(i);
        if (s.empty())
            s = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModOp(i);
        if (retval.empty()) {
            retval = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModOp() {
        return stringify::E_SgModOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1002
namespace stringify {
    const char* E_SgAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndOp_lhs_operand_i";
            case 1L: return "SgAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndOp(i);
        if (s.empty())
            s = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndOp() {
        return stringify::E_SgAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1005
namespace stringify {
    const char* E_SgOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgOrOp_lhs_operand_i";
            case 1L: return "SgOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgOrOp(i);
        if (s.empty())
            s = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOrOp() {
        return stringify::E_SgOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1008
namespace stringify {
    const char* E_SgBitXorOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitXorOp_lhs_operand_i";
            case 1L: return "SgBitXorOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitXorOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitXorOp(i);
        if (s.empty())
            s = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitXorOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitXorOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitXorOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitXorOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitXorOp() {
        return stringify::E_SgBitXorOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1011
namespace stringify {
    const char* E_SgBitAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitAndOp_lhs_operand_i";
            case 1L: return "SgBitAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitAndOp(i);
        if (s.empty())
            s = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitAndOp() {
        return stringify::E_SgBitAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1014
namespace stringify {
    const char* E_SgBitOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitOrOp_lhs_operand_i";
            case 1L: return "SgBitOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitOrOp(i);
        if (s.empty())
            s = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitOrOp() {
        return stringify::E_SgBitOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1017
namespace stringify {
    const char* E_SgCommaOpExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCommaOpExp_lhs_operand_i";
            case 1L: return "SgCommaOpExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCommaOpExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCommaOpExp(i);
        if (s.empty())
            s = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommaOpExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommaOpExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommaOpExp(i);
        if (retval.empty()) {
            retval = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommaOpExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommaOpExp() {
        return stringify::E_SgCommaOpExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1020
namespace stringify {
    const char* E_SgLshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftOp_lhs_operand_i";
            case 1L: return "SgLshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftOp(i);
        if (s.empty())
            s = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftOp() {
        return stringify::E_SgLshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1023
namespace stringify {
    const char* E_SgRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftOp_lhs_operand_i";
            case 1L: return "SgRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftOp(i);
        if (s.empty())
            s = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftOp() {
        return stringify::E_SgRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1026
namespace stringify {
    const char* E_SgPntrArrRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPntrArrRefExp_lhs_operand_i";
            case 1L: return "SgPntrArrRefExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPntrArrRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPntrArrRefExp(i);
        if (s.empty())
            s = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPntrArrRefExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPntrArrRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPntrArrRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPntrArrRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPntrArrRefExp() {
        return stringify::E_SgPntrArrRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1029
namespace stringify {
    const char* E_SgScopeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgScopeOp_lhs_operand_i";
            case 1L: return "SgScopeOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgScopeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgScopeOp(i);
        if (s.empty())
            s = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopeOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopeOp(i);
        if (retval.empty()) {
            retval = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopeOp() {
        return stringify::E_SgScopeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1032
namespace stringify {
    const char* E_SgAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignOp_lhs_operand_i";
            case 1L: return "SgAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignOp(i);
        if (s.empty())
            s = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignOp() {
        return stringify::E_SgAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1035
namespace stringify {
    const char* E_SgExponentiationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationOp_lhs_operand_i";
            case 1L: return "SgExponentiationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationOp(i);
        if (s.empty())
            s = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationOp() {
        return stringify::E_SgExponentiationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1038
namespace stringify {
    const char* E_SgJavaUnsignedRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftOp() {
        return stringify::E_SgJavaUnsignedRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1041
namespace stringify {
    const char* E_SgConcatenationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConcatenationOp_lhs_operand_i";
            case 1L: return "SgConcatenationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgConcatenationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConcatenationOp(i);
        if (s.empty())
            s = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConcatenationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConcatenationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConcatenationOp(i);
        if (retval.empty()) {
            retval = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConcatenationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConcatenationOp() {
        return stringify::E_SgConcatenationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1044
namespace stringify {
    const char* E_SgPointerAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerAssignOp_lhs_operand_i";
            case 1L: return "SgPointerAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerAssignOp(i);
        if (s.empty())
            s = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerAssignOp() {
        return stringify::E_SgPointerAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1047
namespace stringify {
    const char* E_SgUserDefinedBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedBinaryOp_lhs_operand_i";
            case 1L: return "SgUserDefinedBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedBinaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedBinaryOp() {
        return stringify::E_SgUserDefinedBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1050
namespace stringify {
    const char* E_SgPlusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusAssignOp_lhs_operand_i";
            case 1L: return "SgPlusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusAssignOp(i);
        if (s.empty())
            s = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusAssignOp() {
        return stringify::E_SgPlusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1053
namespace stringify {
    const char* E_SgMinusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusAssignOp_lhs_operand_i";
            case 1L: return "SgMinusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusAssignOp(i);
        if (s.empty())
            s = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusAssignOp() {
        return stringify::E_SgMinusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1056
namespace stringify {
    const char* E_SgAndAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndAssignOp_lhs_operand_i";
            case 1L: return "SgAndAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndAssignOp(i);
        if (s.empty())
            s = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndAssignOp() {
        return stringify::E_SgAndAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1059
namespace stringify {
    const char* E_SgIorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIorAssignOp_lhs_operand_i";
            case 1L: return "SgIorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIorAssignOp(i);
        if (s.empty())
            s = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIorAssignOp() {
        return stringify::E_SgIorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1062
namespace stringify {
    const char* E_SgMultAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultAssignOp_lhs_operand_i";
            case 1L: return "SgMultAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultAssignOp(i);
        if (s.empty())
            s = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultAssignOp() {
        return stringify::E_SgMultAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1065
namespace stringify {
    const char* E_SgDivAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivAssignOp_lhs_operand_i";
            case 1L: return "SgDivAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivAssignOp(i);
        if (s.empty())
            s = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivAssignOp() {
        return stringify::E_SgDivAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1068
namespace stringify {
    const char* E_SgModAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModAssignOp_lhs_operand_i";
            case 1L: return "SgModAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModAssignOp(i);
        if (s.empty())
            s = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModAssignOp() {
        return stringify::E_SgModAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1071
namespace stringify {
    const char* E_SgXorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgXorAssignOp_lhs_operand_i";
            case 1L: return "SgXorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgXorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgXorAssignOp(i);
        if (s.empty())
            s = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgXorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgXorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgXorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgXorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgXorAssignOp() {
        return stringify::E_SgXorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1074
namespace stringify {
    const char* E_SgLshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftAssignOp_lhs_operand_i";
            case 1L: return "SgLshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftAssignOp() {
        return stringify::E_SgLshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1077
namespace stringify {
    const char* E_SgRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftAssignOp() {
        return stringify::E_SgRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1080
namespace stringify {
    const char* E_SgJavaUnsignedRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftAssignOp() {
        return stringify::E_SgJavaUnsignedRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1083
namespace stringify {
    const char* E_SgIntegerDivideAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideAssignOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideAssignOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideAssignOp() {
        return stringify::E_SgIntegerDivideAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1086
namespace stringify {
    const char* E_SgExponentiationAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationAssignOp_lhs_operand_i";
            case 1L: return "SgExponentiationAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationAssignOp(i);
        if (s.empty())
            s = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationAssignOp() {
        return stringify::E_SgExponentiationAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1089
namespace stringify {
    const char* E_SgCompoundAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundAssignOp_lhs_operand_i";
            case 1L: return "SgCompoundAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCompoundAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundAssignOp(i);
        if (s.empty())
            s = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundAssignOp() {
        return stringify::E_SgCompoundAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1092
namespace stringify {
    const char* E_SgMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMembershipOp_lhs_operand_i";
            case 1L: return "SgMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMembershipOp(i);
        if (s.empty())
            s = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMembershipOp() {
        return stringify::E_SgMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1095
namespace stringify {
    const char* E_SgNonMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNonMembershipOp_lhs_operand_i";
            case 1L: return "SgNonMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNonMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNonMembershipOp(i);
        if (s.empty())
            s = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonMembershipOp() {
        return stringify::E_SgNonMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1098
namespace stringify {
    const char* E_SgIsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsOp_lhs_operand_i";
            case 1L: return "SgIsOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsOp(i);
        if (s.empty())
            s = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsOp() {
        return stringify::E_SgIsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1101
namespace stringify {
    const char* E_SgIsNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsNotOp_lhs_operand_i";
            case 1L: return "SgIsNotOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsNotOp(i);
        if (s.empty())
            s = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsNotOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsNotOp() {
        return stringify::E_SgIsNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1104
namespace stringify {
    const char* E_SgDotDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotDotExp_lhs_operand_i";
            case 1L: return "SgDotDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotDotExp(i);
        if (s.empty())
            s = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotDotExp() {
        return stringify::E_SgDotDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1107
namespace stringify {
    const char* E_SgElementwiseMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseMultiplyOp_lhs_operand_i";
            case 1L: return "SgElementwiseMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseMultiplyOp(i);
        if (s.empty())
            s = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseMultiplyOp() {
        return stringify::E_SgElementwiseMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1110
namespace stringify {
    const char* E_SgElementwisePowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwisePowerOp_lhs_operand_i";
            case 1L: return "SgElementwisePowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwisePowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwisePowerOp(i);
        if (s.empty())
            s = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwisePowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwisePowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwisePowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwisePowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwisePowerOp() {
        return stringify::E_SgElementwisePowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1113
namespace stringify {
    const char* E_SgElementwiseLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseLeftDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseLeftDivideOp() {
        return stringify::E_SgElementwiseLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1116
namespace stringify {
    const char* E_SgElementwiseDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseDivideOp() {
        return stringify::E_SgElementwiseDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1119
namespace stringify {
    const char* E_SgElementwiseAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseAddOp_lhs_operand_i";
            case 1L: return "SgElementwiseAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseAddOp(i);
        if (s.empty())
            s = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseAddOp() {
        return stringify::E_SgElementwiseAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1122
namespace stringify {
    const char* E_SgElementwiseSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseSubtractOp_lhs_operand_i";
            case 1L: return "SgElementwiseSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseSubtractOp(i);
        if (s.empty())
            s = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseSubtractOp() {
        return stringify::E_SgElementwiseSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1125
namespace stringify {
    const char* E_SgElementwiseOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseOp_lhs_operand_i";
            case 1L: return "SgElementwiseOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseOp(i);
        if (s.empty())
            s = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseOp() {
        return stringify::E_SgElementwiseOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1128
namespace stringify {
    const char* E_SgPowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPowerOp_lhs_operand_i";
            case 1L: return "SgPowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPowerOp(i);
        if (s.empty())
            s = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPowerOp() {
        return stringify::E_SgPowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1131
namespace stringify {
    const char* E_SgLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLeftDivideOp_lhs_operand_i";
            case 1L: return "SgLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLeftDivideOp() {
        return stringify::E_SgLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1134
namespace stringify {
    const char* E_SgBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryOp_lhs_operand_i";
            case 1L: return "SgBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryOp(i);
        if (s.empty())
            s = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryOp() {
        return stringify::E_SgBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1137
namespace stringify {
    const char* E_SgListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgListExp(i);
        if (s.empty())
            s = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListExp(i);
        if (retval.empty()) {
            retval = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListExp() {
        return stringify::E_SgListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1140
namespace stringify {
    const char* E_SgTupleExp(int64_t i) {
        switch (i) {
            case 0L: return "SgTupleExp_expressions";
            default: return "";
        }
    }

    std::string E_SgTupleExp(int64_t i, const std::string &strip) {
        std::string s = E_SgTupleExp(i);
        if (s.empty())
            s = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTupleExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTupleExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTupleExp(i);
        if (retval.empty()) {
            retval = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTupleExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTupleExp() {
        return stringify::E_SgTupleExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1143
namespace stringify {
    const char* E_SgMatrixExp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixExp_expressions";
            default: return "";
        }
    }

    std::string E_SgMatrixExp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixExp(i);
        if (s.empty())
            s = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixExp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixExp() {
        return stringify::E_SgMatrixExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1146
namespace stringify {
    const char* E_SgExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgExprListExp(i);
        if (s.empty())
            s = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprListExp() {
        return stringify::E_SgExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1149
namespace stringify {
    const char* E_SgComplexVal(int64_t i) {
        switch (i) {
            case 0L: return "SgComplexVal_real_value";
            case 1L: return "SgComplexVal_imaginary_value";
            default: return "";
        }
    }

    std::string E_SgComplexVal(int64_t i, const std::string &strip) {
        std::string s = E_SgComplexVal(i);
        if (s.empty())
            s = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComplexVal() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComplexVal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComplexVal(i);
        if (retval.empty()) {
            retval = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComplexVal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComplexVal() {
        return stringify::E_SgComplexVal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1152
namespace stringify {
    const char* E_SgCudaKernelCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelCallExp_function";
            case 1L: return "SgCudaKernelCallExp_args";
            case 2L: return "SgCudaKernelCallExp_exec_config";
            default: return "";
        }
    }

    std::string E_SgCudaKernelCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelCallExp(i);
        if (s.empty())
            s = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelCallExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelCallExp() {
        return stringify::E_SgCudaKernelCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1155
namespace stringify {
    const char* E_SgFunctionCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionCallExp_function";
            case 1L: return "SgFunctionCallExp_args";
            default: return "";
        }
    }

    std::string E_SgFunctionCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionCallExp(i);
        if (s.empty())
            s = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionCallExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionCallExp() {
        return stringify::E_SgFunctionCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1158
namespace stringify {
    const char* E_SgCallExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCallExpression_function";
            case 1L: return "SgCallExpression_args";
            default: return "";
        }
    }

    std::string E_SgCallExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCallExpression(i);
        if (s.empty())
            s = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCallExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCallExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCallExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCallExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCallExpression() {
        return stringify::E_SgCallExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1161
namespace stringify {
    const char* E_SgSizeOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSizeOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgSizeOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSizeOfOp(i);
        if (s.empty())
            s = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSizeOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSizeOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSizeOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSizeOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSizeOfOp() {
        return stringify::E_SgSizeOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1164
namespace stringify {
    const char* E_SgUpcLocalsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcLocalsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcLocalsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcLocalsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcLocalsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcLocalsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcLocalsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcLocalsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcLocalsizeofExpression() {
        return stringify::E_SgUpcLocalsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1167
namespace stringify {
    const char* E_SgUpcBlocksizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBlocksizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBlocksizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBlocksizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBlocksizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBlocksizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBlocksizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBlocksizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBlocksizeofExpression() {
        return stringify::E_SgUpcBlocksizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1170
namespace stringify {
    const char* E_SgUpcElemsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcElemsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcElemsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcElemsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcElemsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcElemsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcElemsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcElemsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcElemsizeofExpression() {
        return stringify::E_SgUpcElemsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1173
namespace stringify {
    const char* E_SgJavaInstanceOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaInstanceOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgJavaInstanceOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaInstanceOfOp(i);
        if (s.empty())
            s = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaInstanceOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaInstanceOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaInstanceOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaInstanceOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaInstanceOfOp() {
        return stringify::E_SgJavaInstanceOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1176
namespace stringify {
    const char* E_SgTypeIdOp(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeIdOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgTypeIdOp(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeIdOp(i);
        if (s.empty())
            s = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeIdOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeIdOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeIdOp(i);
        if (retval.empty()) {
            retval = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeIdOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeIdOp() {
        return stringify::E_SgTypeIdOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1179
namespace stringify {
    const char* E_SgConditionalExp(int64_t i) {
        switch (i) {
            case 0L: return "SgConditionalExp_conditional_exp";
            case 1L: return "SgConditionalExp_true_exp";
            case 2L: return "SgConditionalExp_false_exp";
            default: return "";
        }
    }

    std::string E_SgConditionalExp(int64_t i, const std::string &strip) {
        std::string s = E_SgConditionalExp(i);
        if (s.empty())
            s = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConditionalExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConditionalExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConditionalExp(i);
        if (retval.empty()) {
            retval = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConditionalExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConditionalExp() {
        return stringify::E_SgConditionalExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1182
namespace stringify {
    const char* E_SgNewExp(int64_t i) {
        switch (i) {
            case 0L: return "SgNewExp_placement_args";
            case 1L: return "SgNewExp_constructor_args";
            case 2L: return "SgNewExp_builtin_args";
            default: return "";
        }
    }

    std::string E_SgNewExp(int64_t i, const std::string &strip) {
        std::string s = E_SgNewExp(i);
        if (s.empty())
            s = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNewExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNewExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNewExp(i);
        if (retval.empty()) {
            retval = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNewExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNewExp() {
        return stringify::E_SgNewExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1185
namespace stringify {
    const char* E_SgDeleteExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDeleteExp_variable";
            default: return "";
        }
    }

    std::string E_SgDeleteExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDeleteExp(i);
        if (s.empty())
            s = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeleteExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeleteExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeleteExp(i);
        if (retval.empty()) {
            retval = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeleteExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeleteExp() {
        return stringify::E_SgDeleteExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1188
namespace stringify {
    const char* E_SgAggregateInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAggregateInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgAggregateInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAggregateInitializer(i);
        if (s.empty())
            s = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAggregateInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAggregateInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAggregateInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAggregateInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAggregateInitializer() {
        return stringify::E_SgAggregateInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1191
namespace stringify {
    const char* E_SgCompoundInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgCompoundInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundInitializer(i);
        if (s.empty())
            s = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundInitializer() {
        return stringify::E_SgCompoundInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1194
namespace stringify {
    const char* E_SgConstructorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgConstructorInitializer_args";
            default: return "";
        }
    }

    std::string E_SgConstructorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgConstructorInitializer(i);
        if (s.empty())
            s = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConstructorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConstructorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConstructorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConstructorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConstructorInitializer() {
        return stringify::E_SgConstructorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1197
namespace stringify {
    const char* E_SgAssignInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignInitializer_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignInitializer(i);
        if (s.empty())
            s = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignInitializer() {
        return stringify::E_SgAssignInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1200
namespace stringify {
    const char* E_SgDesignatedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgDesignatedInitializer_designatorList";
            case 1L: return "SgDesignatedInitializer_memberInit";
            default: return "";
        }
    }

    std::string E_SgDesignatedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgDesignatedInitializer(i);
        if (s.empty())
            s = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDesignatedInitializer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDesignatedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDesignatedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDesignatedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDesignatedInitializer() {
        return stringify::E_SgDesignatedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1203
namespace stringify {
    const char* E_SgBracedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgBracedInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgBracedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgBracedInitializer(i);
        if (s.empty())
            s = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBracedInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBracedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBracedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBracedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBracedInitializer() {
        return stringify::E_SgBracedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1206
namespace stringify {
    const char* E_SgVarArgStartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOp_lhs_operand";
            case 1L: return "SgVarArgStartOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOp() {
        return stringify::E_SgVarArgStartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1209
namespace stringify {
    const char* E_SgVarArgOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgOp(i);
        if (s.empty())
            s = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgOp() {
        return stringify::E_SgVarArgOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1212
namespace stringify {
    const char* E_SgVarArgEndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgEndOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgEndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgEndOp(i);
        if (s.empty())
            s = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgEndOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgEndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgEndOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgEndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgEndOp() {
        return stringify::E_SgVarArgEndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1215
namespace stringify {
    const char* E_SgVarArgCopyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgCopyOp_lhs_operand";
            case 1L: return "SgVarArgCopyOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgCopyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgCopyOp(i);
        if (s.empty())
            s = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgCopyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgCopyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgCopyOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgCopyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgCopyOp() {
        return stringify::E_SgVarArgCopyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1218
namespace stringify {
    const char* E_SgVarArgStartOneOperandOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOneOperandOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOneOperandOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOneOperandOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOneOperandOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOneOperandOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOneOperandOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOneOperandOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOneOperandOp() {
        return stringify::E_SgVarArgStartOneOperandOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1221
namespace stringify {
    const char* E_SgSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgSubscriptExpression_lowerBound";
            case 1L: return "SgSubscriptExpression_upperBound";
            case 2L: return "SgSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubscriptExpression() {
        return stringify::E_SgSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1224
namespace stringify {
    const char* E_SgImpliedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgImpliedDo_do_var_initialization";
            case 1L: return "SgImpliedDo_last_val";
            case 2L: return "SgImpliedDo_increment";
            case 3L: return "SgImpliedDo_object_list";
            default: return "";
        }
    }

    std::string E_SgImpliedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgImpliedDo(i);
        if (s.empty())
            s = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImpliedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImpliedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImpliedDo(i);
        if (retval.empty()) {
            retval = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImpliedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImpliedDo() {
        return stringify::E_SgImpliedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1227
namespace stringify {
    const char* E_SgIOItemExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgIOItemExpression_io_item";
            default: return "";
        }
    }

    std::string E_SgIOItemExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgIOItemExpression(i);
        if (s.empty())
            s = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOItemExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOItemExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOItemExpression(i);
        if (retval.empty()) {
            retval = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOItemExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOItemExpression() {
        return stringify::E_SgIOItemExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1230
namespace stringify {
    const char* E_SgStatementExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementExpression_statement";
            default: return "";
        }
    }

    std::string E_SgStatementExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementExpression(i);
        if (s.empty())
            s = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementExpression(i);
        if (retval.empty()) {
            retval = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementExpression() {
        return stringify::E_SgStatementExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1233
namespace stringify {
    const char* E_SgAsmOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOp_expression";
            default: return "";
        }
    }

    std::string E_SgAsmOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOp(i);
        if (s.empty())
            s = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOp() {
        return stringify::E_SgAsmOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1236
namespace stringify {
    const char* E_SgActualArgumentExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgActualArgumentExpression_expression";
            default: return "";
        }
    }

    std::string E_SgActualArgumentExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgActualArgumentExpression(i);
        if (s.empty())
            s = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgActualArgumentExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgActualArgumentExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgActualArgumentExpression(i);
        if (retval.empty()) {
            retval = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgActualArgumentExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgActualArgumentExpression() {
        return stringify::E_SgActualArgumentExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1239
namespace stringify {
    const char* E_SgUnknownArrayOrFunctionReference(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownArrayOrFunctionReference_named_reference";
            case 1L: return "SgUnknownArrayOrFunctionReference_expression_list";
            default: return "";
        }
    }

    std::string E_SgUnknownArrayOrFunctionReference(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownArrayOrFunctionReference(i);
        if (s.empty())
            s = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownArrayOrFunctionReference() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownArrayOrFunctionReference(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownArrayOrFunctionReference(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownArrayOrFunctionReference() {
        return stringify::E_SgUnknownArrayOrFunctionReference();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1242
namespace stringify {
    const char* E_SgCAFCoExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFCoExpression_referData";
            default: return "";
        }
    }

    std::string E_SgCAFCoExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFCoExpression(i);
        if (s.empty())
            s = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFCoExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFCoExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFCoExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFCoExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFCoExpression() {
        return stringify::E_SgCAFCoExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1245
namespace stringify {
    const char* E_SgCudaKernelExecConfig(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelExecConfig_grid";
            case 1L: return "SgCudaKernelExecConfig_blocks";
            case 2L: return "SgCudaKernelExecConfig_shared";
            case 3L: return "SgCudaKernelExecConfig_stream";
            default: return "";
        }
    }

    std::string E_SgCudaKernelExecConfig(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelExecConfig(i);
        if (s.empty())
            s = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelExecConfig() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelExecConfig(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelExecConfig(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelExecConfig::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelExecConfig() {
        return stringify::E_SgCudaKernelExecConfig();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1248
namespace stringify {
    const char* E_SgLambdaRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaRefExp_functionDeclaration";
            default: return "";
        }
    }

    std::string E_SgLambdaRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaRefExp(i);
        if (s.empty())
            s = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaRefExp() {
        return stringify::E_SgLambdaRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1251
namespace stringify {
    const char* E_SgDictionaryExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryExp_key_datum_pairs";
            default: return "";
        }
    }

    std::string E_SgDictionaryExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryExp(i);
        if (s.empty())
            s = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryExp(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryExp() {
        return stringify::E_SgDictionaryExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1254
namespace stringify {
    const char* E_SgKeyDatumPair(int64_t i) {
        switch (i) {
            case 0L: return "SgKeyDatumPair_key";
            case 1L: return "SgKeyDatumPair_datum";
            default: return "";
        }
    }

    std::string E_SgKeyDatumPair(int64_t i, const std::string &strip) {
        std::string s = E_SgKeyDatumPair(i);
        if (s.empty())
            s = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgKeyDatumPair() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgKeyDatumPair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgKeyDatumPair(i);
        if (retval.empty()) {
            retval = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgKeyDatumPair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgKeyDatumPair() {
        return stringify::E_SgKeyDatumPair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1257
namespace stringify {
    const char* E_SgComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgComprehension_target";
            case 1L: return "SgComprehension_iter";
            case 2L: return "SgComprehension_filters";
            default: return "";
        }
    }

    std::string E_SgComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgComprehension(i);
        if (s.empty())
            s = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComprehension() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComprehension() {
        return stringify::E_SgComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1260
namespace stringify {
    const char* E_SgListComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgListComprehension_element";
            case 1L: return "SgListComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgListComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgListComprehension(i);
        if (s.empty())
            s = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListComprehension() {
        return stringify::E_SgListComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1263
namespace stringify {
    const char* E_SgSetComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgSetComprehension_element";
            case 1L: return "SgSetComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgSetComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgSetComprehension(i);
        if (s.empty())
            s = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSetComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSetComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSetComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSetComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSetComprehension() {
        return stringify::E_SgSetComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1266
namespace stringify {
    const char* E_SgDictionaryComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryComprehension_element";
            case 1L: return "SgDictionaryComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgDictionaryComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryComprehension(i);
        if (s.empty())
            s = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryComprehension() {
        return stringify::E_SgDictionaryComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1269
namespace stringify {
    const char* E_SgNaryBooleanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryBooleanOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryBooleanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryBooleanOp(i);
        if (s.empty())
            s = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryBooleanOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryBooleanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryBooleanOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryBooleanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryBooleanOp() {
        return stringify::E_SgNaryBooleanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1272
namespace stringify {
    const char* E_SgNaryComparisonOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryComparisonOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryComparisonOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryComparisonOp(i);
        if (s.empty())
            s = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryComparisonOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryComparisonOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryComparisonOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryComparisonOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryComparisonOp() {
        return stringify::E_SgNaryComparisonOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1275
namespace stringify {
    const char* E_SgNaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryOp(i);
        if (s.empty())
            s = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryOp() {
        return stringify::E_SgNaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1278
namespace stringify {
    const char* E_SgStringConversion(int64_t i) {
        switch (i) {
            case 0L: return "SgStringConversion_expression";
            default: return "";
        }
    }

    std::string E_SgStringConversion(int64_t i, const std::string &strip) {
        std::string s = E_SgStringConversion(i);
        if (s.empty())
            s = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStringConversion() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStringConversion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStringConversion(i);
        if (retval.empty()) {
            retval = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStringConversion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStringConversion() {
        return stringify::E_SgStringConversion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1281
namespace stringify {
    const char* E_SgYieldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgYieldExpression_value";
            default: return "";
        }
    }

    std::string E_SgYieldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgYieldExpression(i);
        if (s.empty())
            s = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgYieldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgYieldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgYieldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgYieldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgYieldExpression() {
        return stringify::E_SgYieldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1284
namespace stringify {
    const char* E_SgAlignOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAlignOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgAlignOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAlignOfOp(i);
        if (s.empty())
            s = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAlignOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAlignOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAlignOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAlignOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAlignOfOp() {
        return stringify::E_SgAlignOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1287
namespace stringify {
    const char* E_SgRangeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeExp_start";
            case 1L: return "SgRangeExp_end";
            case 2L: return "SgRangeExp_stride";
            default: return "";
        }
    }

    std::string E_SgRangeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeExp(i);
        if (s.empty())
            s = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeExp(i);
        if (retval.empty()) {
            retval = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeExp() {
        return stringify::E_SgRangeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1290
namespace stringify {
    const char* E_SgJavaSingleMemberAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSingleMemberAnnotation_value";
            default: return "";
        }
    }

    std::string E_SgJavaSingleMemberAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSingleMemberAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSingleMemberAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSingleMemberAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSingleMemberAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSingleMemberAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSingleMemberAnnotation() {
        return stringify::E_SgJavaSingleMemberAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1293
namespace stringify {
    const char* E_SgJavaNormalAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaNormalAnnotation_value_pair_list";
            default: return "";
        }
    }

    std::string E_SgJavaNormalAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaNormalAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaNormalAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaNormalAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaNormalAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaNormalAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaNormalAnnotation() {
        return stringify::E_SgJavaNormalAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1296
namespace stringify {
    const char* E_SgFunctionParameterRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterRefExp_parameter_expression";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterRefExp(i);
        if (s.empty())
            s = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterRefExp() {
        return stringify::E_SgFunctionParameterRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1299
namespace stringify {
    const char* E_SgLambdaExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaExp_lambda_capture_list";
            case 1L: return "SgLambdaExp_lambda_closure_class";
            case 2L: return "SgLambdaExp_lambda_function";
            default: return "";
        }
    }

    std::string E_SgLambdaExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaExp(i);
        if (s.empty())
            s = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaExp() {
        return stringify::E_SgLambdaExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1302
namespace stringify {
    const char* E_SgHereExp(int64_t i) {
        switch (i) {
            case 0L: return "SgHereExp_expression";
            default: return "";
        }
    }

    std::string E_SgHereExp(int64_t i, const std::string &strip) {
        std::string s = E_SgHereExp(i);
        if (s.empty())
            s = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgHereExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgHereExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgHereExp(i);
        if (retval.empty()) {
            retval = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgHereExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgHereExp() {
        return stringify::E_SgHereExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1305
namespace stringify {
    const char* E_SgAtExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAtExp_expression";
            case 1L: return "SgAtExp_body";
            default: return "";
        }
    }

    std::string E_SgAtExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAtExp(i);
        if (s.empty())
            s = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtExp(i);
        if (retval.empty()) {
            retval = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtExp() {
        return stringify::E_SgAtExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1308
namespace stringify {
    const char* E_SgFinishExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishExp_expression";
            case 1L: return "SgFinishExp_body";
            default: return "";
        }
    }

    std::string E_SgFinishExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishExp(i);
        if (s.empty())
            s = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishExp(i);
        if (retval.empty()) {
            retval = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishExp() {
        return stringify::E_SgFinishExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1311
namespace stringify {
    const char* E_SgNoexceptOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNoexceptOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgNoexceptOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNoexceptOp(i);
        if (s.empty())
            s = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNoexceptOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNoexceptOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNoexceptOp(i);
        if (retval.empty()) {
            retval = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNoexceptOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNoexceptOp() {
        return stringify::E_SgNoexceptOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1314
namespace stringify {
    const char* E_SgNonrealSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealSymbol(i);
        if (s.empty())
            s = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealSymbol() {
        return stringify::E_SgNonrealSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1317
namespace stringify {
    const char* E_SgTemplateMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionSymbol() {
        return stringify::E_SgTemplateMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1320
namespace stringify {
    const char* E_SgMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionSymbol() {
        return stringify::E_SgMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1323
namespace stringify {
    const char* E_SgTemplateFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionSymbol() {
        return stringify::E_SgTemplateFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1326
namespace stringify {
    const char* E_SgRenameSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgRenameSymbol_declaration";
            case 1L: return "SgRenameSymbol_original_symbol";
            default: return "";
        }
    }

    std::string E_SgRenameSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgRenameSymbol(i);
        if (s.empty())
            s = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRenameSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRenameSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRenameSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRenameSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRenameSymbol() {
        return stringify::E_SgRenameSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1329
namespace stringify {
    const char* E_SgFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionSymbol() {
        return stringify::E_SgFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1332
namespace stringify {
    const char* E_SgTemplateClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassSymbol() {
        return stringify::E_SgTemplateClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1335
namespace stringify {
    const char* E_SgClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgClassSymbol(i);
        if (s.empty())
            s = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassSymbol() {
        return stringify::E_SgClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1338
namespace stringify {
    const char* E_SgTemplateSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateSymbol() {
        return stringify::E_SgTemplateSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1341
namespace stringify {
    const char* E_SgEnumSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumSymbol(i);
        if (s.empty())
            s = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumSymbol() {
        return stringify::E_SgEnumSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1344
namespace stringify {
    const char* E_SgTemplateTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefSymbol() {
        return stringify::E_SgTemplateTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1347
namespace stringify {
    const char* E_SgTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefSymbol() {
        return stringify::E_SgTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1350
namespace stringify {
    const char* E_SgLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelSymbol(i);
        if (s.empty())
            s = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelSymbol() {
        return stringify::E_SgLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1353
namespace stringify {
    const char* E_SgNamespaceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceSymbol_declaration";
            case 1L: return "SgNamespaceSymbol_aliasDeclaration";
            default: return "";
        }
    }

    std::string E_SgNamespaceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceSymbol(i);
        if (s.empty())
            s = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceSymbol() {
        return stringify::E_SgNamespaceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1356
namespace stringify {
    const char* E_SgModuleSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgModuleSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleSymbol(i);
        if (s.empty())
            s = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleSymbol() {
        return stringify::E_SgModuleSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1359
namespace stringify {
    const char* E_SgAliasSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAliasSymbol_alias";
            default: return "";
        }
    }

    std::string E_SgAliasSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAliasSymbol(i);
        if (s.empty())
            s = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAliasSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAliasSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAliasSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAliasSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAliasSymbol() {
        return stringify::E_SgAliasSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1362
namespace stringify {
    const char* E_SgJavaLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelSymbol(i);
        if (s.empty())
            s = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelSymbol() {
        return stringify::E_SgJavaLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1365
namespace stringify {
    const char* E_SgAsmFunction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFunction_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmFunction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFunction(i);
        if (s.empty())
            s = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFunction() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFunction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFunction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFunction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFunction() {
        return stringify::E_SgAsmFunction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1368
namespace stringify {
    const char* E_SgAsmBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBlock_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBlock(i);
        if (s.empty())
            s = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBlock() {
        return stringify::E_SgAsmBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1371
namespace stringify {
    const char* E_SgAsmX86Instruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmX86Instruction_operandList";
            case 1L: return "SgAsmX86Instruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmX86Instruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmX86Instruction(i);
        if (s.empty())
            s = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmX86Instruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmX86Instruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmX86Instruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmX86Instruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmX86Instruction() {
        return stringify::E_SgAsmX86Instruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1374
namespace stringify {
    const char* E_SgAsmArmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmArmInstruction_operandList";
            case 1L: return "SgAsmArmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmArmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmArmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmArmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmArmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmArmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmArmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmArmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmArmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmArmInstruction() {
        return stringify::E_SgAsmArmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1377
namespace stringify {
    const char* E_SgAsmPowerpcInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPowerpcInstruction_operandList";
            case 1L: return "SgAsmPowerpcInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmPowerpcInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPowerpcInstruction(i);
        if (s.empty())
            s = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPowerpcInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPowerpcInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPowerpcInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPowerpcInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPowerpcInstruction() {
        return stringify::E_SgAsmPowerpcInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1380
namespace stringify {
    const char* E_SgAsmMipsInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMipsInstruction_operandList";
            case 1L: return "SgAsmMipsInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmMipsInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMipsInstruction(i);
        if (s.empty())
            s = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMipsInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMipsInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMipsInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMipsInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMipsInstruction() {
        return stringify::E_SgAsmMipsInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1383
namespace stringify {
    const char* E_SgAsmM68kInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmM68kInstruction_operandList";
            case 1L: return "SgAsmM68kInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmM68kInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmM68kInstruction(i);
        if (s.empty())
            s = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmM68kInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmM68kInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmM68kInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmM68kInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmM68kInstruction() {
        return stringify::E_SgAsmM68kInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1386
namespace stringify {
    const char* E_SgAsmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInstruction_operandList";
            case 1L: return "SgAsmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInstruction() {
        return stringify::E_SgAsmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1389
namespace stringify {
    const char* E_SgAsmIntegerValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmIntegerValueExpression_unfolded_expression_tree";
            default: return "";
        }
    }

    std::string E_SgAsmIntegerValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmIntegerValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmIntegerValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmIntegerValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmIntegerValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmIntegerValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmIntegerValueExpression() {
        return stringify::E_SgAsmIntegerValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1392
namespace stringify {
    const char* E_SgAsmFloatValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFloatValueExpression_unfolded_expression_tree";
            default: return "";
        }
    }

    std::string E_SgAsmFloatValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFloatValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFloatValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFloatValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFloatValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFloatValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFloatValueExpression() {
        return stringify::E_SgAsmFloatValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1395
namespace stringify {
    const char* E_SgAsmConstantExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmConstantExpression_unfolded_expression_tree";
            default: return "";
        }
    }

    std::string E_SgAsmConstantExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmConstantExpression(i);
        if (s.empty())
            s = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmConstantExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmConstantExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmConstantExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmConstantExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmConstantExpression() {
        return stringify::E_SgAsmConstantExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1398
namespace stringify {
    const char* E_SgAsmValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmValueExpression_unfolded_expression_tree";
            default: return "";
        }
    }

    std::string E_SgAsmValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmValueExpression() {
        return stringify::E_SgAsmValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1401
namespace stringify {
    const char* E_SgAsmBinaryAdd(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAdd_lhs";
            case 1L: return "SgAsmBinaryAdd_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAdd(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAdd(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAdd() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAdd(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAdd(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAdd::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAdd() {
        return stringify::E_SgAsmBinaryAdd();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1404
namespace stringify {
    const char* E_SgAsmBinarySubtract(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinarySubtract_lhs";
            case 1L: return "SgAsmBinarySubtract_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinarySubtract(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinarySubtract(i);
        if (s.empty())
            s = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinarySubtract() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinarySubtract(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinarySubtract(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinarySubtract::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinarySubtract() {
        return stringify::E_SgAsmBinarySubtract();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1407
namespace stringify {
    const char* E_SgAsmBinaryMultiply(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMultiply_lhs";
            case 1L: return "SgAsmBinaryMultiply_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMultiply(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMultiply(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMultiply() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMultiply(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMultiply(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMultiply::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMultiply() {
        return stringify::E_SgAsmBinaryMultiply();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1410
namespace stringify {
    const char* E_SgAsmBinaryDivide(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryDivide_lhs";
            case 1L: return "SgAsmBinaryDivide_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryDivide(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryDivide(i);
        if (s.empty())
            s = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryDivide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryDivide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryDivide(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryDivide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryDivide() {
        return stringify::E_SgAsmBinaryDivide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1413
namespace stringify {
    const char* E_SgAsmBinaryMod(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMod_lhs";
            case 1L: return "SgAsmBinaryMod_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMod(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMod(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMod() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMod(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMod(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMod::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMod() {
        return stringify::E_SgAsmBinaryMod();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1416
namespace stringify {
    const char* E_SgAsmBinaryAddPreupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAddPreupdate_lhs";
            case 1L: return "SgAsmBinaryAddPreupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAddPreupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAddPreupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAddPreupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAddPreupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAddPreupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAddPreupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAddPreupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAddPreupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAddPreupdate() {
        return stringify::E_SgAsmBinaryAddPreupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1419
namespace stringify {
    const char* E_SgAsmBinarySubtractPreupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinarySubtractPreupdate_lhs";
            case 1L: return "SgAsmBinarySubtractPreupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinarySubtractPreupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinarySubtractPreupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinarySubtractPreupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinarySubtractPreupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinarySubtractPreupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinarySubtractPreupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinarySubtractPreupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinarySubtractPreupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinarySubtractPreupdate() {
        return stringify::E_SgAsmBinarySubtractPreupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1422
namespace stringify {
    const char* E_SgAsmBinaryAddPostupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAddPostupdate_lhs";
            case 1L: return "SgAsmBinaryAddPostupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAddPostupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAddPostupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAddPostupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAddPostupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAddPostupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAddPostupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAddPostupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAddPostupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAddPostupdate() {
        return stringify::E_SgAsmBinaryAddPostupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1425
namespace stringify {
    const char* E_SgAsmBinarySubtractPostupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinarySubtractPostupdate_lhs";
            case 1L: return "SgAsmBinarySubtractPostupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinarySubtractPostupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinarySubtractPostupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinarySubtractPostupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinarySubtractPostupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinarySubtractPostupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinarySubtractPostupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinarySubtractPostupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinarySubtractPostupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinarySubtractPostupdate() {
        return stringify::E_SgAsmBinarySubtractPostupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1428
namespace stringify {
    const char* E_SgAsmBinaryLsl(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsl_lhs";
            case 1L: return "SgAsmBinaryLsl_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsl(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsl(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsl(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsl() {
        return stringify::E_SgAsmBinaryLsl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1431
namespace stringify {
    const char* E_SgAsmBinaryLsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsr_lhs";
            case 1L: return "SgAsmBinaryLsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsr() {
        return stringify::E_SgAsmBinaryLsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1434
namespace stringify {
    const char* E_SgAsmBinaryAsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAsr_lhs";
            case 1L: return "SgAsmBinaryAsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAsr() {
        return stringify::E_SgAsmBinaryAsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1437
namespace stringify {
    const char* E_SgAsmBinaryRor(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryRor_lhs";
            case 1L: return "SgAsmBinaryRor_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryRor(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryRor(i);
        if (s.empty())
            s = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryRor() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryRor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryRor(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryRor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryRor() {
        return stringify::E_SgAsmBinaryRor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1440
namespace stringify {
    const char* E_SgAsmBinaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryExpression_lhs";
            case 1L: return "SgAsmBinaryExpression_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryExpression() {
        return stringify::E_SgAsmBinaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1443
namespace stringify {
    const char* E_SgAsmUnaryPlus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryPlus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryPlus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryPlus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryPlus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryPlus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryPlus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryPlus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryPlus() {
        return stringify::E_SgAsmUnaryPlus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1446
namespace stringify {
    const char* E_SgAsmUnaryMinus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryMinus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryMinus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryMinus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryMinus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryMinus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryMinus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryMinus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryMinus() {
        return stringify::E_SgAsmUnaryMinus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1449
namespace stringify {
    const char* E_SgAsmUnaryRrx(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryRrx_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryRrx(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryRrx(i);
        if (s.empty())
            s = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryRrx() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryRrx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryRrx(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryRrx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryRrx() {
        return stringify::E_SgAsmUnaryRrx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1452
namespace stringify {
    const char* E_SgAsmUnaryArmSpecialRegisterList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryArmSpecialRegisterList_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryArmSpecialRegisterList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryArmSpecialRegisterList(i);
        if (s.empty())
            s = "(E_SgAsmUnaryArmSpecialRegisterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryArmSpecialRegisterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryArmSpecialRegisterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryArmSpecialRegisterList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryArmSpecialRegisterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryArmSpecialRegisterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryArmSpecialRegisterList() {
        return stringify::E_SgAsmUnaryArmSpecialRegisterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1455
namespace stringify {
    const char* E_SgAsmUnaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryExpression_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryExpression() {
        return stringify::E_SgAsmUnaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1458
namespace stringify {
    const char* E_SgAsmMemoryReferenceExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMemoryReferenceExpression_address";
            case 1L: return "SgAsmMemoryReferenceExpression_segment";
            default: return "";
        }
    }

    std::string E_SgAsmMemoryReferenceExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMemoryReferenceExpression(i);
        if (s.empty())
            s = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMemoryReferenceExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMemoryReferenceExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMemoryReferenceExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMemoryReferenceExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMemoryReferenceExpression() {
        return stringify::E_SgAsmMemoryReferenceExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1461
namespace stringify {
    const char* E_SgAsmCommonSubExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCommonSubExpression_subexpression";
            default: return "";
        }
    }

    std::string E_SgAsmCommonSubExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCommonSubExpression(i);
        if (s.empty())
            s = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCommonSubExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCommonSubExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCommonSubExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCommonSubExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCommonSubExpression() {
        return stringify::E_SgAsmCommonSubExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1464
namespace stringify {
    const char* E_SgAsmExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgAsmExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmExprListExp(i);
        if (s.empty())
            s = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmExprListExp() {
        return stringify::E_SgAsmExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1467
namespace stringify {
    const char* E_SgAsmRegisterNames(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRegisterNames_registers";
            default: return "";
        }
    }

    std::string E_SgAsmRegisterNames(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRegisterNames(i);
        if (s.empty())
            s = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRegisterNames() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRegisterNames(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRegisterNames(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRegisterNames::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRegisterNames() {
        return stringify::E_SgAsmRegisterNames();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1470
namespace stringify {
    const char* E_SgAsmRiscOperation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRiscOperation_operands";
            default: return "";
        }
    }

    std::string E_SgAsmRiscOperation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRiscOperation(i);
        if (s.empty())
            s = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRiscOperation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRiscOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRiscOperation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRiscOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRiscOperation() {
        return stringify::E_SgAsmRiscOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1473
namespace stringify {
    const char* E_SgAsmInterpretation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretation_global_block";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretation(i);
        if (s.empty())
            s = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretation() {
        return stringify::E_SgAsmInterpretation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1476
namespace stringify {
    const char* E_SgAsmOperandList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOperandList_operands";
            default: return "";
        }
    }

    std::string E_SgAsmOperandList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOperandList(i);
        if (s.empty())
            s = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOperandList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOperandList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOperandList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOperandList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOperandList() {
        return stringify::E_SgAsmOperandList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1479
namespace stringify {
    const char* E_SgAsmGenericDLL(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericDLL_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericDLL(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericDLL(i);
        if (s.empty())
            s = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericDLL() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericDLL(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericDLL(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericDLL::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericDLL() {
        return stringify::E_SgAsmGenericDLL();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1482
namespace stringify {
    const char* E_SgAsmGenericFile(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFile_dwarf_info";
            case 1L: return "SgAsmGenericFile_headers";
            case 2L: return "SgAsmGenericFile_holes";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFile(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFile(i);
        if (s.empty())
            s = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFile(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFile() {
        return stringify::E_SgAsmGenericFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1485
namespace stringify {
    const char* E_SgAsmPEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEFileHeader_exec_format";
            case 1L: return "SgAsmPEFileHeader_dlls";
            case 2L: return "SgAsmPEFileHeader_sections";
            case 3L: return "SgAsmPEFileHeader_rvasize_pairs";
            default: return "";
        }
    }

    std::string E_SgAsmPEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEFileHeader() {
        return stringify::E_SgAsmPEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1488
namespace stringify {
    const char* E_SgAsmLEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEFileHeader_exec_format";
            case 1L: return "SgAsmLEFileHeader_dlls";
            case 2L: return "SgAsmLEFileHeader_sections";
            case 3L: return "SgAsmLEFileHeader_dos2_header";
            case 4L: return "SgAsmLEFileHeader_page_table";
            case 5L: return "SgAsmLEFileHeader_resname_table";
            case 6L: return "SgAsmLEFileHeader_nonresname_table";
            case 7L: return "SgAsmLEFileHeader_entry_table";
            case 8L: return "SgAsmLEFileHeader_reloc_table";
            default: return "";
        }
    }

    std::string E_SgAsmLEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEFileHeader() {
        return stringify::E_SgAsmLEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1491
namespace stringify {
    const char* E_SgAsmNEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEFileHeader_exec_format";
            case 1L: return "SgAsmNEFileHeader_dlls";
            case 2L: return "SgAsmNEFileHeader_sections";
            case 3L: return "SgAsmNEFileHeader_dos2_header";
            case 4L: return "SgAsmNEFileHeader_resname_table";
            case 5L: return "SgAsmNEFileHeader_nonresname_table";
            case 6L: return "SgAsmNEFileHeader_module_table";
            case 7L: return "SgAsmNEFileHeader_entry_table";
            default: return "";
        }
    }

    std::string E_SgAsmNEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEFileHeader() {
        return stringify::E_SgAsmNEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1494
namespace stringify {
    const char* E_SgAsmDOSFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDOSFileHeader_exec_format";
            case 1L: return "SgAsmDOSFileHeader_dlls";
            case 2L: return "SgAsmDOSFileHeader_sections";
            case 3L: return "SgAsmDOSFileHeader_relocs";
            default: return "";
        }
    }

    std::string E_SgAsmDOSFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDOSFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDOSFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDOSFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDOSFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDOSFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDOSFileHeader() {
        return stringify::E_SgAsmDOSFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1497
namespace stringify {
    const char* E_SgAsmElfFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfFileHeader_exec_format";
            case 1L: return "SgAsmElfFileHeader_dlls";
            case 2L: return "SgAsmElfFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmElfFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfFileHeader() {
        return stringify::E_SgAsmElfFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1500
namespace stringify {
    const char* E_SgAsmGenericHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeader_exec_format";
            case 1L: return "SgAsmGenericHeader_dlls";
            case 2L: return "SgAsmGenericHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeader(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeader() {
        return stringify::E_SgAsmGenericHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1503
namespace stringify {
    const char* E_SgAsmElfSymbolSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolSection_section_entry";
            case 1L: return "SgAsmElfSymbolSection_segment_entry";
            case 2L: return "SgAsmElfSymbolSection_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolSection() {
        return stringify::E_SgAsmElfSymbolSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1506
namespace stringify {
    const char* E_SgAsmElfRelocSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocSection_section_entry";
            case 1L: return "SgAsmElfRelocSection_segment_entry";
            case 2L: return "SgAsmElfRelocSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocSection(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocSection() {
        return stringify::E_SgAsmElfRelocSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1509
namespace stringify {
    const char* E_SgAsmElfDynamicSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicSection_section_entry";
            case 1L: return "SgAsmElfDynamicSection_segment_entry";
            case 2L: return "SgAsmElfDynamicSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicSection(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicSection() {
        return stringify::E_SgAsmElfDynamicSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1512
namespace stringify {
    const char* E_SgAsmElfStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfStringSection_section_entry";
            case 1L: return "SgAsmElfStringSection_segment_entry";
            default: return "";
        }
    }

    std::string E_SgAsmElfStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfStringSection(i);
        if (s.empty())
            s = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfStringSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfStringSection() {
        return stringify::E_SgAsmElfStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1515
namespace stringify {
    const char* E_SgAsmElfNoteSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteSection_section_entry";
            case 1L: return "SgAsmElfNoteSection_segment_entry";
            case 2L: return "SgAsmElfNoteSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteSection(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteSection() {
        return stringify::E_SgAsmElfNoteSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1518
namespace stringify {
    const char* E_SgAsmElfEHFrameSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameSection_section_entry";
            case 1L: return "SgAsmElfEHFrameSection_segment_entry";
            case 2L: return "SgAsmElfEHFrameSection_ci_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameSection(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameSection() {
        return stringify::E_SgAsmElfEHFrameSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1521
namespace stringify {
    const char* E_SgAsmElfSymverSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverSection_section_entry";
            case 1L: return "SgAsmElfSymverSection_segment_entry";
            case 2L: return "SgAsmElfSymverSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverSection() {
        return stringify::E_SgAsmElfSymverSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1524
namespace stringify {
    const char* E_SgAsmElfSymverDefinedSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedSection_section_entry";
            case 1L: return "SgAsmElfSymverDefinedSection_segment_entry";
            case 2L: return "SgAsmElfSymverDefinedSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedSection() {
        return stringify::E_SgAsmElfSymverDefinedSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1527
namespace stringify {
    const char* E_SgAsmElfSymverNeededSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededSection_section_entry";
            case 1L: return "SgAsmElfSymverNeededSection_segment_entry";
            case 2L: return "SgAsmElfSymverNeededSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededSection() {
        return stringify::E_SgAsmElfSymverNeededSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1530
namespace stringify {
    const char* E_SgAsmElfSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSection_section_entry";
            case 1L: return "SgAsmElfSection_segment_entry";
            default: return "";
        }
    }

    std::string E_SgAsmElfSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSection() {
        return stringify::E_SgAsmElfSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1533
namespace stringify {
    const char* E_SgAsmPEImportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportSection_section_entry";
            case 1L: return "SgAsmPEImportSection_import_directories";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportSection() {
        return stringify::E_SgAsmPEImportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1536
namespace stringify {
    const char* E_SgAsmPEExportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportSection_section_entry";
            case 1L: return "SgAsmPEExportSection_export_dir";
            case 2L: return "SgAsmPEExportSection_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportSection() {
        return stringify::E_SgAsmPEExportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1539
namespace stringify {
    const char* E_SgAsmPEStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEStringSection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPEStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEStringSection(i);
        if (s.empty())
            s = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEStringSection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEStringSection() {
        return stringify::E_SgAsmPEStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1542
namespace stringify {
    const char* E_SgAsmPESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPESection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPESection(i);
        if (s.empty())
            s = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPESection() {
        return stringify::E_SgAsmPESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1545
namespace stringify {
    const char* E_SgAsmCoffSymbolTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolTable_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolTable(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolTable() {
        return stringify::E_SgAsmCoffSymbolTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1548
namespace stringify {
    const char* E_SgAsmNESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNESection_st_entry";
            case 1L: return "SgAsmNESection_reloc_table";
            default: return "";
        }
    }

    std::string E_SgAsmNESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNESection(i);
        if (s.empty())
            s = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNESection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNESection() {
        return stringify::E_SgAsmNESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1551
namespace stringify {
    const char* E_SgAsmNEModuleTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEModuleTable_strtab";
            default: return "";
        }
    }

    std::string E_SgAsmNEModuleTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEModuleTable(i);
        if (s.empty())
            s = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEModuleTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEModuleTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEModuleTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEModuleTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEModuleTable() {
        return stringify::E_SgAsmNEModuleTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1554
namespace stringify {
    const char* E_SgAsmNEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEEntryTable() {
        return stringify::E_SgAsmNEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1557
namespace stringify {
    const char* E_SgAsmNERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNERelocTable() {
        return stringify::E_SgAsmNERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1560
namespace stringify {
    const char* E_SgAsmLESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLESection_st_entry";
            default: return "";
        }
    }

    std::string E_SgAsmLESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLESection(i);
        if (s.empty())
            s = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLESection() {
        return stringify::E_SgAsmLESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1563
namespace stringify {
    const char* E_SgAsmLEPageTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEPageTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEPageTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEPageTable(i);
        if (s.empty())
            s = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEPageTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEPageTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEPageTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEPageTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEPageTable() {
        return stringify::E_SgAsmLEPageTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1566
namespace stringify {
    const char* E_SgAsmLEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryTable() {
        return stringify::E_SgAsmLEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1569
namespace stringify {
    const char* E_SgAsmLERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLERelocTable() {
        return stringify::E_SgAsmLERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1572
namespace stringify {
    const char* E_SgAsmCoffSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbol(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbol() {
        return stringify::E_SgAsmCoffSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1575
namespace stringify {
    const char* E_SgAsmElfSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbol(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbol() {
        return stringify::E_SgAsmElfSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1578
namespace stringify {
    const char* E_SgAsmGenericSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSymbol(i);
        if (s.empty())
            s = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSymbol() {
        return stringify::E_SgAsmGenericSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1581
namespace stringify {
    const char* E_SgAsmGenericSectionList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSectionList_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSectionList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSectionList(i);
        if (s.empty())
            s = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSectionList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSectionList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSectionList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSectionList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSectionList() {
        return stringify::E_SgAsmGenericSectionList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1584
namespace stringify {
    const char* E_SgAsmGenericHeaderList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeaderList_headers";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeaderList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeaderList(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeaderList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeaderList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeaderList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeaderList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeaderList() {
        return stringify::E_SgAsmGenericHeaderList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1587
namespace stringify {
    const char* E_SgAsmElfSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolList() {
        return stringify::E_SgAsmElfSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1590
namespace stringify {
    const char* E_SgAsmElfRelocEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocEntryList() {
        return stringify::E_SgAsmElfRelocEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1593
namespace stringify {
    const char* E_SgAsmPEExportEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntry_name";
            case 1L: return "SgAsmPEExportEntry_forwarder";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntry(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntry() {
        return stringify::E_SgAsmPEExportEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1596
namespace stringify {
    const char* E_SgAsmPEExportEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntryList_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntryList(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntryList() {
        return stringify::E_SgAsmPEExportEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1599
namespace stringify {
    const char* E_SgAsmElfDynamicEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicEntry() {
        return stringify::E_SgAsmElfDynamicEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1602
namespace stringify {
    const char* E_SgAsmElfSegmentTableEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSegmentTableEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSegmentTableEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSegmentTableEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSegmentTableEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSegmentTableEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSegmentTableEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSegmentTableEntryList() {
        return stringify::E_SgAsmElfSegmentTableEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1605
namespace stringify {
    const char* E_SgAsmElfNoteEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteEntry() {
        return stringify::E_SgAsmElfNoteEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1608
namespace stringify {
    const char* E_SgAsmElfSymverEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverEntryList() {
        return stringify::E_SgAsmElfSymverEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1611
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntry() {
        return stringify::E_SgAsmElfSymverDefinedEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1614
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntryList() {
        return stringify::E_SgAsmElfSymverDefinedEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1617
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAux() {
        return stringify::E_SgAsmElfSymverDefinedAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1620
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAuxList() {
        return stringify::E_SgAsmElfSymverDefinedAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1623
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntry_file_name";
            case 1L: return "SgAsmElfSymverNeededEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntry() {
        return stringify::E_SgAsmElfSymverNeededEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1626
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntryList() {
        return stringify::E_SgAsmElfSymverNeededEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1629
namespace stringify {
    const char* E_SgAsmElfSymverNeededAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAux() {
        return stringify::E_SgAsmElfSymverNeededAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1632
namespace stringify {
    const char* E_SgAsmElfSymverNeededAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAuxList() {
        return stringify::E_SgAsmElfSymverNeededAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1635
namespace stringify {
    const char* E_SgAsmPEImportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectory_dll_name";
            case 1L: return "SgAsmPEImportDirectory_imports";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectory() {
        return stringify::E_SgAsmPEImportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1638
namespace stringify {
    const char* E_SgAsmPEExportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportDirectory_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportDirectory() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportDirectory() {
        return stringify::E_SgAsmPEExportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1641
namespace stringify {
    const char* E_SgAsmCoffSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolList() {
        return stringify::E_SgAsmCoffSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1644
namespace stringify {
    const char* E_SgAsmPERVASizePairList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPERVASizePairList_pairs";
            default: return "";
        }
    }

    std::string E_SgAsmPERVASizePairList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPERVASizePairList(i);
        if (s.empty())
            s = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPERVASizePairList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPERVASizePairList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPERVASizePairList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPERVASizePairList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPERVASizePairList() {
        return stringify::E_SgAsmPERVASizePairList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1647
namespace stringify {
    const char* E_SgAsmElfEHFrameEntryCI(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameEntryCI_fd_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameEntryCI(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameEntryCI(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameEntryCI() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameEntryCI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameEntryCI(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameEntryCI() {
        return stringify::E_SgAsmElfEHFrameEntryCI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1650
namespace stringify {
    const char* E_SgAsmPEImportDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectoryList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectoryList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectoryList() {
        return stringify::E_SgAsmPEImportDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1653
namespace stringify {
    const char* E_SgAsmLEEntryPoint(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryPoint_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryPoint(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryPoint(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryPoint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryPoint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryPoint(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryPoint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryPoint() {
        return stringify::E_SgAsmLEEntryPoint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1656
namespace stringify {
    const char* E_SgAsmDwarfMacroList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfMacroList_macro_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfMacroList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfMacroList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfMacroList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfMacroList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfMacroList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfMacroList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfMacroList() {
        return stringify::E_SgAsmDwarfMacroList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1659
namespace stringify {
    const char* E_SgAsmDwarfLineList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLineList_line_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLineList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLineList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLineList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLineList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLineList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLineList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLineList() {
        return stringify::E_SgAsmDwarfLineList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1662
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnitList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnitList_cu_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnitList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnitList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnitList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnitList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnitList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnitList() {
        return stringify::E_SgAsmDwarfCompilationUnitList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1665
namespace stringify {
    const char* E_SgAsmDwarfArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfArrayType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfArrayType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfArrayType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfArrayType() {
        return stringify::E_SgAsmDwarfArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1668
namespace stringify {
    const char* E_SgAsmDwarfClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfClassType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfClassType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfClassType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfClassType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfClassType() {
        return stringify::E_SgAsmDwarfClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1671
namespace stringify {
    const char* E_SgAsmDwarfEnumerationType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfEnumerationType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfEnumerationType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfEnumerationType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfEnumerationType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfEnumerationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfEnumerationType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfEnumerationType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfEnumerationType() {
        return stringify::E_SgAsmDwarfEnumerationType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1674
namespace stringify {
    const char* E_SgAsmDwarfLexicalBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLexicalBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLexicalBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLexicalBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLexicalBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLexicalBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLexicalBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLexicalBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLexicalBlock() {
        return stringify::E_SgAsmDwarfLexicalBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1677
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnit(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnit_line_info";
            case 1L: return "SgAsmDwarfCompilationUnit_language_constructs";
            case 2L: return "SgAsmDwarfCompilationUnit_macro_info";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnit(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnit(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnit() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnit(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnit(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnit::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnit() {
        return stringify::E_SgAsmDwarfCompilationUnit();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1680
namespace stringify {
    const char* E_SgAsmDwarfStructureType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfStructureType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfStructureType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfStructureType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfStructureType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfStructureType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfStructureType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfStructureType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfStructureType() {
        return stringify::E_SgAsmDwarfStructureType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1683
namespace stringify {
    const char* E_SgAsmDwarfSubroutineType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubroutineType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubroutineType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubroutineType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubroutineType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubroutineType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubroutineType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubroutineType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubroutineType() {
        return stringify::E_SgAsmDwarfSubroutineType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1686
namespace stringify {
    const char* E_SgAsmDwarfUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfUnionType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfUnionType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfUnionType() {
        return stringify::E_SgAsmDwarfUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1689
namespace stringify {
    const char* E_SgAsmDwarfCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCommonBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCommonBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCommonBlock() {
        return stringify::E_SgAsmDwarfCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1692
namespace stringify {
    const char* E_SgAsmDwarfInlinedSubroutine(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfInlinedSubroutine_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfInlinedSubroutine(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfInlinedSubroutine(i);
        if (s.empty())
            s = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfInlinedSubroutine() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfInlinedSubroutine(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfInlinedSubroutine(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfInlinedSubroutine() {
        return stringify::E_SgAsmDwarfInlinedSubroutine();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1695
namespace stringify {
    const char* E_SgAsmDwarfSubprogram(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubprogram_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubprogram(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubprogram(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubprogram() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubprogram(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubprogram(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubprogram::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubprogram() {
        return stringify::E_SgAsmDwarfSubprogram();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1698
namespace stringify {
    const char* E_SgAsmDwarfNamespace(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfNamespace_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfNamespace(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfNamespace(i);
        if (s.empty())
            s = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfNamespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfNamespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfNamespace(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfNamespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfNamespace() {
        return stringify::E_SgAsmDwarfNamespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1701
namespace stringify {
    const char* E_SgAsmDwarfConstructList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfConstructList_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfConstructList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfConstructList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfConstructList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfConstructList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfConstructList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfConstructList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfConstructList() {
        return stringify::E_SgAsmDwarfConstructList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1704
namespace stringify {
    const char* E_SgAsmPEImportItem(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItem_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItem(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItem(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItem() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItem(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItem() {
        return stringify::E_SgAsmPEImportItem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1707
namespace stringify {
    const char* E_SgAsmPEImportItemList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItemList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItemList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItemList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItemList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItemList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItemList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItemList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItemList() {
        return stringify::E_SgAsmPEImportItemList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1710
namespace stringify {
    const char* E_SgAsmInterpretationList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretationList_interpretations";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretationList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretationList(i);
        if (s.empty())
            s = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretationList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretationList() {
        return stringify::E_SgAsmInterpretationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1713
namespace stringify {
    const char* E_SgAsmGenericFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFileList_files";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFileList(i);
        if (s.empty())
            s = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFileList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFileList() {
        return stringify::E_SgAsmGenericFileList();
    }
}

