module Main                           %% Jovial grammar

imports JovialLex

exports 

context-free start-symbols 
  Module

sorts
  
%%CompleteProgram
% 1.1    %  Module
% 1.2.1  %  CompoolModule CompoolName
% 1.2.2  %  ProcedureModule NonNestedSubroutine
% 1.2.3  %  MainProgramModule ProgramName ProgramBody

% 2.0    %  Declaration CompoolDeclaration
            DeclarationList NonNestedSubroutineList CompoolDeclarationList
% 2.1    %  DataDeclaration

% 3.0    %  SubroutineDeclaration SubroutineDefinition

% 4.0    %  Statement SimpleStatement NullStatement Label StatementName LabeledCompoundStatement
            LabeledSimpleStatement LabelList

InterferenceControl
TraceControl
OptTraceControl
OptLetter
CompoolFileName
CompoolDeclaredName
OptCompoolFileName
CompoolDirectiveList
OrderDirective
InitializeDirective
RearrangeDirective
LeftrightDirective
DropDirective
IsbaseDirective
BaseDirective
ListbothDirective
ListexpDirective
ListinvDirective
EjectDirective
ListDirective
NolistDirective
ReducibleDirective
InterferenceDirective
TraceDirective
LinkageDirective
EndDirective
BeginDirective
SkipDirective
CopyDirective
Directive
CompoolDirective
OptNumber
OptExponent
FractionalForm
Exponent
RealLiteral
Number
NumericLiteral
LogicalOperator
AssignmentOperator
DereferenceOperator
BitOperator
ArithmeticOperator
%%Comment %%Moved to JovialLex.sdf
Literal
Operator
Symbol
BitTypeConversion
NentArgument
StatusInverseArgument
NwdsenArgument
DimensionNumber
BoundsArgument
WhichBound
SizeArgument
SizeType
ShiftCount
ShiftDirection
Nbyte
Fbyte
IncrementAmount
NextArgument
LocArgument
NentFunction
StatusInverseFunction
NwdsenFunction
BoundsFunction
SizeFunction
SignFunction
AbsFunction
ShiftFunction
ByteFunction
BitFunction
NextFunction
MachineSpecificFunctionCall
IntrinsicFunctionCall
UserDefinedFunctionCall
ConstantTableItemName
RepConversion
Nbit
Fbit
Index
PointerItemName
Dereference
BlockDereference
OptBlockDereference
Subscript
OptTableDereference
OptSubscript
TableDereference
ItemDereference
BlockTableEntry
BlockTableItem
BlockTable
BlockItem
TableEntry
TableItem
Table
Item
RepFunctionVariable
ByteFunctionVariable
BitFunctionVariable
NamedVariable
  %% UntypedNamedVariable  %% Added to grammar to resolve ambiguity with untyped variable names
                           %% does not seem to be needed after all (remove)
TableConversion
NamedTableConstant
TableVariable
PointerConversion
%%PointerFunctionCall
%%NamedPointerConstant
%%PointerVariable
PointerLiteral
StatusConversion
%%StatusFunctionCall
%%NamedStatusConstant
%%StatusVariable
CharacterConversion
%%CharacterFunctionCall
%%NamedCharacterConstant
%%CharacterVariable
CharacterLiteral
EqualOrNotEqualOperator
RelationalOperator
EqvContinuation
XorContinuation
OrContinuation
LogicalContinuation
AndContinuation
BitConversion
BitFunctionCall
NamedBitConstant
BitVariable
BooleanLiteral
BitLiteral
RelationalExpression
BitPrimary
OptLogicalContinuation
LogicalOperand
LogicalComponent
FixedConversion
%%FixedFunctionCall
%%NamedFixedConstant
%%FixedVariable
FixedLiteral
%%FixedFactor
%%FixedTerm
FloatingConversion
%%FloatingFunctionCall
%%NamedFloatingConstant
%%FloatingVariable
FloatingLiteral
%%FloatingPrimary
MultiplyOrDivide
%%FloatingFactor
%%FloatingTerm
FunctionCall
NamedConstant
IntegerConversion
%%IntegerFunctionCall
%%NamedIntegerConstant
%%IntegerVariable
IntegerLiteral
%%IntegerPrimary
MultiplyDivideOrMod
%%IntegerFactor
Sign
PlusOrMinus
%%IntegerTerm
OptSign
%%FixedFormula
%%FloatingFormula
CompileTimePointerFormula
CompileTimeNumericFormula
TableFormula
PointerFormula
AbortPhrase
BlockReference
ActualOutputParameter
ActualParameterList
OptActualOutputParameters
ActualInputParameter
OptAbortPhrase
OptActualParameterList
MachineSpecificProcedureCall
UserDefinedProcedureCall
CompileTimeCharacterFormula
CompileTimeBitFormula
CaseIndex
DefaultOption
OptFALLTHRU
CaseIndexGroup
CaseAlternative
GeneralFormula        %% added to simplify Character, Status, and Pointer Formula and avoid ambiguities
StatusFormula
CharacterFormula
BitFormula
%%IntegerFormula OptIntegerFormula
CaseBody
CaseSelectorFormula
ElseClause
OptElseClause
ConditionalStatement
RelationalFormula     %% nonstandard
NumericFormula OptNumericFormula
NumericFunctionCall
NamedNumericConstant
NumericVariable
NumericFactor
NumericTerm
NumericPrimary
NumericMachineParameter
%%FixedOrFloatingFormula  %% added to fix ambiguity
ByFormula
ThenPhrase
ByPhrase
OptByOrThenPhrase
WhilePhrase
Continuation
OptWhilePhrase
ByOrThenPhrase
OptContinuation
InitialValue
ControlLetter
ControlVariable
ControlClause
ControlItem
BooleanFormula
ForClause
WhileClause
ControlledStatement
LoopType
Variable
Formula
VariableList
AbortStatement
StopStatement
ExitStatement
GotoStatement
ReturnStatement
ProcedureCallStatement
CaseStatement
IfStatement
LoopStatement
AssignmentStatement
SubroutineName
ParameterBinding
OutputParameterName
InputParameterName
OptParameterBinding
FormalOutputParameter
FormalParameterList
OptFormalOutputParameter
FormalInputParameter
FunctionName
FunctionBody
FunctionHeading
SubroutineBody
SubroutineAttribute
OptFormalParameterList
OptSubroutineAttribute
ProcedureName
ProcedureBody
ProcedureHeading
FunctionDefinition
ProcedureDefinition
FunctionDeclaration
ProcedureDeclaration
DataName
Spacer
OverlayElement
OverlayString
AbsoluteAddress
OverlayAddress
OverlayExpression
OptAbsoluteAddress
RefSpecificationChoice
CompoundRef
SimpleRef
DefBlockInstantiation
DefSpecificationChoice
CompoundDef
SimpleDef
RefSpecification
DefSpecification
ActualDefineParameter
NoList
DefineCall
ActualDefineParameterList
Character
FormalDefineParameterList
FormalDefineParameter
DefineString
OptFormalDefineParameterList
DefinitionPart
DefineName
LikeOption
OptLikeOption
TableTypeSpecifier
BlockTypeDeclaration
TableTypeDeclaration
ItemTypeDeclaration
OptBlockPresetList
OptTablePresetList
BlockPresetValuesOption
BlockPreset
BlockPresetList
RepetitionCount
ConstantIndex
PresetIndexSpecifier
PresetValuesOption
SpecifiedPresetSublist
OptDefaultPresetSublist
DefaultPresetSublist
TablePreset
TablePresetList
OptItemPresetValue
LocFunction
CompileTimeFormula
ItemPresetValue
AllocationSpecifier
BlockBodyOptions
OptBlockPreset
BlockBodyPart
BlockName
ConstantTableName
ItemPreset
ConstantItemName
SpecifiedTableOptions
SpecifiedTableBody
SpecifiedTableItemDeclaration
StartingWord
StartingBit
LocationSpecifier
EntrySize
OptEntrySize
SpecifiedItemDescription
WordsPerEntry
TableItemName
OrdinaryTableOptions
OrdinaryTableBody
OrdinaryTableItemDeclaration
PackingSpecifier
OptPackingSpecifier
BitsPerEntry
OptBitsPerEntry
StructureSpecifier
CompileTimeStatusFormula
LowerBoundOption
LowerBound
UpperBound
OptLowerBoundOption
DimensionList
Dimension
SpecifiedEntrySpecifier
OrdinaryEntrySpecifier
OptTablePreset
EntrySpecifier
OptStructureSpecifier
TableDescription
OptDimensionList
TableName
BlockTypeName
TableTypeName
TypeName
OptTypeName
PointerTypeName
PointerItemDescription
StatusSize
Status
StatusListIndex
StatusConstant
SpecifiedSublist
OptDefaultSublist
DefaultSublist
StatusList
OptStatusSize
StatusTypeName
StatusItemDescription
CharacterSize
OptCharacterSize
CharacterTypeName
CharacterItemDescription
BitSize
OptBitSize
BitTypeName
BitItemDescription
%%CompileTimeFixedFormula
OptFractionSpecifier
FixedTypeName
FixedItemDescription
%%CompileTimeFloatingFormula
RoundOrTruncate
FloatingTypeName
FloatingItemDescription
ItemTypeName
OptIntegerSize
OptRoundOrTruncate
IntegerTypeName
IntegerItemDescription
PointerTypeDescription
StatusTypeDescription
CharacterTypeDescription
BitTypeDescription
FixedTypeDescription
FloatingTypeDescription
IntegerTypeDescription
OptItemPreset
ItemTypeDescription
OptAllocationSpecifier
ItemName
BlockDeclaration
TableDeclaration
ItemDeclaration
ConstantDeclaration
NullDeclaration
InlineDeclaration
OverlayDeclaration
ExternalDeclaration
DefineDeclaration
StatementNameDeclaration
TypeDeclaration
FixedMachineParameter
FloatingMachineParameter
IntegerSize
FractionSpecifier
ScaleSpecifier
Precision
OptPrecision
%%CompileTimeIntegerFormula
IntegerMachineParameter

context-free syntax


%%%%%%%%%%
%% 1.1 THE COMPLETE PROGRAM
%%%%%%%%%%

%%Module+                    -> CompleteProgram       {cons("CompleteProgram")}

  CompoolModule              -> Module                {cons("Module")}
  ProcedureModule            -> Module                {cons("Module")}
  MainProgramModule          -> Module                {cons("Module")}


%%%%%%%%%%
%% 1.2 MODULES
%%%%%%%%%%

%% 1.2.1 COMPOOL MODULES
%%
  'START'
    Directive*
    'COMPOOL' CompoolName ';'
     CompoolDeclarationList
  'TERM'                     -> CompoolModule          {cons("CompoolModule")}

  Name                       -> CompoolName            {cons("Name")}

  CompoolDeclaration*        -> CompoolDeclarationList {cons("DeclarationList")} %% Using DeclarationList traversals

%% 1.2.2 PROCEDURE MODULES
%%
  'START'
    Directive*
    DeclarationList
    NonNestedSubroutineList
  'TERM'                     -> ProcedureModule       {cons("ProcedureModule")}
  
  'DEF' SubroutineDefinition -> NonNestedSubroutine   {cons("NonNestedSubroutineDEF")}
        SubroutineDefinition -> NonNestedSubroutine   {cons("NonNestedSubroutine")}

  Declaration*               -> DeclarationList          {cons("DeclarationList")}
  NonNestedSubroutine*       -> NonNestedSubroutineList  {cons("NonNestedSubroutineList")}

%% 1.2.3 MAIN PROGRAM MODULES
%%
  'START'
    Directive*
    DeclarationList
  'PROGRAM'
    ProgramName ';'
    ProgramBody
    NonNestedSubroutineList
  'TERM'                     -> MainProgramModule     {cons("MainProgramModule")}

  Name                       -> ProgramName           {cons("Name")}

  Statement                  -> ProgramBody           {cons("ProgramSimpleBody")}

  'BEGIN'
%%    Directive*             %% Might need this in the future
    DeclarationList
    Statement+
    SubroutineDefinition*
    LabelList
  'END'                      -> ProgramBody           {cons("ProgramBody"), prefer}

%% 1.4 IMPLEMENTATION PARAMETERS
%%
  'BITSINBYTE'               -> IntegerMachineParameter {cons("BITSINBYTE")}
  'BITSINWORD'               -> IntegerMachineParameter {cons("BITSINWORD")}
  'LOCSINWORD'               -> IntegerMachineParameter {cons("LOCSINWORD")}
  'BYTEPOS' '('
    CompileTimeNumericFormula
            ')'              -> IntegerMachineParameter {cons("BYTEPOS")} %% cons used to be "BitsInWord"
  'BYTESINWORD'              -> IntegerMachineParameter {cons("BYTESINWORD")}
  'BITSINPOINTER'            -> IntegerMachineParameter {cons("BITSINPOINTER")}
  'INTPRECISION'             -> IntegerMachineParameter {cons("INTPRECISION")}
  'FLOATPRECISION'           -> IntegerMachineParameter {cons("FLOATPRECISION")}
  'FIXEDPRECISION'           -> IntegerMachineParameter {cons("FIXEDPRECISION")}
  'FLOATRADIX'               -> IntegerMachineParameter {cons("FLOATRADIX")}
  'IMPLFLOATPRECISION'
    '(' Precision ')'        -> IntegerMachineParameter {cons("IMPLFLOATPRECISION")}
  'IMPLFIXEDPRECISION'
    '(' ScaleSpecifier ','
     FractionSpecifier ')'   -> IntegerMachineParameter {cons("IMPLFIXEDPRECISION")}
  'IMPLINTSIZE'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("IMPLINTSIZE")}
  'MAXFLOATPRECISION'        -> IntegerMachineParameter {cons("MAXFLOATPRECISION")}
  'MAXFIXEDPRECISION'        -> IntegerMachineParameter {cons("MAXFIXEDPRECSION")}
  'MAXINTSIZE'               -> IntegerMachineParameter {cons("MAXINTSIZE")}
  'MAXBYTES'                 -> IntegerMachineParameter {cons("MAXBYTES")}
  'MAXBITS'                  -> IntegerMachineParameter {cons("MAXBITS")}
  'MAXINT'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("MAXINT")}
  'MININT'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("MININT")}
  'MAXTABLESIZE'             -> IntegerMachineParameter {cons("MAXTABLESIZE")}
  'MAXSTOP'                  -> IntegerMachineParameter {cons("MAXSTOP")}
  'MINSTOP'                  -> IntegerMachineParameter {cons("MINSTOP")}
  'MAXSIGNDIGITS'            -> IntegerMachineParameter {cons("MAXSIGNDIGITS")}
  'MINSIZE'
    '('
        CompileTimeNumericFormula
    ')'                      -> IntegerMachineParameter {cons("MINSIZE")}
  'MINFRACTION'
    '('
        CompileTimeNumericFormula
    ')'                      -> IntegerMachineParameter {cons("MINFRACTION")}
  'MINSCALE'
    '('
        CompileTimeNumericFormula
     ')'                     -> IntegerMachineParameter {cons("MINSCALE")}
  'MINRELPRECISION'
     '('
    CompileTimeNumericFormula
     ')'                     -> IntegerMachineParameter {cons("MINRELPRECISION")}

  'MAXFLOAT'
     '(' Precision ')'       -> FloatingMachineParameter {cons("MAXFLOAT")}
  'MINFLOAT'
     '(' Precision ')'       -> FloatingMachineParameter {cons("MINFLOAT")}
  'FLOATRELPRECISION'
     '(' Precision ')'       -> FloatingMachineParameter {cons("FLOATRELPRECISION")}
  'FLOATUNDERFLOW'
     '(' Precision ')'       -> FloatingMachineParameter {cons("FLOATUNDERFLOW")}

  'MAXFIXED'
     '('
    ScaleSpecifier ','
    FractionSpecifier
     ')'                     -> FixedMachineParameter    {cons("MAXFIXED")}

  'MINFIXED'
     '('
    ScaleSpecifier ','
    FractionSpecifier
     ')'                     -> FixedMachineParameter    {cons("MINFIXED")}


%%%%%%%%%%
%% 2.0 DECLARATIONS
%%%%%%%%%%

  DataDeclaration            -> Declaration
  TypeDeclaration            -> Declaration
  SubroutineDeclaration      -> Declaration           {reject} %% AMBIGUOUS with NonNestedSubroutine
  StatementNameDeclaration   -> Declaration
  DefineDeclaration          -> Declaration
  ExternalDeclaration        -> Declaration
  OverlayDeclaration         -> Declaration
  InlineDeclaration          -> Declaration
  NullDeclaration            -> Declaration
  'BEGIN'
    Declaration+
  'END'                      -> Declaration           {cons("Declaration")}

  ExternalDeclaration        -> CompoolDeclaration
  ConstantDeclaration        -> CompoolDeclaration
  TypeDeclaration            -> CompoolDeclaration
  DefineDeclaration          -> CompoolDeclaration
  OverlayDeclaration         -> CompoolDeclaration
  NullDeclaration            -> CompoolDeclaration
  'BEGIN'
    CompoolDeclaration+
  'END'                      -> CompoolDeclaration    {cons("Declaration")} %% Using Declaration traversals


%% 2.1 DATA DECLARATIONS
%%

  ItemDeclaration             -> DataDeclaration
  TableDeclaration            -> DataDeclaration
  ConstantDeclaration         -> DataDeclaration
  BlockDeclaration            -> DataDeclaration

%% 2.1.1 ITEM DECLARATIONS
%%

  'ITEM' ItemName
    OptAllocationSpecifier
    ItemTypeDescription
    OptItemPreset         ';' -> ItemDeclaration         {cons("ItemDeclaration")}

  Name                        -> ItemName

  IntegerTypeDescription      -> ItemTypeDescription
  FloatingTypeDescription     -> ItemTypeDescription
  FixedTypeDescription        -> ItemTypeDescription
  BitTypeDescription          -> ItemTypeDescription
  CharacterTypeDescription    -> ItemTypeDescription
  StatusTypeDescription       -> ItemTypeDescription
  PointerTypeDescription      -> ItemTypeDescription

  ItemTypeName                -> ItemTypeDescription     {prefer}
  %% Prefer above fixes ambiguity with type names

%% 2.1.1.1 INTEGER TYPE DESCRIPTIONS
%%

  IntegerItemDescription      -> IntegerTypeDescription
  IntegerTypeName             -> IntegerTypeDescription

%%  'S'
  SignedTypeDesc
      OptRoundOrTruncate
      OptIntegerSize          -> IntegerItemDescription  {cons("IntegerItemDescription")}
%%  'U'
  UnsignedTypeDesc
      OptRoundOrTruncate
      OptIntegerSize          -> IntegerItemDescription  {cons("IntegerItemDescriptionU")}

  CompileTimeNumericFormula   -> IntegerSize             {cons("ItemSize")}

  IntegerSize                 -> OptIntegerSize
  % empty %                   -> OptIntegerSize          {cons("no-item-size")}

  ItemTypeName                -> IntegerTypeName         {cons("TypeName")} %% using general cons for conversion traversal purposes


%% 2.1.1.2 FLOATING TYPE DESCRIPTIONS
%%

  FloatingItemDescription     -> FloatingTypeDescription
  FloatingTypeName            -> FloatingTypeDescription   {reject} %% Using ItemTypeName

  'F' OptRoundOrTruncate
      OptPrecision            -> FloatingItemDescription {cons("FloatingItemDescription")}

  ',' 'R'                     -> RoundOrTruncate         {cons("R")}
  ',' 'T'                     -> RoundOrTruncate         {cons("T")}
  ',' 'Z'                     -> RoundOrTruncate         {cons("Z")}

  RoundOrTruncate             -> OptRoundOrTruncate
  % empty %                   -> OptRoundOrTruncate      {cons("no-round-or-truncate")}

  CompileTimeNumericFormula   -> Precision

  Precision                   -> OptPrecision
  % empty %                   -> OptPrecision            {cons("no-precision")}

  ItemTypeName                -> FloatingTypeName


%% 2.1.1.3 FIXED TYPE DESCRIPTIONS
%%

  FixedItemDescription        -> FixedTypeDescription
  FixedTypeName               -> FixedTypeDescription    {reject} %% Using ItemTypeName

  'A' OptRoundOrTruncate
      ScaleSpecifier
      OptFractionSpecifier    -> FixedItemDescription    {cons("FixedItemDescription")}

  CompileTimeNumericFormula   -> ScaleSpecifier          {cons("ScaleSpecifier")}
  CompileTimeNumericFormula   -> FractionSpecifier       {cons("FractionSpecifier")}

  ',' FractionSpecifier       -> OptFractionSpecifier    {cons("OptFractionSpecifier")}
  % empty %                   -> OptFractionSpecifier    {cons("no-fraction-specifier")}

  ItemTypeName                -> FixedTypeName


%% 2.1.1.4 BIT TYPE DESCRIPTIONS
%%

  BitItemDescription          -> BitTypeDescription
  BitTypeName                 -> BitTypeDescription       {reject} %% Using ItemTypeName

%%  'B'
  BitTypeDesc
      OptBitSize              -> BitItemDescription       {cons("BitItemDescription")}

  CompileTimeNumericFormula   -> BitSize                  {cons("ItemSize")}

  BitSize                     -> OptBitSize
  % empty %                   -> OptBitSize               {cons("no-item-size")}

  ItemTypeName                -> BitTypeName


%% 2.1.1.5 CHARACTER TYPE DESCRIPTIONS
%%

  CharacterItemDescription    -> CharacterTypeDescription
  CharacterTypeName           -> CharacterTypeDescription  {reject} %% Using ItemTypeName

  'C' OptCharacterSize        -> CharacterItemDescription  {cons("CharacterItemDescription")}

  CompileTimeNumericFormula   -> CharacterSize             {cons("ItemSize")}

  CharacterSize               -> OptCharacterSize
  % empty %                   -> OptCharacterSize          {cons("no-item-size")}

  ItemTypeName                -> CharacterTypeName


%% 2.1.1.6 STATUS TYPE DESCRIPTIONS
%%

  StatusItemDescription      -> StatusTypeDescription
  StatusTypeName             -> StatusTypeDescription  {reject} %% Using ItemTypeName

  'STATUS' OptStatusSize
     '(' StatusList ')'      -> StatusItemDescription  {cons("StatusItemDescription")}

  DefaultSublist             -> StatusList
  OptDefaultSublist
    {SpecifiedSublist ','}+  -> StatusList             {cons("StatusList")}

  {StatusConstant ','}+      -> DefaultSublist         {cons("DefaultSublist")}

  DefaultSublist ','         -> OptDefaultSublist      {cons("OptDefaultSublist")}
  % empty %                  -> OptDefaultSublist      {cons("no-default-sublist")}

  StatusListIndex
    {StatusConstant ','}+    -> SpecifiedSublist       {cons("SpecifiedSublist")}

  CompileTimeNumericFormula  -> StatusListIndex

  'V' '(' Status ')'         -> StatusConstant         {cons("StatusConstant")}

  Name                       -> Status
  Letter                     -> Status
  ReservedWord               -> Status  {prefer}       %%fixes ambiguity between Name and ReservedWord

  ItemTypeName               -> StatusTypeName

  CompileTimeNumericFormula  -> StatusSize             {cons("ItemSize")}

  StatusSize                 -> OptStatusSize
  % empty %                  -> OptStatusSize          {cons("no-item-size")}

%% 2.1.1.7 POINTER TYPE DESCRIPTIONS
%%

  PointerItemDescription      -> PointerTypeDescription
  PointerTypeName             -> PointerTypeDescription  {reject} %% Using ItemTypeName

%%  'P'
  PointerTypeDesc
      OptTypeName             -> PointerItemDescription  {cons("PointerItemDescription")}

  ItemTypeName                -> PointerTypeName         {cons("PointerTypeName")}

  ItemTypeName                -> TypeName  {prefer}      %%fixes ambiguity between ItemTypeName, TableTypeName, and BlockTypeName
  TableTypeName               -> TypeName
  BlockTypeName               -> TypeName

  TypeName                    -> OptTypeName             {cons("TypeName")}
  % empty %                   -> OptTypeName             {cons("no-type-name")}

%% 2.1.2 TABLE DECLARATIONS
%%
  'TABLE' TableName
    OptAllocationSpecifier
    OptDimensionList
    TableDescription         -> TableDeclaration         {cons("TableDeclaration")}

  OptStructureSpecifier
    EntrySpecifier           -> TableDescription         {cons("TableDescription")}

  TableTypeName
    OptTablePreset ';'       -> TableDescription         {prefer, cons("TableDescriptionName")} %% removes ambiguity with other production of TableDescription

  OrdinaryEntrySpecifier     -> EntrySpecifier
  SpecifiedEntrySpecifier    -> EntrySpecifier

  Name                       -> TableName

%% 2.1.2.1 TABLE DIMENSION LISTS
%%
  '(' {Dimension ','}+ ')'   -> DimensionList            {cons("DimensionList")}

  DimensionList              -> OptDimensionList
  % empty %                  -> OptDimensionList         {cons("no-dimension-list")}

  OptLowerBoundOption
    UpperBound               -> Dimension                {cons("Dimension")}
  '*'                        -> Dimension                {cons("DimensionSTAR")}

  LowerBound ':'             -> LowerBoundOption         {cons("LowerBoundOption")}

  LowerBoundOption           -> OptLowerBoundOption
  % empty %                  -> OptLowerBoundOption      {cons("no-lower-bound-option")}

  CompileTimeNumericFormula  -> LowerBound
  CompileTimeStatusFormula   -> LowerBound

  CompileTimeNumericFormula  -> UpperBound
  CompileTimeStatusFormula   -> UpperBound

%% 2.1.2.2 TABLE STRUCTURE
%%
  'PARALLEL'                 -> StructureSpecifier       {cons("StructureSpecifier")}
%%  'T'
  StrucSpecT
    OptBitsPerEntry          -> StructureSpecifier       {cons("StructureSpecifierT")}

  StructureSpecifier         -> OptStructureSpecifier
  % empty %                  -> OptStructureSpecifier    {cons("no-structure-specifier")}

  CompileTimeNumericFormula  -> BitsPerEntry

  BitsPerEntry               -> OptBitsPerEntry
  % empty %                  -> OptBitsPerEntry          {cons("no-bits-per-entry")}

%% 2.1.2.3 ORDINARY TABLE ENTRIES
%%
  OptPackingSpecifier
    ItemTypeDescription
    OptTablePreset ';'         -> OrdinaryEntrySpecifier {cons("OrdinaryEntrySpecifier")}

  OptPackingSpecifier
    OptTablePreset ';'
    OrdinaryTableBody          -> OrdinaryEntrySpecifier {cons("OrdinaryEntrySpecifierBody")}

  'N'                          -> PackingSpecifier       {cons("PackingSpecifierN")}
  'M'                          -> PackingSpecifier       {cons("PackingSpecifierM")}
  'D'                          -> PackingSpecifier       {cons("PackingSpecifierD")}

  OrdinaryTableItemDeclaration -> OrdinaryTableBody
  'BEGIN'
    OrderDirective*
    OrdinaryTableOptions+
  'END'                        -> OrdinaryTableBody      {cons("OrdinaryTableBody")}

  PackingSpecifier             -> OptPackingSpecifier
  % empty %                    -> OptPackingSpecifier    {cons("no-packing-specifier")}

  'ITEM' TableItemName
    ItemTypeDescription
    OptPackingSpecifier
    OptTablePreset ';'         -> OrdinaryTableItemDeclaration {cons("OrdinaryTableItemDeclaration")}

  Name                         -> TableItemName

  OrdinaryTableItemDeclaration -> OrdinaryTableOptions
  NullDeclaration              -> OrdinaryTableOptions

%% 2.1.2.4 SPECIFIED TABLE ENTRIES
%%

  WordsPerEntry
    SpecifiedItemDescription
    OptTablePreset ';'           -> SpecifiedEntrySpecifier  {cons("SpecifiedEntrySpecifier")}

  WordsPerEntry
    OptTablePreset ';'
    SpecifiedTableBody           -> SpecifiedEntrySpecifier  {cons("SpecifiedEntrySpecifierBody")}

  'W' OptEntrySize               -> WordsPerEntry            {cons("WordsPerEntryW")}
  'V'                            -> WordsPerEntry            {cons("WordsPerEntryV")}

  CompileTimeNumericFormula      -> EntrySize

  EntrySize                      -> OptEntrySize
  % empty %                      -> OptEntrySize             {cons("no-entry-size")}

  ItemTypeDescription 'POS'
    '(' LocationSpecifier ')'    -> SpecifiedItemDescription {cons("SpecifiedItemDescription")}

  StartingBit ',' StartingWord   -> LocationSpecifier        {cons("LocationSpecifier")}

  CompileTimeNumericFormula      -> StartingBit
  '*'                            -> StartingBit              {cons("StartingBitSTAR")}

  CompileTimeNumericFormula      -> StartingWord

  SpecifiedTableItemDeclaration  -> SpecifiedTableBody
  'BEGIN'
    SpecifiedTableOptions+
  'END'                          -> SpecifiedTableBody       {cons("SpecifiedTableBody")}

  'ITEM' TableItemName
    SpecifiedItemDescription
    OptTablePreset ';'           -> SpecifiedTableItemDeclaration
                                                             {cons("SpecifiedTableItemDeclaration")}

  SpecifiedTableItemDeclaration -> SpecifiedTableOptions
  NullDeclaration               -> SpecifiedTableOptions

%% 2.1.3 CONSTANT DECLARATIONS
%%
  'CONSTANT' 'ITEM'
    ConstantItemName
    ItemTypeDescription
    ItemPreset ';'               -> ConstantDeclaration      {cons("ConstantItemDeclaration")}

  'CONSTANT' 'TABLE'
    ConstantTableName
    OptDimensionList
    TableDescription             -> ConstantDeclaration      {cons("ConstantTableDeclaration")}

  Name                           -> ConstantItemName
  Name                           -> ConstantTableName

%% 2.1.4 BLOCK DECLARATIONS
%%
  'BLOCK' BlockName
    OptAllocationSpecifier ';'
    BlockBodyPart                -> BlockDeclaration         {cons("BlockDeclarationBodyPart")}
  
  'BLOCK' BlockName
    OptAllocationSpecifier
    BlockTypeName
    OptBlockPreset ';'           -> BlockDeclaration         {cons("BlockDeclarationTypeName")}
  
  Name                           -> BlockName                {cons("Name")}

  NullDeclaration                -> BlockBodyPart
  DataDeclaration                -> BlockBodyPart

  'BEGIN'
    OrderDirective*
    BlockBodyOptions+
  'END'                          -> BlockBodyPart            {cons("BlockBodyPart")}

  DataDeclaration                -> BlockBodyOptions
  OverlayDeclaration             -> BlockBodyOptions
  NullDeclaration                -> BlockBodyOptions

%% 2.1.5 ALLOCATION OF DATA OBJECTS
%%
  'STATIC'                       -> AllocationSpecifier      {cons("STATIC")}

  AllocationSpecifier            -> OptAllocationSpecifier
  % empty %                      -> OptAllocationSpecifier   {cons("no-allocation-specifier")}

%% 2.1.6 INITIALIZATION OF DATA OBJECTS
%%
  '=' ItemPresetValue             -> ItemPreset              {cons("ItemPreset")}

  ItemPreset                      -> OptItemPreset
  % empty %                       -> OptItemPreset           {cons("no-item-preset")}

  CompileTimeFormula              -> ItemPresetValue
  LocFunction                     -> ItemPresetValue         {prefer}  %%fixes many different ambiguities with and within LocFunction in 2.1.1.7 Pointer Type tests

  ItemPresetValue                 -> OptItemPresetValue
  % empty %                       -> ItemPresetValue         {cons("no-item-preset-value")}

  '=' TablePresetList             -> TablePreset             {cons("TablePreset")}

  TablePreset                     -> OptTablePreset
  % empty %                       -> OptTablePreset          {cons("no-table-preset")}

  DefaultPresetSublist            -> TablePresetList
  OptDefaultPresetSublist
    {SpecifiedPresetSublist ','}+ -> TablePresetList         {cons("TablePresetList")}

  {PresetValuesOption ','}+       -> DefaultPresetSublist    {cons("DefaultPresetSublist")}

  DefaultPresetSublist ','        -> OptDefaultPresetSublist
  % empty %                       -> OptDefaultPresetSublist {cons("no-default-preset-sublist")}

  PresetIndexSpecifier
    {PresetValuesOption ','}+     -> SpecifiedPresetSublist  {cons("SpecifiedPresetSublist")}

  'POS'
    '('
       {ConstantIndex ','}+
    ')' ':'                       -> PresetIndexSpecifier    {cons("PresetIndexSpecifier")}

  CompileTimeNumericFormula       -> ConstantIndex
  CompileTimeStatusFormula        -> ConstantIndex
  
  OptItemPresetValue              -> PresetValuesOption    {cons("PresetValuesOption"), prefer}
  RepetitionCount
    '('
       {PresetValuesOption ','}+
    ')'                           -> PresetValuesOption    {cons("PresetValuesOptionRep")}

  CompileTimeNumericFormula       -> RepetitionCount

  '=' BlockPresetList             -> BlockPreset           {cons("BlockPreset")}

  BlockPreset                     -> OptBlockPreset
  % empty %                       -> OptBlockPreset        {cons("no-block-preset")}

  {BlockPresetValuesOption ','}+  -> BlockPresetList

  PresetValuesOption              -> BlockPresetValuesOption
  OptTablePresetList              -> BlockPresetValuesOption
  OptBlockPresetList              -> BlockPresetValuesOption

  '(' TablePresetList ')'         -> OptTablePresetList    {cons("OptTablePresetlist")}
  % empty %                       -> OptTablePresetList    {cons("no-table-preset-list")}

  '(' BlockPresetList ')'         -> OptBlockPresetList    {cons("OptBlockPresetlist"), prefer}
  % empty %                       -> OptBlockPresetList    {cons("no-table-preset-list")}

%% 2.2 TYPE DECLARATIONS
%%
  ItemTypeDeclaration             -> TypeDeclaration
  TableTypeDeclaration            -> TypeDeclaration
  BlockTypeDeclaration            -> TypeDeclaration

  'TYPE' ItemTypeName
    ItemTypeDescription ';'       -> ItemTypeDeclaration   {cons("ItemTypeDeclaration")}

  Name                            -> ItemTypeName          {cons("Name")}

  'TYPE'  TableTypeName
  'TABLE' TableTypeSpecifier      -> TableTypeDeclaration  {cons("TableTypeDeclaration")}

  OptDimensionList
    OptStructureSpecifier
    OptLikeOption
    EntrySpecifier                -> TableTypeSpecifier    {cons("TableTypeSpecifier")}
  
  OptDimensionList
    TableTypeName ';'             -> TableTypeSpecifier    {cons("TableTypeSpecifierName"), prefer}

  Name                            -> TableTypeName         {cons("Name")}

  'LIKE'  TableTypeName           -> LikeOption            {cons("LikeOption")}

  LikeOption                      -> OptLikeOption
  % empty %                       -> OptLikeOption         {cons("no-like-option")}

  'TYPE'  BlockTypeName
  'BLOCK' BlockBodyPart           -> BlockTypeDeclaration  {cons("BlockTypeDeclaration")}

  Name                            -> BlockTypeName         {cons("Name")}

%% 2.3 STATEMENT NAME DECLARATIONS
%%
'LABEL' {StatementName ','}+ ';'  -> StatementNameDeclaration {cons("StatementNameDeclaration")}

%% 2.4 DEFINE DECLARATIONS
%%
'DEFINE' DefineName
  DefinitionPart                  -> DefineDeclaration         {cons("DefineDeclaration")}

  Name                            -> DefineName                {cons("Name")}

  OptFormalDefineParameterList
    DefineString ';'              -> DefinitionPart            {cons("DefinitionPart")}

  '('
     {FormalDefineParameter ','}+
  ')'                             -> FormalDefineParameterList {cons("FormalDefineParameterList")}

  FormalDefineParameterList       -> OptFormalDefineParameterList
  % empty %                       -> OptFormalDefineParameterList {cons("no-formal-define-parameter-list")}

  Letter                          -> FormalDefineParameter        {cons("FormalDefineParameter")}

%% Moved to lexical analysis
%%'?'
%%   {Character ','}*
%%'?'                             -> DefineString                 {cons("DefineString")}

  DefString                       -> DefineString                 {cons("DefineString")}

%% 2.4.1 DEFINE CALLS
%%
  DefineName
   ActualDefineParameterList      -> DefineCall                {cons("DefineCall")}
  DefineName
   NoList                         -> DefineCall                {cons("DefineCall")}

  '('
     {ActualDefineParameter ','}+
  ')'                             -> ActualDefineParameterList {cons("ActualDefineParameterList")}

  % empty %                       -> NoList                    {cons("no-list")}

      Character*                  -> ActualDefineParameter
  '"' Character* '"'              -> ActualDefineParameter     {cons("quoted-string")}

%% 2.5 EXTERNAL DECLARATIONS
%%
  DefSpecification                -> ExternalDeclaration
  RefSpecification                -> ExternalDeclaration

%% 2.5.1 DEF SPECIFICATIONS
%%
  SimpleDef                       -> DefSpecification
  CompoundDef                     -> DefSpecification

  'DEF'
    DefSpecificationChoice        -> SimpleDef            {cons("SimpleDef")}

  'DEF' 'BEGIN'
    DefSpecificationChoice+
  'END'                           -> CompoundDef          {cons("CompoundDef")}

  NullDeclaration                 -> DefSpecificationChoice
  DataDeclaration                 -> DefSpecificationChoice
  DefBlockInstantiation           -> DefSpecificationChoice
  StatementNameDeclaration        -> DefSpecificationChoice

  'BLOCK' 'INSTANCE'
    BlockName ';'                 -> DefBlockInstantiation   {cons("DefBlockInstantiation")}

%% 2.5.2 REF SPECIFICATIONS
%%
  SimpleRef                       -> RefSpecification
  CompoundRef                     -> RefSpecification

  'REF'
    RefSpecificationChoice        -> SimpleRef            {cons("SimpleRef")}

  'REF' 'BEGIN'
    RefSpecificationChoice+
  'END'                           -> CompoundRef          {cons("CompoundRef")}

  NullDeclaration                 -> RefSpecificationChoice
  DataDeclaration                 -> RefSpecificationChoice
  SubroutineDeclaration           -> RefSpecificationChoice
  StatementNameDeclaration        -> RefSpecificationChoice

%% 2.6 OVERLAY DECLARATIONS
%%
  'OVERLAY'
    OptAbsoluteAddress
    OverlayExpression ';'         -> OverlayDeclaration   {cons("OverlayDeclaration")}

  'POS' '(' OverlayAddress ')'    -> AbsoluteAddress      {cons("AbsoluteAddress")}

  AbsoluteAddress                 -> OptAbsoluteAddress
  % empty %                       -> OptAbsoluteAddress   {cons("no-absolute-address")}

  CompileTimeNumericFormula       -> OverlayAddress

  {OverlayString ':'}+            -> OverlayExpression

  {OverlayElement ','}+           -> OverlayString

  Spacer                          -> OverlayElement
  DataName                        -> OverlayElement
  '(' OverlayExpression ')'       -> OverlayElement       {cons("OverlayElement")}

  'W' CompileTimeNumericFormula   -> Spacer               {cons("Spacer")}

  Name                            -> DataName             {cons("Name"), prefer}
  ItemName                        -> DataName
  TableName                       -> DataName
  BlockName                       -> DataName

%% 2.7 NULL DECLARATIONS
%%
  ';'                             -> NullDeclaration      {cons("NullDeclaration")}
  'BEGIN' 'END'                   -> NullDeclaration      {cons("NullDeclaration")}


%%%%%%%%%%
%% 3.0 PROCEDURES AND FUNCTIONS
%%%%%%%%%%

  ProcedureDeclaration            -> SubroutineDeclaration  {prefer}
  FunctionDeclaration             -> SubroutineDeclaration  %% AMBIGUOUS with ProcedureDeclaration

  ProcedureDefinition             -> SubroutineDefinition   {prefer}
  FunctionDefinition              -> SubroutineDefinition   %% AMBIGUOUS with ProcedureDefinition

%% 3.1 PROCEDURES
%%
  ProcedureHeading ';'
    Declaration                   -> ProcedureDeclaration   {cons("ProcedureDeclaration")}

  ProcedureHeading ';'
    ProcedureBody                 -> ProcedureDefinition    {cons("ProcedureDefinition")}

  'PROC'
    ProcedureName
    OptSubroutineAttribute
    OptFormalParameterList        -> ProcedureHeading       {cons("ProcedureHeading")}

  'REC'                           -> SubroutineAttribute    {cons("REC")}
  'RENT'                          -> SubroutineAttribute    {cons("RENT")}

  SubroutineAttribute             -> OptSubroutineAttribute
  % empty %                       -> OptSubroutineAttribute {cons("no-subroutine-attribute")}
 
  Name                            -> ProcedureName          {cons("Name")}

  SubroutineBody                  -> ProcedureBody

  Statement                       -> SubroutineBody         {cons("SubroutineSimpleBody")}

  'BEGIN'
%%    Directive*                  %% Might need this in the future
    DeclarationList
    Statement*
    SubroutineDefinition*
    LabelList
  'END'                           -> SubroutineBody         {cons("SubroutineBody"), prefer}

%% 3.2 FUNCTIONS
%%
  FunctionHeading ';'
    ReducibleDirective*
    Declaration                   -> FunctionDeclaration    {cons("FunctionDeclaration")}

  FunctionHeading ';'
    ReducibleDirective*
    FunctionBody                  -> FunctionDefinition      {cons("FunctionDefinition")}

  'PROC'
    FunctionName
    OptSubroutineAttribute
    OptFormalParameterList
    ItemTypeDescription           -> FunctionHeading      {cons("FunctionHeading")}

  Name                            -> FunctionName         {cons("Name")}

  SubroutineBody                  -> FunctionBody

%% 3.3 PARAMETERS OF PROCEDURES AND FUNCTIONS
%%
  '('
     {FormalInputParameter ','}*
     OptFormalOutputParameter
  ')'                             -> FormalParameterList      {cons("FormalParameterList")}

  FormalParameterList             -> OptFormalParameterList
  % empty %                       -> OptFormalParameterList   {cons("no-formal-parameter-list")}

  ':' {FormalOutputParameter','}+ -> OptFormalOutputParameter {cons("FormalOutputParameterList")}
  % empty %                       -> OptFormalOutputParameter {cons("no-formal-output-parameters")}

  OptParameterBinding
    InputParameterName            -> FormalInputParameter     {cons("FormalInputParameter")}

  OptParameterBinding
    OutputParameterName           -> FormalOutputParameter    {cons("FormalOutputParameter")}

  'BYVAL'                         -> ParameterBinding         {cons("BYVAL")}
  'BYREF'                         -> ParameterBinding         {cons("BYREF")}
  'BYRES'                         -> ParameterBinding         {cons("BYRES")}

  ParameterBinding                -> OptParameterBinding
  % empty %                       -> OptParameterBinding      {cons("no-parameter-binding")}

  Name                            -> InputParameterName       {cons("Name"), prefer} %% added this production and prefer to remove ambiguity within InputParameterName
  DataName                        -> InputParameterName
  StatementName                   -> InputParameterName
  SubroutineName                  -> InputParameterName

  Name                            -> OutputParameterName      {cons("Name"), prefer}
  DataName                        -> OutputParameterName

  Name                            -> SubroutineName           {cons("Name"), prefer}
  ProcedureName                   -> SubroutineName
  FunctionName                    -> SubroutineName

%% 3.4 INLINE PROCEDURES AND FUNCTIONS
%%
  'INLINE'
    {SubroutineName ','}+ ';'     -> InlineDeclaration        {cons("InlineDeclaration")}

%% 3.5 MACHINE-SPECIFIC PROCEDURES AND FUNCTIONS
%%


%%%%%%%%%%
%% 4.0 STATEMENTS
%%%%%%%%%%

  LabelList SimpleStatement   -> Statement             {cons("SimpleStatement")}
  LabeledSimpleStatement      -> Statement             {cons("SimpleStatement")}
  LabeledCompoundStatement    -> Statement

  AssignmentStatement         -> SimpleStatement
  LoopStatement               -> LabeledSimpleStatement
  IfStatement                 -> LabeledSimpleStatement
  CaseStatement               -> LabeledSimpleStatement
  ProcedureCallStatement      -> LabeledSimpleStatement
  ReturnStatement             -> LabeledSimpleStatement
  GotoStatement               -> LabeledSimpleStatement
  ExitStatement               -> LabeledSimpleStatement
  StopStatement               -> LabeledSimpleStatement
  AbortStatement              -> LabeledSimpleStatement
  NullStatement               -> SimpleStatement

  ';'                         -> NullStatement         {cons("NullStatement")}

  'BEGIN'
    LabelList
  'END'                       -> NullStatement         {cons("NullBlockStatement")}

%% StatementName changed to Name when cons("Name") was added to StatementName
%% Otherwise terms like Name(Label("label_string")) would appear.
%%
%% StatementName ':'          -> Label                 {cons("Label")}
%%
  Name ':'                    -> Label                 {cons("Label")}

  Label*                      -> LabelList             {cons("LabelList")}

  Name                        -> StatementName         {cons("Name")}

  LabelList
  'BEGIN'
    Statement+
    LabelList
  'END'                       -> LabeledCompoundStatement {cons("CompoundStatement")}
  
%% 4.1 ASSIGNMENT STATEMENTS
%%

  VariableList
    '=' Formula ';'          -> AssignmentStatement    {cons("AssignmentStatement")}

  {Variable ','}+            -> VariableList           {cons("VariableList")}

%% 4.2 LOOP STATEMENTS
%%

  LabelList
  WhileClause ControlledStatement -> LoopStatement        {cons("WhileStatement")}

  LabelList
  ForClause ControlledStatement   -> LoopStatement        {cons("ForStatement")}

  WhileClause                  -> LoopType
  ForClause                    -> LoopType

  Statement                    -> ControlledStatement

  'WHILE' BooleanFormula ';'   -> WhileClause          {cons("WhileClause")}

  'FOR' ControlItem   ':'
        ControlClause ';'      -> ForClause            {cons("ForClause")}

  ControlVariable              -> ControlItem
  ControlLetter                -> ControlItem

  ItemName                     -> ControlVariable

  Letter                       -> ControlLetter

  InitialValue
    OptContinuation            -> ControlClause        {cons("ControlClause")}

  Formula                      -> InitialValue

  ByOrThenPhrase
    OptWhilePhrase             -> Continuation         {cons("Continuation")}
  WhilePhrase
    OptByOrThenPhrase          -> Continuation         {cons("Continuation")}

  Continuation                 -> OptContinuation
  % empty %                    -> OptContinuation      {cons("no-continuation")}

  ByPhrase                     -> ByOrThenPhrase
  ThenPhrase                   -> ByOrThenPhrase

  ByOrThenPhrase               -> OptByOrThenPhrase
  % empty %                    -> OptByOrThenPhrase    {cons("no-by-or-then-phrase")}

  'BY' ByFormula               -> ByPhrase             {cons("ByPhrase")}

  NumericFormula               -> ByFormula

  'THEN' Formula               -> ThenPhrase           {cons("ThenPhrase")}

  'WHILE' BooleanFormula       -> WhilePhrase          {cons("WhilePhrase")}

  WhilePhrase                  -> OptWhilePhrase
  % empty %                    -> OptWhilePhrase       {cons("no-while-phrase")}

%% 4.3 IF STATEMENTS
%%

  LabelList
  'IF' BooleanFormula ';'
    ConditionalStatement
    OptElseClause            -> IfStatement            {cons("IfStatement")}

  Statement                  -> ConditionalStatement   %%{cons("ConditionalStatement")} This might be unnecessary and clunky in traversal

  'ELSE' Statement           -> ElseClause             {cons("ElseClause")}

  ElseClause                 -> OptElseClause
  % empty %                  -> OptElseClause          {cons("no-else-clause")}

%% 4.4 CASE STATEMENTS
%%

  LabelList
  'CASE'
    CaseSelectorFormula ';'
  'BEGIN'
    CaseBody
    LabelList
  'END'                        -> CaseStatement        {cons("CaseStatement")}

  NumericFormula               -> CaseSelectorFormula
  BitFormula                   -> CaseSelectorFormula
  CharacterFormula             -> CaseSelectorFormula
  StatusFormula                -> CaseSelectorFormula

  CaseAlternative+             -> CaseBody

  CaseIndexGroup
    Statement
    OptFALLTHRU                -> CaseAlternative      {cons("CaseAlternative")}

  DefaultOption                -> CaseAlternative      {prefer}

  '(' 'DEFAULT' ')' ':'
    Statement
    OptFALLTHRU                -> DefaultOption        {cons("DefaultOption")}

  'FALLTHRU'                   -> OptFALLTHRU          {cons("FALLTHRU")}
  % empty %                    -> OptFALLTHRU          {cons("no-fall-thru")}

  '(' {CaseIndex ','}+ ')' ':' -> CaseIndexGroup       {cons("CaseIndexGroup")}

  CompileTimeNumericFormula    -> CaseIndex            {cons("CaseIndex")}
  CompileTimeBitFormula        -> CaseIndex            {cons("CaseIndex")}
  CompileTimeCharacterFormula  -> CaseIndex            {cons("CaseIndex")}
  CompileTimeStatusFormula     -> CaseIndex            {cons("CaseIndex")}
  LowerBound ':' UpperBound    -> CaseIndex            {cons("CaseIndex")}

%% 4.5 PROCEDURE CALL STATEMENTS
%%

  UserDefinedProcedureCall     -> ProcedureCallStatement   {prefer}
  MachineSpecificProcedureCall -> ProcedureCallStatement   %% rejected below

  LabelList ProcedureName
    OptActualParameterList
    OptAbortPhrase ';'         -> UserDefinedProcedureCall {cons("ProcedureCallStatement")}

  AbortPhrase                  -> OptAbortPhrase
  % empty %                    -> OptAbortPhrase           {cons("no-abort-phrase")}

  '('
    {ActualInputParameter ','}*
    OptActualOutputParameters
  ')'                          -> ActualParameterList  {cons("ActualParameterList")}

  ActualParameterList          -> OptActualParameterList
  % empty %                    -> OptActualParameterList   {cons("no-actual-parameter-list")}

  ':' {ActualOutputParameter ','}+ -> OptActualOutputParameters {cons("ActualOutputParameters")}
  % empty%                         -> OptActualOutputParameters {cons("no-actual-output-parameters")}

  Formula                      -> ActualInputParameter     {prefer} %% other paths aren't needed
%%StatementName                -> ActualInputParameter
%%FunctionName                 -> ActualInputParameter
%%ProcedureName                -> ActualInputParameter
%%BlockReference               -> ActualInputParameter

  Variable                     -> ActualOutputParameter    {cons("Variable"), prefer}
  BlockReference               -> ActualOutputParameter    {cons("BlockReference")}

  'ABORT' StatementName        -> AbortPhrase              {cons("AbortPhrase")}

  ProcedureName
    OptActualParameterList     -> MachineSpecificProcedureCall {cons("MachineSpecificProcedureCall"), reject} %%AMBIGUOUS

  Name                         -> ProcedureName
  'RETURN'                     -> ProcedureName            {reject} %% Ambiguous with ReturnStatement
  'EXIT'                       -> ProcedureName            {reject} %% Ambiguous with ExitStatement
  'STOP'                       -> ProcedureName            {reject} %% Ambiguous with StopStatement
  'ABORT'                      -> ProcedureName            {reject} %% Ambiguous with AbortStatement
  Name                         -> FunctionName

%% 4.6 RETURN STATEMENTS
%%

  LabelList 'RETURN' ';'                  -> ReturnStatement        {cons("ReturnStatement")}

%% 4.7 GOTO STATEMENTS
%%

  LabelList 'GOTO' StatementName ';'      -> GotoStatement          {cons("GotoStatement")}

%% 4.8 EXIT STATEMENTS
%%

  LabelList 'EXIT' ';'                    -> ExitStatement          {cons("ExitStatement")}

%% 4.9 STOP STATEMENTS
%%

  LabelList 'STOP' OptNumericFormula ';'  -> StopStatement          {cons("StopStatement")}

  NumericFormula                          -> OptNumericFormula
  % empty %                               -> OptNumericFormula      {cons("no-integer-formula")} %% should be no-numeric-formula? Will keep as is for now

%% 4.10 ABORT STATEMENTS
%%

  LabelList 'ABORT' ';'         -> AbortStatement         {cons("AbortStatement")}



%%%%%%%%%%
%% 5.0 FORMULAS
%%%%%%%%%%

%%UntypedNamedVariable        -> Formula               {cons("VariableFormula")}  %% BEWARE NON_STANDARD_TRIAL
  NumericFormula              -> Formula               {prefer}
  BitFormula                  -> Formula
  GeneralFormula              -> Formula             %%{cons("GeneralFormula")}
  TableFormula                -> Formula               {cons("TableFormula")}

%% Additions to resolve ambiguities with variables (variables are mostly untyped)
%%
%%NamedVariable               -> UntypedNamedVariable   {cons("UntypedNamedVariable")}
%%Sign NamedVariable          -> UntypedNamedVariable   {cons("NumericNamedVariable")}

  CompileTimeNumericFormula   -> CompileTimeFormula     {prefer}
  CompileTimeBitFormula       -> CompileTimeFormula
  CompileTimeCharacterFormula -> CompileTimeFormula
  CompileTimeStatusFormula    -> CompileTimeFormula
  CompileTimePointerFormula   -> CompileTimeFormula

%% 5.1 NUMERIC FORMULAS
%%

  OptSign NumericTerm         -> NumericFormula         {cons("NumericFormula")}
  NumericFormula
    PlusOrMinus NumericTerm   -> NumericFormula         {cons("NumericFormula")}

  Sign                        -> OptSign
  % empty %                   -> OptSign                {cons("no-sign")}

  NumericFactor               -> NumericTerm
  NumericTerm
    MultiplyDivideOrMod
    NumericFactor             -> NumericTerm            {cons("NumericTerm")}

  NumericPrimary              -> NumericFactor
  NumericFactor '**'
    NumericPrimary            -> NumericFactor          {cons("ExponentiationOp")}

  NumericLiteral              -> NumericPrimary
  NumericMachineParameter     -> NumericPrimary
  NumericVariable             -> NumericPrimary         {cons("NumericVariable")}
  NamedNumericConstant        -> NumericPrimary         {cons("NamedNumericConstant")}
  NumericFunctionCall         -> NumericPrimary         {prefer} % prefer a function call to an array/table reference %
  '(' NumericFormula ')'      -> NumericPrimary         {cons("NumericPrimaryParens")}
  IntegerConversion
    '(' Formula ')'           -> NumericPrimary         {cons("NumericPrimary")}
  FloatingConversion
    '(' Formula ')'           -> NumericPrimary         {cons("NumericPrimary")}
  FixedConversion
    '(' NumericTerm '/'
        NumericFactor   ')'   -> NumericPrimary         {cons("NumericPrimary"), prefer} %% added prefer to remove ambiguity with NumericTerm that includes DivideOp above
  FixedConversion
    '(' Formula         ')'   -> NumericPrimary         {cons("NumericPrimary")}

%% Added new production of NumericPrimary to allow ControlLetter through
%% Orginally ControlLetter -> NumericConstant -> NamedNumericConstant -> NumericPrimary
%% However NamedNumericConstant was rejected because of ambiguity
  ControlLetter               -> NumericPrimary      {cons("ControlLetter")}

  IntegerMachineParameter     -> NumericMachineParameter
  FloatingMachineParameter    -> NumericMachineParameter
  FixedMachineParameter       -> NumericMachineParameter

  IntegerLiteral              -> NumericLiteral
  FloatingLiteral             -> NumericLiteral
  FixedLiteral                -> NumericLiteral         {prefer} %% added to remove ambiguity with FloatingLiteral

  Variable                    -> NumericVariable

  NamedConstant               -> NamedNumericConstant   {reject} %% added so deal only with NumericVariables

  FunctionCall                -> NumericFunctionCall

  NumericFormula              -> CompileTimeNumericFormula

%% 5.2 BIT FORMULAS
%%
  LogicalOperand
    OptLogicalContinuation    -> BitFormula             {cons("BitFormula")}

%% Added for when variable is used with LogicalContinuation
  LogicalComponent
    LogicalContinuation       -> BitFormula             {cons("BitFormula"), prefer}

  'NOT' LogicalComponent      -> BitFormula             {cons("BitFormulaNOT")}

  Variable                    -> BitFormula             {cons("BitVariableFormula"), prefer}

%% Added LogicalComponent to allow for nonambiguous use of variables
  LogicalOperand              -> LogicalComponent
  Variable                    -> LogicalComponent

  BitPrimary                  -> LogicalOperand
  RelationalExpression        -> LogicalOperand
%%BitVariable                 -> LogicalOperand
%% Moving variable to LogicalComponent to remove ambiguity

  BitLiteral                  -> BitPrimary
  BooleanLiteral              -> BitPrimary
  BitVariable                 -> BitPrimary             {cons("BitVariable")}

  %% Rejected to fix ambiguity with NamedIntegerConstant
  %% WARNING - may need to be fixed
  NamedBitConstant            -> BitPrimary             {cons("NamedBitConstant"), reject}

  BitFunctionCall             -> BitPrimary
  '(' BitFormula  ')'         -> BitPrimary             {cons("BitPrimaryParens")}
  BitConversion
  '('    Formula ')'          -> BitPrimary             {cons("BitPrimaryConversion")}

  AndContinuation+            -> LogicalContinuation
  OrContinuation+             -> LogicalContinuation
  XorContinuation+            -> LogicalContinuation
  EqvContinuation+            -> LogicalContinuation

  LogicalContinuation         -> OptLogicalContinuation
  % empty %                   -> OptLogicalContinuation {cons("no-logical-continuation")}

%% Using LogicalComponent instead of LogicalOperand
%% for these continuations to allow use of variables
  'AND' LogicalComponent      -> AndContinuation        {cons("AndContinuation")}
  'OR'  LogicalComponent      ->  OrContinuation        {cons( "OrContinuation")}
  'XOR' LogicalComponent      -> XorContinuation        {cons("XorContinuation")}
  'EQV' LogicalComponent      -> EqvContinuation        {cons("EqvContinuation")}

  Variable                    -> BitVariable            {cons("BitVariable")}

  NamedConstant               -> NamedBitConstant

  FunctionCall                -> BitFunctionCall

  BitFormula                  -> CompileTimeBitFormula

%% 5.2.1 RELATIONAL EXPRESSIONS
%%

%% Nonstandard handling to remove ambiguities
%%
  RelationalFormula
    RelationalOperator
    RelationalFormula         -> RelationalExpression   {cons("RelationalExpression")}

  NumericFormula              -> RelationalFormula      {prefer}
  GeneralFormula              -> RelationalFormula
  BitFormula                  -> RelationalFormula
%% This reject that may be needed, but causes other problems, commenting out for now
%%UserDefinedFunctionCall     -> RelationalFormula      {reject}

%%FloatingFormula
%%  RelationalOperator
%%  FloatingFormula           -> RelationalExpression   {cons("RelationalExpression")}

%%FixedFormula
%%  RelationalOperator
%%  FixedFormula              -> RelationalExpression   {cons("RelationalExpression")}

%%CharacterFormula
%%  RelationalOperator
%%  CharacterFormula          -> RelationalExpression   {cons("RelationalExpression")}

%%StatusFormula
%%  RelationalOperator
%%  StatusFormula             -> RelationalExpression   {cons("RelationalExpression")}

%%BitPrimary
%%  EqualOrNotEqualOperator
%%  BitPrimary                -> RelationalExpression   {cons("RelationalExpression")}

%%BitVariable
%%  EqualOrNotEqualOperator
%%  BitPrimary                -> RelationalExpression   {cons("RelationalExpression")}

%%BitPrimary
%%  EqualOrNotEqualOperator
%%  BitVariable               -> RelationalExpression   {cons("RelationalExpression")}

%%PointerFormula
%%  RelationalOperator
%%  PointerFormula            -> RelationalExpression   {cons("RelationalExpression")}

%% 5.2.2 BOOLEAN FORMULAS
%%
  BitFormula                  -> BooleanFormula

%% 5.3.0 GENERAL FORMULAS
%%
%% Not in the original grammar
%% Added to decrease chance for ambiguities

  CharacterFormula            -> GeneralFormula
  StatusFormula               -> GeneralFormula
  PointerFormula              -> GeneralFormula

  Variable                    -> GeneralFormula         {cons("GeneralFormula")}
  NamedConstant               -> GeneralFormula         {cons("GeneralFormula")}
  FunctionCall                -> GeneralFormula         {cons("GeneralFormula")}

%% 5.3 CHARACTER FORMULAS
%%
  CharacterLiteral            -> CharacterFormula       {cons("CharacterFormula")}
%%CharacterVariable           -> CharacterFormula       {cons("CharacterVariable")}
%%NamedCharacterConstant      -> CharacterFormula       {cons("NamedCharacterConstant")}
%%CharacterFunctionCall       -> CharacterFormula
  '(' CharacterFormula ')'    -> CharacterFormula       {cons("CharacterFormulaParens")}
  CharacterConversion
    '(' Formula ')'           -> CharacterFormula       {cons("CharacterFormulaConversion")}

%%Variable                    -> CharacterVariable

%%NamedConstant               -> NamedCharacterConstant

%%FunctionCall                -> CharacterFunctionCall

  CharacterFormula            -> CompileTimeCharacterFormula

%% 5.4 STATUS FORMULAS
%%
  StatusConstant              -> StatusFormula      {cons("StatusFormula")}
%%StatusVariable              -> StatusFormula      {cons("StatusVariable")}
%%NamedStatusConstant         -> StatusFormula      {cons("NamedStatusConstant")}
%%StatusFunctionCall          -> StatusFormula
  '(' StatusFormula ')'       -> StatusFormula      {cons("StatusFormulaParens")}
  StatusConversion
    '(' Formula ')'           -> StatusFormula      {cons("StatusFormulaConversion")}

%%Variable                    -> StatusVariable

%%NamedConstant               -> NamedStatusConstant

%%FunctionCall                -> StatusFunctionCall

  StatusFormula               -> CompileTimeStatusFormula

%% 5.5 POINTER FORMULAS
%%
  PointerLiteral              -> PointerFormula     {cons("PointerFormula")}
%%PointerVariable             -> PointerFormula     {cons("PointerVariable")}
%%NamedPointerConstant        -> PointerFormula     {cons("NamedPointerConstant")}
%%PointerFunctionCall         -> PointerFormula
  '(' PointerFormula ')'      -> PointerFormula     {cons("PointerFormulaParens")}
  PointerConversion
    '(' Formula ')'           -> PointerFormula     {cons("PointerFormulaConversion")}

%%Variable                    -> PointerVariable

%%NamedConstant               -> NamedPointerConstant

%%FunctionCall                -> PointerFunctionCall

  PointerFormula              -> CompileTimePointerFormula

%% 5.6 TABLE FORMULAS
%%
  TableVariable               -> TableFormula       {cons("TableVariable")}
  NamedTableConstant          -> TableFormula       {cons("NamedTableConstant")}
  '(' TableFormula ')'        -> TableFormula       {cons("TableFormulaParens")}
  TableConversion
    '(' Formula ')'           -> TableFormula       {cons("TableFormulaConversion")}

  Variable                    -> TableVariable

  NamedConstant               -> NamedTableConstant


%%%%%%%%%%
%% 6.0 DATA REFERENCES
%%%%%%%%%%

%% 6.1 VARIABLE AND BLOCK REFERENCES
%%
  NamedVariable               -> Variable
  BitFunctionVariable         -> Variable
  ByteFunctionVariable        -> Variable
  RepFunctionVariable         -> Variable
%%FunctionName                -> Variable           {reject} %% AMBIGUOUS with NamedVariable
  
  Item                        -> NamedVariable
  Table                       -> NamedVariable
  TableItem                   -> NamedVariable      {prefer}
  TableEntry                  -> NamedVariable
  BlockItem                   -> NamedVariable      {reject} %% AMBIGUOUS with BlockTable
  BlockTable                  -> NamedVariable
  BlockTableItem              -> NamedVariable      {reject} %% AMBIGUOUS with TableItem
  BlockTableEntry             -> NamedVariable

  ItemName                    -> Item
  ItemDereference             -> Item

%%TableName                   -> Table  %% AMBIGUOUS
  TableDereference            -> Table

  TableItemName
       Subscript
%%  OptSubscript                                                      %% Optional makes AMBIGUOUS with Name
    OptTableDereference       -> TableItem             {cons("TableItem"), prefer}

  TableItemName
    OptSubscript
%%  OptTableDereference                                                          %% Optional makes AMBIGUOUS with Name
       TableDereference       -> TableItem             {cons("TableItem")}

  Subscript                   -> OptSubscript
  % empty %                   -> OptSubscript          {cons("no-subscript")}

  TableDereference            -> OptTableDereference
  % empty %                   -> OptTableDereference   {cons("no-table-dereference")}

  TableName
    Subscript                 -> TableEntry            {cons("TableEntry"), reject} %% Makes AMBIGUOUS with TableItem

  TableDereference
    Subscript                 -> TableEntry            {cons("TableEntry")}

  ItemName
    OptBlockDereference       -> BlockItem             {cons("BlockItem"), reject} %% AMBIGUOUS with BlockTable

  TableName
    BlockDereference          -> BlockTable            {cons("BlockTable")}
%%  OptBlockDereference       -> BlockTable                                        %% Optional makes AMBIGUOUS with Name

  TableItemName
    OptSubscript
    OptBlockDereference       -> BlockTableItem        {cons("BlockTableItem"), reject} %% AMBIGUOUS with TableItem

  TableName
    Subscript
    OptBlockDereference       -> BlockTableEntry       {cons("BlockTableEntry")}

  BlockDereference            -> OptBlockDereference
  % empty %                   -> OptBlockDereference   {cons("no-block-dereference")}

  Dereference                 -> BlockDereference

  Dereference                 -> ItemDereference

  Dereference                 -> TableDereference      {prefer}

  '@' PointerItemName         -> Dereference           {cons("Dereference")}
  '@' '(' GeneralFormula ')'  -> Dereference           {cons("Dereference")}
  '@' '(' PointerLiteral ')'  -> Dereference           {cons("Dereference"), reject}  %% This prevents NULL from being dereferenced

  ItemName                    -> PointerItemName       {prefer}
  TableItemName               -> PointerItemName
  ConstantItemName            -> PointerItemName

  '(' { Index ','}+ ')'       -> Subscript             {cons("Subscript")}

  NumericFormula              -> Index                 {prefer}
  GeneralFormula              -> Index

  'BIT' '(' BitVariable ','
            Fbit ',' Nbit ')' -> BitFunctionVariable   {cons("BitFunctionVariable"), prefer}

%% Added production of BitFunctionVariable with BitFormula inside
%% to allow variables with parentheses to be used
  'BIT' '(' BitFormula ','
            Fbit ',' Nbit ')' -> BitFunctionVariable   {cons("BitFunctionVariable")}

%%'BYTE'
%%  '(' CharacterVariable ','
%%          Fbit ',' Nbit ')' -> ByteFunctionVariable  {cons("ByteFunctionVariable")}

  'BYTE' '(' Variable ','
            Fbit ',' Nbit ')' -> ByteFunctionVariable  {cons("ByteFunctionVariable")}

  RepConversion
    '(' NamedVariable ')'     -> RepFunctionVariable   {cons("RepFunctionVariable")}

  BlockName                   -> BlockReference
  BlockDereference            -> BlockReference
  BlockName
    BlockDereference          -> BlockReference        {cons("BlockReference")}

  Name                        -> ConstantItemName
  Name                        -> BlockName

%% 6.2 NAMED CONSTANTS
%%
  ConstantItemName            -> NamedConstant         {prefer}  %% ambiguous with ConstantTableName
  ConstantTableName           -> NamedConstant         {cons("ConstantTableName")}
  ConstantTableItemName
    OptSubscript              -> NamedConstant         {cons("NamedConstant"), reject} %% AMBIGUOUS with IntegerTerm
  ConstantTableName
    Subscript                 -> NamedConstant         {cons("NamedConstant")}
  ControlLetter               -> NamedConstant         {cons("ControlLetter")}

  TableItemName               -> ConstantTableItemName

  Name                        -> ConstantTableName

%% 6.3 FUNCTION CALLS
%%
  UserDefinedFunctionCall     -> FunctionCall
  IntrinsicFunctionCall       -> FunctionCall
  MachineSpecificFunctionCall -> FunctionCall

%% Removed Opt from ActualParameterList to distinguish from Variable.
%% Now user-defined function calls must have parens. Resolution of function calls
%% without parens will require name resolution using a symbol table.
  FunctionName
    ActualParameterList       -> UserDefinedFunctionCall      {cons("UserDefinedFunctionCall")}

  LocFunction                 -> IntrinsicFunctionCall
  NextFunction                -> IntrinsicFunctionCall
  BitFunction                 -> IntrinsicFunctionCall
  ByteFunction                -> IntrinsicFunctionCall
  ShiftFunction               -> IntrinsicFunctionCall
  AbsFunction                 -> IntrinsicFunctionCall
  SignFunction                -> IntrinsicFunctionCall
  SizeFunction                -> IntrinsicFunctionCall
  BoundsFunction              -> IntrinsicFunctionCall
  NwdsenFunction              -> IntrinsicFunctionCall
  StatusInverseFunction       -> IntrinsicFunctionCall
  NentFunction                -> IntrinsicFunctionCall

  FunctionName                                                %% AMBIGUOUS with NamedConstant
    OptActualParameterList    -> MachineSpecificFunctionCall  {cons("MachineSpecificFunctionCall"), reject}

%% 6.3.1 LOC FUNCTION
%%
  'LOC' '(' LocArgument ')'   -> LocFunction          {cons("LocFunction")}

  Name                        -> LocArgument          {prefer}
%% Added because can't distinguish between the different names below
  NamedVariable               -> LocArgument
  StatementName               -> LocArgument
  ProcedureName               -> LocArgument
  FunctionName                -> LocArgument
  BlockReference              -> LocArgument

%% 6.3.2 NEXT FUNCTION
%%
  'NEXT' '('
    NextArgument ','
    IncrementAmount ')'       -> NextFunction         {cons("NextFunction")}

%% PointerFormula is not general enough anymore because of the accumulation
%% of various expressions into GeneralFormula, therefore replaced by
%% GeneralFormula producing NextArgument.
%%
%%PointerFormula              -> NextArgument

  GeneralFormula              -> NextArgument
  StatusFormula               -> NextArgument

  NumericFormula              -> IncrementAmount

%% 6.3.3 BIT FUNCTION
%%
  'BIT' '(' BitFormula ','
    Fbit ',' Nbit ')'         -> BitFunction          {cons("BitFunction")}

  NumericFormula              -> Fbit                 {cons("Fbit")}
  NumericFormula              -> Nbit                 {cons("Nbit")}

%% 6.3.4 BYTE FUNCTION
%%
  'BYTE' '(' CharacterFormula
    ',' Fbyte ',' Nbyte ')'   -> ByteFunction         {cons("ByteFunction")}

  NumericFormula              -> Fbyte
  NumericFormula              -> Nbyte

%% 6.3.5 SHIFT FUNCTIONS
%%
  ShiftDirection
    '(' BitFormula ','
    ShiftCount ')'            -> ShiftFunction        {cons("ShiftFunction")}

  'SHIFTL'                    -> ShiftDirection       {cons("SHIFTL")}
  'SHIFTR'                    -> ShiftDirection       {cons("SHIFTR")}

  NumericFormula              -> ShiftCount

%% 6.3.6 ABS FUNCTION
%%
  'ABS' '(' NumericFormula ')' -> AbsFunction         {cons("AbsFunction")}

%% 6.3.7 SIGN FUNCTION
%%
  'SGN' '(' NumericFormula ')' -> SignFunction        {cons("SignFunction")}

%% 6.3.7 SIZE FUNCTIONS
%%
  SizeType
    '(' SizeArgument ')'      -> SizeFunction         {cons("SizeFunction")}

  'BITSIZE'                   -> SizeType             {cons("BITSIZE")}
  'BYTESIZE'                  -> SizeType             {cons("BYTESIZE")}
  'WORDSIZE'                  -> SizeType             {cons("WORDSIZE")}

  Formula                     -> SizeArgument         {prefer}
  BlockName                   -> SizeArgument
  TypeName                    -> SizeArgument
  
%% 6.3.9 BOUNDS FUNCTIONS
%%
  WhichBound
    '(' BoundsArgument ','
    DimensionNumber ')'       -> BoundsFunction       {cons("BoundsFunction")}

  'LBOUND'                    -> WhichBound           {cons("LBOUND")}
  'UBOUND'                    -> WhichBound           {cons("UBOUND")}

  TableName                   -> BoundsArgument       {cons("Name"), prefer}
  TableTypeName               -> BoundsArgument

  CompileTimeNumericFormula   -> DimensionNumber
  
%% 6.3.10 NWDSEN FUNCTION
%%
  'NWDSEN'
    '(' NwdsenArgument ')'    -> NwdsenFunction       {cons("NwdsenFunction")}

  TableName                   -> NwdsenArgument       {cons("Name"), prefer}
  TableTypeName               -> NwdsenArgument

%% 6.3.11 STATUS INVERSE FUNCTIONS
%%
  'FIRST' '('
    StatusInverseArgument ')' -> StatusInverseFunction {cons("StatusInverseFunctionFIRST")}

  'LAST'  '('
    StatusInverseArgument ')' -> StatusInverseFunction {cons("StatusInverseFunctionLAST")}

  StatusFormula               -> StatusInverseArgument
  StatusTypeName              -> StatusInverseArgument

%% 6.3.12 NENT FUNCTION
%%
  'NENT' '(' NentArgument ')' -> NentFunction         {cons("NentFunction")}

  TableName                   -> NentArgument         {cons("Name"), prefer}
  TableTypeName               -> NentArgument


%%%%%%%%%%
%% 7.0 TYPE MATCHING AND TYPE CONVERSIONS
%%%%%%%%%%

  BitTypeConversion           -> BitConversion
  RepConversion               -> BitConversion

  '(*'
    BitTypeDescription
                         '*)' -> BitTypeConversion    {cons("BitTypeConversion")}
  BitTypeName                 -> BitTypeConversion
  'B'                         -> BitTypeConversion    {cons("BitTypeConversionB")}

%%  '(*'
%%    IntegerTypeDescription
%%                         '*)' -> IntegerConversion    {cons("IntegerConversion")}
%% Replacing above with two productions of IntegerTypeDescription during IntegerConversion
%% here to allow for distinction while traversing between conversions
%% that are unambiguously IntegerConversion and conversions that are
%% using IntegerTypeName to parse but could be other type conversions

  '(*'
    IntegerItemDescription
                         '*)' -> IntegerConversion    {cons("IntegerConversion")}
  '(*'
    IntegerTypeName
                         '*)' -> IntegerConversion    {cons("TypeNameConversion")}
  IntegerTypeName             -> IntegerConversion
  'S'                         -> IntegerConversion    {cons("IntegerConversionS")}
  'U'                         -> IntegerConversion    {cons("IntegerConversionU")}

  '(*'
    FloatingTypeDescription
                         '*)' -> FloatingConversion   {cons("FloatingConversion")}
  FloatingTypeName            -> FloatingConversion
  'F'                         -> FloatingConversion   {cons("FloatingConversionF")}

  '(*'
    FixedTypeDescription
                         '*)' -> FixedConversion      {cons("FixedConversion")}
  FixedTypeName               -> FixedConversion

  '(*'
    CharacterTypeDescription
                         '*)' -> CharacterConversion  {cons("CharacterConversion")}
  CharacterTypeName           -> CharacterConversion
  'C'                         -> CharacterConversion  {cons("CharacterConversionC")}

  '(*'
    StatusTypeName
                         '*)' -> StatusConversion     {cons("StatusConversion")}
  StatusTypeName              -> StatusConversion

  '(*'
    PointerTypeDescription
                         '*)' -> PointerConversion    {cons("PointerConversion")}
  PointerTypeName             -> PointerConversion
  'P'                         -> PointerConversion    {cons("PointerConversionP")}

  '(*' TableTypeName     '*)' -> TableConversion     {cons("TableConversion")}
  TableTypeName               -> TableConversion

  'REP'                       -> RepConversion       {cons("RepConversion")}


%%%%%%%%%%
%% 8.0 BASIC ELEMENTS (see also, JovialLex.sdf)
%%%%%%%%%%

%% 8.1 CHARACTERS (see also, JovialLex.sdf)
%%
    Letter                  -> Character
    Digit                   -> Character
    Mark                    -> Character
%%  OtherCharacter          -> Character

%% 8.2 SYMBOLS
%%
    Name                     -> Symbol
    ReservedWord             -> Symbol
    Operator                 -> Symbol
    Literal                  -> Symbol
    StatusConstant           -> Symbol
%%  Comment                  -> Symbol %% Moved to JovialLex.sdf
    DefineString             -> Symbol
    DefineCall               -> Symbol
    Letter                   -> Symbol
%%  Separator                -> Symbol

%% 8.2.1 NAMES (see JovialLex.sdf)
%%

%% 8.2.3 OPERATORS
%%
  ArithmeticOperator         -> Operator
  BitOperator                -> Operator
  RelationalOperator         -> Operator
  DereferenceOperator        -> Operator
  AssignmentOperator         -> Operator

  PlusOrMinus                -> ArithmeticOperator
  MultiplyDivideOrMod        -> ArithmeticOperator
  MultiplyOrDivide           -> ArithmeticOperator
  '**'                       -> ArithmeticOperator      {cons("PowerOp")}

  '+'                        -> PlusOrMinus             {cons("AddOp")}
  '-'                        -> PlusOrMinus             {cons("SubtractOp")}

  '*'                        -> MultiplyDivideOrMod     {cons("MultiplyOp")}
  '/'                        -> MultiplyDivideOrMod     {cons("DivideOp")}
  'MOD'                      -> MultiplyDivideOrMod     {cons("ModOp")}

  '*'                        -> MultiplyOrDivide        {cons("MultiplyOp")}
  '/'                        -> MultiplyOrDivide        {cons("DivideOp")}


%% Cons for NOT, AND, OR, XOR, EQV, DerefOp, and AssignOp will not be produced
  LogicalOperator            -> BitOperator
  'NOT'                      -> BitOperator             {cons("NOT")}

  'AND'                      -> LogicalOperator         {cons("AND")}
  'OR'                       -> LogicalOperator         {cons("OR")}
  'XOR'                      -> LogicalOperator         {cons("XOR")}
  'EQV'                      -> LogicalOperator         {cons("EQV")}

  EqualOrNotEqualOperator    -> RelationalOperator
  '<'                        -> RelationalOperator      {cons("LessThanOp")}
  '>'                        -> RelationalOperator      {cons("GreaterThanOp")}
  '<='                       -> RelationalOperator      {cons("LessOrEqualOp")}
  '>='                       -> RelationalOperator      {cons("GreaterOrEqualOp")}

  '='                        -> EqualOrNotEqualOperator {cons("EqualityOp")}
  '<>'                       -> EqualOrNotEqualOperator {cons("NotEqualOp")}

  '@'                        -> DereferenceOperator     {cons("DerefOp")}

  '='                        -> AssignmentOperator      {cons("AssignOp")}

%% 8.2.4 SEPARATORS
%%
%% TODO - see if constructors are needed for these
%%

%% 8.3 LITERALS
%%
  NumericLiteral             -> Literal
  BitLiteral                 -> Literal
  BooleanLiteral             -> Literal
  CharacterLiteral           -> Literal
  PointerLiteral             -> Literal

%% 8.3.1 NUMERIC LITERALS
%%
  IntegerLiteral             -> NumericLiteral
  FloatingLiteral            -> NumericLiteral
  FixedLiteral               -> NumericLiteral

  Number                     -> IntegerLiteral        {cons("IntegerLiteral")}
  Icon                       -> Number

  RealLiteral                -> FloatingLiteral
  Icon Exponent              -> RealLiteral           {cons("RealLiteralIE")}
  FractionalForm OptExponent -> RealLiteral           {cons("RealLiteralFF")}

  'E' OptSign Number         -> Exponent              {cons("Exponent")}

  '+'                        -> Sign                  {cons("PLUS")}
  '-'                        -> Sign                  {cons("MINUS")}

  OptNumber '.' OptNumber    -> FractionalForm        {cons("FractionalForm")}

  RealLiteral                -> FixedLiteral

  Exponent                   -> OptExponent
  % empty %                  -> OptExponent           {cons("no-exponent")}
  Number                     -> OptNumber
  % empty %                  -> OptNumber             {cons("no-number")}

%% 8.3.2 BIT LITERALS
%%
  BeadSize 'B' "'" Bead+ "'"  -> BitLiteral              {cons("BitLiteral")}

  Digit                       -> Bead

%% 8.3.3 BOOLEAN LITERALS
%%
  'TRUE'                   -> BooleanLiteral          {cons("True")}
  'FALSE'                  -> BooleanLiteral          {cons("False")}

%% 8.3.3 CHARACTER LITERALS
%%
%% CharString moved to JovialLex.sdf
  CharString               -> CharacterLiteral        {cons("CharacterLiteral")}

%% 8.3.4 POINTER LITERALS
%%
  'NULL'                   -> PointerLiteral          {cons("Null")}

%% Comment moved to JovialLex.sdf
%%  '"' Character* '"'     -> Comment                 {cons("Comment")}
%%  '%' Character* '%'     -> Comment                 {cons("Comment")}


%%%%%%%%%%
%% 9.0 DIRECTIVES
%%%%%%%%%%

  CompoolDirective         -> Directive
  CopyDirective            -> Directive
  SkipDirective            -> Directive
  BeginDirective           -> Directive
  EndDirective             -> Directive
  LinkageDirective         -> Directive
  TraceDirective           -> Directive
  InterferenceDirective    -> Directive
  ReducibleDirective       -> Directive
  NolistDirective          -> Directive
  ListDirective            -> Directive
  EjectDirective           -> Directive
  ListinvDirective         -> Directive
  ListexpDirective         -> Directive
  ListbothDirective        -> Directive
  BaseDirective            -> Directive
  IsbaseDirective          -> Directive
  DropDirective            -> Directive
  LeftrightDirective       -> Directive
  RearrangeDirective       -> Directive
  InitializeDirective      -> Directive
  OrderDirective           -> Directive

%% 9.1 COMPOOL DIRECTIVE
%%
  '!COMPOOL'
     CompoolDirectiveList ';'   -> CompoolDirective         {cons("CompoolDirective")}

  OptCompoolFileName
     {CompoolDeclaredName ','}+ -> CompoolDirectiveList     {cons("CompoolDirectiveList")}

  '(' OptCompoolFileName ')'    -> CompoolDirectiveList     {cons("CompoolDirectiveList")}

      Name                      -> CompoolDeclaredName
  '(' Name ')'                  -> CompoolDeclaredName      {cons("Name")}

  CharacterLiteral              -> CompoolFileName

  CompoolFileName               -> OptCompoolFileName
  % empty %                     -> OptCompoolFileName       {cons("no-compool-file-name")}


%% 9.2 TEXT DIRECTIVES
%%

%% 9.2.1 COPY DIRECTIVES
%%
  '!COPY' CharacterLiteral ';'  -> CopyDirective            {cons("CopyDirective")}

%% 9.2.2 SKIP, BEGIN, AND END DIRECTIVES
%%
  '!SKIP'  OptLetter ';'        -> SkipDirective            {cons("SkipDirective")}

  '!BEGIN' OptLetter ';'        -> BeginDirective           {cons("BeginDirective")}

  '!END' ';'                    -> EndDirective             {cons("EndDirective")}

  Letter                        -> OptLetter
  % empty %                     -> OptLetter                {cons("no-letter")}

%% 9.3 LINKAGES DIRECTIVES
%%
  '!LINKAGE' Symbol+ ';'        -> LinkageDirective         {cons("LinkageDirective")}

%% 9.4 TRACE DIRECTIVES
%%
  '!TRACE' OptTraceControl
    {Name ','}+ ';'             -> TraceDirective           {cons("TraceDirective")}

  '(' BooleanFormula ')'        -> TraceControl             {cons("TraceControl")}
  
  TraceControl                  -> OptTraceControl
  % empty %                     -> OptTraceControl          {cons("no-trace-control")}

%% 9.5 INTERFERENCE DIRECTIVES
%%
  '!INTERFERENCE'
    InterferenceControl ';'     -> InterferenceDirective    {cons("InterferenceDirective")}

  DataName ':' {DataName ','}+  -> InterferenceControl      {cons("InterferenceControl")}

  Name                          -> DataName

%% 9.6 REDUCIBLE DIRECTIVES
%%
  '!REDUCIBLE' ';'              -> ReducibleDirective       {cons("ReducibleDirective")}


%% 9.7 LISTING DIRECTIVES
%%
%% 9.7.1 SOURCE-LISTING DIRECTIVES
%%
  '!NOLIST' ';'                  -> NolistDirective         {cons("NolistDirective")}
  '!LIST'   ';'                  ->   ListDirective         {cons("  ListDirective")}
  '!EJECT'  ';'                  ->  EjectDirective         {cons(" EjectDirective")}

%% 9.7.2 DEFINE-LISTING DIRECTIVES
%%
  '!LISTINV'  ';'                -> ListinvDirective        {cons("ListinvDirective")}
  '!LISTEXP'  ';'                -> ListexpDirective        {cons("ListexpDirective")}
  '!LISTBOTH' ';'                -> ListbothDirective       {cons("ListbothDirective")}

%% 9.8 REGISTER DIRECTIVES
%%
  '!BASE'   DataName
    IntegerLiteral   ';'         -> BaseDirective           {cons("BaseDirective")}

  '!ISBASE' DataName
    IntegerLiteral   ';'         -> IsbaseDirective         {cons("IsbaseDirective")}

  '!DROP'
    IntegerLiteral   ';'         -> DropDirective           {cons("DropDirective")}

%% 9.9 EXPRESSION EVALUATION ORDER DIRECTIVES
%%
  '!LEFTRIGHT' ';'               -> LeftrightDirective      {cons("LeftrightDirective")}
  '!REARRANGE' ';'               -> RearrangeDirective      {cons("RearrangeDirective")}

%% 9.10 INITIALIZATION DIRECTIVES
%%
  '!INITIALIZE' ';'               -> InitializeDirective    {cons("InitializeDirective")}

%% 9.11 ALLOCATION ORDER DIRECTIVES
%%
  '!ORDER' ';'                    -> OrderDirective         {cons("OrderDirective")}
