module Main                           %% Jovial grammar

imports JovialLex

exports 

context-free start-symbols 
  Module

sorts
  
%%CompleteProgram
% 1.1    %  Module
% 1.2.1  %  CompoolModule CompoolName
% 1.2.2  %  ProcedureModule NonNestedSubroutine
% 1.2.3  %  MainProgramModule ProgramName ProgramBody

% 2.0    %  Declaration CompoolDeclaration
            DeclarationList NonNestedSubroutineList CompoolDeclarationList
% 2.1    %  DataDeclaration

% 3.0    %  SubroutineDeclaration SubroutineDefinition

% 4.0    %  Statement SimpleStatement StatementOrNull NullBlockStatement Label StatementName LabeledCompoundStatement
            LabeledSimpleStatement LabelList

InterferenceControl
TraceControl
OptTraceControl
OptLetter
CompoolFileName
CompoolDeclaredName
OptCompoolFileName
CompoolDirectiveList
PostProcDirective
OrderDirective
InitializeDirective
RearrangeDirective
LeftrightDirective
DropDirective
IsbaseDirective
BaseDirective
ListbothDirective
ListexpDirective
ListinvDirective
EjectDirective
ListDirective
NolistDirective
ReducibleDirective
InterferenceDirective
TraceDirective
LinkageDirective
EndDirective
BeginDirective
SkipDirective
CopyDirective
AlignDirective
AlwaysDirective
Directive
CompoolDirective
OptNumber
OptExponent
FractionalForm
Exponent
RealLiteral
Number
NumericLiteral
LogicalOperator
AssignmentOperator
DereferenceOperator
BitOperator
ArithmeticOperator
%%Comment %%Moved to JovialLex.sdf
Literal
Operator
Symbol
BitTypeConversion
NentArgument
StatusInverseArgument
NwdsenArgument
DimensionNumber
BoundsArgument
WhichBound
SizeArgument
SizeType
ShiftCount
ShiftDirection
Nbyte
Fbyte
IncrementAmount
NextArgument
LocArgument
NentFunction
StatusInverseFunction
NwdsenFunction
BoundsFunction
SizeFunction
SignFunction
AbsFunction
ShiftFunction
ByteFunction
BitFunction
NextFunction
MachineSpecificFunctionCall
IntrinsicFunctionCall
UserDefinedFunctionCall
ConstantTableItemName
RepConversion
Nbit
Fbit
Index
PointerItemName
Dereference
BlockDereference
OptBlockDereference
Subscript
OptTableDereference
OptSubscript
TableDereference
ItemDereference
BlockTableEntry
BlockTableItem
BlockTable
BlockItem
TableEntry
TableItem
TableItemNoDeref
Table
Item
RepFunctionVariable
ByteFunctionVariable
BitFunctionVariable
NamedVariable
TableConversion
PointerConversion
PointerLiteral
StatusConversion
CharacterConversion
CharacterLiteral
EqualOrNotEqualOperator
RelationalOperator
BitConversion
BooleanLiteral
BitLiteral
BitPrimary
LogicalOperand
FixedConversion
FixedLiteral
FloatingConversion
FloatingLiteral
MultiplyOrDivide
FunctionCall
NamedConstant
IntegerConversion
IntegerLiteral
MultiplyDivideOrMod
Sign
PlusOrMinus
OptSign
CompileTimeNumericFormula
AbortPhrase
BlockReference
ActualOutputParameter
ActualParameterList
OptActualOutputParameters
ActualInputParameter
OptAbortPhrase
OptActualParameterList
MachineSpecificProcedureCall
UserDefinedProcedureCall
CaseIndex
DefaultOption
OptFALLTHRU
CaseIndexGroup
CaseAlternative
CaseBody
CaseSelectorFormula
ElseClause
NumericMachineParameter
ByFormula
ThenPhrase
ByPhrase
OptByOrThenPhrase
WhilePhrase
Continuation
OptWhilePhrase
ByOrThenPhrase
OptContinuation
InitialValue
ControlVariable
ControlClause
ControlItem
BooleanFormula
ForClause
WhileClause
ControlledStatement
LoopType
Variable
VariableLVal
Formula OptFormula
VariableList
AbortStatement
StopStatement
ExitStatement
GotoStatement
ReturnStatement
ProcedureCallStatement
CaseStatement
IfStatement
IfSimpleStatement
IfElseStatement
ConditionalStatement
LoopStatement
AssignmentStatement
SubroutineName
ParameterBinding
OutputParameterName
InputParameterName
OptParameterBinding
FormalOutputParameter
FormalParameterList
OptFormalOutputParameter
FormalInputParameter
FunctionName
FunctionBody
FunctionHeading
SubroutineBody
SubroutineAttribute
OptFormalParameterList
OptSubroutineAttribute
ProcedureName
ProcedureBody
ProcedureHeading
FunctionDefinition
ProcedureDefinition
FunctionDeclaration
ProcedureDeclaration
DataName
Spacer
OverlayElement
OverlayString
AbsoluteAddress
OverlayAddress
OverlayExpression
OptAbsoluteAddress
RefSpecificationChoice
CompoundRef
SimpleRef
DefBlockInstantiation
DefSpecificationChoice
CompoundDef
SimpleDef
RefSpecification
DefSpecification
ActualDefineParameter
NoList
DefineCall
ActualDefineParameterList
Character
FormalDefineParameterList
FormalDefineParameter
DefineString
OptFormalDefineParameterList
DefinitionPart
DefineName
LikeOption
OptLikeOption
TableTypeSpecifier
BlockTypeDeclaration
TableTypeDeclaration
ItemTypeDeclaration
BlockPreset
BlockPresetList
BlockPresetValue
RepetitionCount
ConstantIndex
PresetValue
PresetValuePositioner
TablePreset
TablePresetList
OptItemPresetValue
LocFunction
ItemPresetValue
AllocationSpecifier
BlockBodyOptions
OptBlockPreset
BlockBodyPart
BlockName
ConstantTableName
ItemPreset
ConstantItemName
SpecifiedTableOptions
SpecifiedTableBody
SpecifiedTableItemDeclaration
StartingWord
StartingBit
LocationSpecifier
EntrySize
OptEntrySize
SpecifiedItemDescription
WordsPerEntry
TableItemName
OrdinaryTableOptions
OrdinaryTableBody
OrdinaryTableItemDeclaration
PackingSpecifier
OptPackingSpecifier
BitsPerEntry
OptBitsPerEntry
StructureSpecifier
LowerBoundOption
LowerBound
UpperBound
OptLowerBoundOption
DimensionList
Dimension
SpecifiedEntrySpecifier
OrdinaryEntrySpecifier
OptTablePreset
EntrySpecifier
OptStructureSpecifier
TableDescription
OptDimensionList
TableName
BlockTypeName
TableTypeName
TypeName
OptTypeName
PointerTypeName
PointerItemDescription
StatusSize
Status
StatusListIndex
StatusConstant
SpecifiedSublist
OptDefaultSublist
DefaultSublist
StatusList
OptStatusSize
StatusTypeName
StatusItemDescription
CharacterSize
OptCharacterSize
CharacterTypeName
CharacterItemDescription
BitSize
OptBitSize
BitTypeName
BitItemDescription
OptFractionSpecifier
FixedTypeName
FixedItemDescription
RoundOrTruncate
FloatingTypeName
FloatingItemDescription
ItemTypeName
OptIntegerSize
OptRoundOrTruncate
IntegerTypeName
IntegerItemDescription
PointerTypeDescription
StatusTypeDescription
CharacterTypeDescription
BitTypeDescription
FixedTypeDescription
FloatingTypeDescription
IntegerTypeDescription
OptItemPreset
ItemTypeDescription
OptAllocationSpecifier
ItemName
BlockDeclaration
TableDeclaration
ItemDeclaration
ConstantDeclaration
NullDeclaration
InlineDeclaration
OverlayDeclaration
ExternalDeclaration
DefineDeclaration
StatementNameDeclaration
TypeDeclaration
FixedMachineParameter
FloatingMachineParameter
IntegerSize
FractionSpecifier
ScaleSpecifier
Precision
OptPrecision
ParensPrecision
IntegerMachineParameter

%% Changes to combine Declaration and Statement lists
DeclOrStmt
DeclsAndStmts

%%%%%%%%%%
%% Changes to add operator precedence to the grammar based on Fortran
%%%%%%%%%%
Primary
Level1Expr
Level2Expr
Level3Expr
Level4Expr
EQ
AddOperand
MultOperand
AndOperand
Conversion

context-free syntax


%%%%%%%%%%
%% 1.1 THE COMPLETE PROGRAM
%%%%%%%%%%

%%Module+                    -> CompleteProgram       {cons("CompleteProgram")}

  CompoolModule              -> Module                {cons("Module")}
  ProcedureModule            -> Module                {cons("Module")}
  MainProgramModule          -> Module                {cons("Module")}


%%%%%%%%%%
%% 1.2 MODULES
%%%%%%%%%%

%% 1.2.1 COMPOOL MODULES
%%
  'START'
    Directive*
    'COMPOOL' CompoolName ';'
     CompoolDeclarationList
  'TERM'                     -> CompoolModule          {cons("CompoolModule")}

  Name                       -> CompoolName            {cons("Name")}

  CompoolDeclaration*        -> CompoolDeclarationList {cons("DeclarationList")} %% Using DeclarationList traversals

%% 1.2.2 PROCEDURE MODULES
%%
  'START'
%%  Directive* has been moved from the original grammar to DeclarationList
    DeclarationList
    NonNestedSubroutineList
  'TERM'                     -> ProcedureModule       {cons("ProcedureModule")}
  
  'DEF' SubroutineDefinition -> NonNestedSubroutine   {cons("NonNestedSubroutineDEF")}
        SubroutineDefinition -> NonNestedSubroutine   {cons("NonNestedSubroutine")}

  Declaration*               -> DeclarationList          {cons("DeclarationList")}
  NonNestedSubroutine*       -> NonNestedSubroutineList  {cons("NonNestedSubroutineList")}

%% Odd construction not apparently in the grammar, see gitlab-issue-{372,390}.jov
  'BEGIN'
    NonNestedSubroutine*
  'END'                      -> NonNestedSubroutineList  {cons("NonNestedSubroutineList")}

%% 1.2.3 MAIN PROGRAM MODULES
%%
  'START'
%%  Directive* has been moved from the original grammar to DeclarationList
    DeclarationList
  'PROGRAM'
    ProgramName ';'
    ProgramBody
    NonNestedSubroutineList
  'TERM'                     -> MainProgramModule     {cons("MainProgramModule")}

  Name                       -> ProgramName           {cons("Name")}

  StatementOrNull            -> ProgramBody           {cons("ProgramSimpleBody")}

  'BEGIN'
%%  Directive*, Declaration* and Statement+ moved from the original grammar to DeclsAndStmts
    DeclsAndStmts
    SubroutineDefinition*
    LabelList
  'END'                      -> ProgramBody           {cons("ProgramBody"), prefer}


%% 1.4 IMPLEMENTATION PARAMETERS
%%
  'BITSINBYTE'               -> IntegerMachineParameter {cons("BITSINBYTE")}
  'BITSINWORD'               -> IntegerMachineParameter {cons("BITSINWORD")}
  'LOCSINWORD'               -> IntegerMachineParameter {cons("LOCSINWORD")}
  'BYTEPOS' '('
    CompileTimeNumericFormula
            ')'              -> IntegerMachineParameter {cons("BYTEPOS")} %% cons used to be "BitsInWord"
  'BYTESINWORD'              -> IntegerMachineParameter {cons("BYTESINWORD")}
  'BITSINPOINTER'            -> IntegerMachineParameter {cons("BITSINPOINTER")}
  'INTPRECISION'             -> IntegerMachineParameter {cons("INTPRECISION")}
  'FLOATPRECISION'           -> IntegerMachineParameter {cons("FLOATPRECISION")}
  'FIXEDPRECISION'           -> IntegerMachineParameter {cons("FIXEDPRECISION")}
  'FLOATRADIX'               -> IntegerMachineParameter {cons("FLOATRADIX")}
  'IMPLFLOATPRECISION'
    '(' Precision ')'        -> IntegerMachineParameter {cons("IMPLFLOATPRECISION")}
  'IMPLFIXEDPRECISION'
    '(' ScaleSpecifier ','
     FractionSpecifier ')'   -> IntegerMachineParameter {cons("IMPLFIXEDPRECISION")}
  'IMPLINTSIZE'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("IMPLINTSIZE")}
  'MAXFLOATPRECISION'        -> IntegerMachineParameter {cons("MAXFLOATPRECISION")}
  'MAXFIXEDPRECISION'        -> IntegerMachineParameter {cons("MAXFIXEDPRECISION")}
  'MAXINTSIZE'               -> IntegerMachineParameter {cons("MAXINTSIZE")}
  'MAXBYTES'                 -> IntegerMachineParameter {cons("MAXBYTES")}
  'MAXBITS'                  -> IntegerMachineParameter {cons("MAXBITS")}
  'MAXINT'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("MAXINT")}
  'MININT'
    '(' IntegerSize    ')'   -> IntegerMachineParameter {cons("MININT")}
  'MAXTABLESIZE'             -> IntegerMachineParameter {cons("MAXTABLESIZE")}
  'MAXSTOP'                  -> IntegerMachineParameter {cons("MAXSTOP")}
  'MINSTOP'                  -> IntegerMachineParameter {cons("MINSTOP")}
  'MAXSIGNDIGITS'            -> IntegerMachineParameter {cons("MAXSIGNDIGITS")}
  'MINSIZE'
    '('
        CompileTimeNumericFormula
    ')'                      -> IntegerMachineParameter {cons("MINSIZE")}
  'MINFRACTION'
    '('
        CompileTimeNumericFormula
    ')'                      -> IntegerMachineParameter {cons("MINFRACTION")}
  'MINSCALE'
    '('
        CompileTimeNumericFormula
     ')'                     -> IntegerMachineParameter {cons("MINSCALE")}
  'MINRELPRECISION'
     '('
    CompileTimeNumericFormula
     ')'                     -> IntegerMachineParameter {cons("MINRELPRECISION")}

  'MAXFLOAT'
     '(' Precision ')'       -> FloatingMachineParameter {cons("MAXFLOAT")}
  'MINFLOAT'
     '(' Precision ')'       -> FloatingMachineParameter {cons("MINFLOAT")}
  'FLOATRELPRECISION'
     '(' Precision ')'       -> FloatingMachineParameter {cons("FLOATRELPRECISION")}
  'FLOATUNDERFLOW'
     '(' Precision ')'       -> FloatingMachineParameter {cons("FLOATUNDERFLOW")}

  'MAXFIXED'
     '('
    ScaleSpecifier ','
    FractionSpecifier
     ')'                     -> FixedMachineParameter    {cons("MAXFIXED")}

  'MINFIXED'
     '('
    ScaleSpecifier ','
    FractionSpecifier
     ')'                     -> FixedMachineParameter    {cons("MINFIXED")}


%%%%%%%%%%
%% 2.0 DECLARATIONS
%%%%%%%%%%

  DataDeclaration            -> Declaration
  TypeDeclaration            -> Declaration
  SubroutineDeclaration      -> Declaration           {reject} %% AMBIGUOUS with NonNestedSubroutine
  StatementNameDeclaration   -> Declaration
  DefineDeclaration          -> Declaration
  ExternalDeclaration        -> Declaration
  OverlayDeclaration         -> Declaration
  InlineDeclaration          -> Declaration
  NullDeclaration            -> Declaration
  'BEGIN'
    Declaration+
  'END'                      -> Declaration           {cons("Declaration")}
  Directive                  -> Declaration

  ExternalDeclaration        -> CompoolDeclaration
  ConstantDeclaration        -> CompoolDeclaration
  TypeDeclaration            -> CompoolDeclaration
  DefineDeclaration          -> CompoolDeclaration
  OverlayDeclaration         -> CompoolDeclaration
  NullDeclaration            -> CompoolDeclaration
  'BEGIN'
    CompoolDeclaration+
  'END'                      -> CompoolDeclaration    {cons("Declaration")} %% Using Declaration traversals
  Directive                  -> CompoolDeclaration


%% 2.1 DATA DECLARATIONS
%%

  ItemDeclaration             -> DataDeclaration
  TableDeclaration            -> DataDeclaration
  ConstantDeclaration         -> DataDeclaration
  BlockDeclaration            -> DataDeclaration

%% 2.1.1 ITEM DECLARATIONS
%%

  'ITEM' ItemName
    OptAllocationSpecifier
    ItemTypeDescription
    OptItemPreset         ';' -> ItemDeclaration         {cons("ItemDeclaration")}

  Name                        -> ItemName

  IntegerTypeDescription      -> ItemTypeDescription
  FloatingTypeDescription     -> ItemTypeDescription
  FixedTypeDescription        -> ItemTypeDescription
  BitTypeDescription          -> ItemTypeDescription
  CharacterTypeDescription    -> ItemTypeDescription
  StatusTypeDescription       -> ItemTypeDescription
  PointerTypeDescription      -> ItemTypeDescription

  ItemTypeName                -> ItemTypeDescription     {prefer}
  %% Prefer above fixes ambiguity with type names

%% 2.1.1.1 INTEGER TYPE DESCRIPTIONS
%%

  IntegerItemDescription      -> IntegerTypeDescription
  IntegerTypeName             -> IntegerTypeDescription

%%  'S'
  SignedTypeDesc
      OptRoundOrTruncate
      OptIntegerSize          -> IntegerItemDescription  {cons("IntegerItemDescription")}
%%  'U'
  UnsignedTypeDesc
      OptRoundOrTruncate
      OptIntegerSize          -> IntegerItemDescription  {cons("IntegerItemDescriptionU")}

  CompileTimeNumericFormula   -> IntegerSize             {cons("ItemSize")}
  EQ                          -> IntegerSize             {reject}

  IntegerSize                 -> OptIntegerSize
  % empty %                   -> OptIntegerSize          {cons("no-item-size")}

  ItemTypeName                -> IntegerTypeName         {cons("TypeName")} %% using general cons for conversion traversal purposes


%% 2.1.1.2 FLOATING TYPE DESCRIPTIONS
%%

  FloatingItemDescription     -> FloatingTypeDescription
  FloatingTypeName            -> FloatingTypeDescription   {reject} %% Using ItemTypeName

%%'F'
  FloatingTypeDesc
      OptRoundOrTruncate
      OptPrecision            -> FloatingItemDescription {cons("FloatingItemDescription")}

  ',' 'R'                     -> RoundOrTruncate         {cons("R")}
  ',' 'T'                     -> RoundOrTruncate         {cons("T")}
  ',' 'Z'                     -> RoundOrTruncate         {cons("Z")}

  RoundOrTruncate             -> OptRoundOrTruncate
  % empty %                   -> OptRoundOrTruncate      {cons("no-round-or-truncate")}

%%CompileTimeNumericFormula   -> Precision
  IntegerMachineParameter     -> Precision
  IntegerLiteral              -> Precision
  '(' IntegerLiteral ')'      -> ParensPrecision         {cons("Parens")}
  ParensPrecision             -> Precision

  Precision                   -> OptPrecision
  % empty %                   -> OptPrecision            {cons("no-precision")}

  ItemTypeName                -> FloatingTypeName


%% 2.1.1.3 FIXED TYPE DESCRIPTIONS
%%

  FixedItemDescription        -> FixedTypeDescription
  FixedTypeName               -> FixedTypeDescription    {reject} %% Using ItemTypeName

%%  'A'
  FixedTypeDesc
      OptRoundOrTruncate
      ScaleSpecifier
      OptFractionSpecifier    -> FixedItemDescription    {cons("FixedItemDescription")}

  CompileTimeNumericFormula   -> ScaleSpecifier          {cons("ScaleSpecifier")}
  EQ                          -> ScaleSpecifier          {reject}
  CompileTimeNumericFormula   -> FractionSpecifier       {cons("FractionSpecifier")}
  EQ                          -> FractionSpecifier       {reject}
%% What to do here

  ',' FractionSpecifier       -> OptFractionSpecifier    {cons("OptFractionSpecifier")}
  % empty %                   -> OptFractionSpecifier    {cons("no-fraction-specifier")}

  ItemTypeName                -> FixedTypeName


%% 2.1.1.4 BIT TYPE DESCRIPTIONS
%%

  BitItemDescription          -> BitTypeDescription
  BitTypeName                 -> BitTypeDescription       {reject} %% Using ItemTypeName

%%  'B'
  BitTypeDesc
      OptBitSize              -> BitItemDescription       {cons("BitItemDescription")}

  CompileTimeNumericFormula   -> BitSize                  {cons("ItemSize")}
  EQ                          -> BitSize                  {reject}

  BitSize                     -> OptBitSize
  % empty %                   -> OptBitSize               {cons("no-item-size")}

  ItemTypeName                -> BitTypeName


%% 2.1.1.5 CHARACTER TYPE DESCRIPTIONS
%%

  CharacterItemDescription    -> CharacterTypeDescription
  CharacterTypeName           -> CharacterTypeDescription  {reject} %% Using ItemTypeName

%% 'C'
  CharacterTypeDesc
     OptCharacterSize         -> CharacterItemDescription  {cons("CharacterItemDescription")}

  CompileTimeNumericFormula   -> CharacterSize             {cons("ItemSize")}
  EQ                          -> CharacterSize             {reject}

  CharacterSize               -> OptCharacterSize
  % empty %                   -> OptCharacterSize          {cons("no-item-size")}

  ItemTypeName                -> CharacterTypeName


%% 2.1.1.6 STATUS TYPE DESCRIPTIONS
%%

  StatusItemDescription      -> StatusTypeDescription
  StatusTypeName             -> StatusTypeDescription  {reject} %% Using ItemTypeName

  'STATUS' OptStatusSize
     '(' StatusList ')'      -> StatusItemDescription  {cons("StatusItemDescription")}

  DefaultSublist             -> StatusList
  OptDefaultSublist
    {SpecifiedSublist ','}+  -> StatusList             {cons("StatusList")}

  {StatusConstant ','}+      -> DefaultSublist         {cons("DefaultSublist")}

  DefaultSublist ','         -> OptDefaultSublist      {cons("OptDefaultSublist")}
  % empty %                  -> OptDefaultSublist      {cons("no-default-sublist")}

  StatusListIndex
    {StatusConstant ','}+    -> SpecifiedSublist       {cons("SpecifiedSublist")}

  CompileTimeNumericFormula  -> StatusListIndex

  'V' '(' Status ')'         -> StatusConstant         {cons("StatusConstant")}

  Name                       -> Status
  Letter                     -> Status
  ReservedWord               -> Status  {prefer}       %%fixes ambiguity between Name and ReservedWord

  ItemTypeName               -> StatusTypeName

  CompileTimeNumericFormula  -> StatusSize             {cons("ItemSize")}

  StatusSize                 -> OptStatusSize
  % empty %                  -> OptStatusSize          {cons("no-item-size")}

%% 2.1.1.7 POINTER TYPE DESCRIPTIONS
%%

  PointerItemDescription      -> PointerTypeDescription
  PointerTypeName             -> PointerTypeDescription  {reject} %% Using ItemTypeName

%%  'P'
  PointerTypeDesc
      OptTypeName             -> PointerItemDescription  {cons("PointerItemDescription")}

  ItemTypeName                -> PointerTypeName         {cons("PointerTypeName")}

  ItemTypeName                -> TypeName  {prefer}      %%fixes ambiguity between ItemTypeName, TableTypeName, and BlockTypeName
  TableTypeName               -> TypeName
  BlockTypeName               -> TypeName

  TypeName                    -> OptTypeName             {cons("TypeName")}
  % empty %                   -> OptTypeName             {cons("no-type-name")}

%% 2.1.2 TABLE DECLARATIONS
%%
  'TABLE' TableName
    OptAllocationSpecifier
    OptDimensionList
    TableDescription         -> TableDeclaration         {cons("TableDeclaration")}

  OptStructureSpecifier
    EntrySpecifier           -> TableDescription         {cons("TableDescription")}

  TableTypeName
    OptTablePreset ';'       -> TableDescription         {prefer, cons("TableDescriptionName")} %% removes ambiguity with other production of TableDescription

  OrdinaryEntrySpecifier     -> EntrySpecifier
  SpecifiedEntrySpecifier    -> EntrySpecifier

  Name                       -> TableName

%% 2.1.2.1 TABLE DIMENSION LISTS
%%
  '(' {Dimension ','}+ ')'   -> DimensionList            {cons("DimensionList")}

  DimensionList              -> OptDimensionList
  % empty %                  -> OptDimensionList         {cons("no-dimension-list")}

  OptLowerBoundOption
    UpperBound               -> Dimension                {cons("Dimension")}
  '*'                        -> Dimension                {cons("DimensionSTAR")}

  LowerBound ':'             -> LowerBoundOption         {cons("LowerBoundOption")}

  LowerBoundOption           -> OptLowerBoundOption
  % empty %                  -> OptLowerBoundOption      {cons("no-lower-bound-option")}

  CompileTimeNumericFormula  -> LowerBound
  CompileTimeNumericFormula  -> UpperBound

%% 2.1.2.2 TABLE STRUCTURE
%%
  'PARALLEL'                 -> StructureSpecifier       {cons("StructureSpecifier")}
%%  'T'
  StrucSpecT
    OptBitsPerEntry          -> StructureSpecifier       {cons("StructureSpecifierT")}

  StructureSpecifier         -> OptStructureSpecifier
  % empty %                  -> OptStructureSpecifier    {cons("no-structure-specifier")}

  CompileTimeNumericFormula  -> BitsPerEntry

  BitsPerEntry               -> OptBitsPerEntry
  % empty %                  -> OptBitsPerEntry          {cons("no-bits-per-entry")}

%% 2.1.2.3 ORDINARY TABLE ENTRIES
%%
  OptPackingSpecifier
    ItemTypeDescription
    OptTablePreset ';'         -> OrdinaryEntrySpecifier {cons("OrdinaryEntrySpecifier")}

  OptPackingSpecifier
    OptTablePreset ';'
    OrdinaryTableBody          -> OrdinaryEntrySpecifier {cons("OrdinaryEntrySpecifierBody")}

  NPackSpec                    -> PackingSpecifier       {cons("PackingSpecifier")}
  MPackSpec                    -> PackingSpecifier       {cons("PackingSpecifier")}
  DPackSpec                    -> PackingSpecifier       {cons("PackingSpecifier")}

  OrdinaryTableItemDeclaration -> OrdinaryTableBody
  'BEGIN'
    OrderDirective*
    OrdinaryTableOptions+
  'END'                        -> OrdinaryTableBody      {cons("OrdinaryTableBody")}

  PackingSpecifier             -> OptPackingSpecifier
  % empty %                    -> OptPackingSpecifier    {cons("no-packing-specifier")}

  'ITEM' TableItemName
    ItemTypeDescription
    OptPackingSpecifier
    OptTablePreset ';'         -> OrdinaryTableItemDeclaration {cons("OrdinaryTableItemDeclaration")}

  Name                         -> TableItemName

  OrdinaryTableItemDeclaration -> OrdinaryTableOptions
  NullDeclaration              -> OrdinaryTableOptions

%% 2.1.2.4 SPECIFIED TABLE ENTRIES
%%

  WordsPerEntry
    SpecifiedItemDescription
    OptTablePreset ';'           -> SpecifiedEntrySpecifier  {cons("SpecifiedEntrySpecifier")}

  WordsPerEntry
    OptTablePreset ';'
    SpecifiedTableBody           -> SpecifiedEntrySpecifier  {cons("SpecifiedEntrySpecifierBody")}

  'W' OptEntrySize               -> WordsPerEntry            {cons("WordsPerEntryW")}
  'V'                            -> WordsPerEntry            {cons("WordsPerEntryV")}

  CompileTimeNumericFormula      -> EntrySize
  EQ                             -> EntrySize                {reject}

  EntrySize                      -> OptEntrySize
  % empty %                      -> OptEntrySize             {cons("no-entry-size")}

  ItemTypeDescription 'POS'
    '(' LocationSpecifier ')'    -> SpecifiedItemDescription {cons("SpecifiedItemDescription")}

  StartingBit ',' StartingWord   -> LocationSpecifier        {cons("LocationSpecifier")}

  CompileTimeNumericFormula      -> StartingBit
  '*'                            -> StartingBit              {cons("StartingBitSTAR")}

  CompileTimeNumericFormula      -> StartingWord

  SpecifiedTableItemDeclaration  -> SpecifiedTableBody
  'BEGIN'
    SpecifiedTableOptions+
  'END'                          -> SpecifiedTableBody       {cons("SpecifiedTableBody")}

  'ITEM' TableItemName
    SpecifiedItemDescription
    OptTablePreset ';'           -> SpecifiedTableItemDeclaration
                                                             {cons("SpecifiedTableItemDeclaration")}

  SpecifiedTableItemDeclaration -> SpecifiedTableOptions
  NullDeclaration               -> SpecifiedTableOptions

%% 2.1.3 CONSTANT DECLARATIONS
%%
  'CONSTANT' 'ITEM'
    ConstantItemName
    ItemTypeDescription
    ItemPreset ';'               -> ConstantDeclaration      {cons("ConstantItemDeclaration")}

  'CONSTANT' 'TABLE'
    ConstantTableName
    OptDimensionList
    TableDescription             -> ConstantDeclaration      {cons("ConstantTableDeclaration")}

  Name                           -> ConstantItemName
  Name                           -> ConstantTableName

%% 2.1.4 BLOCK DECLARATIONS
%%
  'BLOCK' BlockName
    OptAllocationSpecifier ';'
    BlockBodyPart                -> BlockDeclaration         {cons("BlockDeclarationBodyPart")}
  
  'BLOCK' BlockName
    OptAllocationSpecifier
    BlockTypeName
    OptBlockPreset ';'           -> BlockDeclaration         {cons("BlockDeclarationTypeName")}
  
  Name                           -> BlockName                {cons("Name")}

  NullDeclaration                -> BlockBodyPart
  DataDeclaration                -> BlockBodyPart

  'BEGIN'
    OrderDirective*
    BlockBodyOptions+
  'END'                          -> BlockBodyPart            {cons("BlockBodyPart")}

  DataDeclaration                -> BlockBodyOptions
  OverlayDeclaration             -> BlockBodyOptions
  NullDeclaration                -> BlockBodyOptions

%% 2.1.5 ALLOCATION OF DATA OBJECTS
%%
  'STATIC'                       -> AllocationSpecifier      {cons("STATIC")}

  AllocationSpecifier            -> OptAllocationSpecifier
  % empty %                      -> OptAllocationSpecifier   {cons("no-allocation-specifier")}

%% 2.1.6 INITIALIZATION OF DATA OBJECTS
%%
  '=' ItemPresetValue             -> ItemPreset              {cons("ItemPreset")}

  ItemPreset                      -> OptItemPreset
  % empty %                       -> OptItemPreset           {cons("no-item-preset")}

  CompileTimeNumericFormula       -> ItemPresetValue         {prefer}
  LocFunction                     -> ItemPresetValue

%%Added UserDefinedFunctionCall to remove ambiguities
%% when there is a PresetValuesOption that is a TableItem
%% TableItems can only be parsed as UserDefinedFunctionCall
  FunctionCall                    -> OptItemPresetValue      {prefer}
  ItemPresetValue                 -> OptItemPresetValue
  % empty %                       -> ItemPresetValue         {cons("no-item-preset-value")}

%% The grammar for table and block presets departs from the standard in
%% order to produce a single list (rather than a wierd list of lists). This
%% is hinted as in standard examples and is helpful for a list with
%% empty members, e.g., [1,,3,4]
%%
  '=' TablePresetList             -> TablePreset             {cons("TablePreset")}

  TablePreset                     -> OptTablePreset
  % empty %                       -> OptTablePreset          {cons("no-table-preset")}

  {PresetValue ','}+              -> TablePresetList         {cons("TablePresetList")}
  % empty %                       -> PresetValue             {cons("PresetValueNone")}
  Formula                         -> PresetValue
  RepetitionCount
    '('
       {PresetValue ','}+
    ')'                           -> PresetValue             {cons("PresetValueRep")}
  PresetValuePositioner           -> PresetValue

  'POS'
    '('
       {ConstantIndex ','}+
    ')'
    ':' PresetValue               -> PresetValuePositioner   {cons("PresetValuePositioner")}

  CompileTimeNumericFormula       -> ConstantIndex
  CompileTimeNumericFormula       -> RepetitionCount

  '=' BlockPresetList             -> BlockPreset           {cons("BlockPreset")}

  BlockPreset                     -> OptBlockPreset
  % empty %                       -> OptBlockPreset        {cons("no-block-preset")}

  {BlockPresetValue ','}+         -> BlockPresetList       {cons("BlockPresetList")}

  PresetValue                     -> BlockPresetValue
  '(' TablePresetList ')'         -> BlockPresetValue      {cons("BlockPresetValueParens")}
%%'(' BlockPresetList ')'         -> BlockPresetValue      %% AMBIGUOUS


%% 2.2 TYPE DECLARATIONS
%%
  ItemTypeDeclaration             -> TypeDeclaration
  TableTypeDeclaration            -> TypeDeclaration
  BlockTypeDeclaration            -> TypeDeclaration

  'TYPE' ItemTypeName
    ItemTypeDescription ';'       -> ItemTypeDeclaration   {cons("ItemTypeDeclaration")}

  Name                            -> ItemTypeName          {cons("Name")}

  'TYPE'  TableTypeName
  'TABLE' TableTypeSpecifier      -> TableTypeDeclaration  {cons("TableTypeDeclaration")}

  OptDimensionList
    OptStructureSpecifier
    OptLikeOption
    EntrySpecifier                -> TableTypeSpecifier    {cons("TableTypeSpecifier")}
  
  OptDimensionList
    TableTypeName ';'             -> TableTypeSpecifier    {cons("TableTypeSpecifierName"), prefer}

  Name                            -> TableTypeName         {cons("Name")}

  'LIKE'  TableTypeName           -> LikeOption            {cons("LikeOption")}

  LikeOption                      -> OptLikeOption
  % empty %                       -> OptLikeOption         {cons("no-like-option")}

  'TYPE'  BlockTypeName
  'BLOCK' BlockBodyPart           -> BlockTypeDeclaration  {cons("BlockTypeDeclaration")}

%% Following because of !ORDER before BEGIN of BlockBodyPart
  'TYPE'  BlockTypeName
  'BLOCK' OrderDirective
          BlockBodyPart           -> BlockTypeDeclaration  {cons("BlockOrderedTypeDeclaration")}

  Name                            -> BlockTypeName         {cons("Name")}

%% 2.3 STATEMENT NAME DECLARATIONS
%%
'LABEL' {StatementName ','}+ ';'  -> StatementNameDeclaration {cons("StatementNameDeclaration")}

%% 2.4 DEFINE DECLARATIONS
%%
'DEFINE' DefineName
  DefinitionPart                  -> DefineDeclaration         {cons("DefineDeclaration")}

  Name                            -> DefineName                {cons("Name")}

  OptFormalDefineParameterList
    DefineString ';'              -> DefinitionPart            {cons("DefinitionPart")}

  '('
     {FormalDefineParameter ','}+
  ')'                             -> FormalDefineParameterList {cons("FormalDefineParameterList")}

  FormalDefineParameterList       -> OptFormalDefineParameterList
  % empty %                       -> OptFormalDefineParameterList {cons("no-formal-define-parameter-list")}

  Letter                          -> FormalDefineParameter        {cons("FormalDefineParameter")}

%% Moved to lexical analysis
%%'?'
%%   {Character ','}*
%%'?'                             -> DefineString                 {cons("DefineString")}

  DefString                       -> DefineString                 {cons("DefineString")}

%% 2.4.1 DEFINE CALLS
%%
  DefineName
   ActualDefineParameterList      -> DefineCall                {cons("DefineCall")}
  DefineName
   NoList                         -> DefineCall                {cons("DefineCall")}

  '('
     {ActualDefineParameter ','}+
  ')'                             -> ActualDefineParameterList {cons("ActualDefineParameterList")}

  % empty %                       -> NoList                    {cons("no-list")}

      Character*                  -> ActualDefineParameter
  '"' Character* '"'              -> ActualDefineParameter     {cons("quoted-string")}

%% 2.5 EXTERNAL DECLARATIONS
%%
  DefSpecification                -> ExternalDeclaration
  RefSpecification                -> ExternalDeclaration

%% 2.5.1 DEF SPECIFICATIONS
%%
  SimpleDef                       -> DefSpecification
  CompoundDef                     -> DefSpecification

  'DEF'
    DefSpecificationChoice        -> SimpleDef            {cons("SimpleDef")}

  'DEF' 'BEGIN'
    DefSpecificationChoice+
  'END'                           -> CompoundDef          {cons("CompoundDef")}

  NullDeclaration                 -> DefSpecificationChoice
  DataDeclaration                 -> DefSpecificationChoice
  DefBlockInstantiation           -> DefSpecificationChoice
  StatementNameDeclaration        -> DefSpecificationChoice
%%Not originally in grammar
  OverlayDeclaration              -> DefSpecificationChoice

  'BLOCK' 'INSTANCE'
    BlockName ';'                 -> DefBlockInstantiation   {cons("DefBlockInstantiation")}

%% 2.5.2 REF SPECIFICATIONS
%%
  SimpleRef                       -> RefSpecification
  CompoundRef                     -> RefSpecification

  'REF'
    RefSpecificationChoice        -> SimpleRef            {cons("SimpleRef")}

  'REF' 'BEGIN'
    RefSpecificationChoice+
  'END'                           -> CompoundRef          {cons("CompoundRef")}

  NullDeclaration                 -> RefSpecificationChoice
  DataDeclaration                 -> RefSpecificationChoice
  SubroutineDeclaration           -> RefSpecificationChoice
  StatementNameDeclaration        -> RefSpecificationChoice

%% 2.6 OVERLAY DECLARATIONS
%%
  'OVERLAY'
    OptAbsoluteAddress
    OverlayExpression ';'         -> OverlayDeclaration   {cons("OverlayDeclaration")}

  'POS' '(' OverlayAddress ')'    -> AbsoluteAddress      {cons("AbsoluteAddress")}

  AbsoluteAddress                 -> OptAbsoluteAddress
  % empty %                       -> OptAbsoluteAddress   {cons("no-absolute-address")}

  CompileTimeNumericFormula       -> OverlayAddress

  {OverlayString ':'}+            -> OverlayExpression

  {OverlayElement ','}+           -> OverlayString

  Spacer                          -> OverlayElement
  DataName                        -> OverlayElement
  '(' OverlayExpression ')'       -> OverlayElement       {cons("OverlayElement")}

  'W' CompileTimeNumericFormula   -> Spacer               {cons("Spacer")}

  Name                            -> DataName             {cons("Name"), prefer}
  ItemName                        -> DataName
  TableName                       -> DataName
  BlockName                       -> DataName

%% 2.7 NULL DECLARATIONS
%%
  ';'                             -> NullDeclaration      {cons("NullDeclaration")}
  'BEGIN' 'END'                   -> NullDeclaration      {cons("NullDeclaration")}


%%%%%%%%%%
%% 3.0 PROCEDURES AND FUNCTIONS
%%%%%%%%%%

  ProcedureDeclaration            -> SubroutineDeclaration  {prefer}
  FunctionDeclaration             -> SubroutineDeclaration  %% AMBIGUOUS with ProcedureDeclaration

  ProcedureDefinition             -> SubroutineDefinition   {prefer}
  FunctionDefinition              -> SubroutineDefinition   %% AMBIGUOUS with ProcedureDefinition

%% 3.1 PROCEDURES
%%
  ProcedureHeading ';'
    PostProcDirective*
    Declaration                   -> ProcedureDeclaration   {cons("ProcedureDeclaration")}

  ProcedureHeading ';'
    PostProcDirective*
    ProcedureBody                 -> ProcedureDefinition    {cons("ProcedureDefinition")}

  'PROC'
    ProcedureName
    OptSubroutineAttribute
    OptFormalParameterList        -> ProcedureHeading       {cons("ProcedureHeading")}

  'REC'                           -> SubroutineAttribute    {cons("REC")}
  'RENT'                          -> SubroutineAttribute    {cons("RENT")}

  SubroutineAttribute             -> OptSubroutineAttribute
  % empty %                       -> OptSubroutineAttribute {cons("no-subroutine-attribute")}
 
  Name                            -> ProcedureName          {cons("Name")}

  SubroutineBody                  -> ProcedureBody

  StatementOrNull                 -> SubroutineBody         {cons("SubroutineSimpleBody")}

  Declaration                     -> DeclOrStmt
  Statement                       -> DeclOrStmt

  DeclOrStmt*                     -> DeclsAndStmts          {cons("DeclsAndStmts")}


  'BEGIN'
%%  Directive*, Declaration* and Statement* moved from the original grammar to DeclsAndStmts
    DeclsAndStmts
    SubroutineDefinition*
    LabelList
  'END'                           -> SubroutineBody         {cons("SubroutineBody"), prefer}

%% 3.2 FUNCTIONS
%%
  FunctionHeading ';'
    PostProcDirective*
    Declaration                   -> FunctionDeclaration    {cons("FunctionDeclaration")}

  FunctionHeading ';'
    PostProcDirective*
    FunctionBody                  -> FunctionDefinition      {cons("FunctionDefinition")}

  'PROC'
    FunctionName
    OptSubroutineAttribute
    OptFormalParameterList
    ItemTypeDescription           -> FunctionHeading      {cons("FunctionHeading")}

  Name                            -> FunctionName         {cons("Name")}

  SubroutineBody                  -> FunctionBody

%% 3.3 PARAMETERS OF PROCEDURES AND FUNCTIONS
%%
  '('
     {FormalInputParameter ','}*
     OptFormalOutputParameter
  ')'                             -> FormalParameterList      {cons("FormalParameterList")}

  FormalParameterList             -> OptFormalParameterList
  % empty %                       -> OptFormalParameterList   {cons("no-formal-parameter-list")}

  ':' {FormalOutputParameter','}+ -> OptFormalOutputParameter {cons("FormalOutputParameterList")}
  % empty %                       -> OptFormalOutputParameter {cons("no-formal-output-parameters")}

  OptParameterBinding
    InputParameterName            -> FormalInputParameter     {cons("FormalInputParameter")}

  OptParameterBinding
    OutputParameterName           -> FormalOutputParameter    {cons("FormalOutputParameter")}

  'BYVAL'                         -> ParameterBinding         {cons("BYVAL")}
  'BYREF'                         -> ParameterBinding         {cons("BYREF")}
  'BYRES'                         -> ParameterBinding         {cons("BYRES")}

  ParameterBinding                -> OptParameterBinding
  % empty %                       -> OptParameterBinding      {cons("no-parameter-binding")}

  Name                            -> InputParameterName       {cons("Name"), prefer} %% added this production and prefer to remove ambiguity within InputParameterName
  DataName                        -> InputParameterName
  StatementName                   -> InputParameterName
  SubroutineName                  -> InputParameterName

  Name                            -> OutputParameterName      {cons("Name"), prefer}
  DataName                        -> OutputParameterName

  Name                            -> SubroutineName           {cons("Name"), prefer}
  ProcedureName                   -> SubroutineName
  FunctionName                    -> SubroutineName

%% 3.4 INLINE PROCEDURES AND FUNCTIONS
%%
  'INLINE'
    {SubroutineName ','}+ ';'     -> InlineDeclaration        {cons("InlineDeclaration")}

%% 3.5 MACHINE-SPECIFIC PROCEDURES AND FUNCTIONS
%%


%%%%%%%%%%
%% 4.0 STATEMENTS
%%%%%%%%%%

  LabelList SimpleStatement   -> Statement             {cons("SimpleStatement")}
  LabeledSimpleStatement      -> Statement             {cons("SimpleStatement")}
  LabeledCompoundStatement    -> Statement

  AssignmentStatement         -> SimpleStatement
  LoopStatement               -> LabeledSimpleStatement
  IfStatement                 -> LabeledSimpleStatement
  CaseStatement               -> LabeledSimpleStatement
  ProcedureCallStatement      -> LabeledSimpleStatement
  ReturnStatement             -> LabeledSimpleStatement
  GotoStatement               -> LabeledSimpleStatement
  ExitStatement               -> LabeledSimpleStatement
  StopStatement               -> LabeledSimpleStatement
  AbortStatement              -> LabeledSimpleStatement
  NullBlockStatement          -> SimpleStatement

  ';'                         -> SimpleStatement         {cons("LabeledNullStatement"), reject}
  LabelList ';'               -> SimpleStatement         {cons("LabeledNullStatement"), prefer}

  ';'                          -> StatementOrNull        {cons("NullStatement")}
  Statement                    -> StatementOrNull

  'BEGIN'
    LabelList
  'END'                       -> NullBlockStatement     {cons("NullBlockStatement")}

%% StatementName changed to Name when cons("Name") was added to StatementName
%% Otherwise terms like Name(Label("label_string")) would appear.
%%
%% StatementName ':'          -> Label                 {cons("Label")}
%%
  Name ':'                    -> Label                 {cons("Label")}

  Label*                      -> LabelList             {cons("LabelList")}

  Name                        -> StatementName         {cons("Name")}

  LabelList
  'BEGIN'
    StatementOrNull+
    LabelList
  'END'                       -> LabeledCompoundStatement {cons("CompoundStatement")}
  
%% 4.1 ASSIGNMENT STATEMENTS
%%

  VariableList
    '=' Formula ';'          -> AssignmentStatement    {cons("AssignmentStatement")}

  {VariableLVal  ','}+       -> VariableList           {cons("VariableList")}

  Variable                   -> VariableLVal           {cons("VariableLVal")}
  TableItemNoDeref           -> VariableLVal           {cons("VariableLVal")}

%% 4.2 LOOP STATEMENTS
%%

  LabelList
  WhileClause ControlledStatement -> LoopStatement        {cons("WhileStatement")}

  LabelList
  ForClause ControlledStatement   -> LoopStatement        {cons("ForStatement")}

  WhileClause                  -> LoopType
  ForClause                    -> LoopType

  StatementOrNull              -> ControlledStatement

  'WHILE' Formula     ';'      -> WhileClause          {cons("WhileClause")}

  'FOR' ControlItem   ':'
        ControlClause ';'      -> ForClause            {cons("ForClause")}

  ControlVariable              -> ControlItem
  ControlLetter                -> ControlItem

  ItemName                     -> ControlVariable

  InitialValue
    OptContinuation            -> ControlClause        {cons("ControlClause")}

  Formula                      -> InitialValue

  ByOrThenPhrase
    OptWhilePhrase             -> Continuation         {cons("Continuation")}
  WhilePhrase
    OptByOrThenPhrase          -> Continuation         {cons("Continuation")}

  Continuation                 -> OptContinuation
  % empty %                    -> OptContinuation      {cons("no-continuation")}

  ByPhrase                     -> ByOrThenPhrase
  ThenPhrase                   -> ByOrThenPhrase

  ByOrThenPhrase               -> OptByOrThenPhrase
  % empty %                    -> OptByOrThenPhrase    {cons("no-by-or-then-phrase")}

  'BY' ByFormula               -> ByPhrase             {cons("ByPhrase")}

  Formula                      -> ByFormula            %% generalized to Formula after removal of NumericFormula

  'THEN' Formula               -> ThenPhrase           {cons("ThenPhrase")}

  'WHILE' Formula              -> WhilePhrase          {cons("WhilePhrase")}

  WhilePhrase                  -> OptWhilePhrase
  % empty %                    -> OptWhilePhrase       {cons("no-while-phrase")}

%% 4.3 IF STATEMENTS
%%

  IfSimpleStatement          -> IfStatement {prefer}
  IfElseStatement            -> IfStatement

  LabelList
  IfKeyword Formula ';'      %% Generalized to Formula after changes to formulas
    ConditionalStatement     -> IfSimpleStatement      {cons("IfSimpleStatement")}

  LabelList
  IfKeyword Formula ';'
    ConditionalStatement
    ElseClause               -> IfElseStatement        {cons("IfElseStatement")}

  'ELSE' StatementOrNull     -> ElseClause             {cons("ElseClause")}

  StatementOrNull            -> ConditionalStatement

%% 4.4 CASE STATEMENTS
%%

  LabelList
  'CASE'
    CaseSelectorFormula ';'
  'BEGIN'
    CaseBody
    LabelList
  'END'                        -> CaseStatement        {cons("CaseStatement")}

%% Generalized to Formula
%% Grammar allows for Integer, Bit, Character, and Status Formulas
  Formula                      -> CaseSelectorFormula

  CaseAlternative+             -> CaseBody

  CaseIndexGroup
    StatementOrNull
    OptFALLTHRU                -> CaseAlternative      {cons("CaseAlternative")}

  DefaultOption                -> CaseAlternative      {prefer}

  '(' 'DEFAULT' ')' ':'
    StatementOrNull
    OptFALLTHRU                -> DefaultOption        {cons("DefaultOption"), prefer}
%% Not in grammar
  '(' 'DEFAULT' ')' ':'        -> DefaultOption        {cons("DefaultOptionNoBlock")}

  'FALLTHRU'                   -> OptFALLTHRU          {cons("FALLTHRU")}
  % empty %                    -> OptFALLTHRU          {cons("no-fall-thru")}

  '(' {CaseIndex ','}+ ')' ':' -> CaseIndexGroup       {cons("CaseIndexGroup")}

  CompileTimeNumericFormula    -> CaseIndex            {cons("CaseIndex"), prefer}
  LowerBound ':' UpperBound    -> CaseIndex            {cons("CaseIndex")}

%% 4.5 PROCEDURE CALL STATEMENTS
%%

  UserDefinedProcedureCall     -> ProcedureCallStatement   {prefer}
  MachineSpecificProcedureCall -> ProcedureCallStatement   %% rejected below

  LabelList ProcedureName
    OptActualParameterList
    OptAbortPhrase ';'         -> UserDefinedProcedureCall {cons("ProcedureCallStatement")}

  AbortPhrase                  -> OptAbortPhrase
  % empty %                    -> OptAbortPhrase           {cons("no-abort-phrase")}

  '('
    {ActualInputParameter ','}*
    OptActualOutputParameters
  ')'                          -> ActualParameterList  {cons("ActualParameterList")}

  ActualParameterList          -> OptActualParameterList
  % empty %                    -> OptActualParameterList   {cons("no-actual-parameter-list")}

  ':' {ActualOutputParameter ','}+ -> OptActualOutputParameters {cons("ActualOutputParameters")}
  % empty%                         -> OptActualOutputParameters {cons("no-actual-output-parameters")}

%%Formula used to avoid ambuiguities
%%Grammar originally allows for Formula, StatementName, FunctionName, ProcedureName, BlockReference
  Formula                      -> ActualInputParameter     {prefer}

  Variable                     -> ActualOutputParameter    {cons("Variable"), prefer}
  BlockReference               -> ActualOutputParameter    {cons("BlockReference")}
  %% Added UserDefinedFunctionCall to allow for TableItems that can't produce Variable because of ambiguities
  UserDefinedFunctionCall      -> ActualOutputParameter


  'ABORT' StatementName        -> AbortPhrase              {cons("AbortPhrase")}

  ProcedureName
    OptActualParameterList     -> MachineSpecificProcedureCall {cons("MachineSpecificProcedureCall"), reject} %%AMBIGUOUS

  Name                         -> ProcedureName
  'RETURN'                     -> ProcedureName            {reject} %% Ambiguous with ReturnStatement
  'EXIT'                       -> ProcedureName            {reject} %% Ambiguous with ExitStatement
  'STOP'                       -> ProcedureName            {reject} %% Ambiguous with StopStatement
  'ABORT'                      -> ProcedureName            {reject} %% Ambiguous with AbortStatement
  Name                         -> FunctionName

%% 4.6 RETURN STATEMENTS
%%

  LabelList 'RETURN' ';'                  -> ReturnStatement        {cons("ReturnStatement")}

%% 4.7 GOTO STATEMENTS
%%

  LabelList 'GOTO' StatementName ';'      -> GotoStatement          {cons("GotoStatement")}

%% 4.8 EXIT STATEMENTS
%%

  LabelList 'EXIT' ';'                    -> ExitStatement          {cons("ExitStatement")}

%% 4.9 STOP STATEMENTS
%%

  LabelList 'STOP' OptFormula ';'         -> StopStatement          {cons("StopStatement")}

  Formula                                 -> OptFormula
  % empty %                               -> OptFormula             {cons("no-integer-formula")} %% should be no-numeric-formula? Will keep as is for now

%% 4.10 ABORT STATEMENTS
%%

  LabelList 'ABORT' ';'         -> AbortStatement         {cons("AbortStatement")}



%%%%%%%%%%
%% 5.0 FORMULAS
%%%%%%%%%%

%% Most formulas will go through Level4Expr -> Formula, but some conversions and some others
%% will go through these productions
%%  StatusFormula               -> Formula

%% All CompileTimeFormulas will use this production to remove ambiguities
  Formula                     -> CompileTimeNumericFormula      %% new Jan.11

%% 5.1 NUMERIC FORMULAS (expression hierarchy derived from Fortran)
%%
%% Restructuring of NumericFormula has removed
%% IntegerTerm, IntegerFactor, IntegerPrimary, IntegerVariable
%% NamedIntegerConstant, IntegerFunctionCall, IntegerFormula
%% FloatingTerm, FloatingFactor, FloatingPrimary, FloatingVariable
%% NamedFloatingConstant, FloatingFunctionCall, FloatingFormula
%% FixedTerm, FixedFactor, FixedVariable
%% NamedFixedConstant, FixedFunctionCall, FixedFormula
%% Sign, PlusOrMinus, MultiplyDivideOrMod

  Literal                         -> Primary
  FunctionCall                    -> Primary            {prefer}
  Variable                        -> Primary
  '(' Formula ')'                 -> Primary            {cons("Parens")}
  StatusConstant                  -> Primary            {cons("StatusFormula")}
  Conversion                      -> Primary
  NumericMachineParameter         -> Primary

  Primary                         -> Level1Expr
  ControlLetter                   -> Level1Expr

  Level1Expr                      -> MultOperand
  Level1Expr '**' MultOperand     -> MultOperand        {cons("Power")}

  MultOperand                          -> AddOperand
  AddOperand  '*'         MultOperand  -> AddOperand    {cons("Mult")}
  AddOperand  '/'         MultOperand  -> AddOperand    {cons("Div")}
  AddOperand  MODOperator MultOperand  -> AddOperand    {cons("Mod")}

  AddOperand                      -> Level2Expr
              '+' AddOperand      -> Level2Expr         {cons("UnaryPlus"),  prefer}
              '-' AddOperand      -> Level2Expr         {cons("UnaryMinus"), prefer}
  Level2Expr  '+' AddOperand      -> Level2Expr         {cons("Plus")}
  Level2Expr  '-' AddOperand      -> Level2Expr         {cons("Minus")}

  Level2Expr                      -> Level3Expr %% for concatenation operator in Fortran

  Level2Expr  '='   Level2Expr    -> EQ                 {cons("EQ")}
  UserDefinedFunctionCall
              '='   Level2Expr    -> EQ                 {cons("EQ"), prefer}
  EQ                              -> Level3Expr
  Level2Expr  '<'   Level2Expr    -> Level3Expr         {cons("LT")}
  Level2Expr  '>'   Level2Expr    -> Level3Expr         {cons("GT")}
  Level2Expr  '<='  Level2Expr    -> Level3Expr         {cons("LE")}
  Level2Expr  '>='  Level2Expr    -> Level3Expr         {cons("GE")}
  Level2Expr  '<>'  Level2Expr    -> Level3Expr         {cons("NE")}

  Level3Expr                               -> AndOperand
  'NOT' Level3Expr                         -> AndOperand      {cons("NOT")}

  AndOperand                               -> LogicalOperand

%% 'AND', 'OR', 'EQV', 'XOR' moved to lexer
  LogicalOperand ANDOperator AndOperand    -> LogicalOperand    {cons("AND")}
  LogicalOperand OROperator  AndOperand    -> LogicalOperand    {cons("OR")}
  LogicalOperand EQVOperator AndOperand    -> LogicalOperand    {cons("EQV")}
  LogicalOperand XOROperator AndOperand    -> LogicalOperand    {cons("XOR")}

  LogicalOperand                           -> Level4Expr

  Level4Expr                               -> Formula           {prefer}

%%Conversions have all been moved here
  IntegerConversion
    '(' Formula ')'           -> Conversion       {cons("NumericConversion")}
  FloatingConversion
    '(' Formula ')'           -> Conversion       {cons("NumericConversion")}
  FixedConversion
    '(' Formula ')'           -> Conversion       {cons("NumericConversion"), prefer}
  BitConversion
    '(' Formula ')'           -> Conversion       {cons("BitPrimaryConversion")}
  CharacterConversion
    '(' Formula ')'           -> Conversion       {cons("CharacterFormulaConversion")}
  StatusConversion
    '(' Formula ')'           -> Conversion       {cons("StatusFormulaConversion")}
  PointerConversion
    '(' Formula ')'           -> Conversion       {cons("PointerFormulaConversion")}
  TableConversion
    '(' Formula ')'           -> Conversion       {cons("TableFormulaConversion")}


  IntegerMachineParameter     -> NumericMachineParameter
  FloatingMachineParameter    -> NumericMachineParameter
  FixedMachineParameter       -> NumericMachineParameter

%% 5.2 BIT FORMULAS
%%
%%LogicalOperand, LogicalContinuation, RelationalExpression moved to Level4Expr
%%NamedBitConstant, like all constants, will be a Name or a Variable
%%BitConversion moved to Conversion which produces Primary
%%BitVariable, BitFunctionCall not accessible and will go through more general productions

  BitLiteral                  -> BitPrimary
  BooleanLiteral              -> BitPrimary

%% 5.2.1 RELATIONAL EXPRESSIONS
%%

%% All RelationalExpressions have been moved to Level3Expr in 5.1

%% 5.2.2 BOOLEAN FORMULAS
%%
%%BitFormula                  -> BooleanFormula
  Formula                     -> BooleanFormula

%% 5.3 CHARACTER FORMULAS
%%
%%CharacterLiteral, CharacterVariable, NamedCharacterConstant
%%CharacterConversion moved to Conversion which produces Primary
%%CharacterFunctionCall not accessible and will go through more general productions


%% 5.4 STATUS FORMULAS
%%
%%StatusConstant moved to Primary
%%StatusConversion moved to Conversion which produces Primary
%%StatusVariable, NamedStatusConstant, StatusFunctionCall not accessible
%%and will go through more general productions


%% 5.5 POINTER FORMULAS
%%
%%PointerLiteral has been moved to Formula
%%PointerConversion moved to Conversion which produces Primary
%%PointerVariable, NamedPointerConstant, PointerFunctionCall not accessible
%%and will go through more general productions

%% 5.6 TABLE FORMULAS
%%
%%TableConversion moved to Conversion which produces Primary
%%TableVariable, NamedTableConstant not accessible
%%and will go through more general productions

%%%%%%%%%%
%% 6.0 DATA REFERENCES
%%%%%%%%%%

%% 6.1 VARIABLE AND BLOCK REFERENCES
%%
  NamedVariable               -> Variable
  BitFunctionVariable         -> Variable
  ByteFunctionVariable        -> Variable
  RepFunctionVariable         -> Variable
%%FunctionName                -> Variable           {reject} %% AMBIGUOUS with NamedVariable
  
  Item                        -> NamedVariable
  Table                       -> NamedVariable
  TableItem                   -> NamedVariable      {prefer}
  TableEntry                  -> NamedVariable
  BlockItem                   -> NamedVariable      {reject} %% AMBIGUOUS with BlockTable
  BlockTable                  -> NamedVariable
  BlockTableItem              -> NamedVariable      {reject} %% AMBIGUOUS with TableItem
  BlockTableEntry             -> NamedVariable      {reject}

  ItemName                    -> Item
  ItemDereference             -> Item

%%TableName                   -> Table  %% AMBIGUOUS
  TableDereference            -> Table  {reject}

%% This is only used on right side of assignment statement
  TableItemName
    Subscript
    OptTableDereference        -> TableItemNoDeref    {cons("TableItem")}

  TableItemName
    OptSubscript
%%  OptTableDereference                                                          %% Optional makes AMBIGUOUS with Name
    TableDereference          -> TableItem             {cons("TableItem")}

  Subscript                   -> OptSubscript
  % empty %                   -> OptSubscript          {cons("no-subscript")}

  TableDereference            -> OptTableDereference
  % empty %                   -> OptTableDereference   {cons("no-table-dereference")}

  TableName
    Subscript                 -> TableEntry            {cons("TableEntry"), reject} %% Makes AMBIGUOUS with TableItem

  TableDereference
    Subscript                 -> TableEntry            {cons("TableEntry"), reject} %% Makes AMBIGUOUS with TableDereference

  ItemName
    OptBlockDereference       -> BlockItem             {cons("BlockItem"), reject} %% AMBIGUOUS with BlockTable

  TableName
    BlockDereference          -> BlockTable            {cons("BlockTable")}
%%  OptBlockDereference       -> BlockTable                                        %% Optional makes AMBIGUOUS with Name

  TableItemName
    OptSubscript
    OptBlockDereference       -> BlockTableItem        {cons("BlockTableItem"), reject} %% AMBIGUOUS with TableItem

  TableName
    Subscript
    OptBlockDereference       -> BlockTableEntry       {cons("BlockTableEntry")}

  BlockDereference            -> OptBlockDereference
  % empty %                   -> OptBlockDereference   {cons("no-block-dereference")}

  Dereference                 -> BlockDereference      {reject}

  Dereference                 -> ItemDereference

  Dereference                 -> TableDereference      {prefer}

  '@' PointerItemName         -> Dereference           {cons("Dereference")}
  '@' '(' Formula ')'         -> Dereference           {cons("Dereference")}
  '@' '(' PointerLiteral ')'  -> Dereference           {cons("Dereference"), reject}  %% This prevents NULL from being dereferenced

  '@' Name Subscript          -> Dereference           {cons("TableDereference")}
  Dereference Subscript       -> Dereference           {cons("TableDereference"), prefer}

  ItemName                    -> PointerItemName       {prefer}
  TableItemName               -> PointerItemName
  ConstantItemName            -> PointerItemName

  '(' { Index ','}+ ')'       -> Subscript             {cons("Subscript")}

%% Productions of Index generalized to Formula
%% Grammar originally allows for IntegerFormula, StatusFormula
  Formula                     -> Index                 {prefer}

  'BIT' '(' Variable ','
            Fbit ',' Nbit ')' -> BitFunctionVariable   {cons("BitFunctionVariable"), prefer}

%% Added production of BitFunctionVariable with BitFormula inside
%% to allow variables with parentheses to be used
  'BIT' '(' Formula ','
            Fbit ',' Nbit ')' -> BitFunctionVariable   {cons("BitFunctionVariable")}

  'BYTE' '(' Variable ','
          Fbyte ',' Nbyte ')' -> ByteFunctionVariable  {cons("ByteFunctionVariable"), prefer}
  'BYTE' '(' Formula ','
          Fbyte ',' Nbyte ')' -> ByteFunctionVariable  {cons("ByteFunctionVariable")}

  RepConversion
    '(' NamedVariable ')'           -> RepFunctionVariable   {cons("RepFunctionVariable")}
  RepConversion
    '(' NamedVariable Subscript ')' -> RepFunctionVariable   {cons("RepFunctionVariable")}

  BlockName                   -> BlockReference
  BlockDereference            -> BlockReference
  BlockName
    BlockDereference          -> BlockReference        {cons("BlockReference")}

  Name                        -> ConstantItemName
  Name                        -> BlockName

%% 6.2 NAMED CONSTANTS
%%
  ConstantItemName            -> NamedConstant         {prefer}  %% ambiguous with ConstantTableName
  ConstantTableName           -> NamedConstant         {cons("ConstantTableName")}
  ConstantTableItemName
    OptSubscript              -> NamedConstant         {cons("NamedConstant"), reject} %% AMBIGUOUS with IntegerTerm
  ConstantTableName
    Subscript                 -> NamedConstant         {cons("NamedConstant")}
  ControlLetter               -> NamedConstant         {cons("ControlLetter")}

  TableItemName               -> ConstantTableItemName

  Name                        -> ConstantTableName

%% 6.3 FUNCTION CALLS
%%
  IntrinsicFunctionCall       -> FunctionCall         {prefer}
  MachineSpecificFunctionCall -> FunctionCall
  UserDefinedFunctionCall     -> FunctionCall

%% Removed Opt from ActualParameterList to distinguish from Variable.
%% Now user-defined function calls must have parens. Resolution of function calls
%% without parens will require name resolution using a symbol table.
  FunctionName
    ActualParameterList       -> UserDefinedFunctionCall      {cons("UserDefinedFunctionCall")}

  LocFunction                 -> IntrinsicFunctionCall
  NextFunction                -> IntrinsicFunctionCall
  BitFunction                 -> IntrinsicFunctionCall
  ByteFunction                -> IntrinsicFunctionCall
  ShiftFunction               -> IntrinsicFunctionCall
  AbsFunction                 -> IntrinsicFunctionCall
  SignFunction                -> IntrinsicFunctionCall
  SizeFunction                -> IntrinsicFunctionCall
  BoundsFunction              -> IntrinsicFunctionCall
  NwdsenFunction              -> IntrinsicFunctionCall
  StatusInverseFunction       -> IntrinsicFunctionCall
  NentFunction                -> IntrinsicFunctionCall

  FunctionName                                                %% AMBIGUOUS with NamedConstant
    OptActualParameterList    -> MachineSpecificFunctionCall  {cons("MachineSpecificFunctionCall"), reject}

%% 6.3.1 LOC FUNCTION
%%
  'LOC' '(' LocArgument ')'   -> LocFunction          {cons("LocFunction")}

%% Added because can't distinguish between the different names below
  Name                        -> LocArgument          {prefer}
%% Added because TableItem is a NamedVariable
%% but can only be accessed through UserDefinedFunctionCall
  UserDefinedFunctionCall     -> LocArgument

  NamedVariable               -> LocArgument
  StatementName               -> LocArgument
  ProcedureName               -> LocArgument
  FunctionName                -> LocArgument
  BlockReference              -> LocArgument

%% 6.3.2 NEXT FUNCTION
%%
  'NEXT' '('
    NextArgument ','
    IncrementAmount ')'       -> NextFunction         {cons("NextFunction")}

%%Productions of NextArgument generalized to Formula
%%Grammar originally allows for PointerFormula, StatusFormula
  Formula                     -> NextArgument

  Formula                     -> IncrementAmount

%% 6.3.3 BIT FUNCTION
%%
%%Grammar originally allows BitFormula as first argument
  'BIT' '(' Formula
    ',' Fbit ',' Nbit ')'     -> BitFunction          {cons("BitFunction")}
  'BIT' '(' RepFunctionVariable
    ',' Fbit ',' Nbit ')'     -> BitFunction          {cons("BitFunction"), prefer}

  Formula                     -> Fbit                 {cons("Fbit")}
  Formula                     -> Nbit                 {cons("Nbit")}

%% 6.3.4 BYTE FUNCTION
%%
  'BYTE' '(' Formula
    ',' Fbyte ',' Nbyte ')'   -> ByteFunction         {cons("ByteFunction")}
  'BYTE' '(' RepFunctionVariable
    ',' Fbyte ',' Nbyte ')'   -> ByteFunction         {cons("ByteFunction"), prefer}

  Formula                     -> Fbyte
  Formula                     -> Nbyte

%% 6.3.5 SHIFT FUNCTIONS
%%
  ShiftDirection
    '(' Formula ','
    ShiftCount ')'            -> ShiftFunction        {cons("ShiftFunction")}

  ShiftDirection
    '(' RepFunctionVariable ','
    ShiftCount ')'            -> ShiftFunction        {cons("ShiftFunction"), prefer}

  'SHIFTL'                    -> ShiftDirection       {cons("SHIFTL")}
  'SHIFTR'                    -> ShiftDirection       {cons("SHIFTR")}

  Formula                     -> ShiftCount

%% 6.3.6 ABS FUNCTION
%%
  'ABS' '(' Formula ')'        -> AbsFunction         {cons("AbsFunction")}

%% 6.3.7 SIGN FUNCTION
%%
  'SGN' '(' Formula ')'        -> SignFunction        {cons("SignFunction")}

%% 6.3.7 SIZE FUNCTIONS
%%
  SizeType
    '(' SizeArgument ')'      -> SizeFunction         {cons("SizeFunction")}

  'BITSIZE'                   -> SizeType             {cons("BITSIZE")}
  'BYTESIZE'                  -> SizeType             {cons("BYTESIZE")}
  'WORDSIZE'                  -> SizeType             {cons("WORDSIZE")}

  Formula                     -> SizeArgument         {prefer}
  BlockName                   -> SizeArgument
  TypeName                    -> SizeArgument
  
%% 6.3.9 BOUNDS FUNCTIONS
%%
  WhichBound
    '(' BoundsArgument ','
    DimensionNumber ')'       -> BoundsFunction       {cons("BoundsFunction")}

  'LBOUND'                    -> WhichBound           {cons("LBOUND")}
  'UBOUND'                    -> WhichBound           {cons("UBOUND")}

  TableName                   -> BoundsArgument       {cons("Name"), prefer}
  TableTypeName               -> BoundsArgument

  CompileTimeNumericFormula   -> DimensionNumber
  
%% 6.3.10 NWDSEN FUNCTION
%%
  'NWDSEN'
    '(' NwdsenArgument ')'    -> NwdsenFunction       {cons("NwdsenFunction")}

  TableName                   -> NwdsenArgument       {cons("Name"), prefer}
  TableTypeName               -> NwdsenArgument

%% 6.3.11 STATUS INVERSE FUNCTIONS
%%
  'FIRST' '('
    StatusInverseArgument ')' -> StatusInverseFunction {cons("StatusInverseFunctionFIRST")}

  'LAST'  '('
    StatusInverseArgument ')' -> StatusInverseFunction {cons("StatusInverseFunctionLAST")}

%%Grammar originially allows for StatusFormula as a StatusInverseArgument
  Formula                     -> StatusInverseArgument
  StatusTypeName              -> StatusInverseArgument {prefer}

%% 6.3.12 NENT FUNCTION
%%
  'NENT' '(' NentArgument ')' -> NentFunction         {cons("NentFunction")}

  TableName                   -> NentArgument         {cons("Name"), prefer}
  TableTypeName               -> NentArgument


%%%%%%%%%%
%% 7.0 TYPE MATCHING AND TYPE CONVERSIONS
%%%%%%%%%%

  BitTypeConversion           -> BitConversion
  RepConversion               -> BitConversion        {reject} %% fixes ambiguity, RepFunctionVariable and BitPrimaryConversion

  '(*'
    BitTypeDescription
                         '*)' -> BitTypeConversion    {cons("BitTypeConversion")}
  '['
    BitTypeDescription
                         ']'  -> BitTypeConversion    {cons("BitTypeConversion")}
  BitTypeName                 -> BitTypeConversion    {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  'B'                         -> BitTypeConversion    {cons("BitTypeConversionB")}

%%  '(*'
%%    IntegerTypeDescription
%%                         '*)' -> IntegerConversion    {cons("IntegerConversion")}
%% Replacing above with two productions of IntegerTypeDescription during IntegerConversion
%% here to allow for distinction while traversing between conversions
%% that are unambiguously IntegerConversion and conversions that are
%% using IntegerTypeName to parse but could be other type conversions

  '(*'
    IntegerItemDescription
                         '*)' -> IntegerConversion    {cons("IntegerConversion")}
  '(*'
    IntegerTypeName
                         '*)' -> IntegerConversion    {cons("TypeNameConversion")}
  IntegerTypeName             -> IntegerConversion    {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  'S'                         -> IntegerConversion    {cons("IntegerConversionS")}
  'U'                         -> IntegerConversion    {cons("IntegerConversionU")}

  '(*'
    FloatingTypeDescription
                         '*)' -> FloatingConversion   {cons("FloatingConversion")}
  FloatingTypeName            -> FloatingConversion   {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  'F'                         -> FloatingConversion   {cons("FloatingConversionF")}

  '(*'
    FixedTypeDescription
                         '*)' -> FixedConversion      {cons("FixedConversion")}
  FixedTypeName               -> FixedConversion      {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions

  '(*'
    CharacterTypeDescription
                         '*)' -> CharacterConversion  {cons("CharacterConversion")}
  CharacterTypeName           -> CharacterConversion  {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  'C'                         -> CharacterConversion  {cons("CharacterConversionC")}

%% reject these to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  '(*' StatusTypeName '*)'    -> StatusConversion     {cons("StatusConversion"), reject}
  StatusTypeName              -> StatusConversion     {reject}

  '(*'
    PointerTypeDescription
                         '*)' -> PointerConversion    {cons("PointerConversion")}
  PointerTypeName             -> PointerConversion    {reject} %% reject to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  'P'                         -> PointerConversion    {cons("PointerConversionP")}

%% reject these to remove ambiguities, using UserDefinedFunctionCall for type name conversions
  '(*' TableTypeName     '*)' -> TableConversion     {cons("TableConversion"), reject}
  TableTypeName               -> TableConversion     {reject}

  'REP'                       -> RepConversion       {cons("RepConversion")}


%%%%%%%%%%
%% 8.0 BASIC ELEMENTS (see also, JovialLex.sdf)
%%%%%%%%%%

%% 8.1 CHARACTERS (see also, JovialLex.sdf)
%%
    Letter                  -> Character
    Digit                   -> Character
    Mark                    -> Character
%%  OtherCharacter          -> Character

%% 8.2 SYMBOLS
%%
    Name                     -> Symbol
    ReservedWord             -> Symbol
    Operator                 -> Symbol
    Literal                  -> Symbol
    StatusConstant           -> Symbol
%%  Comment                  -> Symbol %% Moved to JovialLex.sdf
    DefineString             -> Symbol
    DefineCall               -> Symbol
    Letter                   -> Symbol
%%  Separator                -> Symbol

%% 8.2.1 NAMES (see JovialLex.sdf)
%%

%% 8.2.3 OPERATORS
%%
  ArithmeticOperator         -> Operator
  BitOperator                -> Operator
  RelationalOperator         -> Operator
  DereferenceOperator        -> Operator
  AssignmentOperator         -> Operator

  PlusOrMinus                -> ArithmeticOperator
  MultiplyDivideOrMod        -> ArithmeticOperator
  MultiplyOrDivide           -> ArithmeticOperator
  '**'                       -> ArithmeticOperator      {cons("PowerOp")}

  '+'                        -> PlusOrMinus             {cons("AddOp")}
  '-'                        -> PlusOrMinus             {cons("SubtractOp")}

  '*'                        -> MultiplyDivideOrMod     {cons("MultiplyOp")}
  '/'                        -> MultiplyDivideOrMod     {cons("DivideOp")}
  MODOperator                -> MultiplyDivideOrMod     {cons("ModOp")}

  '*'                        -> MultiplyOrDivide        {cons("MultiplyOp")}
  '/'                        -> MultiplyOrDivide        {cons("DivideOp")}


%% Cons for NOT, AND, OR, XOR, EQV, DerefOp, and AssignOp will not be produced
  LogicalOperator            -> BitOperator
  'NOT'                      -> BitOperator             {cons("NOT")}

  'AND'                      -> LogicalOperator         {cons("AND")}
  'OR'                       -> LogicalOperator         {cons("OR")}
  'XOR'                      -> LogicalOperator         {cons("XOR")}
  'EQV'                      -> LogicalOperator         {cons("EQV")}

  EqualOrNotEqualOperator    -> RelationalOperator
  '<'                        -> RelationalOperator      {cons("LessThanOp")}
%%'>'                        -> RelationalOperator      {cons("GreaterThanOp")}
  '<='                       -> RelationalOperator      {cons("LessOrEqualOp")}
  '>='                       -> RelationalOperator      {cons("GreaterOrEqualOp")}

  '='                        -> EqualOrNotEqualOperator {cons("EqualityOp")}
  '<>'                       -> EqualOrNotEqualOperator {cons("NotEqualOp")}

  '@'                        -> DereferenceOperator     {cons("DerefOp")}

  '='                        -> AssignmentOperator      {cons("AssignOp")}

%% 8.2.4 SEPARATORS
%%
%% TODO - see if constructors are needed for these
%%

%% 8.3 LITERALS
%%
  NumericLiteral             -> Literal
  BitLiteral                 -> Literal
  BooleanLiteral             -> Literal
  CharacterLiteral           -> Literal
  PointerLiteral             -> Literal

%% 8.3.1 NUMERIC LITERALS
%%
  IntegerLiteral             -> NumericLiteral
  FloatingLiteral            -> NumericLiteral
  FixedLiteral               -> NumericLiteral        {prefer} %% added to remove ambiguity with FloatingLiteral

  Number                     -> IntegerLiteral        {cons("IntVal")}
  Icon                       -> Number

  RealLiteral                -> FloatingLiteral
  Icon Exponent              -> RealLiteral           {cons("RealLiteralIE")}
  FractionalForm OptExponent -> RealLiteral           {cons("RealLiteralFF")}

  'E' OptSign Number         -> Exponent              {cons("Exponent")}

  '+'                        -> Sign                  {cons("PLUS")}
  '-'                        -> Sign                  {cons("MINUS")}

%% Unary signs now dealt with in Level2Expr as "UnaryPlus" and "UnaryMinus"
%% OptSign is retained for the production of RealLiteral
  Sign                        -> OptSign
  % empty %                   -> OptSign                {cons("no-sign")}

  OptNumber '.' OptNumber    -> FractionalForm        {cons("FractionalForm")}

  RealLiteral                -> FixedLiteral

  Exponent                   -> OptExponent
  % empty %                  -> OptExponent           {cons("no-exponent")}
  Number                     -> OptNumber
  % empty %                  -> OptNumber             {cons("no-number")}

%% 8.3.2 BIT LITERALS
%%
  BeadSize 'B' "'" Bead+ "'"  -> BitLiteral              {cons("BitLiteral")}

%% 8.3.3 BOOLEAN LITERALS
%%
  'TRUE'                   -> BooleanLiteral          {cons("True")}
  'FALSE'                  -> BooleanLiteral          {cons("False")}

%% 8.3.3 CHARACTER LITERALS
%%
%% CharString moved to JovialLex.sdf
  CharString               -> CharacterLiteral        {cons("CharacterLiteral")}

%% 8.3.4 POINTER LITERALS
%%
  'NULL'                   -> PointerLiteral          {cons("Null")}

%% Comment moved to JovialLex.sdf
%%  '"' Character* '"'     -> Comment                 {cons("Comment")}
%%  '%' Character* '%'     -> Comment                 {cons("Comment")}


%%%%%%%%%%
%% 9.0 DIRECTIVES
%%%%%%%%%%

  CompoolDirective         -> Directive
  CopyDirective            -> Directive
  SkipDirective            -> Directive
  BeginDirective           -> Directive
  EndDirective             -> Directive
  TraceDirective           -> Directive
  InterferenceDirective    -> Directive
  NolistDirective          -> Directive
  ListDirective            -> Directive
  EjectDirective           -> Directive
  ListinvDirective         -> Directive
  ListexpDirective         -> Directive
  ListbothDirective        -> Directive
  BaseDirective            -> Directive
  IsbaseDirective          -> Directive
  DropDirective            -> Directive
  LeftrightDirective       -> Directive
  RearrangeDirective       -> Directive
  InitializeDirective      -> Directive
  OrderDirective           -> Directive

  AlignDirective           -> Directive  %% nonstandard, probably some odd compiler
  AlwaysDirective          -> Directive  %% nonstandard

  LinkageDirective         -> PostProcDirective  %% only after ProcedureHeading
  ReducibleDirective       -> PostProcDirective  %% only after FunctionHeading (but SEA compiler is flexible)


%% 9.1 COMPOOL DIRECTIVE
%%
  '!COMPOOL'
     CompoolDirectiveList ';'   -> CompoolDirective         {cons("CompoolDirective")}

  OptCompoolFileName
     {CompoolDeclaredName ','}+ -> CompoolDirectiveList     {cons("CompoolDirectiveList")}

  '(' OptCompoolFileName ')'    -> CompoolDirectiveList     {cons("CompoolDirectiveList")}

      Name                      -> CompoolDeclaredName      {cons("Name")}
  '(' Name ')'                  -> CompoolDeclaredName      {cons("Name")}

  CharacterLiteral              -> CompoolFileName

  CompoolFileName               -> OptCompoolFileName
  % empty %                     -> OptCompoolFileName       {cons("no-compool-file-name")}


%% 9.2 TEXT DIRECTIVES
%%

%% 9.2.1 COPY DIRECTIVES
%%
  '!COPY' CharacterLiteral ';'  -> CopyDirective            {cons("CopyDirective")}

%% 9.2.2 SKIP, BEGIN, AND END DIRECTIVES
%%
  '!SKIP'  OptLetter ';'        -> SkipDirective            {cons("SkipDirective")}

  '!BEGIN' OptLetter ';'        -> BeginDirective           {cons("BeginDirective")}

  '!END' ';'                    -> EndDirective             {cons("EndDirective")}

  Letter                        -> OptLetter
  % empty %                     -> OptLetter                {cons("no-letter")}

%% 9.3 LINKAGES DIRECTIVES
%%
  '!LINKAGE' Symbol+ ';'        -> LinkageDirective         {cons("LinkageDirective")}

%% 9.4 TRACE DIRECTIVES
%%
  '!TRACE' OptTraceControl
    {Name ','}+ ';'             -> TraceDirective           {cons("TraceDirective")}

  '(' BooleanFormula ')'        -> TraceControl             {cons("TraceControl")}
  
  TraceControl                  -> OptTraceControl
  % empty %                     -> OptTraceControl          {cons("no-trace-control")}

%% 9.5 INTERFERENCE DIRECTIVES
%%
  '!INTERFERENCE'
    InterferenceControl ';'     -> InterferenceDirective    {cons("InterferenceDirective")}

  DataName ':' {DataName ','}+  -> InterferenceControl      {cons("InterferenceControl")}

  Name                          -> DataName

%% 9.6 REDUCIBLE DIRECTIVES
%%
  '!REDUCIBLE' ';'              -> ReducibleDirective       {cons("ReducibleDirective")}


%% 9.7 LISTING DIRECTIVES
%%
%% 9.7.1 SOURCE-LISTING DIRECTIVES
%%
  '!NOLIST' ';'                  -> NolistDirective         {cons("NolistDirective")}
  '!LIST'   ';'                  ->   ListDirective         {cons("  ListDirective")}
  '!EJECT'  ';'                  ->  EjectDirective         {cons(" EjectDirective")}

%% 9.7.2 DEFINE-LISTING DIRECTIVES
%%
  '!LISTINV'  ';'                -> ListinvDirective        {cons("ListinvDirective")}
  '!LISTEXP'  ';'                -> ListexpDirective        {cons("ListexpDirective")}
  '!LISTBOTH' ';'                -> ListbothDirective       {cons("ListbothDirective")}

%% 9.8 REGISTER DIRECTIVES
%%
  '!BASE' DataName
    IntegerLiteral   ';'         -> BaseDirective           {cons("BaseDirective")}

  '!ISBASE' DataName
    IntegerLiteral   ';'         -> IsbaseDirective         {cons("IsbaseDirective")}

  '!DROP'
    IntegerLiteral   ';'         -> DropDirective           {cons("DropDirective")}

%% 9.9 EXPRESSION EVALUATION ORDER DIRECTIVES
%%
  '!LEFTRIGHT' ';'               -> LeftrightDirective      {cons("LeftrightDirective")}
  '!REARRANGE' ';'               -> RearrangeDirective      {cons("RearrangeDirective")}

%% 9.10 INITIALIZATION DIRECTIVES
%%
  '!INITIALIZE' ';'               -> InitializeDirective    {cons("InitializeDirective")}

%% 9.11 ALLOCATION ORDER DIRECTIVES
%%
  '!ORDER' ';'                    -> OrderDirective         {cons("OrderDirective")}

%% Nonstandard directives, must be some odd compiler
%%
  "!ALIGN" Name ';'               -> AlignDirective    {cons("AlignDirective")}
  "!ALWAYS'STORE" {Name ','}+ ';' -> AlwaysDirective   {cons("AlwaysDirective")}
  "!always'store" {Name ','}+ ';' -> AlwaysDirective   {cons("AlwaysDirective")}
