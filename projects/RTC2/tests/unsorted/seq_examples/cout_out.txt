"/usr/include/sys/cdefs.h", line 140: warning: incompatible redefinition of
          macro "__dead2" (declared at line 148 of
          "/Users/vanka1/research/compilers/rose/rose_build/include-staging/g++
          _HEADERS/rose_edg_required_macros_and_functions.h")
  #define	__dead2		__attribute__((__noreturn__))
         	^

"/usr/include/sys/cdefs.h", line 141: warning: incompatible redefinition of
          macro "__pure2" (declared at line 149 of
          "/Users/vanka1/research/compilers/rose/rose_build/include-staging/g++
          _HEADERS/rose_edg_required_macros_and_functions.h")
  #define	__pure2		__attribute__((__const__))
         	^

Hello World
HackyPtrCheck7
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef char char_type;
node: SgTypedefDeclaration = public: typedef char char_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef char char_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef int_type int_type;
node: SgTypedefDeclaration = public: typedef int_type int_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef int_type int_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef pos_type pos_type;
node: SgTypedefDeclaration = public: typedef pos_type pos_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef pos_type pos_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef off_type off_type;
node: SgTypedefDeclaration = public: typedef off_type off_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef off_type off_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
node: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
node: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_ios< char , char_traits< char > > __ios_type;
node: SgTypedefDeclaration = public: typedef class basic_ios< char , char_traits< char > > __ios_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_ios< char , char_traits< char > > __ios_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > __ostream_type;
node: SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > __ostream_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > __ostream_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;
node: SgTypedefDeclaration = public: typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class ctype< char > __ctype_type;
node: SgTypedefDeclaration = public: typedef class ctype< char > __ctype_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class ctype< char > __ctype_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDeclaration = public: class sentry ;
node: SgClassDeclaration = public: class sentry ;
File: (compilerGenerated, 0, 0) SgClassDeclaration = public: class sentry ;
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDeclaration = public: friend class sentry ;
node: SgClassDeclaration = public: friend class sentry ;
File: (compilerGenerated, 0, 0) SgClassDeclaration = public: friend class sentry ;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__pf
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__p
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__p
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__p
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__sb
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__c
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__c
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__c
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );
node: SgTemplateDeclaration = protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDefn = template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );}
node: SgTemplateInstantiationDefn = template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDefn = template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 4, 1) SgFunctionParameterList = 
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?Yes
Main function param list found. Skipping
Always returning NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgIntVal = 5
node: SgIntVal = 5
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 5, 8) SgIntVal = 5
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgAssignInitializer = 5
node: SgAssignInitializer = 5
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 5, 8) SgAssignInitializer = 5
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = a
node: SgInitializedName = a
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 5, 2) SgInitializedName = a
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = int a = 5;
node: SgVariableDeclaration = int a = 5;
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 5, 2) SgVariableDeclaration = int a = 5;
Is variable declaration? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionRefExp = <<
node: SgFunctionRefExp = <<
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 12) SgFunctionRefExp = <<
Is variable declaration? No
is variable reference? No
is function ref? Yes
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgVarRefExp = cout
node: SgVarRefExp = cout
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 2) SgVarRefExp = cout
Is variable declaration? No
is variable reference? Yes
Is it an lvalue? No
Is it an LVal? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgAddressOfOp = (&cout)
node: SgAddressOfOp = (&cout)
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 2) SgAddressOfOp = (&cout)
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgCastExp = ((class basic_ostream< char , char_traits< char > > *)(&cout))
node: SgCastExp = ((class basic_ostream< char , char_traits< char > > *)(&cout))
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 2) SgCastExp = ((class basic_ostream< char , char_traits< char > > *)(&cout))
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgPointerDerefExp = *((class basic_ostream< char , char_traits< char > > *)(&cout))
node: SgPointerDerefExp = *((class basic_ostream< char , char_traits< char > > *)(&cout))
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 2) SgPointerDerefExp = *((class basic_ostream< char , char_traits< char > > *)(&cout))
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgStringVal = "Test case "
node: SgStringVal = "Test case "
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 15) SgStringVal = "Test case "
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgCastExp = ("Test case ")
node: SgCastExp = ("Test case ")
File: (transformation, 0, 0) SgCastExp = ("Test case ")
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgExprListExp = *((class basic_ostream< char , char_traits< char > > *)(&cout)),("Test case ")
node: SgExprListExp = *((class basic_ostream< char , char_traits< char > > *)(&cout)),("Test case ")
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 12) SgExprListExp = *((class basic_ostream< char , char_traits< char > > *)(&cout)),("Test case ")
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionCallExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case "))
node: SgFunctionCallExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case "))
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 12) SgFunctionCallExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case "))
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?Yes
Added to NodesToInstrument
TopBotTrack2: Ev_Synth_Attr
Current: SgMemberFunctionRefExp = <<
node: SgMemberFunctionRefExp = <<
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 28) SgMemberFunctionRefExp = <<
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgDotExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) <<
node: SgDotExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) <<
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 28) SgDotExp = ( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) <<
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgVarRefExp = a
node: SgVarRefExp = a
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 31) SgVarRefExp = a
Is variable declaration? No
is variable reference? Yes
Is it an lvalue? No
Is it an LVal? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgExprListExp = a
node: SgExprListExp = a
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 28) SgExprListExp = a
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a)
node: SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a)
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 28) SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a)
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgMemberFunctionRefExp = <<
node: SgMemberFunctionRefExp = <<
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 33) SgMemberFunctionRefExp = <<
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgDotExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) <<
node: SgDotExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) <<
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 33) SgDotExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) <<
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionRefExp = endl< char , char_traits< char > >
node: SgFunctionRefExp = endl< char , char_traits< char > >
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 36) SgFunctionRefExp = endl< char , char_traits< char > >
Is variable declaration? No
is variable reference? No
is function ref? Yes
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgExprListExp = endl< char , char_traits< char > >
node: SgExprListExp = endl< char , char_traits< char > >
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 33) SgExprListExp = endl< char , char_traits< char > >
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > >
node: SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > >
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 33) SgFunctionCallExp = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > >
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgExprStatement = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;
node: SgExprStatement = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 6, 2) SgExprStatement = (( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgIntVal = 0
node: SgIntVal = 0
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 7, 9) SgIntVal = 0
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgReturnStmt = return 0;
node: SgReturnStmt = return 0;
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 7, 2) SgReturnStmt = return 0;
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?Yes
TopBotTrack2: Ev_Synth_Attr
Current: SgBasicBlock = {int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
node: SgBasicBlock = {int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 4, 12) SgBasicBlock = {int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionDefinition = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
node: SgFunctionDefinition = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 4, 1) SgFunctionDefinition = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionDeclaration = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
node: SgFunctionDeclaration = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 4, 1) SgFunctionDeclaration = int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?Yes
Always returning NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_length
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_length
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_length
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = size_type _M_length;
node: SgVariableDeclaration = size_type _M_length;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = size_type _M_length;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_capacity
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_capacity
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_capacity
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = size_type _M_capacity;
node: SgVariableDeclaration = size_type _M_capacity;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = size_type _M_capacity;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_refcount
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_refcount
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep_base::_M_refcount
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = _Atomic_word _M_refcount;
node: SgVariableDeclaration = _Atomic_word _M_refcount;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = _Atomic_word _M_refcount;
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDefinition = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;}
node: SgClassDefinition = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;}
File: (compilerGenerated, 0, 0) SgClassDefinition = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;}
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDeclaration = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};
node: SgClassDeclaration = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};
File: (compilerGenerated, 0, 0) SgClassDeclaration = struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = typedef other _Raw_bytes_alloc;
node: SgTypedefDeclaration = typedef other _Raw_bytes_alloc;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = typedef other _Raw_bytes_alloc;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_max_size
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_max_size
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_max_size
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = static const size_type _S_max_size;
node: SgVariableDeclaration = static const size_type _S_max_size;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = static const size_type _S_max_size;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_terminal
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_terminal
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_terminal
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = static const char _S_terminal;
node: SgVariableDeclaration = static const char _S_terminal;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = static const char _S_terminal;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_empty_rep_storage
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_empty_rep_storage
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::_S_empty_rep_storage
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = static size_type _S_empty_rep_storage[];
node: SgVariableDeclaration = static size_type _S_empty_rep_storage[];
File: (compilerGenerated, 0, 0) SgVariableDeclaration = static size_type _S_empty_rep_storage[];
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__n
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc1
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc1
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc1
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc2
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc2
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__alloc2
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__a
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__a
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__a
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__res
node: SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__res
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_string < char , char_traits< char > , allocator< char > > ::_Rep::__res
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDefinition = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];}
node: SgClassDefinition = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];}
File: (compilerGenerated, 0, 0) SgClassDefinition = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];}
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDeclaration = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};
node: SgClassDeclaration = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};
File: (compilerGenerated, 0, 0) SgClassDeclaration = struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_ok
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_ok
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_ok
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = private: bool _M_ok;
node: SgVariableDeclaration = private: bool _M_ok;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = private: bool _M_ok;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_os
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_os
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::_M_os
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = private: class basic_ostream< char , char_traits< char > > &_M_os;
node: SgVariableDeclaration = private: class basic_ostream< char , char_traits< char > > &_M_os;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = private: class basic_ostream< char , char_traits< char > > &_M_os;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::__os
node: SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::__os
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_ostream < char , char_traits< char > > ::sentry::__os
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDefinition = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;}
node: SgClassDefinition = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;}
File: (compilerGenerated, 0, 0) SgClassDefinition = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;}
TopBotTrack2: Ev_Synth_Attr
Current: SgClassDeclaration = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};
node: SgClassDeclaration = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};
File: (compilerGenerated, 0, 0) SgClassDeclaration = class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef char char_type;
node: SgTypedefDeclaration = public: typedef char char_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef char char_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
node: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef int_type int_type;
node: SgTypedefDeclaration = public: typedef int_type int_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef int_type int_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef pos_type pos_type;
node: SgTypedefDeclaration = public: typedef pos_type pos_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef pos_type pos_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef off_type off_type;
node: SgTypedefDeclaration = public: typedef off_type off_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef off_type off_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
node: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ios < char , char_traits< char > > ;}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ios < char , char_traits< char > > ;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ios < char , char_traits< char > > ;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_istream < char , char_traits< char > > ;}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_istream < char , char_traits< char > > ;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_istream < char , char_traits< char > > ;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ostream < char , char_traits< char > > ;}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ostream < char , char_traits< char > > ;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class basic_ostream < char , char_traits< char > > ;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class istreambuf_iterator < char , char_traits< char > > ;}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class istreambuf_iterator < char , char_traits< char > > ;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class istreambuf_iterator < char , char_traits< char > > ;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {public: template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationFunctionDecl = 
node: SgTemplateInstantiationFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );
node: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );
node: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );
node: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );
node: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );
node: SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_beg
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_beg
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_beg
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_in_beg;
node: SgVariableDeclaration = protected: char_type *_M_in_beg;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_in_beg;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_cur
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_cur
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_cur
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_in_cur;
node: SgVariableDeclaration = protected: char_type *_M_in_cur;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_in_cur;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_end
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_end
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_in_end
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_in_end;
node: SgVariableDeclaration = protected: char_type *_M_in_end;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_in_end;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_beg
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_beg
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_beg
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_out_beg;
node: SgVariableDeclaration = protected: char_type *_M_out_beg;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_out_beg;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_cur
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_cur
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_cur
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_out_cur;
node: SgVariableDeclaration = protected: char_type *_M_out_cur;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_out_cur;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_end
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_end
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_out_end
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: char_type *_M_out_end;
node: SgVariableDeclaration = protected: char_type *_M_out_end;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: char_type *_M_out_end;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_buf_locale
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_buf_locale
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::_M_buf_locale
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = protected: class locale _M_buf_locale;
node: SgVariableDeclaration = protected: class locale _M_buf_locale;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = protected: class locale _M_buf_locale;
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__loc
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__loc
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__loc
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__off
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__off
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__off
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__way
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__way
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__way
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sp
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sp
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sp
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__mode
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__c
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gbeg
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gbeg
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gbeg
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gnext
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gnext
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gnext
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gend
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gend
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__gend
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pbeg
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pbeg
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pbeg
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pend
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pend
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__pend
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__n
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sb
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sb
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::__sb
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
node: SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::basic_streambuf < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDefn = template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;}
node: SgTemplateInstantiationDefn = template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDefn = template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef char char_type;
node: SgTypedefDeclaration = public: typedef char char_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef char char_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
node: SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef struct char_traits< char > traits_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > streambuf_type;
node: SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > streambuf_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_streambuf< char , char_traits< char > > streambuf_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > ostream_type;
node: SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > ostream_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class basic_ostream< char , char_traits< char > > ostream_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );
node: SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = public: template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_sbuf
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_sbuf
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_sbuf
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = private: streambuf_type *_M_sbuf;
node: SgVariableDeclaration = private: streambuf_type *_M_sbuf;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = private: streambuf_type *_M_sbuf;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_failed
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_failed
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::_M_failed
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = private: bool _M_failed;
node: SgVariableDeclaration = private: bool _M_failed;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = private: bool _M_failed;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__c
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__c
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__c
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__ws
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__ws
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__ws
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__len
node: SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__len
File: (compilerGenerated, 0, 0) SgInitializedName = std::ostreambuf_iterator < char , char_traits< char > > ::__len
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDefn = template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;}
node: SgTemplateInstantiationDefn = template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDefn = template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef char char_type;
node: SgTypedefDeclaration = public: typedef char char_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef char char_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgTypedefDeclaration = public: typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;
node: SgTypedefDeclaration = public: typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;
File: (compilerGenerated, 0, 0) SgTypedefDeclaration = public: typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::id
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::id
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::id
TopBotTrack2: Ev_Synth_Attr
Current: SgVariableDeclaration = public: static class id id;
node: SgVariableDeclaration = public: static class id id;
File: (compilerGenerated, 0, 0) SgVariableDeclaration = public: static class id id;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__refs
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__refs
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__refs
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__s
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__f
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;
node: SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__p
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__p
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__p
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;
node: SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;
File: (compilerGenerated, 0, 0) SgTemplateDeclaration = protected: template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__grouping_size
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__sep
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__w
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__w
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__w
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__io
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__new
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__cs
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__len
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__fill
TopBotTrack2: Ev_Synth_Attr
Current: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
node: SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
File: (compilerGenerated, 0, 0) SgInitializedName = std::num_put < char , ostreambuf_iterator< char , char_traits< char > > > ::__v
TopBotTrack2: Ev_Synth_Attr
Current: SgFunctionParameterList = 
node: SgFunctionParameterList = 
File: (compilerGenerated, 0, 0) SgFunctionParameterList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgCtorInitializerList = 
node: SgCtorInitializerList = 
File: (compilerGenerated, 0, 0) SgCtorInitializerList = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationMemberFunctionDecl = 
node: SgTemplateInstantiationMemberFunctionDecl = 
File: (compilerGenerated, 0, 0) SgTemplateInstantiationMemberFunctionDecl = 
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDefn = template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;}
node: SgTemplateInstantiationDefn = template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDefn = template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;}
TopBotTrack2: Ev_Synth_Attr
Current: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
node: SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
File: (compilerGenerated, 0, 0) SgTemplateInstantiationDecl = namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
TopBotTrack2: Ev_Synth_Attr
Current: SgGlobal = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
node: SgGlobal = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 0, 0) SgGlobal = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
TopBotTrack2: Ev_Synth_Attr
Current: SgSourceFile = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
node: SgSourceFile = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
File: (/Users/vanka1/research/compilers/rose/rose_build/projects/RTC/cout_example.cpp, 1, 1) SgSourceFile = double __builtin_copysign(double __builtin__x,double __builtin__y);float __builtin_copysignf(float __builtin__x,float __builtin__y);long double __builtin_copysignl(long double __builtin__x,long double __builtin__y);float __builtin_acosf(float __builtin__x);long double __builtin_acosl(long double __builtin__x);float __builtin_asinf(float __builtin__x);long double __builtin_asinl(long double __builtin__x);float __builtin_atanf(float __builtin__x);long double __builtin_atanl(long double __builtin__x);float __builtin_atan2f(float __builtin__x,float __builtin__y);long double __builtin_atan2l(long double __builtin__x,long double __builtin__y);float __builtin_ceilf(float __builtin__x);long double __builtin_ceill(long double __builtin__x);float __builtin_coshf(float __builtin__x);long double __builtin_coshl(long double __builtin__x);float __builtin_floorf(float __builtin__x);long double __builtin_floorl(long double __builtin__x);float __builtin_fmodf(float __builtin__x,float __builtin__y);long double __builtin_fmodl(long double __builtin__x,long double __builtin__y);float __builtin_frexpf(float __builtin__x,int *__builtin__y);long double __builtin_frexpl(long double __builtin__x,int *__builtin__y);float __builtin_ldexpf(float __builtin__x,float __builtin__y);long double __builtin_ldexpl(long double __builtin__x,long double __builtin__y);float __builtin_log10f(float __builtin__x);long double __builtin_log10l(long double __builtin__x);float __builtin_modff(float __builtin__x,float *__builtin__y);long double __builtin_modfl(long double __builtin__x,long double *__builtin__y);float __builtin_powf(float __builtin__x,float __builtin__y);long double __builtin_powl(long double __builtin__x,long double __builtin__y);float __builtin_sinhf(float __builtin__x);long double __builtin_sinhl(long double __builtin__x);float __builtin_tanf(float __builtin__x);long double __builtin_tanl(long double __builtin__x);float __builtin_tanhf(float __builtin__x);long double __builtin_tanhl(long double __builtin__x);long double __builtin_powil(long double __builtin__x,int __builtin__i);double __builtin_powi(double __builtin__x,int __builtin__i);float __builtin_powif(float __builtin__x,int __builtin__i);char *__builtin_strchr(const char *__builtin__s,int __builtin__c);char *__builtin_strrchr(const char *__builtin__s,int __builtin__c);char *__builtin_strpbrk(const char *__builtin__s,const char *__builtin__accept);char *__builtin_strstr(const char *__builtin__haystack,const char *__builtin__needle);float __builtin_nansf(const char *__builtin__x);double __builtin_nans(const char *__builtin__x);long double __builtin_nansl(const char *__builtin__x);double __builtin_fabs(double __builtin__x);float __builtin_fabsf(float __builtin__x);long double __builtin_fabsl(long double __builtin__x);float __builtin_cosf(float __builtin__x);long double __builtin_cosl(long double __builtin__x);float __builtin_sinf(float __builtin__x);long double __builtin_sinl(long double __builtin__x);float __builtin_sqrtf(float __builtin__x);long double __builtin_sqrtl(long double __builtin__x);int __builtin_fpclassify(int ,int ,int ,int ,int ,... );void *__builtin_return_address(unsigned int level);void *__builtin_frame_address(unsigned int level);long __builtin_expect(long __builtin__exp,long __builtin__c);void __builtin_prefetch(const void *__builtin__addr,... );double __builtin_huge_val();float __builtin_huge_valf();long double __builtin_huge_vall();double __builtin_inf();float __builtin_inff();long double __builtin_infl();double __builtin_nan(const char *__builtin__str);float __builtin_nanf(const char *__builtin__str);long double __builtin_nanl(const char *__builtin__str);double __builtin_nans(const char *__builtin__str);float __builtin_nansf(const char *__builtin__str);long double __builtin_nansl(const char *__builtin__str);int __builtin_clz(unsigned int __builtin__x);int __builtin_ctz(unsigned int __builtin__x);int __builtin_popcount(unsigned int __builtin__x);int __builtin_parity(unsigned int __builtin__x);int __builtin_ffsl(unsigned long __builtin__x);int __builtin_clzl(unsigned long __builtin__x);int __builtin_ctzl(unsigned long __builtin__x);int __builtin_popcountl(unsigned long __builtin__x);int __builtin_parityl(unsigned long __builtin__x);int __builtin_ffsll(unsigned long long __builtin__x);int __builtin_clzll(unsigned long long __builtin__x);int __builtin_ctzll(unsigned long long __builtin__x);int __builtin_popcountll(unsigned long long __builtin__x);int __builtin_parityll(unsigned long long __builtin__x);double __builtin_powi(double __builtin__x,int __builtin__y);float __builtin_powif(float __builtin__x,int __builtin__y);long double __builtin_powil(long double __builtin__x,int __builtin__y);int __sync_lock_test_and_set(int &v,int n);int __sync_lock_release(int &v);void __builtin_ia32_emms();int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_ext_v2si(int ,int );int __builtin_ia32_packsswb(short ,short );int __builtin_ia32_packssdw(int ,int );int __builtin_ia32_packuswb(short ,short );int __builtin_ia32_punpckhbw(short ,short );int __builtin_ia32_punpckhwd(short ,short );int __builtin_ia32_punpckhdq(int ,int );int __builtin_ia32_punpcklbw(char ,char );int __builtin_ia32_punpcklwd(short ,short );int __builtin_ia32_punpckldq(int ,int );int __builtin_ia32_paddb(char ,char );int __builtin_ia32_paddw(int ,int );int __builtin_ia32_paddd(short ,short );int __builtin_ia32_paddq(long long ,long long );int __builtin_ia32_paddsb(char ,char );int __builtin_ia32_paddsw(int ,int );int __builtin_ia32_paddusb(char ,char );int __builtin_ia32_paddusw(int ,int );int __builtin_ia32_psubb(char ,char );int __builtin_ia32_psubw(int ,int );int __builtin_ia32_psubd(int ,int );int __builtin_ia32_psubq(long long ,long long );int __builtin_ia32_psubsb(char ,char );int __builtin_ia32_psubsw(short ,short );int __builtin_ia32_psubusb(char ,char );int __builtin_ia32_psubusw(int ,int );int __builtin_ia32_pmaddwd(short ,short );int __builtin_ia32_pmulhw(short ,short );int __builtin_ia32_pmullw(short ,short );int __builtin_ia32_psllw(short ,long long );int __builtin_ia32_pslld(int ,long long );int __builtin_ia32_psllq(long long ,long long );int __builtin_ia32_psraw(short ,long long );int __builtin_ia32_psrad(short ,long long );int __builtin_ia32_psrlw(short ,long long );int __builtin_ia32_psrld(short ,long long );int __builtin_ia32_psrlq(long long ,long long );int __builtin_ia32_pand(int ,int );int __builtin_ia32_pandn(int ,int );int __builtin_ia32_por(int ,int );int __builtin_ia32_pxor(int ,int );int __builtin_ia32_pcmpeqb(char ,char );int __builtin_ia32_pcmpgtb(char ,char );int __builtin_ia32_pcmpeqw(short ,short );int __builtin_ia32_pcmpgtw(short ,short );int __builtin_ia32_pcmpeqd(int ,int );int __builtin_ia32_pcmpgtd(int ,int );int __builtin_ia32_vec_init_v2si(int ,int );int __builtin_ia32_vec_init_v4hi(short ,short ,short ,short );int __builtin_ia32_vec_init_v8qi(char ,char ,char ,char ,char ,char ,char ,char );int __builtin_ia32_addss(float ,float );int __builtin_ia32_subss(float ,float );int __builtin_ia32_mulss(float ,float );int __builtin_ia32_divss(float ,float );int __builtin_ia32_sqrtss(float );int __builtin_ia32_rcpss(float );int __builtin_ia32_rsqrtss(float );int __builtin_ia32_minss(float ,float );int __builtin_ia32_maxss(float ,float );int __builtin_ia32_addps(float ,float );int __builtin_ia32_subps(float ,float );int __builtin_ia32_mulps(float ,float );int __builtin_ia32_divps(float ,float );int __builtin_ia32_sqrtps(float );int __builtin_ia32_rcpps(float );int __builtin_ia32_rsqrtps(float );int __builtin_ia32_minps(float ,float );int __builtin_ia32_maxps(float ,float );int __builtin_ia32_andps(float ,float );int __builtin_ia32_andnps(float ,float );int __builtin_ia32_orps(float ,float );int __builtin_ia32_xorps(float ,float );int __builtin_ia32_cmpeqss(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpltss(float ,float );int __builtin_ia32_movss(float ,float );int __builtin_ia32_cmpless(float ,float );int __builtin_ia32_cmpneqss(float ,float );int __builtin_ia32_cmpnltss(float ,float );int __builtin_ia32_cmpnless(float ,float );int __builtin_ia32_cmpordss(float ,float );int __builtin_ia32_cmpunordss(float ,float );int __builtin_ia32_cmpeqps(float ,float );int __builtin_ia32_cmpltps(float ,float );int __builtin_ia32_cmpleps(float ,float );int __builtin_ia32_cmpgtps(float ,float );int __builtin_ia32_cmpgeps(float ,float );int __builtin_ia32_cmpneqps(float ,float );int __builtin_ia32_cmpnltps(float ,float );int __builtin_ia32_cmpnleps(float ,float );int __builtin_ia32_cmpngtps(float ,float );int __builtin_ia32_cmpngeps(float ,float );int __builtin_ia32_cmpordps(float ,float );int __builtin_ia32_cmpunordps(float ,float );int __builtin_ia32_comieq(float ,float );int __builtin_ia32_comilt(float ,float );int __builtin_ia32_comile(float ,float );int __builtin_ia32_comigt(float ,float );int __builtin_ia32_comige(float ,float );int __builtin_ia32_comineq(float ,float );int __builtin_ia32_ucomieq(float ,float );int __builtin_ia32_ucomilt(float ,float );int __builtin_ia32_ucomile(float ,float );int __builtin_ia32_ucomigt(float ,float );int __builtin_ia32_ucomige(float ,float );int __builtin_ia32_ucomineq(float ,float );int __builtin_ia32_cvtss2si(float );int __builtin_ia32_cvtss2si64(float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_cvttss2si(float );int __builtin_ia32_cvttss2si64(float );int __builtin_ia32_cvttps2pi(float );int __builtin_ia32_cvtsi2ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtsi642ss(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_cvtpi2ps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_cvtps2pi(float );int __builtin_ia32_unpckhps(float ,float );int __builtin_ia32_unpcklps(float ,float );int __builtin_ia32_loadhps(float ,int *);int __builtin_ia32_storehps(int *,float );int __builtin_ia32_movhlps(float ,float );int __builtin_ia32_movlhps(float ,float );int __builtin_ia32_loadlps(float ,int *);int __builtin_ia32_storelps(int *,float );int __builtin_ia32_movmskps(float );int __builtin_ia32_stmxcsr();int __builtin_ia32_ldmxcsr(int );int __builtin_ia32_loadups(const float *);int __builtin_ia32_shufps(short ,short ,int );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_vec_ext_v4sf(float ,float );int __builtin_ia32_storeups(float *,short );int __builtin_ia32_pmaxsw(float ,float );int __builtin_ia32_pmaxub(float ,float );int __builtin_ia32_pminsw(float ,float );int __builtin_ia32_pminub(float ,float );int __builtin_ia32_pmovmskb(char );int __builtin_ia32_pmulhuw(float ,float );int __builtin_ia32_maskmovq(char ,char ,char *);int __builtin_ia32_pavgb(float ,float );int __builtin_ia32_pavgw(float ,float );int __builtin_ia32_psadbw(float ,float );int __builtin_ia32_movntq(unsigned long long *,unsigned long long );int __builtin_ia32_movntps(float *,float );int __builtin_ia32_sfence();int __builtin_ia32_movsd(double ,double );int __builtin_ia32_loadupd(const double *);int __builtin_ia32_shufpd(double ,double ,int );int __builtin_ia32_storeupd(double *,double );int __builtin_ia32_vec_ext_v2df(double ,int );int __builtin_ia32_shufpd();int __builtin_ia32_vec_ext_v4si(int ,int );int __builtin_ia32_vec_ext_v2di(long long ,int );int __builtin_ia32_addpd(double ,double );int __builtin_ia32_addsd(double ,double );int __builtin_ia32_subpd(double ,double );int __builtin_ia32_subsd(double ,double );int __builtin_ia32_mulpd(double ,double );int __builtin_ia32_mulsd(double ,double );int __builtin_ia32_divpd(double ,double );int __builtin_ia32_divsd(double ,double );int __builtin_ia32_sqrtpd(double );int __builtin_ia32_sqrtsd(double );int __builtin_ia32_minpd(double ,double );int __builtin_ia32_minsd(double ,double );int __builtin_ia32_maxpd(double ,double );int __builtin_ia32_maxsd(double ,double );int __builtin_ia32_andpd(double ,double );int __builtin_ia32_andnpd(double ,double );int __builtin_ia32_orpd(double ,double );int __builtin_ia32_xorpd(double ,double );int __builtin_ia32_cmpeqpd(double ,double );int __builtin_ia32_cmpltpd(double ,double );int __builtin_ia32_cmplepd(double ,double );int __builtin_ia32_cmpgtpd(double ,double );int __builtin_ia32_cmpgepd(double ,double );int __builtin_ia32_cmpneqpd(double ,double );int __builtin_ia32_cmpnltpd(double ,double );int __builtin_ia32_cmpnlepd(double ,double );int __builtin_ia32_cmpngtpd(double ,double );int __builtin_ia32_cmpngepd(double ,double );int __builtin_ia32_cmpordpd(double ,double );int __builtin_ia32_cmpunordpd(double ,double );int __builtin_ia32_cmpeqsd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpltsd(double ,double );int __builtin_ia32_cmplesd(double ,double );int __builtin_ia32_cmpneqsd(double ,double );int __builtin_ia32_cmpnltsd(double ,double );int __builtin_ia32_cmpnlesd(double ,double );int __builtin_ia32_cmpordsd(double ,double );int __builtin_ia32_cmpunordsd(double ,double );int __builtin_ia32_comisdeq(double ,double );int __builtin_ia32_comisdlt(double ,double );int __builtin_ia32_comisdle(double ,double );int __builtin_ia32_comisdgt(double ,double );int __builtin_ia32_comisdge(double ,double );int __builtin_ia32_comisdg(double ,double );int __builtin_ia32_comisdneq(double ,double );int __builtin_ia32_ucomisdeq(double ,double );int __builtin_ia32_ucomisdlt(double ,double );int __builtin_ia32_ucomisdle(double ,double );int __builtin_ia32_ucomisdgt(double ,double );int __builtin_ia32_ucomisdge(double ,double );int __builtin_ia32_ucomisdneq(double ,double );int __builtin_ia32_loaddqu(const char *);int __builtin_ia32_storedqu(char *,char );int __builtin_ia32_cvtdq2pd(int );int __builtin_ia32_cvtdq2ps(int );int __builtin_ia32_cvtpd2dq(double );int __builtin_ia32_cvtpd2pi(double );int __builtin_ia32_cvtpd2ps(double );int __builtin_ia32_cvttpd2dq(double );int __builtin_ia32_cvttpd2pi(double );int __builtin_ia32_cvtpi2pd(int );int __builtin_ia32_cvtps2dq(double );int __builtin_ia32_cvttps2dq(double );int __builtin_ia32_cvtps2pd(float );int __builtin_ia32_cvtsd2si(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvtsd2si64(double );int __builtin_ia32_cvttsd2si(double );int __builtin_ia32_cvttsd2si64(double );int __builtin_ia32_cvtsd2ss(int ,int );int __builtin_ia32_cvtsi2sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtsi642sd(int ,int );int __builtin_ia32_cvtss2sd(int ,int );int __builtin_ia32_unpcklpd(int ,int );int __builtin_ia32_unpckhpd(double ,double );int __builtin_ia32_loadhpd(double ,const double *);int __builtin_ia32_loadlpd(double ,const double *);int __builtin_ia32_movmskpd(double );int __builtin_ia32_packsswb128(short ,short );int __builtin_ia32_packssdw128(short ,short );int __builtin_ia32_packuswb128(short ,short );int __builtin_ia32_punpckhbw128(short ,short );int __builtin_ia32_punpckhwd128(int ,int );int __builtin_ia32_punpckhdq128(int ,int );int __builtin_ia32_punpckhqdq128(int ,int );int __builtin_ia32_punpcklbw128(int ,int );int __builtin_ia32_punpcklwd128(int ,int );int __builtin_ia32_punpckldq128(int ,int );int __builtin_ia32_punpcklqdq128(int ,int );int __builtin_ia32_paddb128(long long ,long long );int __builtin_ia32_paddw128(short ,short );int __builtin_ia32_paddd128(int ,int );int __builtin_ia32_paddq128(long long ,long long );int __builtin_ia32_paddsb128(long long ,long long );int __builtin_ia32_paddsw128(short ,short );int __builtin_ia32_paddusb128(char ,char );int __builtin_ia32_paddusw128(short ,short );int __builtin_ia32_psubb128(char ,char );int __builtin_ia32_psubw128(short ,short );int __builtin_ia32_psubd128(int ,int );int __builtin_ia32_psubq128(double ,double );int __builtin_ia32_psubsb128(char ,char );int __builtin_ia32_psubsw128(short ,short );int __builtin_ia32_psubusb128(char ,char );int __builtin_ia32_psubusw128(short ,short );int __builtin_ia32_pmaddwd128(short ,short );int __builtin_ia32_pmulhw128(short ,short );int __builtin_ia32_pmullw128(short ,short );int __builtin_ia32_pmuludq(int ,int );int __builtin_ia32_pmuludq128(int ,int );int __builtin_ia32_psllwi128(short ,short );int __builtin_ia32_pslldi128(int ,int );int __builtin_ia32_psllqi128(int ,int );int __builtin_ia32_psrawi128(short ,short );int __builtin_ia32_psradi128(short ,short );int __builtin_ia32_psrlwi128(short ,short );int __builtin_ia32_psrldi128(short ,short );int __builtin_ia32_psrlqi128(short ,short );int __builtin_ia32_psllw128(short ,short );int __builtin_ia32_pslld128(short ,short );int __builtin_ia32_psllq128(short ,short );int __builtin_ia32_psraw128(short ,short );int __builtin_ia32_psrad128(short ,short );int __builtin_ia32_psrlw128(short ,short );int __builtin_ia32_psrld128(short ,short );int __builtin_ia32_psrlq128(short ,short );int __builtin_ia32_pand128(int ,int );int __builtin_ia32_pandn128(int ,int );int __builtin_ia32_por128(int ,int );int __builtin_ia32_pxor128(int ,int );int __builtin_ia32_pcmpeqb128(char ,char );int __builtin_ia32_pcmpeqw128(short ,short );int __builtin_ia32_pcmpeqd128(short ,short );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pcmpgtd128(int ,int );int __builtin_ia32_pcmpgtb128(char ,char );int __builtin_ia32_pcmpgtw128(short ,short );int __builtin_ia32_pmaxsw128(short ,short );int __builtin_ia32_pmaxub128(char ,char );int __builtin_ia32_pminsw128(short ,short );int __builtin_ia32_pminub128(char ,char );int __builtin_ia32_pmovmskb128(char );int __builtin_ia32_pmulhuw128(short ,short );int __builtin_ia32_maskmovdqu(char ,char ,char *);int __builtin_ia32_pavgb128(char ,char );int __builtin_ia32_pavgw128(short ,short );int __builtin_ia32_psadbw128(char ,char );int __builtin_ia32_movnti(int *,int );int __builtin_ia32_movntdq(long long *,long long );int __builtin_ia32_movntpd(double *,double );int __builtin_ia32_clflush(const void *);int __builtin_ia32_lfence();int __builtin_ia32_mfence();int __builtin_ia32_psllwi(short ,int );int __builtin_ia32_pslldi(int ,int );int __builtin_ia32_psllqi(long long ,int );int __builtin_ia32_psrawi(short ,int );int __builtin_ia32_psradi(int ,int );int __builtin_ia32_psrlwi(int ,int );int __builtin_ia32_psrldi(int ,int );int __builtin_ia32_psrlqi(long long ,int );#pragma GCC system_headertypedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;typedef int __darwin_ct_rune_t;typedef union __unnamed_class___F3_L76_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_128_Ae__variable_name_unknown_scope_and_name__scope____mbstate8__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope___mbstateL {char __mbstate8[128UL];long long _mbstateL;}__mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long __darwin_ptrdiff_t;typedef unsigned long __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;struct __darwin_pthread_handler_rec {void(*__routine)(void *);void *__arg;struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_cond_t {long __sig;char __opaque[40UL];};struct _opaque_pthread_condattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_mutex_t {long __sig;char __opaque[56UL];};struct _opaque_pthread_mutexattr_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_once_t {long __sig;char __opaque[8UL];};struct _opaque_pthread_rwlock_t {long __sig;char __opaque[192UL];};struct _opaque_pthread_rwlockattr_t {long __sig;char __opaque[16UL];};struct _opaque_pthread_t {long __sig;struct __darwin_pthread_handler_rec *__cleanup_stack;char __opaque[1168UL];};typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16UL];typedef char __darwin_uuid_string_t[37UL];typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;struct accessx_descriptor {unsigned int ad_name_offset;int ad_flags;int ad_pad[2UL];};typedef __darwin_dev_t dev_t;typedef __darwin_gid_t gid_t;typedef __darwin_intptr_t intptr_t;typedef __darwin_mode_t mode_t;typedef __darwin_off_t off_t;typedef __darwin_pid_t pid_t;typedef __darwin_size_t size_t;typedef __darwin_ssize_t ssize_t;typedef __darwin_uid_t uid_t;typedef __darwin_useconds_t useconds_t;typedef __darwin_uuid_t uuid_t;extern "C" {void _exit(int );}extern "C" {int access(const char *,int );}extern "C" {unsigned int alarm(unsigned int );}extern "C" {int chdir(const char *);}extern "C" {int chown(const char *,uid_t ,gid_t );}extern "C" {int close(int );}extern "C" {size_t confstr(int ,char *,size_t );}extern "C" {char *crypt(const char *,const char *);}extern "C" {char *ctermid(char *);}extern "C" {int dup(int );}extern "C" {int dup2(int ,int );}extern "C" {void encrypt(char *,int );}extern "C" {int execl(const char *,const char *,... );}extern "C" {int execle(const char *,const char *,... );}extern "C" {int execlp(const char *,const char *,... );}extern "C" {int execv(const char *,char *const *);}extern "C" {int execve(const char *,char *const *,char *const *);}extern "C" {int execvp(const char *,char *const *);}extern "C" {int fchown(int ,uid_t ,gid_t );}extern "C" {int fchdir(int );}extern "C" {pid_t fork();}extern "C" {long fpathconf(int ,int );}extern "C" {int fsync(int );}extern "C" {int ftruncate(int ,off_t );}extern "C" {char *getcwd(char *,size_t );}extern "C" {gid_t getegid();}extern "C" {uid_t geteuid();}extern "C" {gid_t getgid();}extern "C" {int getgroups(int ,gid_t []);}extern "C" {long gethostid();}extern "C" {int gethostname(char *,size_t );}extern "C" {char *getlogin();}extern "C" {int getlogin_r(char *,size_t );}extern "C" {int getopt(int ,char *const [],const char *);}extern "C" {pid_t getpgid(pid_t );}extern "C" {pid_t getpgrp();}extern "C" {pid_t getpid();}extern "C" {pid_t getppid();}extern "C" {pid_t getsid(pid_t );}extern "C" {uid_t getuid();}extern "C" {char *getwd(char *);}extern "C" {int isatty(int );}extern "C" {int lchown(const char *,uid_t ,gid_t );}extern "C" {int link(const char *,const char *);}extern "C" {int lockf(int ,int ,off_t );}extern "C" {off_t lseek(int ,off_t ,int );}extern "C" {int nice(int );}extern "C" {long pathconf(const char *,int );}extern "C" {int pause();}extern "C" {int pipe(int [2UL]);}extern "C" {ssize_t pread(int ,void *,size_t ,off_t );}extern "C" {ssize_t pwrite(int ,const void *,size_t ,off_t );}extern "C" {ssize_t read(int ,void *,size_t );}extern "C" {ssize_t readlink(const char *,char *,size_t );}extern "C" {int rmdir(const char *);}extern "C" {int setegid(gid_t );}extern "C" {int seteuid(uid_t );}extern "C" {int setgid(gid_t );}extern "C" {int setpgid(pid_t ,pid_t );}extern "C" {pid_t setpgrp();}extern "C" {int setregid(gid_t ,gid_t );}extern "C" {int setreuid(uid_t ,uid_t );}extern "C" {pid_t setsid();}extern "C" {int setuid(uid_t );}extern "C" {unsigned int sleep(unsigned int );}extern "C" {void swab(const void *,void *,ssize_t );}extern "C" {int symlink(const char *,const char *);}extern "C" {void sync();}extern "C" {long sysconf(int );}extern "C" {pid_t tcgetpgrp(int );}extern "C" {int tcsetpgrp(int ,pid_t );}extern "C" {int truncate(const char *,off_t );}extern "C" {char *ttyname(int );}extern "C" {int ttyname_r(int ,char *,size_t );}extern "C" {useconds_t ualarm(useconds_t ,useconds_t );}extern "C" {int unlink(const char *);}extern "C" {int usleep(useconds_t );}extern "C" {pid_t vfork();}extern "C" {ssize_t write(int ,const void *,size_t );}extern "C" char *optarg;extern "C" int optind;extern "C" int opterr;extern "C" int optopt;struct timespec {__darwin_time_t tv_sec;long tv_nsec;};struct timeval {__darwin_time_t tv_sec;__darwin_suseconds_t tv_usec;};typedef struct fd_set {__int32_t fds_bits[(((1024 %((sizeof(__int32_t )) * 8)) == 0)?(1024 /((sizeof(__int32_t )) * 8)) :((1024 /((sizeof(__int32_t )) * 8)) + 1))];}fd_set;inline static int __darwin_fd_isset(int _n,const struct fd_set *_p){return(_p -> fds_bits)[_n / 32ULL] &(1 <<(_n % 32ULL));}typedef __darwin_time_t time_t;typedef __darwin_suseconds_t suseconds_t;typedef __darwin_sigset_t sigset_t;extern "C" {int pselect(int ,fd_set *,fd_set *,fd_set *,const struct timespec *,const sigset_t *);}extern "C" {int select(int ,fd_set *,fd_set *,fd_set *,struct timeval *);}extern "C" {void _Exit(int );}extern "C" {int accessx_np(const struct accessx_descriptor *,size_t ,int *,uid_t );}extern "C" {int acct(const char *);}extern "C" {int add_profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {void *brk(const void *);}extern "C" {int chroot(const char *);}extern "C" {void endusershell();}extern "C" {int execvP(const char *,const char *,char *const *);}extern "C" {char *fflagstostr(unsigned long );}extern "C" {int getdtablesize();}extern "C" {int getdomainname(char *,int );}extern "C" {int getgrouplist(const char *,int ,int *,int *);}extern "C" {int gethostuuid(uuid_t ,const struct timespec *);}extern "C" {mode_t getmode(const void *,mode_t );}extern "C" {int getpagesize();}extern "C" {char *getpass(const char *);}extern "C" {int getpeereid(int ,uid_t *,gid_t *);}extern "C" {pid_t getpgid(pid_t _pid);}extern "C" {int getsgroups_np(int *,uuid_t );}extern "C" {pid_t getsid(pid_t _pid);}extern "C" {char *getusershell();}extern "C" {int getwgroups_np(int *,uuid_t );}extern "C" {int initgroups(const char *,int );}extern "C" {int iruserok(unsigned long ,int ,const char *,const char *);}extern "C" {int iruserok_sa(const void *,int ,int ,const char *,const char *);}extern "C" {int issetugid();}extern "C" {char *mkdtemp(char *);}extern "C" {int mknod(const char *,mode_t ,dev_t );}extern "C" {int mkstemp(char *);}extern "C" {int mkstemps(char *,int );}extern "C" {char *mktemp(char *);}extern "C" {int nfssvc(int ,void *);}extern "C" {int profil(char *,size_t ,unsigned long ,unsigned int );}extern "C" {int pthread_setugid_np(uid_t ,gid_t );}extern "C" {int pthread_getugid_np(uid_t *,gid_t *);}extern "C" {int rcmd(char **,int ,const char *,const char *,const char *,int *);}extern "C" {int rcmd_af(char **,int ,const char *,const char *,const char *,int *,int );}extern "C" {int reboot(int );}extern "C" {int revoke(const char *);}extern "C" {int rresvport(int *);}extern "C" {int rresvport_af(int *,int );}extern "C" {int ruserok(const char *,int ,const char *,const char *);}extern "C" {void *sbrk(int );}extern "C" {int setdomainname(const char *,int );}extern "C" {int setgroups(int ,const gid_t *);}extern "C" {void sethostid(long );}extern "C" {int sethostname(const char *,int );}extern "C" {void setkey(const char *);}extern "C" {int setlogin(const char *);}extern "C" {void *setmode(const char *);}extern "C" {int setrgid(gid_t );}extern "C" {int setruid(uid_t );}extern "C" {int setsgroups_np(int ,const uuid_t );}extern "C" {void setusershell();}extern "C" {int setwgroups_np(int ,const uuid_t );}extern "C" {int strtofflags(char **,unsigned long *,unsigned long *);}extern "C" {int swapon(const char *);}extern "C" {int syscall(int ,... );}extern "C" {int ttyslot();}extern "C" {int undelete(const char *);}extern "C" {int unwhiteout(const char *);}extern "C" {void *valloc(size_t );}extern "C" char *suboptarg;extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int fgetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int fsetattrlist(int ,void *,void *,size_t ,unsigned int );}extern "C" {int getattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int setattrlist(const char *,void *,void *,size_t ,unsigned int );}extern "C" {int exchangedata(const char *,const char *,unsigned int );}extern "C" {int getdirentriesattr(int ,void *,void *,size_t ,unsigned int *,unsigned int *,unsigned int *,unsigned int );}struct fssearchblock ;struct searchstate ;extern "C" {int searchfs(const char *,struct fssearchblock *,unsigned long *,unsigned int ,unsigned int ,struct searchstate *);}extern "C" {int fsctl(const char *,unsigned long ,void *,unsigned int );}extern "C" {int ffsctl(int ,unsigned long ,void *,unsigned int );}extern "C" int optreset;extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1();}extern "C" {void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);}extern "C" {int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1();}namespace std{}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headerstruct lconv {char *decimal_point;char *thousands_sep;char *grouping;char *int_curr_symbol;char *currency_symbol;char *mon_decimal_point;char *mon_thousands_sep;char *mon_grouping;char *positive_sign;char *negative_sign;char int_frac_digits;char frac_digits;char p_cs_precedes;char p_sep_by_space;char n_cs_precedes;char n_sep_by_space;char p_sign_posn;char n_sign_posn;char int_p_cs_precedes;char int_n_cs_precedes;char int_p_sep_by_space;char int_n_sep_by_space;char int_p_sign_posn;char int_n_sign_posn;};extern "C" {struct lconv *localeconv();}extern "C" {char *setlocale(int ,const char *);}namespace std{using lconv;using setlocale;using localeconv;}#pragma GCC system_header#pragma GCC system_headertypedef long ptrdiff_t;namespace std{using ptrdiff_t;using size_t;}extern "C" {void *memchr(const void *,int ,size_t );}extern "C" {int memcmp(const void *,const void *,size_t );}extern "C" {void *memcpy(void *,const void *,size_t );}extern "C" {void *memmove(void *,const void *,size_t );}extern "C" {void *memset(void *,int ,size_t );}extern "C" {char *stpcpy(char *,const char *);}extern "C" {char *strcasestr(const char *,const char *);}extern "C" {char *strcat(char *,const char *);}extern "C" {char *strchr(const char *,int );}extern "C" {int strcmp(const char *,const char *);}extern "C" {int strcoll(const char *,const char *);}extern "C" {char *strcpy(char *,const char *);}extern "C" {size_t strcspn(const char *,const char *);}extern "C" {char *strerror(int );}extern "C" {int strerror_r(int ,char *,size_t );}extern "C" {size_t strlen(const char *);}extern "C" {char *strncat(char *,const char *,size_t );}extern "C" {int strncmp(const char *,const char *,size_t );}extern "C" {char *strncpy(char *,const char *,size_t );}extern "C" {char *strnstr(const char *,const char *,size_t );}extern "C" {char *strpbrk(const char *,const char *);}extern "C" {char *strrchr(const char *,int );}extern "C" {size_t strspn(const char *,const char *);}extern "C" {char *strstr(const char *,const char *);}extern "C" {char *strtok(char *,const char *);}extern "C" {size_t strxfrm(char *,const char *,size_t );}extern "C" {void *memccpy(void *,const void *,int ,size_t );}extern "C" {char *strtok_r(char *,const char *,char **);}extern "C" {char *strdup(const char *);}extern "C" {int bcmp(const void *,const void *,size_t );}extern "C" {void bcopy(const void *,void *,size_t );}extern "C" {void bzero(void *,size_t );}extern "C" {int ffs(int );}extern "C" {int ffsl(long );}extern "C" {int fls(int );}extern "C" {int flsl(long );}extern "C" {char *index(const char *,int );}extern "C" {void memset_pattern4(void *,const void *,size_t );}extern "C" {void memset_pattern8(void *,const void *,size_t );}extern "C" {void memset_pattern16(void *,const void *,size_t );}extern "C" {char *rindex(const char *,int );}extern "C" {int strcasecmp(const char *,const char *);}extern "C" {size_t strlcat(char *,const char *,size_t );}extern "C" {size_t strlcpy(char *,const char *,size_t );}extern "C" {void strmode(int ,char *);}extern "C" {int strncasecmp(const char *,const char *,size_t );}extern "C" {char *strsep(char **,const char *);}extern "C" {char *strsignal(int sig);}extern "C" {void swab(const void *,void *,ssize_t );}namespace std{using memcpy;using memmove;using strcpy;using strncpy;using strcat;using strncat;using memcmp;using strcmp;using strcoll;using strncmp;using strxfrm;using strcspn;using strspn;using strtok;using memset;using strerror;using strlen;using memchr;inline void *memchr(void *__p,int __c,size_t __n){return memchr(((const void *)__p),__c,__n);}using strchr;inline char *strchr(char *__s1,int __n){return __builtin_strchr(((const char *)__s1),__n);}using strpbrk;inline char *strpbrk(char *__s1,const char *__s2){return __builtin_strpbrk(((const char *)__s1),__s2);}using strrchr;inline char *strrchr(char *__s1,int __n){return __builtin_strrchr(((const char *)__s1),__n);}using strstr;inline char *strstr(char *__s1,const char *__s2){return __builtin_strstr(((const char *)__s1),__s2);}}#pragma GCC system_headertypedef __darwin_va_list va_list;typedef __darwin_off_t fpos_t;struct __sbuf {unsigned char *_base;int _size;};struct __sFILEX ;typedef struct __sFILE {unsigned char *_p;int _r;int _w;short _flags;short _file;struct __sbuf _bf;int _lbfsize;void *_cookie;int(*_close)(void *);int(*_read)(void *, char *, int );fpos_t(*_seek)(void *, fpos_t , int );int(*_write)(void *, const char *, int );struct __sbuf _ub;struct __sFILEX *_extra;int _ur;unsigned char _ubuf[3UL];unsigned char _nbuf[1UL];struct __sbuf _lb;int _blksize;fpos_t _offset;}FILE;extern "C" FILE *__stdinp;extern "C" FILE *__stdoutp;extern "C" FILE *__stderrp;extern "C" {void clearerr(FILE *);}extern "C" {int fclose(FILE *);}extern "C" {int feof(FILE *);}extern "C" {int ferror(FILE *);}extern "C" {int fflush(FILE *);}extern "C" {int fgetc(FILE *);}extern "C" {int fgetpos(FILE *,fpos_t *);}extern "C" {char *fgets(char *,int ,FILE *);}extern "C" {FILE *fopen(const char *,const char *);}extern "C" {int fprintf(FILE *,const char *,... );}extern "C" {int fputc(int ,FILE *);}extern "C" {int fputs(const char *,FILE *);}extern "C" {size_t fread(void *,size_t ,size_t ,FILE *);}extern "C" {FILE *freopen(const char *,const char *,FILE *);}extern "C" {int fscanf(FILE *,const char *,... );}extern "C" {int fseek(FILE *,long ,int );}extern "C" {int fsetpos(FILE *,const fpos_t *);}extern "C" {long ftell(FILE *);}extern "C" {size_t fwrite(const void *,size_t ,size_t ,FILE *);}extern "C" {int getc(FILE *);}extern "C" {int getchar();}extern "C" {char *gets(char *);}extern "C" const int sys_nerr;extern "C" const char *const sys_errlist[];extern "C" {void perror(const char *);}extern "C" {int printf(const char *,... );}extern "C" {int putc(int ,FILE *);}extern "C" {int putchar(int );}extern "C" {int puts(const char *);}extern "C" {int remove(const char *);}extern "C" {int rename(const char *,const char *);}extern "C" {void rewind(FILE *);}extern "C" {int scanf(const char *,... );}extern "C" {void setbuf(FILE *,char *);}extern "C" {int setvbuf(FILE *,char *,int ,size_t );}extern "C" {int sprintf(char *,const char *,... );}extern "C" {int sscanf(const char *,const char *,... );}extern "C" {FILE *tmpfile();}extern "C" {char *tmpnam(char *);}extern "C" {int ungetc(int ,FILE *);}extern "C" {int vfprintf(FILE *,const char *,va_list );}extern "C" {int vprintf(const char *,va_list );}extern "C" {int vsprintf(char *,const char *,va_list );}extern "C" {int asprintf(char **,const char *,... );}extern "C" {int vasprintf(char **,const char *,va_list );}extern "C" {char *ctermid(char *);}extern "C" {char *ctermid_r(char *);}extern "C" {FILE *fdopen(int ,const char *);}extern "C" {char *fgetln(FILE *,size_t *);}extern "C" {int fileno(FILE *);}extern "C" {void flockfile(FILE *);}extern "C" {const char *fmtcheck(const char *,const char *);}extern "C" {int fpurge(FILE *);}extern "C" {int fseeko(FILE *,off_t ,int );}extern "C" {off_t ftello(FILE *);}extern "C" {int ftrylockfile(FILE *);}extern "C" {void funlockfile(FILE *);}extern "C" {int getc_unlocked(FILE *);}extern "C" {int getchar_unlocked();}extern "C" {int getw(FILE *);}extern "C" {int pclose(FILE *);}extern "C" {FILE *popen(const char *,const char *);}extern "C" {int putc_unlocked(int ,FILE *);}extern "C" {int putchar_unlocked(int );}extern "C" {int putw(int ,FILE *);}extern "C" {void setbuffer(FILE *,char *,int );}extern "C" {int setlinebuf(FILE *);}extern "C" {int snprintf(char *,size_t ,const char *,... );}extern "C" {char *tempnam(const char *,const char *);}extern "C" {int vfscanf(FILE *,const char *,va_list );}extern "C" {int vscanf(const char *,va_list );}extern "C" {int vsnprintf(char *,size_t ,const char *,va_list );}extern "C" {int vsscanf(const char *,const char *,va_list );}extern "C" {FILE *zopen(const char *,const char *,int );}extern "C" {FILE *funopen(const void *,int(*)(void *, char *, int ),int(*)(void *, const char *, int ),fpos_t(*)(void *, fpos_t , int ),int(*)(void *));}extern "C" {int __srget(FILE *);}extern "C" {int __svfscanf(FILE *,const char *,va_list );}extern "C" {int __swbuf(int ,FILE *);}inline static int __sputc(int _c,FILE *_p){if((--_p -> _w >= 0) ||(((_p -> _w) >=(_p -> _lbfsize)) &&(((char )_c) != 10))) return( *(_p -> _p++) = _c);else return __swbuf(_c,_p);}namespace std{using FILE;using fpos_t;using clearerr;using fclose;using feof;using ferror;using fflush;using fgetc;using fgetpos;using fgets;using fopen;using fprintf;using fputc;using fputs;using fread;using freopen;using fscanf;using fseek;using fsetpos;using ftell;using fwrite;using getc;using getchar;using gets;using perror;using printf;using putc;using putchar;using puts;using remove;using rename;using rewind;using scanf;using setbuf;using setvbuf;using sprintf;using sscanf;using tmpfile;using tmpnam;using ungetc;using vfprintf;using vprintf;using vsprintf;}namespace __gnu_cxx{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}namespace std{using snprintf;using vfscanf;using vscanf;using vsnprintf;using vsscanf;}#pragma GCC system_headertypedef __builtin_va_list __gnuc_va_list;namespace std{using va_list;}namespace std{typedef int *__c_locale;inline int __convert_from_v(const __c_locale &,char *__out,const int __size,const char *__fmt,... ){char *__old = setlocale(4,0);char *__sav = 0;if((strcmp(__old,"C"))) {__sav =(new char [(strlen(__old) + 1)]);strcpy(__sav,__old);setlocale(4,"C");}va_list __args;va_start(__args,__fmt);const int __ret = vsnprintf(__out,__size,__fmt,__args);va_end(__args);if(__sav) {setlocale(4,__sav);delete []__sav;}return __ret;}}#pragma GCC visibility push( default )struct sched_param {int sched_priority;char __opaque[4UL];};extern "C" {int sched_yield();}extern "C" {int sched_get_priority_min(int );}extern "C" {int sched_get_priority_max(int );}typedef __darwin_clock_t clock_t;struct tm {int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int tm_year;int tm_wday;int tm_yday;int tm_isdst;long tm_gmtoff;char *tm_zone;};extern char *tzname[];extern int getdate_err;extern long timezone;extern int daylight;extern "C" {char *asctime(const struct tm *);}extern "C" {clock_t clock();}extern "C" {char *ctime(const time_t *);}extern "C" {double difftime(time_t ,time_t );}extern "C" {struct tm *getdate(const char *);}extern "C" {struct tm *gmtime(const time_t *);}extern "C" {struct tm *localtime(const time_t *);}extern "C" {time_t mktime(struct tm *);}extern "C" {size_t strftime(char *,size_t ,const char *,const struct tm *);}extern "C" {char *strptime(const char *,const char *,struct tm *);}extern "C" {time_t time(time_t *);}extern "C" {void tzset();}extern "C" {char *asctime_r(const struct tm *,char *);}extern "C" {char *ctime_r(const time_t *,char *);}extern "C" {struct tm *gmtime_r(const time_t *,struct tm *);}extern "C" {struct tm *localtime_r(const time_t *,struct tm *);}extern "C" {time_t posix2time(time_t );}extern "C" {void tzsetwall();}extern "C" {time_t time2posix(time_t );}extern "C" {time_t timelocal(struct tm *const );}extern "C" {time_t timegm(struct tm *const );}extern "C" {int nanosleep(const struct timespec *,struct timespec *);}typedef __darwin_pthread_attr_t pthread_attr_t;typedef __darwin_pthread_cond_t pthread_cond_t;typedef __darwin_pthread_condattr_t pthread_condattr_t;typedef __darwin_pthread_key_t pthread_key_t;typedef __darwin_pthread_mutex_t pthread_mutex_t;typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;typedef __darwin_pthread_once_t pthread_once_t;typedef __darwin_pthread_rwlock_t pthread_rwlock_t;typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;typedef __darwin_pthread_t pthread_t;typedef __darwin_mach_port_t mach_port_t;extern "C" {int pthread_atfork(void(*)(),void(*)(),void(*)());}extern "C" {int pthread_attr_destroy(pthread_attr_t *);}extern "C" {int pthread_attr_getdetachstate(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getguardsize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_getinheritsched(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);}extern "C" {int pthread_attr_getschedpolicy(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getscope(const pthread_attr_t *,int *);}extern "C" {int pthread_attr_getstack(const pthread_attr_t *,void **,size_t *);}extern "C" {int pthread_attr_getstackaddr(const pthread_attr_t *,void **);}extern "C" {int pthread_attr_getstacksize(const pthread_attr_t *,size_t *);}extern "C" {int pthread_attr_init(pthread_attr_t *);}extern "C" {int pthread_attr_setdetachstate(pthread_attr_t *,int );}extern "C" {int pthread_attr_setguardsize(pthread_attr_t *,size_t );}extern "C" {int pthread_attr_setinheritsched(pthread_attr_t *,int );}extern "C" {int pthread_attr_setschedparam(pthread_attr_t *,const struct sched_param *);}extern "C" {int pthread_attr_setschedpolicy(pthread_attr_t *,int );}extern "C" {int pthread_attr_setscope(pthread_attr_t *,int );}extern "C" {int pthread_attr_setstack(pthread_attr_t *,void *,size_t );}extern "C" {int pthread_attr_setstackaddr(pthread_attr_t *,void *);}extern "C" {int pthread_attr_setstacksize(pthread_attr_t *,size_t );}extern "C" {int pthread_cancel(pthread_t );}extern "C" {int pthread_cond_broadcast(pthread_cond_t *);}extern "C" {int pthread_cond_destroy(pthread_cond_t *);}extern "C" {int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *);}extern "C" {int pthread_cond_signal(pthread_cond_t *);}extern "C" {int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_cond_wait(pthread_cond_t *,pthread_mutex_t *);}extern "C" {int pthread_condattr_destroy(pthread_condattr_t *);}extern "C" {int pthread_condattr_init(pthread_condattr_t *);}extern "C" {int pthread_condattr_getpshared(const pthread_condattr_t *,int *);}extern "C" {int pthread_condattr_setpshared(pthread_condattr_t *,int );}extern "C" {int pthread_create(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_detach(pthread_t );}extern "C" {int pthread_equal(pthread_t ,pthread_t );}extern "C" {void pthread_exit(void *);}extern "C" {int pthread_getconcurrency();}extern "C" {int pthread_getschedparam(pthread_t ,int *,struct sched_param *);}extern "C" {void *pthread_getspecific(pthread_key_t );}extern "C" {int pthread_join(pthread_t ,void **);}extern "C" {int pthread_key_create(pthread_key_t *,void(*)(void *));}extern "C" {int pthread_key_delete(pthread_key_t );}extern "C" {int pthread_mutex_destroy(pthread_mutex_t *);}extern "C" {int pthread_mutex_getprioceiling(const pthread_mutex_t *,int *);}extern "C" {int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *);}extern "C" {int pthread_mutex_lock(pthread_mutex_t *);}extern "C" {int pthread_mutex_setprioceiling(pthread_mutex_t *,int ,int *);}extern "C" {int pthread_mutex_trylock(pthread_mutex_t *);}extern "C" {int pthread_mutex_unlock(pthread_mutex_t *);}extern "C" {int pthread_mutexattr_destroy(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_gettype(const pthread_mutexattr_t *,int *);}extern "C" {int pthread_mutexattr_init(pthread_mutexattr_t *);}extern "C" {int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setprotocol(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_setpshared(pthread_mutexattr_t *,int );}extern "C" {int pthread_mutexattr_settype(pthread_mutexattr_t *,int );}extern "C" {int pthread_once(pthread_once_t *,void(*)());}extern "C" {int pthread_rwlock_destroy(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);}extern "C" {int pthread_rwlock_rdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_tryrdlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_trywrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_wrlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlock_unlock(pthread_rwlock_t *);}extern "C" {int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);}extern "C" {int pthread_rwlockattr_init(pthread_rwlockattr_t *);}extern "C" {int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,int );}extern "C" {pthread_t pthread_self();}extern "C" {int pthread_setcancelstate(int ,int *);}extern "C" {int pthread_setcanceltype(int ,int *);}extern "C" {int pthread_setconcurrency(int );}extern "C" {int pthread_setschedparam(pthread_t ,int ,const struct sched_param *);}extern "C" {int pthread_setspecific(pthread_key_t ,const void *);}extern "C" {void pthread_testcancel();}extern "C" {int pthread_is_threaded_np();}extern "C" {int pthread_threadid_np(pthread_t ,__uint64_t *);}extern "C" {int pthread_getname_np(pthread_t ,char *,size_t );}extern "C" {int pthread_setname_np(const char *);}extern "C" {int pthread_main_np();}extern "C" {mach_port_t pthread_mach_thread_np(pthread_t );}extern "C" {size_t pthread_get_stacksize_np(pthread_t );}extern "C" {void *pthread_get_stackaddr_np(pthread_t );}extern "C" {int pthread_cond_signal_thread_np(pthread_cond_t *,pthread_t );}extern "C" {int pthread_cond_timedwait_relative_np(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);}extern "C" {int pthread_create_suspended_np(pthread_t *,const pthread_attr_t *,void *(*)(void *),void *);}extern "C" {int pthread_kill(pthread_t ,int );}extern "C" {pthread_t pthread_from_mach_thread_np(mach_port_t );}extern "C" {int pthread_sigmask(int ,const sigset_t *,sigset_t *);}extern "C" {void pthread_yield_np();}typedef pthread_key_t __gthread_key_t;typedef pthread_once_t __gthread_once_t;typedef pthread_mutex_t __gthread_mutex_t;typedef pthread_mutex_t __gthread_recursive_mutex_t;inline static int __gthread_active_p(){return 1;}inline static int __gthread_once(__gthread_once_t *once,void(*func)()){if((__gthread_active_p())) return pthread_once(once,func);else return -1;}inline static int __gthread_key_create(__gthread_key_t *key,void(*dtor)(void *)){return pthread_key_create(key,dtor);}inline static int __gthread_key_delete(__gthread_key_t key){return pthread_key_delete(key);}inline static void *__gthread_getspecific(__gthread_key_t key){return pthread_getspecific(key);}inline static int __gthread_setspecific(__gthread_key_t key,const void *ptr){return pthread_setspecific(key,ptr);}inline static int __gthread_mutex_lock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_lock(mutex);else return 0;}inline static int __gthread_mutex_trylock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_trylock(mutex);else return 0;}inline static int __gthread_mutex_unlock(__gthread_mutex_t *mutex){if((__gthread_active_p())) return pthread_mutex_unlock(mutex);else return 0;}inline static int __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *mutex){if((__gthread_active_p())) {pthread_mutexattr_t attr;int r;r = pthread_mutexattr_init(&attr);if(!r) r = pthread_mutexattr_settype(&attr,2);if(!r) r = pthread_mutex_init(mutex,(&attr));if(!r) r = pthread_mutexattr_destroy(&attr);return r;}return 0;}inline static int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_lock(mutex);}inline static int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_trylock(mutex);}inline static int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *mutex){return __gthread_mutex_unlock(mutex);}#pragma GCC visibility popnamespace std{typedef __gthread_mutex_t __c_lock;typedef FILE __c_file;}#pragma GCC system_headertypedef __darwin_ct_rune_t ct_rune_t;typedef __darwin_rune_t rune_t;typedef __darwin_wint_t wint_t;typedef struct __unnamed_class___F35_L81_C9_unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____min__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____max__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____map__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb____uint32_tUi__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____types {__darwin_rune_t __min;__darwin_rune_t __max;__darwin_rune_t __map;__uint32_t *__types;}_RuneEntry;typedef struct __unnamed_class___F35_L88_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____nranges__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneEntryL263R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____ranges {int __nranges;_RuneEntry *__ranges;}_RuneRange;typedef struct __unnamed_class___F35_L93_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_14_Ae__variable_name_unknown_scope_and_name__scope____name__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___uint32_tUi__typedef_declaration_variable_name_unknown_scope_and_name__scope____mask {char __name[14UL];__uint32_t __mask;}_RuneCharClass;typedef struct __unnamed_class___F35_L98_C9_unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_8_Ae__variable_name_unknown_scope_and_name__scope____magic__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_c_index_32_Ae__variable_name_unknown_scope_and_name__scope____encoding__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_L3R_Gb___Pb__Cc__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__Cc__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sgetrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___Fb_i_Gb_L3R__sep____Pb__c__Pe____sep____darwin_size_tUl__typedef_declaration__sep____Pb____Pb__c__Pe____Pe___Fe___Pe___variable_name_unknown_scope_and_name__scope____sputrune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L3R_variable_name_unknown_scope_and_name__scope____invalid_rune__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab___uint32_tUi__typedef_declaration_index_256_Ae__variable_name_unknown_scope_and_name__scope____runetype__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____maplower__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__Ab_L3R_index_256_Ae__variable_name_unknown_scope_and_name__scope____mapupper__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____runetype_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____maplower_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type__RuneRangeL264R__typedef_declaration_variable_name_unknown_scope_and_name__scope____mapupper_ext__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb__v__Pe___variable_name_unknown_scope_and_name__scope____variable__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____variable_len__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope____ncharclasses__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type___Pb___RuneCharClassL265R__typedef_declaration__Pe___variable_name_unknown_scope_and_name__scope____charclasses {char __magic[8UL];char __encoding[32UL];__darwin_rune_t(*__sgetrune)(const char *, __darwin_size_t , const char **);int(*__sputrune)(__darwin_rune_t , char *, __darwin_size_t , char **);__darwin_rune_t __invalid_rune;__uint32_t __runetype[(1 << 8)];__darwin_rune_t __maplower[(1 << 8)];__darwin_rune_t __mapupper[(1 << 8)];_RuneRange __runetype_ext;_RuneRange __maplower_ext;_RuneRange __mapupper_ext;void *__variable;int __variable_len;int __ncharclasses;_RuneCharClass *__charclasses;}_RuneLocale;extern "C" _RuneLocale _DefaultRuneLocale;extern "C" _RuneLocale *_CurrentRuneLocale;extern "C" {unsigned long ___runetype(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t );}inline static int isascii(int _c){return((_c & -128) == 0);}extern "C" {int __maskrune(__darwin_ct_rune_t ,unsigned long );}inline static int __istype(__darwin_ct_rune_t _c,unsigned long _f){return((isascii(_c))?!(!(_DefaultRuneLocale.__runetype[_c] & _f)) : !(!(__maskrune(_c,_f))));}inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c,unsigned long _f){return((_c < 0) ||(_c >= 256))?0 :(!(!(_DefaultRuneLocale.__runetype[_c] & _f)));}extern "C" {__darwin_ct_rune_t __toupper(__darwin_ct_rune_t );}extern "C" {__darwin_ct_rune_t __tolower(__darwin_ct_rune_t );}inline static int __wcwidth(__darwin_ct_rune_t _c){unsigned int _x;if(_c == 0) return 0;_x =((unsigned int )(__maskrune(_c,3758358528UL)));if((_x & 0xe0000000L) != 0L) return((_x & 0xe0000000L) >> 30);return((_x & 0x00040000L) != 0L)?1 : -1;}inline static int isalnum(int _c){return __istype(_c,1280UL);}inline static int isalpha(int _c){return __istype(_c,256UL);}inline static int isblank(int _c){return __istype(_c,131072UL);}inline static int iscntrl(int _c){return __istype(_c,512UL);}inline static int isdigit(int _c){return __isctype(_c,1024UL);}inline static int isgraph(int _c){return __istype(_c,2048UL);}inline static int islower(int _c){return __istype(_c,4096UL);}inline static int isprint(int _c){return __istype(_c,262144UL);}inline static int ispunct(int _c){return __istype(_c,8192UL);}inline static int isspace(int _c){return __istype(_c,16384UL);}inline static int isupper(int _c){return __istype(_c,32768UL);}inline static int isxdigit(int _c){return __isctype(_c,65536UL);}inline static int toascii(int _c){return _c & 0x7F;}inline static int tolower(int _c){return __tolower(_c);}inline static int toupper(int _c){return __toupper(_c);}inline static int digittoint(int _c){return __maskrune(_c,15UL);}inline static int ishexnumber(int _c){return __istype(_c,65536UL);}inline static int isideogram(int _c){return __istype(_c,524288UL);}inline static int isnumber(int _c){return __istype(_c,1024UL);}inline static int isphonogram(int _c){return __istype(_c,2097152UL);}inline static int isrune(int _c){return __istype(_c,4294967280UL);}inline static int isspecial(int _c){return __istype(_c,1048576UL);}namespace std{using isalnum;using isalpha;using iscntrl;using isdigit;using isgraph;using islower;using isprint;using ispunct;using isspace;using isupper;using isxdigit;using tolower;using toupper;}#pragma GCC system_headernamespace std{template < typename _Alloc >class allocator;template < class _CharT >struct char_traits;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > ;}typedef class basic_string< char , char_traits< char > , allocator< char > > string;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstring;}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headernamespace std{using clock_t;using time_t;using tm;using clock;using difftime;using mktime;using time;using asctime;using ctime;using gmtime;using localtime;using strftime;}typedef __darwin_mbstate_t mbstate_t;typedef __darwin_wctype_t wctype_t;inline static int iswalnum(wint_t _wc){return __istype(_wc,1280UL);}inline static int iswalpha(wint_t _wc){return __istype(_wc,256UL);}inline static int iswcntrl(wint_t _wc){return __istype(_wc,512UL);}inline static int iswctype(wint_t _wc,wctype_t _charclass){return __istype(_wc,_charclass);}inline static int iswdigit(wint_t _wc){return __isctype(_wc,1024UL);}inline static int iswgraph(wint_t _wc){return __istype(_wc,2048UL);}inline static int iswlower(wint_t _wc){return __istype(_wc,4096UL);}inline static int iswprint(wint_t _wc){return __istype(_wc,262144UL);}inline static int iswpunct(wint_t _wc){return __istype(_wc,8192UL);}inline static int iswspace(wint_t _wc){return __istype(_wc,16384UL);}inline static int iswupper(wint_t _wc){return __istype(_wc,32768UL);}inline static int iswxdigit(wint_t _wc){return __isctype(_wc,65536UL);}inline static wint_t towlower(wint_t _wc){return __tolower(_wc);}inline static wint_t towupper(wint_t _wc){return __toupper(_wc);}extern "C" {wctype_t wctype(const char *);}extern "C" {wint_t btowc(int );}extern "C" {wint_t fgetwc(FILE *);}extern "C" {wchar_t *fgetws(wchar_t *,int ,FILE *);}extern "C" {wint_t fputwc(wchar_t ,FILE *);}extern "C" {int fputws(const wchar_t *,FILE *);}extern "C" {int fwide(FILE *,int );}extern "C" {int fwprintf(FILE *,const wchar_t *,... );}extern "C" {int fwscanf(FILE *,const wchar_t *,... );}extern "C" {wint_t getwc(FILE *);}extern "C" {wint_t getwchar();}extern "C" {size_t mbrlen(const char *,size_t ,mbstate_t *);}extern "C" {size_t mbrtowc(wchar_t *,const char *,size_t ,mbstate_t *);}extern "C" {int mbsinit(const mbstate_t *);}extern "C" {size_t mbsrtowcs(wchar_t *,const char **,size_t ,mbstate_t *);}extern "C" {wint_t putwc(wchar_t ,FILE *);}extern "C" {wint_t putwchar(wchar_t );}extern "C" {int swprintf(wchar_t *,size_t ,const wchar_t *,... );}extern "C" {int swscanf(const wchar_t *,const wchar_t *,... );}extern "C" {wint_t ungetwc(wint_t ,FILE *);}extern "C" {int vfwprintf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswprintf(wchar_t *,size_t ,const wchar_t *,__darwin_va_list );}extern "C" {int vwprintf(const wchar_t *,__darwin_va_list );}extern "C" {size_t wcrtomb(char *,wchar_t ,mbstate_t *);}extern "C" {wchar_t *wcscat(wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcschr(const wchar_t *,wchar_t );}extern "C" {int wcscmp(const wchar_t *,const wchar_t *);}extern "C" {int wcscoll(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcscpy(wchar_t *,const wchar_t *);}extern "C" {size_t wcscspn(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsftime(wchar_t *,size_t ,const wchar_t *,const struct tm *);}extern "C" {size_t wcslen(const wchar_t *);}extern "C" {wchar_t *wcsncat(wchar_t *,const wchar_t *,size_t );}extern "C" {int wcsncmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcsncpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wcspbrk(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsrchr(const wchar_t *,wchar_t );}extern "C" {size_t wcsrtombs(char *,const wchar_t **,size_t ,mbstate_t *);}extern "C" {size_t wcsspn(const wchar_t *,const wchar_t *);}extern "C" {wchar_t *wcsstr(const wchar_t *,const wchar_t *);}extern "C" {size_t wcsxfrm(wchar_t *,const wchar_t *,size_t );}extern "C" {int wctob(wint_t );}extern "C" {double wcstod(const wchar_t *,wchar_t **);}extern "C" {wchar_t *wcstok(wchar_t *,const wchar_t *,wchar_t **);}extern "C" {long wcstol(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long wcstoul(const wchar_t *,wchar_t **,int );}extern "C" {wchar_t *wmemchr(const wchar_t *,wchar_t ,size_t );}extern "C" {int wmemcmp(const wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemmove(wchar_t *,const wchar_t *,size_t );}extern "C" {wchar_t *wmemset(wchar_t *,wchar_t ,size_t );}extern "C" {int wprintf(const wchar_t *,... );}extern "C" {int wscanf(const wchar_t *,... );}extern "C" {int vfwscanf(FILE *,const wchar_t *,__darwin_va_list );}extern "C" {int vswscanf(const wchar_t *,const wchar_t *,__darwin_va_list );}extern "C" {int vwscanf(const wchar_t *,__darwin_va_list );}extern "C" {float wcstof(const wchar_t *,wchar_t **);}extern "C" {long double wcstold(const wchar_t *,wchar_t **);}extern "C" {long long wcstoll(const wchar_t *,wchar_t **,int );}extern "C" {unsigned long long wcstoull(const wchar_t *,wchar_t **,int );}extern "C" {int wcswidth(const wchar_t *,size_t );}extern "C" {int wcwidth(wchar_t );}extern "C" {size_t mbsnrtowcs(wchar_t *,const char **,size_t ,size_t ,mbstate_t *);}extern "C" {size_t wcslcat(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcslcpy(wchar_t *,const wchar_t *,size_t );}extern "C" {size_t wcsnrtombs(char *,const wchar_t **,size_t ,size_t ,mbstate_t *);}namespace std{using mbstate_t;}namespace std{using wint_t;using btowc;using fgetwc;using fgetws;using fputwc;using fputws;using fwide;using fwprintf;using fwscanf;using getwc;using getwchar;using mbrlen;using mbrtowc;using mbsinit;using mbsrtowcs;using putwc;using putwchar;using swprintf;using swscanf;using ungetwc;using vfwprintf;using vfwscanf;using vswprintf;using vswscanf;using vwprintf;using vwscanf;using wcrtomb;using wcscat;using wcscmp;using wcscoll;using wcscpy;using wcscspn;using wcsftime;using wcslen;using wcsncat;using wcsncmp;using wcsncpy;using wcsrtombs;using wcsspn;using wcstod;using wcstof;using wcstok;using wcstol;using wcstoul;using wcsxfrm;using wctob;using wmemcmp;using wmemcpy;using wmemmove;using wmemset;using wprintf;using wscanf;using wcschr;inline wchar_t *wcschr(wchar_t *__p,wchar_t __c){return wcschr(((const wchar_t *)__p),__c);}using wcspbrk;inline wchar_t *wcspbrk(wchar_t *__s1,const wchar_t *__s2){return wcspbrk(((const wchar_t *)__s1),__s2);}using wcsrchr;inline wchar_t *wcsrchr(wchar_t *__p,wchar_t __c){return wcsrchr(((const wchar_t *)__p),__c);}using wcsstr;inline wchar_t *wcsstr(wchar_t *__s1,const wchar_t *__s2){return wcsstr(((const wchar_t *)__s1),__s2);}using wmemchr;inline wchar_t *wmemchr(wchar_t *__p,wchar_t __c,size_t __n){return wmemchr(((const wchar_t *)__p),__c,__n);}}namespace __gnu_cxx{using wcstold;using wcstoll;using wcstoull;}namespace std{using wcstold;using wcstoll;using wcstoull;}typedef signed char int8_t;typedef short int16_t;typedef int int32_t;typedef long long int64_t;typedef unsigned char uint8_t;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef unsigned long long uint64_t;typedef int8_t int_least8_t;typedef int16_t int_least16_t;typedef int32_t int_least32_t;typedef int64_t int_least64_t;typedef uint8_t uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t;typedef int8_t int_fast8_t;typedef int16_t int_fast16_t;typedef int32_t int_fast32_t;typedef int64_t int_fast64_t;typedef uint8_t uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;typedef unsigned long uintptr_t;typedef long intmax_t;typedef unsigned long uintmax_t;namespace std{typedef int64_t streamoff;typedef ptrdiff_t streamsize;template < typename _StateT >class fpos;template < typename _StateT >class fpos{private :streamoff _M_off;_StateT _M_state;public :fpos( );fpos( streamoff __off );operator streamoff( ) const;voidstate( _StateT __st );_StateTstate( ) const;fpos &operator +=( streamoff __off );fpos &operator -=( streamoff __off );fposoperator +( streamoff __off ) const;fposoperator -( streamoff __off ) const;streamoffoperator -( const fpos & __other ) const;};template < typename _StateT >inline booloperator ==( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) == streamoff( __rhs );}template < typename _StateT >inline booloperator !=( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs ){return streamoff( __lhs ) != streamoff( __rhs );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class fpos < mbstate_t > ;}typedef class fpos< mbstate_t > streampos;typedef class fpos< mbstate_t > wstreampos;}namespace std{void __throw_bad_exception();void __throw_bad_alloc();void __throw_bad_cast();void __throw_bad_typeid();void __throw_logic_error(const char *);void __throw_domain_error(const char *);void __throw_invalid_argument(const char *);void __throw_length_error(const char *);void __throw_out_of_range(const char *);void __throw_runtime_error(const char *);void __throw_range_error(const char *);void __throw_overflow_error(const char *);void __throw_underflow_error(const char *);void __throw_ios_failure(const char *);}namespace std{template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ios;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_streambuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_istream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ostream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_iostream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringbuf;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_istringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_ostringstream;template < typename _CharT, typename _Traits = char_traits < _CharT >,typename _Alloc = allocator < _CharT > >class basic_stringstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_filebuf;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ifstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_ofstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class basic_fstream;template < typename _CharT, typename _Traits = char_traits < _CharT > >class istreambuf_iterator;template < typename _CharT, typename _Traits = char_traits < _CharT > >class ostreambuf_iterator;class ios_base ;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > ;}typedef class basic_ios< char , char_traits< char > > ios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > ;}typedef class basic_streambuf< char , char_traits< char > > streambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > ;}typedef class basic_istream< char , char_traits< char > > istream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > ;}typedef class basic_ostream< char , char_traits< char > > ostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < char , char_traits< char > > ;}typedef class basic_iostream< char , char_traits< char > > iostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringbuf< char , char_traits< char > , allocator< char > > stringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_istringstream< char , char_traits< char > , allocator< char > > istringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_ostringstream< char , char_traits< char > , allocator< char > > ostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < char , char_traits< char > , allocator< char > > ;}typedef class basic_stringstream< char , char_traits< char > , allocator< char > > stringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < char , char_traits< char > > ;}typedef class basic_filebuf< char , char_traits< char > > filebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < char , char_traits< char > > ;}typedef class basic_ifstream< char , char_traits< char > > ifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < char , char_traits< char > > ;}typedef class basic_ofstream< char , char_traits< char > > ofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < char , char_traits< char > > ;}typedef class basic_fstream< char , char_traits< char > > fstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ios< wchar_t , char_traits< wchar_t > > wios;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > wstreambuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_istream< wchar_t , char_traits< wchar_t > > wistream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ostream< wchar_t , char_traits< wchar_t > > wostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_iostream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_iostream< wchar_t , char_traits< wchar_t > > wiostream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringbuf < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringbuf< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringbuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_istringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wistringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_ostringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wostringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_stringstream < wchar_t , char_traits< wchar_t > , allocator< wchar_t > > ;}typedef class basic_stringstream< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > wstringstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_filebuf < wchar_t , char_traits< wchar_t > > ;}typedef class basic_filebuf< wchar_t , char_traits< wchar_t > > wfilebuf;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ifstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ifstream< wchar_t , char_traits< wchar_t > > wifstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ofstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_ofstream< wchar_t , char_traits< wchar_t > > wofstream;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_fstream < wchar_t , char_traits< wchar_t > > ;}typedef class basic_fstream< wchar_t , char_traits< wchar_t > > wfstream;}#pragma GCC visibility push( default )namespace std{class exception {public: inline exception() throw(){}virtual ~exception() throw();virtual const char *what() const throw();};class bad_exception : public exception{public: inline bad_exception() throw(){}virtual ~bad_exception() throw();virtual const char *what() const throw();};typedef void(*terminate_handler)();typedef void(*unexpected_handler)();terminate_handler set_terminate(terminate_handler ) throw();void terminate();unexpected_handler set_unexpected(unexpected_handler ) throw();void unexpected();bool uncaught_exception() throw();}namespace __gnu_cxx{void __verbose_terminate_handler();}#pragma GCC visibility pop#pragma GCC system_header#pragma GCC system_header#pragma GCC system_headertypedef enum idtype_t {P_ALL,P_PID,P_PGID}idtype_t;typedef __darwin_id_t id_t;typedef int sig_atomic_t;struct __darwin_i386_thread_state {unsigned int __eax;unsigned int __ebx;unsigned int __ecx;unsigned int __edx;unsigned int __edi;unsigned int __esi;unsigned int __ebp;unsigned int __esp;unsigned int __ss;unsigned int __eflags;unsigned int __eip;unsigned int __cs;unsigned int __ds;unsigned int __es;unsigned int __fs;unsigned int __gs;};struct __darwin_fp_control {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short :2UL;unsigned short __pc:2UL;unsigned short __rc:2UL;unsigned short :1UL;unsigned short :3UL;};typedef struct __darwin_fp_control __darwin_fp_control_t;struct __darwin_fp_status {unsigned short __invalid:1UL;unsigned short __denorm:1UL;unsigned short __zdiv:1UL;unsigned short __ovrfl:1UL;unsigned short __undfl:1UL;unsigned short __precis:1UL;unsigned short __stkflt:1UL;unsigned short __errsumm:1UL;unsigned short __c0:1UL;unsigned short __c1:1UL;unsigned short __c2:1UL;unsigned short __tos:3UL;unsigned short __c3:1UL;unsigned short __busy:1UL;};typedef struct __darwin_fp_status __darwin_fp_status_t;struct __darwin_mmst_reg {char __mmst_reg[10UL];char __mmst_rsrv[6UL];};struct __darwin_xmm_reg {char __xmm_reg[16UL];};struct __darwin_i386_float_state {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;char __fpu_rsrv4[(14 * 16)];int __fpu_reserved1;};struct __darwin_i386_exception_state {unsigned int __trapno;unsigned int __err;unsigned int __faultvaddr;};struct __darwin_x86_debug_state32 {unsigned int __dr0;unsigned int __dr1;unsigned int __dr2;unsigned int __dr3;unsigned int __dr4;unsigned int __dr5;unsigned int __dr6;unsigned int __dr7;};struct __darwin_x86_thread_state64 {__uint64_t __rax;__uint64_t __rbx;__uint64_t __rcx;__uint64_t __rdx;__uint64_t __rdi;__uint64_t __rsi;__uint64_t __rbp;__uint64_t __rsp;__uint64_t __r8;__uint64_t __r9;__uint64_t __r10;__uint64_t __r11;__uint64_t __r12;__uint64_t __r13;__uint64_t __r14;__uint64_t __r15;__uint64_t __rip;__uint64_t __rflags;__uint64_t __cs;__uint64_t __fs;__uint64_t __gs;};struct __darwin_x86_float_state64 {int __fpu_reserved[2UL];struct __darwin_fp_control __fpu_fcw;struct __darwin_fp_status __fpu_fsw;__uint8_t __fpu_ftw;__uint8_t __fpu_rsrv1;__uint16_t __fpu_fop;__uint32_t __fpu_ip;__uint16_t __fpu_cs;__uint16_t __fpu_rsrv2;__uint32_t __fpu_dp;__uint16_t __fpu_ds;__uint16_t __fpu_rsrv3;__uint32_t __fpu_mxcsr;__uint32_t __fpu_mxcsrmask;struct __darwin_mmst_reg __fpu_stmm0;struct __darwin_mmst_reg __fpu_stmm1;struct __darwin_mmst_reg __fpu_stmm2;struct __darwin_mmst_reg __fpu_stmm3;struct __darwin_mmst_reg __fpu_stmm4;struct __darwin_mmst_reg __fpu_stmm5;struct __darwin_mmst_reg __fpu_stmm6;struct __darwin_mmst_reg __fpu_stmm7;struct __darwin_xmm_reg __fpu_xmm0;struct __darwin_xmm_reg __fpu_xmm1;struct __darwin_xmm_reg __fpu_xmm2;struct __darwin_xmm_reg __fpu_xmm3;struct __darwin_xmm_reg __fpu_xmm4;struct __darwin_xmm_reg __fpu_xmm5;struct __darwin_xmm_reg __fpu_xmm6;struct __darwin_xmm_reg __fpu_xmm7;struct __darwin_xmm_reg __fpu_xmm8;struct __darwin_xmm_reg __fpu_xmm9;struct __darwin_xmm_reg __fpu_xmm10;struct __darwin_xmm_reg __fpu_xmm11;struct __darwin_xmm_reg __fpu_xmm12;struct __darwin_xmm_reg __fpu_xmm13;struct __darwin_xmm_reg __fpu_xmm14;struct __darwin_xmm_reg __fpu_xmm15;char __fpu_rsrv4[(6 * 16)];int __fpu_reserved1;};struct __darwin_x86_exception_state64 {unsigned int __trapno;unsigned int __err;__uint64_t __faultvaddr;};struct __darwin_x86_debug_state64 {__uint64_t __dr0;__uint64_t __dr1;__uint64_t __dr2;__uint64_t __dr3;__uint64_t __dr4;__uint64_t __dr5;__uint64_t __dr6;__uint64_t __dr7;};struct __darwin_mcontext32 {struct __darwin_i386_exception_state __es;struct __darwin_i386_thread_state __ss;struct __darwin_i386_float_state __fs;};struct __darwin_mcontext64 {struct __darwin_x86_exception_state64 __es;struct __darwin_x86_thread_state64 __ss;struct __darwin_x86_float_state64 __fs;};typedef struct __darwin_mcontext64 *mcontext_t;struct __darwin_sigaltstack {void *ss_sp;__darwin_size_t ss_size;int ss_flags;};struct __darwin_ucontext {int uc_onstack;__darwin_sigset_t uc_sigmask;struct __darwin_sigaltstack uc_stack;struct __darwin_ucontext *uc_link;__darwin_size_t uc_mcsize;struct __darwin_mcontext64 *uc_mcontext;};typedef struct __darwin_sigaltstack stack_t;typedef struct __darwin_ucontext ucontext_t;union sigval {int sival_int;void *sival_ptr;};struct sigevent {int sigev_notify;int sigev_signo;union sigval sigev_value;void(*sigev_notify_function)(union sigval );pthread_attr_t *sigev_notify_attributes;};typedef struct __siginfo {int si_signo;int si_errno;int si_code;pid_t si_pid;uid_t si_uid;int si_status;void *si_addr;union sigval si_value;long si_band;unsigned long __pad[7UL];}siginfo_t;union __sigaction_u {void(*__sa_handler)(int );void(*__sa_sigaction)(int , struct __siginfo *, void *);};struct __sigaction {union __sigaction_u __sigaction_u;void(*sa_tramp)(void *, int , int , siginfo_t *, void *);sigset_t sa_mask;int sa_flags;};struct sigaction {union __sigaction_u __sigaction_u;sigset_t sa_mask;int sa_flags;};typedef void(*sig_t)(int );struct sigvec {void(*sv_handler)(int );int sv_mask;int sv_flags;};struct sigstack {char *ss_sp;int ss_onstack;};extern "C" {void(*signal(int ,void(*)(int )))(int );}typedef __uint64_t rlim_t;struct rusage {struct timeval ru_utime;struct timeval ru_stime;long ru_maxrss;long ru_ixrss;long ru_idrss;long ru_isrss;long ru_minflt;long ru_majflt;long ru_nswap;long ru_inblock;long ru_oublock;long ru_msgsnd;long ru_msgrcv;long ru_nsignals;long ru_nvcsw;long ru_nivcsw;};struct rlimit {rlim_t rlim_cur;rlim_t rlim_max;};extern "C" {int getpriority(int ,id_t );}extern "C" {int getiopolicy_np(int ,int );}extern "C" {int getrlimit(int ,struct rlimit *);}extern "C" {int getrusage(int ,struct rusage *);}extern "C" {int setpriority(int ,id_t ,int );}extern "C" {int setiopolicy_np(int ,int ,int );}extern "C" {int setrlimit(int ,const struct rlimit *);}inline static __uint16_t _OSSwapInt16(__uint16_t _data){return((_data << 8) |(_data >> 8));}inline static __uint32_t _OSSwapInt32(__uint32_t _data){asm("bswap %0" : "+r"(_data));return _data;}inline static __uint64_t _OSSwapInt64(__uint64_t _data){asm("bswap %0" : "+r"(_data));return _data;}union wait {int w_status;struct __unnamed_class___F49_L206_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Termsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Coredump__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Retcode__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Termsig:7UL;unsigned int w_Coredump:1UL;unsigned int w_Retcode:8UL;unsigned int w_Filler:16UL;}w_T;struct __unnamed_class___F49_L225_C2_wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopval__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Stopsig__DELIMITER__wait_variable_declaration__variable_type_Ui_variable_name_wait__scope__w_Filler {unsigned int w_Stopval:8UL;unsigned int w_Stopsig:8UL;unsigned int w_Filler:16UL;}w_S;};extern "C" {pid_t wait(int *);}extern "C" {pid_t waitpid(pid_t ,int *,int );}extern "C" {int waitid(idtype_t ,id_t ,siginfo_t *,int );}extern "C" {pid_t wait3(int *,int ,struct rusage *);}extern "C" {pid_t wait4(pid_t ,int *,int ,struct rusage *);}extern "C" {void *alloca(size_t );}typedef struct __unnamed_class___F57_L97_C9_unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_i_variable_name_unknown_scope_and_name__scope__rem {int quot;int rem;}div_t;typedef struct __unnamed_class___F57_L102_C9_unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_l_variable_name_unknown_scope_and_name__scope__rem {long quot;long rem;}ldiv_t;typedef struct __unnamed_class___F57_L108_C9_unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__quot__DELIMITER__unknown_scope_and_name_variable_declaration__variable_type_L_variable_name_unknown_scope_and_name__scope__rem {long long quot;long long rem;}lldiv_t;extern int __mb_cur_max;extern "C" {void abort();}extern "C" {int abs(int );}extern "C" {int atexit(void(*)());}extern "C" {double atof(const char *);}extern "C" {int atoi(const char *);}extern "C" {long atol(const char *);}extern "C" {long long atoll(const char *);}extern "C" {void *bsearch(const void *,const void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void *calloc(size_t ,size_t );}extern "C" {div_t div(int ,int );}extern "C" {void exit(int );}extern "C" {void free(void *);}extern "C" {char *getenv(const char *);}extern "C" {long labs(long );}extern "C" {ldiv_t ldiv(long ,long );}extern "C" {long long llabs(long long );}extern "C" {lldiv_t lldiv(long long ,long long );}extern "C" {void *malloc(size_t );}extern "C" {int mblen(const char *,size_t );}extern "C" {size_t mbstowcs(wchar_t *,const char *,size_t );}extern "C" {int mbtowc(wchar_t *,const char *,size_t );}extern "C" {int posix_memalign(void **,size_t ,size_t );}extern "C" {void qsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int rand();}extern "C" {void *realloc(void *,size_t );}extern "C" {void srand(unsigned int );}extern "C" {double strtod(const char *,char **);}extern "C" {float strtof(const char *,char **);}extern "C" {long strtol(const char *,char **,int );}extern "C" {long double strtold(const char *,char **);}extern "C" {long long strtoll(const char *,char **,int );}extern "C" {unsigned long strtoul(const char *,char **,int );}extern "C" {unsigned long long strtoull(const char *,char **,int );}extern "C" {int system(const char *);}extern "C" {size_t wcstombs(char *,const wchar_t *,size_t );}extern "C" {int wctomb(char *,wchar_t );}extern "C" {void _Exit(int );}extern "C" {long a64l(const char *);}extern "C" {double drand48();}extern "C" {char *ecvt(double ,int ,int *,int *);}extern "C" {double erand48(unsigned short [3UL]);}extern "C" {char *fcvt(double ,int ,int *,int *);}extern "C" {char *gcvt(double ,int ,char *);}extern "C" {int getsubopt(char **,char *const *,char **);}extern "C" {int grantpt(int );}extern "C" {char *initstate(unsigned int ,char *,size_t );}extern "C" {long jrand48(unsigned short [3UL]);}extern "C" {char *l64a(long );}extern "C" {void lcong48(unsigned short [7UL]);}extern "C" {long lrand48();}extern "C" {char *mktemp(char *);}extern "C" {int mkstemp(char *);}extern "C" {long mrand48();}extern "C" {long nrand48(unsigned short [3UL]);}extern "C" {int posix_openpt(int );}extern "C" {char *ptsname(int );}extern "C" {int putenv(char *);}extern "C" {long random();}extern "C" {int rand_r(unsigned int *);}extern "C" {char *realpath(const char *,char *);}extern "C" {unsigned short *seed48(unsigned short [3UL]);}extern "C" {int setenv(const char *,const char *,int );}extern "C" {void setkey(const char *);}extern "C" {char *setstate(const char *);}extern "C" {void srand48(long );}extern "C" {void srandom(unsigned int );}extern "C" {int unlockpt(int );}extern "C" {int unsetenv(const char *);}typedef unsigned char u_int8_t;typedef unsigned short u_int16_t;typedef unsigned int u_int32_t;typedef unsigned long long u_int64_t;typedef int64_t register_t;typedef u_int64_t user_addr_t;typedef u_int64_t user_size_t;typedef int64_t user_ssize_t;typedef int64_t user_long_t;typedef u_int64_t user_ulong_t;typedef int64_t user_time_t;typedef int64_t user_off_t;typedef u_int64_t syscall_arg_t;extern "C" {u_int32_t arc4random();}extern "C" {void arc4random_addrandom(unsigned char *dat,int datlen);}extern "C" {void arc4random_stir();}extern "C" {char *cgetcap(char *,const char *,int );}extern "C" {int cgetclose();}extern "C" {int cgetent(char **,char **,const char *);}extern "C" {int cgetfirst(char **,char **);}extern "C" {int cgetmatch(const char *,const char *);}extern "C" {int cgetnext(char **,char **);}extern "C" {int cgetnum(char *,const char *,long *);}extern "C" {int cgetset(const char *);}extern "C" {int cgetstr(char *,const char *,char **);}extern "C" {int cgetustr(char *,const char *,char **);}extern "C" {int daemon(int ,int );}extern "C" {char *devname(dev_t ,mode_t );}extern "C" {char *devname_r(dev_t ,mode_t ,char *buf,int len);}extern "C" {char *getbsize(int *,long *);}extern "C" {int getloadavg(double [],int );}extern "C" {const char *getprogname();}extern "C" {int heapsort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {int mergesort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort(void *,size_t ,size_t ,int(*)(const void *, const void *));}extern "C" {void psort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {void qsort_r(void *,size_t ,size_t ,void *,int(*)(void *, const void *, const void *));}extern "C" {int radixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void setprogname(const char *);}extern "C" {int sradixsort(const unsigned char **,int ,const unsigned char *,unsigned int );}extern "C" {void sranddev();}extern "C" {void srandomdev();}extern "C" {void *reallocf(void *,size_t );}extern "C" {long long strtoq(const char *,char **,int );}extern "C" {unsigned long long strtouq(const char *,char **,int );}extern "C" char *suboptarg;extern "C" {void *valloc(size_t );}namespace std{using div_t;using ldiv_t;using abort;using abs;using atexit;using atof;using atoi;using atol;using bsearch;using calloc;using div;using exit;using free;using getenv;using labs;using ldiv;using malloc;using mblen;using mbstowcs;using mbtowc;using qsort;using rand;using realloc;using srand;using strtod;using strtol;using strtoul;using system;using wcstombs;using wctomb;inline long abs(long __i){return labs(__i);}inline ldiv_t div(long __i,long __j){return ldiv(__i,__j);}}namespace __gnu_cxx{using lldiv_t;using _Exit;inline long long abs(long long __x){return(__x >= 0LL)?__x : -__x;}using llabs;inline lldiv_t div(long long __n,long long __d){lldiv_t __q;__q.quot =(__n / __d);__q.rem =(__n % __d);return __q;}using lldiv;using atoll;using strtoll;using strtoull;using strtof;using strtold;}namespace std{using lldiv_t;using _Exit;using abs;using llabs;using div;using lldiv;using atoll;using strtof;using strtoll;using strtoull;using strtold;}namespace std{template < class _T1, class _T2 >struct pair{typedef _T1 first_type;typedef _T2 second_type;_T1 first;_T2 second;pair( );pair( const _T1 & __a, const _T2 & __b );template < class _U1, class _U2 >pair( const pair < _U1, _U2 > & __p ): first( __p . first ), second( __p . second ) {}};template < class _T1, class _T2 >inline booloperator ==( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first == __y . first && __x . second == __y . second;}template < class _T1, class _T2 >inline booloperator <( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __x . first < __y . first||( !( __y . first < __x . first ) && __x . second < __y . second );}template < class _T1, class _T2 >inline booloperator !=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x == __y );}template < class _T1, class _T2 >inline booloperator >( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return __y < __x;}template < class _T1, class _T2 >inline booloperator <=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __y < __x );}template < class _T1, class _T2 >inline booloperator >=( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y ){return !( __x < __y );}template < class _T1, class _T2 >inline pair < _T1, _T2 >make_pair( _T1 __x, _T2 __y ){return pair < _T1, _T2 >( __x, __y );}}#pragma GCC system_headernamespace __gnu_cxx{template < typename _Iterator, typename _Container >class __normal_iterator;}namespace std{namespace __detail{typedef char __one;typedef char __two[2UL];template < typename _Tp >__one __test_type( int _Tp :: * );template < typename _Tp >__two & __test_type( ... );}struct __true_type {};struct __false_type {};template < bool >struct __truth_type{typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __truth_type < true > {typedef struct __true_type __type;};}template < class _Sp, class _Tp >struct __traitor{enum {__value = bool( _Sp :: __value ) || bool( _Tp :: __value ) };typedef typename __truth_type < __value > :: __type __type;};template < typename, typename >struct __are_same{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __are_same < _Tp, _Tp >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_void{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_void < void > {enum __unnamed_enum___F60_L143_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_integer{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < bool > {enum __unnamed_enum___F60_L163_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < char > {enum __unnamed_enum___F60_L170_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < signed char > {enum __unnamed_enum___F60_L177_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned char > {enum __unnamed_enum___F60_L184_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < wchar_t > {enum __unnamed_enum___F60_L192_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < short > {enum __unnamed_enum___F60_L200_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned short > {enum __unnamed_enum___F60_L207_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < int > {enum __unnamed_enum___F60_L214_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned int > {enum __unnamed_enum___F60_L221_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long > {enum __unnamed_enum___F60_L228_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long > {enum __unnamed_enum___F60_L235_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < long long > {enum __unnamed_enum___F60_L242_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_integer < unsigned long long > {enum __unnamed_enum___F60_L249_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_floating{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < float > {enum __unnamed_enum___F60_L267_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < double > {enum __unnamed_enum___F60_L274_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_floating < long double > {enum __unnamed_enum___F60_L281_C7___value {__value=1};typedef struct __true_type __type;};}template < typename _Tp >struct __is_pointer{enum {__value = 0 };typedef __false_type __type;};template < typename _Tp >struct __is_pointer < _Tp * >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_normal_iterator{enum {__value = 0 };typedef __false_type __type;};template < typename _Iterator, typename _Container >struct __is_normal_iterator < __gnu_cxx :: __normal_iterator < _Iterator,_Container > >{enum {__value = 1 };typedef __true_type __type;};template < typename _Tp >struct __is_arithmetic: public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >{};template < typename _Tp >struct __is_fundamental: public __traitor < __is_void < _Tp >, __is_arithmetic < _Tp > >{};template < typename _Tp >struct __is_scalar: public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >{};template < typename _Tp >struct __is_pod{enum{__value =( sizeof( __detail :: __test_type < _Tp >( 0 ) )!= sizeof( __detail :: __one ) )};};template < typename _Tp >struct __is_empty{private :template < typename >struct __first {};template < typename _Up >struct __second: public _Up {};public :enum{__value = sizeof( __first < _Tp > ) == sizeof( __second < _Tp > )};};template < typename _Tp >struct __is_char{enum {__value = 0 };typedef __false_type __type;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < char > {enum __unnamed_enum___F60_L388_C7___value {__value=1};typedef struct __true_type __type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __is_char < wchar_t > {enum __unnamed_enum___F60_L396_C7___value {__value=1};typedef struct __true_type __type;};}}#pragma GCC system_header#pragma GCC system_headernamespace std{namespace rel_ops{template < class _Tp >inline booloperator !=( const _Tp & __x, const _Tp & __y ){return !( __x == __y );}template < class _Tp >inline booloperator >( const _Tp & __x, const _Tp & __y ){return __y < __x;}template < class _Tp >inline booloperator <=( const _Tp & __x, const _Tp & __y ){return !( __y < __x );}template < class _Tp >inline booloperator >=( const _Tp & __x, const _Tp & __y ){return !( __x < __y );}}}namespace __gnu_cxx{template < bool, typename >struct __enable_if{};template < typename _Tp >struct __enable_if < true, _Tp >{typedef _Tp __type;};template < bool _Cond, typename _Iftrue, typename _Iffalse >struct __conditional_type{typedef _Iftrue __type;};template < typename _Iftrue, typename _Iffalse >struct __conditional_type < false, _Iftrue, _Iffalse >{typedef _Iffalse __type;};template < typename _Tp >struct __add_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < signed char > {typedef unsigned char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < short > {typedef unsigned short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < int > {typedef unsigned int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long > {typedef unsigned long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < long long > {typedef unsigned long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __add_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __add_unsigned < wchar_t > ;}template < typename _Tp >struct __remove_unsigned{private :typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;public :typedef typename __if_type :: __type __type;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned char > {typedef signed char __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned short > {typedef short __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned int > {typedef int __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long > {typedef long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < unsigned long long > {typedef long long __type;};}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < bool > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __remove_unsigned < wchar_t > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __remove_unsigned < wchar_t > ;}}#pragma GCC system_headernamespace std{struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag{};struct bidirectional_iterator_tag : public forward_iterator_tag{};struct random_access_iterator_tag : public bidirectional_iterator_tag{};template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,typename _Pointer = _Tp *, typename _Reference = _Tp & >struct iterator{typedef _Category iterator_category;typedef _Tp value_type;typedef _Distance difference_type;typedef _Pointer pointer;typedef _Reference reference;};template < typename _Iterator >struct iterator_traits{typedef typename _Iterator :: iterator_category iterator_category;typedef typename _Iterator :: value_type value_type;typedef typename _Iterator :: difference_type difference_type;typedef typename _Iterator :: pointer pointer;typedef typename _Iterator :: reference reference;};template < typename _Tp >struct iterator_traits < _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef _Tp & reference;};template < typename _Tp >struct iterator_traits < const _Tp * >{typedef random_access_iterator_tag iterator_category;typedef _Tp value_type;typedef ptrdiff_t difference_type;typedef const _Tp * pointer;typedef const _Tp & reference;};template < typename _Iter >inline typename iterator_traits < _Iter > :: iterator_category__iterator_category( const _Iter & ){return typename iterator_traits < _Iter > :: iterator_category( );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_type__distance( _InputIterator __first, _InputIterator __last,input_iterator_tag ){typename iterator_traits < _InputIterator > :: difference_type __n = 0;while( __first != __last ){++ __first;++ __n;}return __n;}template < typename _RandomAccessIterator >inline typename iterator_traits < _RandomAccessIterator > :: difference_type__distance( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){return __last - __first;}template < typename _InputIterator >inline typename iterator_traits < _InputIterator > :: difference_typedistance( _InputIterator __first, _InputIterator __last ){return std :: __distance( __first, __last,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Distance >inline void__advance( _InputIterator & __i, _Distance __n, input_iterator_tag ){while( __n -- )++ __i;}template < typename _BidirectionalIterator, typename _Distance >inline void__advance( _BidirectionalIterator & __i, _Distance __n,bidirectional_iterator_tag ){if( __n > 0 )while( __n -- )++ __i;elsewhile( __n ++ )-- __i;}template < typename _RandomAccessIterator, typename _Distance >inline void__advance( _RandomAccessIterator & __i, _Distance __n,random_access_iterator_tag ){__i += __n;}template < typename _InputIterator, typename _Distance >inline voidadvance( _InputIterator & __i, _Distance __n ){typename iterator_traits < _InputIterator > :: difference_type __d = __n;std :: __advance( __i, __d, std :: __iterator_category( __i ) );}}namespace std{template < typename _Iterator >class reverse_iterator: public iterator < typename iterator_traits < _Iterator > :: iterator_category,typename iterator_traits < _Iterator > :: value_type,typename iterator_traits < _Iterator > :: difference_type,typename iterator_traits < _Iterator > :: pointer,typename iterator_traits < _Iterator > :: reference >{protected :_Iterator current;public :typedef _Iterator iterator_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;public :reverse_iterator( );explicitreverse_iterator( iterator_type __x );reverse_iterator( const reverse_iterator & __x );template < typename _Iter >reverse_iterator( const reverse_iterator < _Iter > & __x ): current( __x . base( ) ) {}iterator_typebase( ) const;referenceoperator *( ) const;pointeroperator ->( ) const;reverse_iterator &operator ++( );reverse_iteratoroperator ++( int );reverse_iterator &operator --( );reverse_iteratoroperator --( int );reverse_iteratoroperator +( difference_type __n ) const;reverse_iterator &operator +=( difference_type __n );reverse_iteratoroperator -( difference_type __n ) const;reverse_iterator &operator -=( difference_type __n );referenceoperator [ ]( difference_type __n ) const;};template < typename _Iterator >inline booloperator ==( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __x . base( ) == __y . base( );}template < typename _Iterator >inline booloperator <( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) < __x . base( );}template < typename _Iterator >inline booloperator !=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x == __y );}template < typename _Iterator >inline booloperator >( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y < __x;}template < typename _Iterator >inline booloperator <=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __y < __x );}template < typename _Iterator >inline booloperator >=( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return !( __x < __y );}template < typename _Iterator >inline typename reverse_iterator < _Iterator > :: difference_typeoperator -( const reverse_iterator < _Iterator > & __x,const reverse_iterator < _Iterator > & __y ){return __y . base( ) - __x . base( );}template < typename _Iterator >inline reverse_iterator < _Iterator >operator +( typename reverse_iterator < _Iterator > :: difference_type __n,const reverse_iterator < _Iterator > & __x ){return reverse_iterator < _Iterator >( __x . base( ) - __n );}template < typename _IteratorL, typename _IteratorR >inline booloperator ==( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __x . base( ) == __y . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator <( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) < __x . base( );}template < typename _IteratorL, typename _IteratorR >inline booloperator !=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x == __y );}template < typename _IteratorL, typename _IteratorR >inline booloperator >( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y < __x;}template < typename _IteratorL, typename _IteratorR >inline booloperator <=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __y < __x );}template < typename _IteratorL, typename _IteratorR >inline booloperator >=( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return !( __x < __y );}template < typename _IteratorL, typename _IteratorR >inline typename reverse_iterator < _IteratorL > :: difference_typeoperator -( const reverse_iterator < _IteratorL > & __x,const reverse_iterator < _IteratorR > & __y ){return __y . base( ) - __x . base( );}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct iterator < output_iterator_tag , void , void , void , void > {typedef struct output_iterator_tag iterator_category;typedef void value_type;typedef void difference_type;typedef void pointer;typedef void reference;};}template < typename _Container >class back_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicitback_insert_iterator( _Container & __x );back_insert_iterator &operator =( typename _Container :: const_reference __value );back_insert_iterator &operator *( );back_insert_iterator &operator ++( );back_insert_iteratoroperator ++( int );};template < typename _Container >inline back_insert_iterator < _Container >back_inserter( _Container & __x ){return back_insert_iterator < _Container >( __x );}template < typename _Container >class front_insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;public :typedef _Container container_type;explicit front_insert_iterator( _Container & __x );front_insert_iterator &operator =( typename _Container :: const_reference __value );front_insert_iterator &operator *( );front_insert_iterator &operator ++( );front_insert_iteratoroperator ++( int );};template < typename _Container >inline front_insert_iterator < _Container >front_inserter( _Container & __x ){return front_insert_iterator < _Container >( __x );}template < typename _Container >class insert_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_Container * container;typename _Container :: iterator iter;public :typedef _Container container_type;insert_iterator( _Container & __x, typename _Container :: iterator __i );insert_iterator &operator =( const typename _Container :: const_reference __value );insert_iterator &operator *( );insert_iterator &operator ++( );insert_iterator &operator ++( int );};template < typename _Container, typename _Iterator >inline insert_iterator < _Container >inserter( _Container & __x, _Iterator __i ){return insert_iterator < _Container >( __x,typename _Container :: iterator( __i ) );}}namespace __gnu_cxx{using iterator_traits;using iterator;template < typename _Iterator, typename _Container >class __normal_iterator{protected :_Iterator _M_current;public :typedef typename iterator_traits < _Iterator > :: iterator_categoryiterator_category;typedef typename iterator_traits < _Iterator > :: value_type value_type;typedef typename iterator_traits < _Iterator > :: difference_typedifference_type;typedef typename iterator_traits < _Iterator > :: reference reference;typedef typename iterator_traits < _Iterator > :: pointer pointer;__normal_iterator( );explicit__normal_iterator( const _Iterator & __i );template < typename _Iter >__normal_iterator( const __normal_iterator < _Iter,typename __enable_if <( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),_Container > :: __type > & __i ): _M_current( __i . base( ) ) {}referenceoperator *( ) const;pointeroperator ->( ) const;__normal_iterator &operator ++( );__normal_iteratoroperator ++( int );__normal_iterator &operator --( );__normal_iteratoroperator --( int );referenceoperator [ ]( const difference_type & __n ) const;__normal_iterator &operator +=( const difference_type & __n );__normal_iteratoroperator +( const difference_type & __n ) const;__normal_iterator &operator -=( const difference_type & __n );__normal_iteratoroperator -( const difference_type & __n ) const;const _Iterator &base( ) const;};template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator ==( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator ==( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) == __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator !=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator !=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) != __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) < __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) > __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator <=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator <=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) <= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline booloperator >=( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _Iterator, typename _Container >inline booloperator >=( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) >= __rhs . base( );}template < typename _IteratorL, typename _IteratorR, typename _Container >inline typename __normal_iterator < _IteratorL, _Container > :: difference_typeoperator -( const __normal_iterator < _IteratorL, _Container > & __lhs,const __normal_iterator < _IteratorR, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline typename __normal_iterator < _Iterator, _Container > :: difference_typeoperator -( const __normal_iterator < _Iterator, _Container > & __lhs,const __normal_iterator < _Iterator, _Container > & __rhs ){return __lhs . base( ) - __rhs . base( );}template < typename _Iterator, typename _Container >inline __normal_iterator < _Iterator, _Container >operator +( typename __normal_iterator < _Iterator, _Container > :: difference_type__n, const __normal_iterator < _Iterator, _Container > & __i ){return __normal_iterator < _Iterator, _Container >( __i . base( ) + __n );}}namespace std{namespace __debug{}}namespace __gnu_cxx{namespace __debug{}}namespace __gnu_debug{using namespace __debug;using namespace __debug;}namespace std{template < typename _Tp >inline voidswap( _Tp & __a, _Tp & __b ){_Tp __tmp = __a;__a = __b;__b = __tmp;}template < bool _BoolType >struct __iter_swap{template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;_ValueType1 __tmp = * __a;* __a = * __b;* __b = __tmp;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __iter_swap < true > {template < typename _ForwardIterator1, typename _ForwardIterator2 >static voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){swap( * __a, * __b );}};}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline voiditer_swap( _ForwardIterator1 __a, _ForwardIterator2 __b ){typedef typename iterator_traits < _ForwardIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _ForwardIterator2 > :: value_type_ValueType2;typedef typename iterator_traits < _ForwardIterator1 > :: reference_ReferenceType1;typedef typename iterator_traits < _ForwardIterator2 > :: reference_ReferenceType2;std :: __iter_swap < __are_same < _ValueType1, _ValueType2 > :: __value &&__are_same < _ValueType1 &, _ReferenceType1 > :: __value &&__are_same < _ValueType2 &, _ReferenceType2 > :: __value > ::iter_swap( __a, __b );}template < typename _Tp >inline const _Tp &min( const _Tp & __a, const _Tp & __b ){if( __b < __a )return __b;return __a;}template < typename _Tp >inline const _Tp &max( const _Tp & __a, const _Tp & __b ){if( __a < __b )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &min( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __b, __a ) )return __b;return __a;}template < typename _Tp, typename _Compare >inline const _Tp &max( const _Tp & __a, const _Tp & __b, _Compare __comp ){if( __comp( __a, __b ) )return __b;return __a;}template < bool, typename >struct __copy{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){for(;__first != __last;++ __result, ++ __first )* __result = * __first;return __result;}};template < bool _BoolType >struct __copy < _BoolType, random_access_iterator_tag >{template < typename _II, typename _OI >static _OIcopy( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: difference_type _Distance;for( _Distance __n = __last - __first;__n > 0;-- __n ){* __result = * __first;++ __first;++ __result;}return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *copy( const _Tp * __first, const _Tp * __last, _Tp * __result ){std :: memmove( __result, __first, sizeof( _Tp ) *( __last - __first ) );return __result +( __last - __first );}};}template < typename _II, typename _OI >inline _OI__copy_aux( _II __first, _II __last, _OI __result ){typedef typename iterator_traits < _II > :: value_type _ValueTypeI;typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;typedef typename iterator_traits < _II > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueTypeI > :: __value&& __is_pointer < _II > :: __value&& __is_pointer < _OI > :: __value&& __are_same < _ValueTypeI, _ValueTypeO > :: __value );return std :: __copy < __simple, _Category > :: copy( __first, __last, __result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT *, _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT *, const _CharT *, ostreambuf_iterator < _CharT > );template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, _CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,_CharT * );template < bool, bool >struct __copy_normal{template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , false > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return std :: __copy_aux( __first . base( ), __last . base( ), __result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < false , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first, __last, __result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_normal < true , true > {template < typename _II, typename _OI >static _OI__copy_n( _II __first, _II __last, _OI __result ){return _OI( std :: __copy_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorcopy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;const bool __in = __is_normal_iterator < _InputIterator > :: __value;const bool __out = __is_normal_iterator < _OutputIterator > :: __value;return std :: __copy_normal < __in, __out > :: __copy_n( __first, __last,__result );}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,ostreambuf_iterator < _CharT > );template < bool, typename >struct __copy_backward{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){while( __first != __last )* -- __result = * -- __last;return __result;}};template < bool _BoolType >struct __copy_backward < _BoolType, random_access_iterator_tag >{template < typename _BI1, typename _BI2 >static _BI2__copy_b( _BI1 __first, _BI1 __last, _BI2 __result ){typename iterator_traits < _BI1 > :: difference_type __n;for( __n = __last - __first;__n > 0;-- __n )* -- __result = * -- __last;return __result;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward < true , random_access_iterator_tag > {template < typename _Tp >static _Tp *__copy_b( const _Tp * __first, const _Tp * __last, _Tp * __result ){const ptrdiff_t _Num = __last - __first;std :: memmove( __result - _Num, __first, sizeof( _Tp ) * _Num );return __result - _Num;}};}template < typename _BI1, typename _BI2 >inline _BI2__copy_backward_aux( _BI1 __first, _BI1 __last, _BI2 __result ){typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;typedef typename iterator_traits < _BI1 > :: iterator_category _Category;const bool __simple =( __is_scalar < _ValueType1 > :: __value&& __is_pointer < _BI1 > :: __value&& __is_pointer < _BI2 > :: __value&& __are_same < _ValueType1, _ValueType2 > :: __value );return std :: __copy_backward < __simple, _Category > :: __copy_b( __first,__last,__result );}template < bool, bool >struct __copy_backward_normal{template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first, __last, __result );}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , false > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return std :: __copy_backward_aux( __first . base( ), __last . base( ),__result );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < false , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first, __last,__result . base( ) ) );}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __copy_backward_normal < true , true > {template < typename _BI1, typename _BI2 >static _BI2__copy_b_n( _BI1 __first, _BI1 __last, _BI2 __result ){return _BI2( std :: __copy_backward_aux( __first . base( ), __last . base( ),__result . base( ) ) );}};}template < typename _BI1, typename _BI2 >inline _BI2copy_backward( _BI1 __first, _BI1 __last, _BI2 __result ){;const bool __bi1 = __is_normal_iterator < _BI1 > :: __value;const bool __bi2 = __is_normal_iterator < _BI2 > :: __value;return std :: __copy_backward_normal < __bi1, __bi2 > :: __copy_b_n( __first,__last,__result );}template < bool >struct __fill{template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){for(;__first != __last;++ __first )* __first = __value;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill < true > {template < typename _ForwardIterator, typename _Tp >static voidfill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){const _Tp __tmp = __value;for(;__first != __last;++ __first )* __first = __tmp;}};}template < typename _ForwardIterator, typename _Tp >voidfill( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value ){;const bool __scalar = __is_scalar < _Tp > :: __value;std :: __fill < __scalar > :: fill( __first, __last, __value );}inline void fill(unsigned char *__first,unsigned char *__last,const unsigned char &__c){;const unsigned char __tmp = __c;memset(__first,__tmp,(__last - __first));}inline void fill(signed char *__first,signed char *__last,const signed char &__c){;const signed char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}inline void fill(char *__first,char *__last,const char &__c){;const char __tmp = __c;memset(__first,((unsigned char )__tmp),(__last - __first));}template < bool >struct __fill_n{template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){for(;__n > 0;-- __n, ++ __first )* __first = __value;return __first;}};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __fill_n < true > {template < typename _OutputIterator, typename _Size, typename _Tp >static _OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const _Tp __tmp = __value;for(;__n > 0;-- __n, ++ __first )* __first = __tmp;return __first;}};}template < typename _OutputIterator, typename _Size, typename _Tp >_OutputIteratorfill_n( _OutputIterator __first, _Size __n, const _Tp & __value ){const bool __scalar = __is_scalar < _Tp > :: __value;return std :: __fill_n < __scalar > :: fill_n( __first, __n, __value );}template < typename _Size >inline unsigned char *fill_n( unsigned char * __first, _Size __n, const unsigned char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline signed char *fill_n( signed char * __first, _Size __n, const signed char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _Size >inline char *fill_n( char * __first, _Size __n, const char & __c ){std :: fill( __first, __first + __n, __c );return __first + __n;}template < typename _InputIterator1, typename _InputIterator2 >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;while( __first1 != __last1 && * __first1 == * __first2 ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >pair < _InputIterator1, _InputIterator2 >mismatch( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _BinaryPredicate __binary_pred ){;while( __first1 != __last1 && __binary_pred( * __first1, * __first2 ) ){++ __first1;++ __first2;}return pair < _InputIterator1, _InputIterator2 >( __first1, __first2 );}template < typename _InputIterator1, typename _InputIterator2 >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( !( * __first1 == * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2,typename _BinaryPredicate >inline boolequal( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2,_BinaryPredicate __binary_pred ){;for(;__first1 != __last1;++ __first1, ++ __first2 )if( ! __binary_pred( * __first1, * __first2 ) )return false;return true;}template < typename _InputIterator1, typename _InputIterator2 >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( * __first1 < * __first2 )return true;if( * __first2 < * __first1 )return false;}return __first1 == __last1 && __first2 != __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boollexicographical_compare( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_Compare __comp ){;;for(;__first1 != __last1 && __first2 != __last2;++ __first1, ++ __first2 ){if( __comp( * __first1, * __first2 ) )return true;if( __comp( * __first2, * __first1 ) )return false;}return __first1 == __last1 && __first2 != __last2;}inline bool lexicographical_compare(const unsigned char *__first1,const unsigned char *__last1,const unsigned char *__first2,const unsigned char *__last2){;;const size_t __len1 =(__last1 - __first1);const size_t __len2 =(__last2 - __first2);const int __result = memcmp(__first1,__first2,min< unsigned long >(__len1,__len2));return(__result != 0)?(__result < 0) :(__len1 < __len2);}inline bool lexicographical_compare(const char *__first1,const char *__last1,const char *__first2,const char *__last2){;;return lexicographical_compare< const signed char * , const signed char * >(((const signed char *)__first1),((const signed char *)__last1),((const signed char *)__first2),((const signed char *)__last2));}}namespace __gnu_cxx{template < class _CharT >struct _Char_types{typedef unsigned long int_type;typedef std :: streampos pos_type;typedef std :: streamoff off_type;typedef std :: mbstate_t state_type;};template < typename _CharT >struct char_traits{typedef _CharT char_type;typedef typename _Char_types < _CharT > :: int_type int_type;typedef typename _Char_types < _CharT > :: pos_type pos_type;typedef typename _Char_types < _CharT > :: off_type off_type;typedef typename _Char_types < _CharT > :: state_type state_type;static voidassign( char_type & __c1, const char_type & __c2 );static booleq( const char_type & __c1, const char_type & __c2 );static boollt( const char_type & __c1, const char_type & __c2 );static intcompare( const char_type * __s1, const char_type * __s2, std :: size_t __n );static std :: size_tlength( const char_type * __s );static const char_type *find( const char_type * __s, std :: size_t __n, const char_type & __a );static char_type *move( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *copy( char_type * __s1, const char_type * __s2, std :: size_t __n );static char_type *assign( char_type * __s, std :: size_t __n, char_type __a );static char_typeto_char_type( const int_type & __c );static int_typeto_int_type( const char_type & __c );static booleq_int_type( const int_type & __c1, const int_type & __c2 );static int_typeeof( );static int_typenot_eof( const int_type & __c );};template < typename _CharT >intchar_traits < _CharT > ::compare( const char_type * __s1, const char_type * __s2, std :: size_t __n ){for( std :: size_t __i = 0;__i < __n;++ __i )if( lt( __s1 [ __i ], __s2 [ __i ] ) )return - 1;else if( lt( __s2 [ __i ], __s1 [ __i ] ) )return 1;return 0;}template < typename _CharT >std :: size_tchar_traits < _CharT > ::length( const char_type * __p ){std :: size_t __i = 0;while( ! eq( __p [ __i ], char_type( ) ) )++ __i;return __i;}template < typename _CharT >const typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::find( const char_type * __s, std :: size_t __n, const char_type & __a ){for( std :: size_t __i = 0;__i < __n;++ __i )if( eq( __s [ __i ], __a ) )return __s + __i;return 0;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::move( char_type * __s1, const char_type * __s2, std :: size_t __n ){return static_cast < _CharT * >( std :: memmove( __s1, __s2,__n * sizeof( char_type ) ) );}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::copy( char_type * __s1, const char_type * __s2, std :: size_t __n ){std :: copy( __s2, __s2 + __n, __s1 );return __s1;}template < typename _CharT >typename char_traits < _CharT > :: char_type *char_traits < _CharT > ::assign( char_type * __s, std :: size_t __n, char_type __a ){std :: fill_n( __s, __n, __a );return __s;}}namespace std{template < class _CharT >struct char_traits : public __gnu_cxx :: char_traits < _CharT >{};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < char > {typedef char char_type;typedef int int_type;typedef streampos pos_type;typedef streamoff off_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return memcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return strlen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(const char_type *)(memchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memmove(__s1,__s2,__n));}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return(char_type *)(memcpy(__s1,__s2,__n));}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return(char_type *)(memset(__s,__a,__n));}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )((unsigned char )__c);}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return(__c == eof())?0 : __c;}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct char_traits < wchar_t > {typedef wchar_t char_type;typedef wint_t int_type;typedef streamoff off_type;typedef wstreampos pos_type;typedef mbstate_t state_type;inline static void assign(char_type &__c1,const char_type &__c2){__c1 = __c2;}inline static bool eq(const char_type &__c1,const char_type &__c2){return __c1 == __c2;}inline static bool lt(const char_type &__c1,const char_type &__c2){return __c1 < __c2;}inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n){return wmemcmp(__s1,__s2,__n);}inline static size_t length(const char_type *__s){return wcslen(__s);}inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a){return(wmemchr(__s,__a,__n));}inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n){return wmemmove(__s1,__s2,__n);}inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n){return wmemcpy(__s1,__s2,__n);}inline static char_type *assign(char_type *__s,size_t __n,char_type __a){return wmemset(__s,__a,__n);}inline static char_type to_char_type(const int_type &__c){return(char_type )__c;}inline static int_type to_int_type(const char_type &__c){return(int_type )__c;}inline static bool eq_int_type(const int_type &__c1,const int_type &__c2){return __c1 == __c2;}inline static int_type eof(){return -1;}inline static int_type not_eof(const int_type &__c){return eq_int_type(__c, eof())?0 : __c;}};}}#pragma GCC system_headernamespace std{class locale ;template < typename _CharT >inline boolisspace( _CharT, const locale & );template < typename _CharT >inline boolisprint( _CharT, const locale & );template < typename _CharT >inline booliscntrl( _CharT, const locale & );template < typename _CharT >inline boolisupper( _CharT, const locale & );template < typename _CharT >inline boolislower( _CharT, const locale & );template < typename _CharT >inline boolisalpha( _CharT, const locale & );template < typename _CharT >inline boolisdigit( _CharT, const locale & );template < typename _CharT >inline boolispunct( _CharT, const locale & );template < typename _CharT >inline boolisxdigit( _CharT, const locale & );template < typename _CharT >inline boolisalnum( _CharT, const locale & );template < typename _CharT >inline boolisgraph( _CharT, const locale & );template < typename _CharT >inline _CharTtoupper( _CharT, const locale & );template < typename _CharT >inline _CharTtolower( _CharT, const locale & );struct ctype_base ;template < typename _CharT >class ctype;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > ;}template < typename _CharT >class ctype_byname;class codecvt_base ;class __enc_traits ;template < typename _InternT, typename _ExternT, typename _StateT >class codecvt;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > ;}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class num_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class num_put;template < typename _CharT > class numpunct;template < typename _CharT > class numpunct_byname;template < typename _CharT >class collate;template < typename _CharT > classcollate_byname;class time_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class time_get_byname;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class time_put_byname;class money_base ;template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >class money_get;template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >class money_put;template < typename _CharT, bool _Intl = false >class moneypunct;template < typename _CharT, bool _Intl = false >class moneypunct_byname;struct messages_base ;template < typename _CharT >class messages;template < typename _CharT >class messages_byname;template < typename _Facet >boolhas_facet( const locale & __loc ) throw( );template < typename _Facet >const _Facet &use_facet( const locale & __loc );template < typename _Facet >inline const _Facet &__check_facet( const _Facet * __f ){if( ! __f )__throw_bad_cast( );return * __f;}}#pragma GCC system_headertypedef int _Atomic_word;namespace __gnu_cxx{_Atomic_word __exchange_and_add(volatile _Atomic_word *,int );void __atomic_add(volatile _Atomic_word *,int );inline static _Atomic_word __exchange_and_add_single(_Atomic_word *__mem,int __val){_Atomic_word __result = *__mem;*__mem += __val;return __result;}inline static void __atomic_add_single(_Atomic_word *__mem,int __val){*__mem += __val;}inline static _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) return __exchange_and_add(__mem,__val);else return __exchange_and_add_single(__mem,__val);}inline static void __atomic_add_dispatch(_Atomic_word *__mem,int __val){if((__gthread_active_p())) __atomic_add(__mem,__val);else __atomic_add_single(__mem,__val);}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace std{class bad_alloc : public exception{public: inline bad_alloc() throw(){}virtual ~bad_alloc() throw();virtual const char *what() const throw();};struct nothrow_t {};extern const struct nothrow_t nothrow;typedef void(*new_handler)();new_handler set_new_handler(new_handler ) throw();}void *operator new(size_t ) throw(class bad_alloc );void *operator new[](size_t ) throw(class bad_alloc );void operator delete(void *) throw();void operator delete[](void *) throw();void *operator new(size_t ,const struct nothrow_t &) throw();void *operator new[](size_t ,const struct nothrow_t &) throw();void operator delete(void *,const struct nothrow_t &) throw();void operator delete[](void *,const struct nothrow_t &) throw();inline void *operator new(size_t ,void *__p) throw(){return __p;}inline void *operator new[](size_t ,void *__p) throw(){return __p;}inline void operator delete(void *,void *) throw(){}inline void operator delete[](void *,void *) throw(){}#pragma GCC visibility popnamespace __gnu_cxx{using size_t;using ptrdiff_t;template < typename _Tp >class new_allocator{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef new_allocator < _Tp1 > other;};new_allocator( ) throw( );new_allocator( const new_allocator & ) throw( );template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( ) {}~ new_allocator( ) throw( );pointeraddress( reference __x ) const;const_pointeraddress( const_reference __x ) const;pointerallocate( size_type __n, const void * = 0 );voiddeallocate( pointer __p, size_type );size_typemax_size( ) const throw( );voidconstruct( pointer __p, const _Tp & __val );voiddestroy( pointer __p );};template < typename _Tp >inline booloperator ==( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return true;}template < typename _Tp >inline booloperator !=( const new_allocator < _Tp > &, const new_allocator < _Tp > & ){return false;}}namespace std{template < typename _Tp >class allocator;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < void > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef void *pointer;typedef const void *const_pointer;typedef void value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};};}template < typename _Tp >class allocator : public __gnu_cxx :: new_allocator < _Tp >{public :typedef size_t size_type;typedef ptrdiff_t difference_type;typedef _Tp * pointer;typedef const _Tp * const_pointer;typedef _Tp & reference;typedef const _Tp & const_reference;typedef _Tp value_type;template < typename _Tp1 >struct rebind{typedef allocator < _Tp1 > other;};allocator( ) throw( );allocator( const allocator & __a ) throw( );template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( ) {}~ allocator( ) throw( );};template < typename _T1, typename _T2 >inline booloperator ==( const allocator < _T1 > &, const allocator < _T2 > & ){return true;}template < typename _T1, typename _T2 >inline booloperator !=( const allocator < _T1 > &, const allocator < _T2 > & ){return false;}template < typename _Alloc, bool = std :: __is_empty < _Alloc > :: __value >struct __alloc_swap{static void _S_do_it( _Alloc &, _Alloc & );};template < typename _Alloc >struct __alloc_swap < _Alloc, false >{static void_S_do_it( _Alloc & __one, _Alloc & __two );};}namespace std{template < typename _T1, typename _T2 >inline void_Construct( _T1 * __p, const _T2 & __value ){:: new( static_cast < void * >( __p ) ) _T1( __value );}template < typename _T1 >inline void_Construct( _T1 * __p ){:: new( static_cast < void * >( __p ) ) _T1( );}template < typename _Tp >inline void_Destroy( _Tp * __pointer ){__pointer -> ~ _Tp( );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator __first, _ForwardIterator __last,__false_type ){for(;__first != __last;++ __first )std :: _Destroy( & * __first );}template < typename _ForwardIterator >inline void__destroy_aux( _ForwardIterator, _ForwardIterator, __true_type ){}template < typename _ForwardIterator >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last ){typedef typename iterator_traits < _ForwardIterator > :: value_type_Value_type;typedef typename std :: __is_scalar < _Value_type > :: __type_Has_trivial_destructor;std :: __destroy_aux( __first, __last, _Has_trivial_destructor( ) );}template < typename _Tp > class allocator;template < typename _ForwardIterator, typename _Allocator >void_Destroy( _ForwardIterator __first, _ForwardIterator __last,_Allocator __alloc ){for(;__first != __last;++ __first )__alloc . destroy( & * __first );}template < typename _ForwardIterator, typename _Tp >inline void_Destroy( _ForwardIterator __first, _ForwardIterator __last,allocator < _Tp > ){_Destroy( __first, __last );}}namespace std{template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__true_type ){return std :: copy( __first, __last, __result );}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIterator__uninitialized_copy_aux( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,__false_type ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )std :: _Construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur );throw;}}template < typename _InputIterator, typename _ForwardIterator >inline _ForwardIteratoruninitialized_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;return std :: __uninitialized_copy_aux( __first, __last, __result,_Is_POD( ) );}inline char *uninitialized_copy(const char *__first,const char *__last,char *__result){memmove(__result,__first,(__last - __first));return __result +(__last - __first);}inline wchar_t *uninitialized_copy(const wchar_t *__first,const wchar_t *__last,wchar_t *__result){memmove(__result,__first,(4ULL *(__last - __first)));return __result +(__last - __first);}template < typename _ForwardIterator, typename _Tp >inline void__uninitialized_fill_aux( _ForwardIterator __first,_ForwardIterator __last,const _Tp & __x, __true_type ){std :: fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Tp >void__uninitialized_fill_aux( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Tp >inline voiduninitialized_fill( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_aux( __first, __last, __x, _Is_POD( ) );}template < typename _ForwardIterator, typename _Size, typename _Tp >inline void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __true_type ){std :: fill_n( __first, __n, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp >void__uninitialized_fill_n_aux( _ForwardIterator __first, _Size __n,const _Tp & __x, __false_type ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )std :: _Construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp >inline voiduninitialized_fill_n( _ForwardIterator __first, _Size __n, const _Tp & __x ){typedef typename iterator_traits < _ForwardIterator > :: value_type _ValueType;typedef typename std :: __is_scalar < _ValueType > :: __type _Is_POD;std :: __uninitialized_fill_n_aux( __first, __n, __x, _Is_POD( ) );}template < typename _InputIterator, typename _ForwardIterator,typename _Allocator >_ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __cur = __result;try{for(;__first != __last;++ __first, ++ __cur )__alloc . construct( & * __cur, * __first );return __cur;}catch( ... ){std :: _Destroy( __result, __cur, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp >inline _ForwardIterator__uninitialized_copy_a( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,allocator < _Tp > ){return std :: uninitialized_copy( __first, __last, __result );}template < typename _ForwardIterator, typename _Tp, typename _Allocator >void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, _Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__cur != __last;++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _Tp2 >inline void__uninitialized_fill_a( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __x, allocator < _Tp2 > ){std :: uninitialized_fill( __first, __last, __x );}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Allocator >void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,_Allocator __alloc ){_ForwardIterator __cur = __first;try{for(;__n > 0;-- __n, ++ __cur )__alloc . construct( & * __cur, __x );}catch( ... ){std :: _Destroy( __first, __cur, __alloc );throw;}}template < typename _ForwardIterator, typename _Size, typename _Tp,typename _Tp2 >inline void__uninitialized_fill_n_a( _ForwardIterator __first, _Size __n,const _Tp & __x,allocator < _Tp2 > ){std :: uninitialized_fill_n( __first, __n, __x );}template < typename _InputIterator1, typename _InputIterator2,typename _ForwardIterator, typename _Allocator >inline _ForwardIterator__uninitialized_copy_copy( _InputIterator1 __first1,_InputIterator1 __last1,_InputIterator2 __first2,_InputIterator2 __last2,_ForwardIterator __result,_Allocator __alloc ){_ForwardIterator __mid = std :: __uninitialized_copy_a( __first1, __last1,__result,__alloc );try{return std :: __uninitialized_copy_a( __first2, __last2, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _ForwardIterator, typename _Tp, typename _InputIterator,typename _Allocator >inline _ForwardIterator__uninitialized_fill_copy( _ForwardIterator __result, _ForwardIterator __mid,const _Tp & __x, _InputIterator __first,_InputIterator __last,_Allocator __alloc ){std :: __uninitialized_fill_a( __result, __mid, __x, __alloc );try{return std :: __uninitialized_copy_a( __first, __last, __mid, __alloc );}catch( ... ){std :: _Destroy( __result, __mid, __alloc );throw;}}template < typename _InputIterator, typename _ForwardIterator, typename _Tp,typename _Allocator >inline void__uninitialized_copy_fill( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2,_ForwardIterator __last2, const _Tp & __x,_Allocator __alloc ){_ForwardIterator __mid2 = std :: __uninitialized_copy_a( __first1, __last1,__first2,__alloc );try{std :: __uninitialized_fill_a( __mid2, __last2, __x, __alloc );}catch( ... ){std :: _Destroy( __first2, __mid2, __alloc );throw;}}}namespace std{template < class _ForwardIterator, class _Tp >class raw_storage_iterator: public iterator < output_iterator_tag, void, void, void, void >{protected :_ForwardIterator _M_iter;public :explicitraw_storage_iterator( _ForwardIterator __x );raw_storage_iterator &operator *( );raw_storage_iterator &operator =( const _Tp & __element );raw_storage_iterator < _ForwardIterator, _Tp > &operator ++( );raw_storage_iterator < _ForwardIterator, _Tp >operator ++( int );};}#pragma GCC system_headernamespace std{enum float_round_style {round_indeterminate=-1,round_toward_zero,round_to_nearest,round_toward_infinity,round_toward_neg_infinity};enum float_denorm_style {denorm_indeterminate=-1,denorm_absent,denorm_present};struct __numeric_limits_base {static const bool is_specialized = false;static const int digits = 0;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 0;static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;static const bool is_iec559 = false;static const bool is_bounded = false;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};template < typename _Tp >struct numeric_limits : public __numeric_limits_base{static _Tp min( ) throw( );static _Tp max( ) throw( );static _Tp epsilon( ) throw( );static _Tp round_error( ) throw( );static _Tp infinity( ) throw( );static _Tp quiet_NaN( ) throw( );static _Tp signaling_NaN( ) throw( );static _Tp denorm_min( ) throw( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < bool > {static const bool is_specialized = true;inline static bool min() throw(){return false;}inline static bool max() throw(){return true;}static const int digits = 1;static const int digits10 = 0;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static bool epsilon() throw(){return false;}inline static bool round_error() throw(){return false;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static bool infinity() throw(){return false;}inline static bool quiet_NaN() throw(){return false;}inline static bool signaling_NaN() throw(){return false;}inline static bool denorm_min() throw(){return false;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < char > {static const bool is_specialized = true;inline static char min() throw(){return '';}inline static char max() throw(){return char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static char epsilon() throw(){return '\0';}inline static char round_error() throw(){return '\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static char infinity() throw(){return '\0';}inline static char quiet_NaN() throw(){return '\0';}inline static char signaling_NaN() throw(){return '\0';}inline static char denorm_min() throw(){return '\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < signed char > {static const bool is_specialized = true;inline static signed char min() throw(){return(signed char )'';}inline static signed char max() throw(){return(signed char )char(127);}static const int digits = 7;static const int digits10 = 2;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static signed char epsilon() throw(){return(signed char )'\0';}inline static signed char round_error() throw(){return(signed char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static signed char infinity() throw(){return(signed char )'\0';}inline static signed char quiet_NaN() throw(){return(signed char )'\0';}inline static signed char signaling_NaN() throw(){return(signed char )'\0';}inline static signed char denorm_min() throw(){return(signed char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned char > {static const bool is_specialized = true;inline static unsigned char min() throw(){return(unsigned char )'\0';}inline static unsigned char max() throw(){return(unsigned char )'';}static const int digits = 8;static const int digits10 = 2;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned char epsilon() throw(){return(unsigned char )'\0';}inline static unsigned char round_error() throw(){return(unsigned char )'\0';}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned char infinity() throw(){return(unsigned char )'\0';}inline static unsigned char quiet_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char signaling_NaN() throw(){return(unsigned char )'\0';}inline static unsigned char denorm_min() throw(){return(unsigned char )'\0';}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < wchar_t > {static const bool is_specialized = true;inline static wchar_t min() throw(){return((((wchar_t )(-1)) < 0)?((((wchar_t )1) <<(((sizeof(wchar_t )) * 8) -(((wchar_t )(-1)) < 0)))) :((wchar_t )0));}inline static wchar_t max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static wchar_t epsilon() throw(){return 0;}inline static wchar_t round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static wchar_t infinity() throw(){return 0;}inline static wchar_t quiet_NaN() throw(){return 0;}inline static wchar_t signaling_NaN() throw(){return 0;}inline static wchar_t denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < short > {static const bool is_specialized = true;inline static short min() throw(){return(short )(-32767 - 1);}inline static short max() throw(){return(short )32767;}static const int digits = 15;static const int digits10 = 4;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static short epsilon() throw(){return(short )0;}inline static short round_error() throw(){return(short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static short infinity() throw(){return(short )0;}inline static short quiet_NaN() throw(){return(short )0;}inline static short signaling_NaN() throw(){return(short )0;}inline static short denorm_min() throw(){return(short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned short > {static const bool is_specialized = true;inline static unsigned short min() throw(){return(unsigned short )0;}inline static unsigned short max() throw(){return(unsigned short )65535;}static const int digits = 16;static const int digits10 = 4;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned short epsilon() throw(){return(unsigned short )0;}inline static unsigned short round_error() throw(){return(unsigned short )0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned short infinity() throw(){return(unsigned short )0;}inline static unsigned short quiet_NaN() throw(){return(unsigned short )0;}inline static unsigned short signaling_NaN() throw(){return(unsigned short )0;}inline static unsigned short denorm_min() throw(){return(unsigned short )0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < int > {static const bool is_specialized = true;inline static int min() throw(){return((-2147483647) - 1);}inline static int max() throw(){return 2147483647;}static const int digits = 31;static const int digits10 = 9;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static int epsilon() throw(){return 0;}inline static int round_error() throw(){return 0;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static int infinity() throw(){return 0;}inline static int quiet_NaN() throw(){return 0;}inline static int signaling_NaN() throw(){return 0;}inline static int denorm_min() throw(){return 0;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned int > {static const bool is_specialized = true;inline static unsigned int min() throw(){return 0U;}inline static unsigned int max() throw(){return 4294967295U;}static const int digits = 32;static const int digits10 = 9;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned int epsilon() throw(){return 0U;}inline static unsigned int round_error() throw(){return 0U;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned int infinity() throw(){return 0U;}inline static unsigned int quiet_NaN() throw(){return 0U;}inline static unsigned int signaling_NaN() throw(){return 0U;}inline static unsigned int denorm_min() throw(){return 0U;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long > {static const bool is_specialized = true;inline static long min() throw(){return((-9223372036854775807L) - 1);}inline static long max() throw(){return 9223372036854775807L;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long epsilon() throw(){return 0L;}inline static long round_error() throw(){return 0L;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long infinity() throw(){return 0L;}inline static long quiet_NaN() throw(){return 0L;}inline static long signaling_NaN() throw(){return 0L;}inline static long denorm_min() throw(){return 0L;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long > {static const bool is_specialized = true;inline static unsigned long min() throw(){return 0UL;}inline static unsigned long max() throw(){return 18446744073709551615UL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long epsilon() throw(){return 0UL;}inline static unsigned long round_error() throw(){return 0UL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long infinity() throw(){return 0UL;}inline static unsigned long quiet_NaN() throw(){return 0UL;}inline static unsigned long signaling_NaN() throw(){return 0UL;}inline static unsigned long denorm_min() throw(){return 0UL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long long > {static const bool is_specialized = true;inline static long long min() throw(){return((-9223372036854775807LL) - 1);}inline static long long max() throw(){return 9223372036854775807LL;}static const int digits = 63;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static long long epsilon() throw(){return 0LL;}inline static long long round_error() throw(){return 0LL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static long long infinity() throw(){return 0LL;}inline static long long quiet_NaN() throw(){return 0LL;}inline static long long signaling_NaN() throw(){return 0LL;}inline static long long denorm_min() throw(){return 0LL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < unsigned long long > {static const bool is_specialized = true;inline static unsigned long long min() throw(){return 0ULL;}inline static unsigned long long max() throw(){return 18446744073709551615ULL;}static const int digits = 64;static const int digits10 = 19;static const bool is_signed = false;static const bool is_integer = true;static const bool is_exact = true;static const int radix = 2;inline static unsigned long long epsilon() throw(){return 0ULL;}inline static unsigned long long round_error() throw(){return 0ULL;}static const int min_exponent = 0;static const int min_exponent10 = 0;static const int max_exponent = 0;static const int max_exponent10 = 0;static const bool has_infinity = false;static const bool has_quiet_NaN = false;static const bool has_signaling_NaN = false;static const enum float_denorm_style has_denorm = denorm_absent;static const bool has_denorm_loss = false;inline static unsigned long long infinity() throw(){return 0ULL;}inline static unsigned long long quiet_NaN() throw(){return 0ULL;}inline static unsigned long long signaling_NaN() throw(){return 0ULL;}inline static unsigned long long denorm_min() throw(){return 0ULL;}static const bool is_iec559 = false;static const bool is_bounded = true;static const bool is_modulo = true;static const bool traps = true;static const bool tinyness_before = false;static const enum float_round_style round_style = round_toward_zero;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < float > {static const bool is_specialized = true;inline static float min() throw(){return 1.17549435e-38F;}inline static float max() throw(){return 3.40282347e+38F;}static const int digits = 24;static const int digits10 = 6;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static float epsilon() throw(){return 1.19209290e-7F;}inline static float round_error() throw(){return 0.5F;}static const int min_exponent = -125;static const int min_exponent10 = -37;static const int max_exponent = 128;static const int max_exponent10 = 38;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static float infinity() throw(){return __builtin_huge_valf();}inline static float quiet_NaN() throw(){return __builtin_nanf("");}inline static float signaling_NaN() throw(){return __builtin_nansf("");}inline static float denorm_min() throw(){return 1.40129846e-45F;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < double > {static const bool is_specialized = true;inline static double min() throw(){return 2.2250738585072014e-308;}inline static double max() throw(){return 1.7976931348623157e+308;}static const int digits = 53;static const int digits10 = 15;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static double epsilon() throw(){return 2.2204460492503131e-16;}inline static double round_error() throw(){return 0.5;}static const int min_exponent = -1021;static const int min_exponent10 = -307;static const int max_exponent = 1024;static const int max_exponent10 = 308;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static double infinity() throw(){return __builtin_huge_val();}inline static double quiet_NaN() throw(){return __builtin_nan("");}inline static double signaling_NaN() throw(){return __builtin_nans("");}inline static double denorm_min() throw(){return 4.9406564584124654e-324;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct numeric_limits < long double > {static const bool is_specialized = true;inline static long double min() throw(){return 3.36210314311209350626e-4932L;}inline static long double max() throw(){return 1.18973149535723176502e+4932L;}static const int digits = 64;static const int digits10 = 18;static const bool is_signed = true;static const bool is_integer = false;static const bool is_exact = false;static const int radix = 2;inline static long double epsilon() throw(){return 1.08420217248550443401e-19L;}inline static long double round_error() throw(){return 0.5L;}static const int min_exponent = -16381;static const int min_exponent10 = -4931;static const int max_exponent = 16384;static const int max_exponent10 = 4932;static const bool has_infinity = true;static const bool has_quiet_NaN = true;static const bool has_signaling_NaN = true;static const enum float_denorm_style has_denorm = denorm_present;static const bool has_denorm_loss = false;inline static long double infinity() throw(){return __builtin_huge_vall();}inline static long double quiet_NaN() throw(){return __builtin_nanl("");}inline static long double signaling_NaN() throw(){return __builtin_nansl("");}inline static long double denorm_min() throw(){return 3.64519953188247460253e-4951L;}static const bool is_iec559 = true;static const bool is_bounded = true;static const bool is_modulo = false;static const bool traps = false;static const bool tinyness_before = false;static const enum float_round_style round_style = round_to_nearest;};}}namespace std{template < typename _Tp >pair < _Tp *, ptrdiff_t >__get_temporary_buffer( ptrdiff_t __len, _Tp * ){const ptrdiff_t __max = numeric_limits < ptrdiff_t > :: max( ) / sizeof( _Tp );if( __len > __max )__len = __max;while( __len > 0 ){_Tp * __tmp = static_cast < _Tp * >( :: operator new( __len * sizeof( _Tp ),nothrow ) );if( __tmp != 0 )return pair < _Tp *, ptrdiff_t >( __tmp, __len );__len /= 2;}return pair < _Tp *, ptrdiff_t >( static_cast < _Tp * >( 0 ), 0 );}template < typename _Tp >inline pair < _Tp *, ptrdiff_t >get_temporary_buffer( ptrdiff_t __len ){return std :: __get_temporary_buffer( __len, static_cast < _Tp * >( 0 ) );}template < typename _Tp >voidreturn_temporary_buffer( _Tp * __p ){:: operator delete( __p, nothrow );}template < typename _Tp1 >struct auto_ptr_ref{_Tp1 * _M_ptr;explicitauto_ptr_ref( _Tp1 * __p );};template < typename _Tp >class auto_ptr{private :_Tp * _M_ptr;public :typedef _Tp element_type;explicitauto_ptr( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr( auto_ptr < _Tp1 > & __a ) throw( ) : _M_ptr( __a . release( ) ) {}auto_ptr &operator =( auto_ptr & __a ) throw( );template < typename _Tp1 >auto_ptr &operator =( auto_ptr < _Tp1 > & __a ) throw( ){reset( __a . release( ) );return * this;}~ auto_ptr( );element_type &operator *( ) const throw( );element_type *operator ->( ) const throw( );element_type *get( ) const throw( );element_type *release( ) throw( );voidreset( element_type * __p = 0 ) throw( );auto_ptr( auto_ptr_ref < element_type > __ref ) throw( );auto_ptr &operator =( auto_ptr_ref < element_type > __ref ) throw( );template < typename _Tp1 >operator auto_ptr_ref < _Tp1 >( ) throw( ){return auto_ptr_ref < _Tp1 >( this -> release( ) );}template < typename _Tp1 >operator auto_ptr < _Tp1 >( ) throw( ){return auto_ptr < _Tp1 >( this -> release( ) );}};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >inline void__ostream_write( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const streamsize __put = __out . rdbuf( ) -> sputn( __s, __n );if( __put != __n )__out . setstate( __ios_base :: badbit );}template < typename _CharT, typename _Traits >inline void__ostream_fill( basic_ostream < _CharT, _Traits > & __out, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;const _CharT __c = __out . fill( );for(;__n > 0;-- __n ){const typename _Traits :: int_type __put = __out . rdbuf( ) -> sputc( __c );if( _Traits :: eq_int_type( __put, _Traits :: eof( ) ) ){__out . setstate( __ios_base :: badbit );break;}}}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &__ostream_insert( basic_ostream < _CharT, _Traits > & __out,const _CharT * __s, streamsize __n ){typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef typename __ostream_type :: ios_base __ios_base;typename __ostream_type :: sentry __cerb( __out );if( __cerb ){try{const streamsize __w = __out . width( );if( __w > __n ){const bool __left =(( __out . flags( )& __ios_base :: adjustfield )== __ios_base :: left );if( ! __left )__ostream_fill( __out, __w - __n );if( __out . good( ) )__ostream_write( __out, __s, __n );if( __left && __out . good( ) )__ostream_fill( __out, __w - __n );}else__ostream_write( __out, __s, __n );__out . width( 0 );}catch( ... ){__out . _M_setstate( __ios_base :: badbit );}}return __out;}}namespace std{template < class _Arg, class _Result >struct unary_function{typedef _Arg argument_type;typedef _Result result_type;};template < class _Arg1, class _Arg2, class _Result >struct binary_function{typedef _Arg1 first_argument_type;typedef _Arg2 second_argument_type;typedef _Result result_type;};template < class _Tp >struct plus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct minus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct multiplies : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct divides : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct modulus : public binary_function < _Tp, _Tp, _Tp >{_Tpoperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct negate : public unary_function < _Tp, _Tp >{_Tpoperator( )( const _Tp & __x ) const;};template < class _Tp >struct equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct not_equal_to : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct greater_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct less_equal : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_and : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_or : public binary_function < _Tp, _Tp, bool >{booloperator( )( const _Tp & __x, const _Tp & __y ) const;};template < class _Tp >struct logical_not : public unary_function < _Tp, bool >{booloperator( )( const _Tp & __x ) const;};template < class _Predicate >class unary_negate: public unary_function < typename _Predicate :: argument_type, bool >{protected :_Predicate _M_pred;public :explicitunary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: argument_type & __x ) const;};template < class _Predicate >inline unary_negate < _Predicate >not1( const _Predicate & __pred ){return unary_negate < _Predicate >( __pred );}template < class _Predicate >class binary_negate: public binary_function < typename _Predicate :: first_argument_type,typename _Predicate :: second_argument_type,bool >{protected :_Predicate _M_pred;public :explicitbinary_negate( const _Predicate & __x );booloperator( )( const typename _Predicate :: first_argument_type & __x,const typename _Predicate :: second_argument_type & __y ) const;};template < class _Predicate >inline binary_negate < _Predicate >not2( const _Predicate & __pred ){return binary_negate < _Predicate >( __pred );}template < class _Operation >class binder1st: public unary_function < typename _Operation :: second_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: first_argument_type value;public :binder1st( const _Operation & __x,const typename _Operation :: first_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: second_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: second_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder1st < _Operation >bind1st( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: first_argument_type _Arg1_type;return binder1st < _Operation >( __fn, _Arg1_type( __x ) );}template < class _Operation >class binder2nd: public unary_function < typename _Operation :: first_argument_type,typename _Operation :: result_type >{protected :_Operation op;typename _Operation :: second_argument_type value;public :binder2nd( const _Operation & __x,const typename _Operation :: second_argument_type & __y );typename _Operation :: result_typeoperator( )( const typename _Operation :: first_argument_type & __x ) const;typename _Operation :: result_typeoperator( )( typename _Operation :: first_argument_type & __x ) const;};template < class _Operation, class _Tp >inline binder2nd < _Operation >bind2nd( const _Operation & __fn, const _Tp & __x ){typedef typename _Operation :: second_argument_type _Arg2_type;return binder2nd < _Operation >( __fn, _Arg2_type( __x ) );}template < class _Arg, class _Result >class pointer_to_unary_function : public unary_function < _Arg, _Result >{protected :_Result( * _M_ptr )( _Arg );public :pointer_to_unary_function( );explicitpointer_to_unary_function( _Result( * __x )( _Arg ) );_Resultoperator( )( _Arg __x ) const;};template < class _Arg, class _Result >inline pointer_to_unary_function < _Arg, _Result >ptr_fun( _Result( * __x )( _Arg ) ){return pointer_to_unary_function < _Arg, _Result >( __x );}template < class _Arg1, class _Arg2, class _Result >class pointer_to_binary_function: public binary_function < _Arg1, _Arg2, _Result >{protected :_Result( * _M_ptr )( _Arg1, _Arg2 );public :pointer_to_binary_function( );explicitpointer_to_binary_function( _Result( * __x )( _Arg1, _Arg2 ) );_Resultoperator( )( _Arg1 __x, _Arg2 __y ) const;};template < class _Arg1, class _Arg2, class _Result >inline pointer_to_binary_function < _Arg1, _Arg2, _Result >ptr_fun( _Result( * __x )( _Arg1, _Arg2 ) ){return pointer_to_binary_function < _Arg1, _Arg2, _Result >( __x );}template < class _Tp >struct _Identity : public unary_function < _Tp, _Tp >{_Tp &operator( )( _Tp & __x ) const;const _Tp &operator( )( const _Tp & __x ) const;};template < class _Pair >struct _Select1st : public unary_function < _Pair,typename _Pair :: first_type >{typename _Pair :: first_type &operator( )( _Pair & __x ) const;const typename _Pair :: first_type &operator( )( const _Pair & __x ) const;};template < class _Pair >struct _Select2nd : public unary_function < _Pair,typename _Pair :: second_type >{typename _Pair :: second_type &operator( )( _Pair & __x ) const;const typename _Pair :: second_type &operator( )( const _Pair & __x ) const;};template < class _Ret, class _Tp >class mem_fun_t : public unary_function < _Tp *, _Ret >{public :explicitmem_fun_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_t : public unary_function < const _Tp *, _Ret >{public :explicitconst_mem_fun_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp * __p ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp >class mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitmem_fun_ref_t( _Ret( _Tp :: * __pf )( ) );_Retoperator( )( _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( );};template < class _Ret, class _Tp >class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >{public :explicitconst_mem_fun_ref_t( _Ret( _Tp :: * __pf )( ) const );_Retoperator( )( const _Tp & __r ) const;private :_Ret( _Tp :: * _M_f )( ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >{public :explicitmem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >{public :explicitconst_mem_fun1_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp * __p, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp, class _Arg >class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitmem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) );_Retoperator( )( _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg );};template < class _Ret, class _Tp, class _Arg >class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >{public :explicitconst_mem_fun1_ref_t( _Ret( _Tp :: * __pf )( _Arg ) const );_Retoperator( )( const _Tp & __r, _Arg __x ) const;private :_Ret( _Tp :: * _M_f )( _Arg ) const;};template < class _Ret, class _Tp >inline mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) ){return mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_t < _Ret, _Tp >mem_fun( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) ){return mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp >inline const_mem_fun_ref_t < _Ret, _Tp >mem_fun_ref( _Ret( _Tp :: * __f )( ) const ){return const_mem_fun_ref_t < _Ret, _Tp >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_t < _Ret, _Tp, _Arg >mem_fun( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) ){return mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}template < class _Ret, class _Tp, class _Arg >inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >mem_fun_ref( _Ret( _Tp :: * __f )( _Arg ) const ){return const_mem_fun1_ref_t < _Ret, _Tp, _Arg >( __f );}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits, typename _Alloc >class basic_string{typedef typename _Alloc :: template rebind < _CharT > :: other _CharT_alloc_type;public :typedef _Traits traits_type;typedef typename _Traits :: char_type value_type;typedef _Alloc allocator_type;typedef typename _CharT_alloc_type :: size_type size_type;typedef typename _CharT_alloc_type :: difference_type difference_type;typedef typename _CharT_alloc_type :: reference reference;typedef typename _CharT_alloc_type :: const_reference const_reference;typedef typename _CharT_alloc_type :: pointer pointer;typedef typename _CharT_alloc_type :: const_pointer const_pointer;typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >const_iterator;typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;typedef std :: reverse_iterator < iterator > reverse_iterator;private :struct _Rep_base{size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : _Rep_base{typedef typename _Alloc :: template rebind < char > :: other _Raw_bytes_alloc;static const size_type _S_max_size;static const _CharT _S_terminal;static size_type _S_empty_rep_storage [ ];static _Rep &_S_empty_rep( );bool_M_is_leaked( ) const;bool_M_is_shared( ) const;void_M_set_leaked( );void_M_set_sharable( );void_M_set_length_and_sharable( size_type __n );_CharT *_M_refdata( ) throw( );_CharT *_M_grab( const _Alloc & __alloc1, const _Alloc & __alloc2 );static _Rep *_S_create( size_type, size_type, const _Alloc & );void_M_dispose( const _Alloc & __a );void_M_destroy( const _Alloc & ) throw( );_CharT *_M_refcopy( ) throw( );_CharT *_M_clone( const _Alloc &, size_type __res = 0 );};struct _Alloc_hider : _Alloc{_Alloc_hider( _CharT * __dat, const _Alloc & __a );_CharT * _M_p;};public :static const size_type npos = static_cast < size_type >( - 1 );private :mutable _Alloc_hider _M_dataplus;_CharT *_M_data( ) const;_CharT *_M_data( _CharT * __p );_Rep *_M_rep( ) const;iterator_M_ibegin( ) const;iterator_M_iend( ) const;void_M_leak( );size_type_M_check( size_type __pos, const char * __s ) const;void_M_check_length( size_type __n1, size_type __n2, const char * __s ) const;size_type_M_limit( size_type __pos, size_type __off ) const;bool_M_disjunct( const _CharT * __s ) const;static void_M_copy( _CharT * __d, const _CharT * __s, size_type __n );static void_M_move( _CharT * __d, const _CharT * __s, size_type __n );static void_M_assign( _CharT * __d, size_type __n, _CharT __c );template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 ){for(;__k1 != __k2;++ __k1, ++ __p )traits_type :: assign( * __p, * __k1 );}static void_S_copy_chars( _CharT * __p, iterator __k1, iterator __k2 );static void_S_copy_chars( _CharT * __p, const_iterator __k1, const_iterator __k2 );static void_S_copy_chars( _CharT * __p, _CharT * __k1, _CharT * __k2 );static void_S_copy_chars( _CharT * __p, const _CharT * __k1, const _CharT * __k2 );static int_S_compare( size_type __x, size_type __y );void_M_mutate( size_type __pos, size_type __len1, size_type __len2 );void_M_leak_hard( );static _Rep &_S_empty_rep( );public :inlinebasic_string( );explicitbasic_string( const _Alloc & __a );basic_string( const basic_string & __str );basic_string( const basic_string & __str, size_type __pos,size_type __n = npos );basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a );basic_string( const _CharT * __s, size_type __n,const _Alloc & __a = _Alloc( ) );basic_string( const _CharT * __s, const _Alloc & __a = _Alloc( ) );basic_string( size_type __n, _CharT __c, const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );~ basic_string( );basic_string &operator =( const basic_string & __str );basic_string &operator =( const _CharT * __s );basic_string &operator =( _CharT __c );iteratorbegin( );const_iteratorbegin( ) const;iteratorend( );const_iteratorend( ) const;reverse_iteratorrbegin( );const_reverse_iteratorrbegin( ) const;reverse_iteratorrend( );const_reverse_iteratorrend( ) const;public :size_typesize( ) const;size_typelength( ) const;size_typemax_size( ) const;voidresize( size_type __n, _CharT __c );voidresize( size_type __n );size_typecapacity( ) const;voidreserve( size_type __res_arg = 0 );voidclear( );boolempty( ) const;const_referenceoperator [ ]( size_type __pos ) const;referenceoperator [ ]( size_type __pos );const_referenceat( size_type __n ) const;referenceat( size_type __n );basic_string &operator +=( const basic_string & __str );basic_string &operator +=( const _CharT * __s );basic_string &operator +=( _CharT __c );basic_string &append( const basic_string & __str );basic_string &append( const basic_string & __str, size_type __pos, size_type __n );basic_string &append( const _CharT * __s, size_type __n );basic_string &append( const _CharT * __s );basic_string &append( size_type __n, _CharT __c );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_iend( ), _M_iend( ), __first, __last );}voidpush_back( _CharT __c );basic_string &assign( const basic_string & __str );basic_string &assign( const basic_string & __str, size_type __pos, size_type __n );basic_string &assign( const _CharT * __s, size_type __n );basic_string &assign( const _CharT * __s );basic_string &assign( size_type __n, _CharT __c );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last ){return this -> replace( _M_ibegin( ), _M_iend( ), __first, __last );}voidinsert( iterator __p, size_type __n, _CharT __c );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end ){this -> replace( __p, __p, __beg, __end );}basic_string &insert( size_type __pos1, const basic_string & __str );basic_string &insert( size_type __pos1, const basic_string & __str,size_type __pos2, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s, size_type __n );basic_string &insert( size_type __pos, const _CharT * __s );basic_string &insert( size_type __pos, size_type __n, _CharT __c );iteratorinsert( iterator __p, _CharT __c );basic_string &erase( size_type __pos = 0, size_type __n = npos );iteratorerase( iterator __position );iteratorerase( iterator __first, iterator __last );basic_string &replace( size_type __pos, size_type __n, const basic_string & __str );basic_string &replace( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 );basic_string &replace( size_type __pos, size_type __n1, const _CharT * __s );basic_string &replace( size_type __pos, size_type __n1, size_type __n2, _CharT __c );basic_string &replace( iterator __i1, iterator __i2, const basic_string & __str );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s, size_type __n );basic_string &replace( iterator __i1, iterator __i2, const _CharT * __s );basic_string &replace( iterator __i1, iterator __i2, size_type __n, _CharT __c );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 ){;;typedef typename std :: __is_integer < _InputIterator > :: __type _Integral;return _M_replace_dispatch( __i1, __i2, __k1, __k2, _Integral( ) );}basic_string &replace( iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2,const _CharT * __k1, const _CharT * __k2 );basic_string &replace( iterator __i1, iterator __i2, iterator __k1, iterator __k2 );basic_string &replace( iterator __i1, iterator __i2,const_iterator __k1, const_iterator __k2 );private :template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type ){return _M_replace_aux( __i1 - _M_ibegin( ), __i2 - __i1, __n, __val );}template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );basic_string &_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c );basic_string &_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type ){typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;return _S_construct( __beg, __end, __a, _Tag( ) );}template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type ){return _S_construct( static_cast < size_type >( __beg ),static_cast < value_type >( __end ), __a );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a ){typedef typename std :: __is_integer < _InIterator > :: __type _Integral;return _S_construct_aux( __beg, __end, __a, _Integral( ) );}template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );static _CharT *_S_construct( size_type __req, _CharT __c, const _Alloc & __a );public :size_typecopy( _CharT * __s, size_type __n, size_type __pos = 0 ) const;voidswap( basic_string & __s );const _CharT *c_str( ) const;const _CharT *data( ) const;allocator_typeget_allocator( ) const;size_typefind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind( const basic_string & __str, size_type __pos = 0 ) const;size_typefind( const _CharT * __s, size_type __pos = 0 ) const;size_typefind( _CharT __c, size_type __pos = 0 ) const;size_typerfind( const basic_string & __str, size_type __pos = npos ) const;size_typerfind( const _CharT * __s, size_type __pos, size_type __n ) const;size_typerfind( const _CharT * __s, size_type __pos = npos ) const;size_typerfind( _CharT __c, size_type __pos = npos ) const;size_typefind_first_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_first_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_of( const _CharT * __s, size_type __pos, size_type __n ) const;size_typefind_last_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_of( _CharT __c, size_type __pos = npos ) const;size_typefind_first_not_of( const basic_string & __str, size_type __pos = 0 ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_first_not_of( const _CharT * __s, size_type __pos = 0 ) const;size_typefind_first_not_of( _CharT __c, size_type __pos = 0 ) const;size_typefind_last_not_of( const basic_string & __str, size_type __pos = npos ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos,size_type __n ) const;size_typefind_last_not_of( const _CharT * __s, size_type __pos = npos ) const;size_typefind_last_not_of( _CharT __c, size_type __pos = npos ) const;basic_stringsubstr( size_type __pos = 0, size_type __n = npos ) const;intcompare( const basic_string & __str ) const;intcompare( size_type __pos, size_type __n, const basic_string & __str ) const;intcompare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const;intcompare( const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s ) const;intcompare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const;};template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc > ::basic_string( ): _M_dataplus( _S_empty_rep( ) . _M_refdata( ), _Alloc( ) ) {}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){basic_string < _CharT, _Traits, _Alloc > __str( __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline basic_string < _CharT, _Traits, _Alloc >operator +( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str( __lhs );__str . append( __size_type( 1 ), __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator ==( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) == 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator !=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) != 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) > 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) < 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator <=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const basic_string < _CharT, _Traits, _Alloc > & __lhs,const _CharT * __rhs ){return __lhs . compare( __rhs ) >= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline booloperator >=( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){return __rhs . compare( __lhs ) <= 0;}template < typename _CharT, typename _Traits, typename _Alloc >inline voidswap( basic_string < _CharT, _Traits, _Alloc > & __lhs,basic_string < _CharT, _Traits, _Alloc > & __rhs ){__lhs . swap( __rhs );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __os,const basic_string < _CharT, _Traits, _Alloc > & __str ){return __ostream_insert( __os, __str . data( ), __str . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );template < typename _CharT, typename _Traits, typename _Alloc >inline basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __is,basic_string < _CharT, _Traits, _Alloc > & __str ){return getline( __is, __str, __is . widen( '\n' ) );}}#pragma GCC system_headernamespace std{template < typename _RandomAccessIterator, typename _Distance >bool__is_heap( _RandomAccessIterator __first, _Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __first [ __parent ] < __first [ __child ] )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator, typename _Distance,typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _StrictWeakOrdering __comp,_Distance __n ){_Distance __parent = 0;for( _Distance __child = 1;__child < __n;++ __child ){if( __comp( __first [ __parent ], __first [ __child ] ) )return false;if(( __child & 1 ) == 0 )++ __parent;}return true;}template < typename _RandomAccessIterator >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){return std :: __is_heap( __first, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _StrictWeakOrdering >bool__is_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_StrictWeakOrdering __comp ){return std :: __is_heap( __first, __comp, std :: distance( __first, __last ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__push_heap( _RandomAccessIterator __first,_Distance __holeIndex, _Distance __topIndex, _Tp __value ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex && *( __first + __parent ) < __value ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp,typename _Compare >void__push_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __topIndex, _Tp __value, _Compare __comp ){_Distance __parent =( __holeIndex - 1 ) / 2;while( __holeIndex > __topIndex&& __comp( *( __first + __parent ), __value ) ){*( __first + __holeIndex ) = *( __first + __parent );__holeIndex = __parent;__parent =( __holeIndex - 1 ) / 2;}*( __first + __holeIndex ) = __value;}template < typename _RandomAccessIterator, typename _Compare >inline voidpush_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;std :: __push_heap( __first, _DistanceType(( __last - __first ) - 1 ),_DistanceType( 0 ), _ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator, typename _Distance, typename _Tp >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( *( __first + __secondChild ) < *( __first +( __secondChild - 1 ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value );}template < typename _RandomAccessIterator, typename _Tp >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value );}template < typename _RandomAccessIterator >inline voidpop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ) );}template < typename _RandomAccessIterator, typename _Distance,typename _Tp, typename _Compare >void__adjust_heap( _RandomAccessIterator __first, _Distance __holeIndex,_Distance __len, _Tp __value, _Compare __comp ){const _Distance __topIndex = __holeIndex;_Distance __secondChild = 2 * __holeIndex + 2;while( __secondChild < __len ){if( __comp( *( __first + __secondChild ),*( __first +( __secondChild - 1 ) ) ) )__secondChild --;*( __first + __holeIndex ) = *( __first + __secondChild );__holeIndex = __secondChild;__secondChild = 2 *( __secondChild + 1 );}if( __secondChild == __len ){*( __first + __holeIndex ) = *( __first +( __secondChild - 1 ) );__holeIndex = __secondChild - 1;}std :: __push_heap( __first, __holeIndex, __topIndex, __value, __comp );}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >inline void__pop_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomAccessIterator __result, _Tp __value, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;* __result = * __first;std :: __adjust_heap( __first, _Distance( 0 ), _Distance( __last - __first ),__value, __comp );}template < typename _RandomAccessIterator, typename _Compare >inline voidpop_heap( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){;;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: __pop_heap( __first, __last - 1, __last - 1,_ValueType( *( __last - 1 ) ), __comp );}template < typename _RandomAccessIterator >voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ) );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator, typename _Compare >inline voidmake_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;if( __last - __first < 2 )return;const _DistanceType __len = __last - __first;_DistanceType __parent =( __len - 2 ) / 2;while( true ){std :: __adjust_heap( __first, __parent, __len,_ValueType( *( __first + __parent ) ), __comp );if( __parent == 0 )return;__parent --;}}template < typename _RandomAccessIterator >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last ){;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ) );}template < typename _RandomAccessIterator, typename _Compare >voidsort_heap( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){;;while( __last - __first > 1 )std :: pop_heap( __first, _RandomAccessIterator( __last -- ), __comp );}}namespace std{template < typename _ForwardIterator, typename _Tp >class _Temporary_buffer{public :typedef _Tp value_type;typedef value_type * pointer;typedef pointer iterator;typedef ptrdiff_t size_type;protected :size_type _M_original_len;size_type _M_len;pointer _M_buffer;void_M_initialize_buffer( const _Tp &, __true_type );void_M_initialize_buffer( const _Tp & __val, __false_type );public :size_typesize( ) const;size_typerequested_size( ) const;iteratorbegin( );iteratorend( );_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last );~ _Temporary_buffer( );private :_Temporary_buffer( const _Temporary_buffer & );voidoperator =( const _Temporary_buffer & );};template < typename _ForwardIterator, typename _Tp >_Temporary_buffer < _ForwardIterator, _Tp > ::_Temporary_buffer( _ForwardIterator __first, _ForwardIterator __last ): _M_original_len( std :: distance( __first, __last ) ),_M_len( 0 ), _M_buffer( 0 ){typedef typename std :: __is_scalar < _Tp > :: __type _Trivial;try{pair < pointer, size_type > __p( get_temporary_buffer <value_type >( _M_original_len ) );_M_buffer = __p . first;_M_len = __p . second;if( _M_len > 0 )_M_initialize_buffer( * __first, _Trivial( ) );}catch( ... ){std :: return_temporary_buffer( _M_buffer );_M_buffer = 0;_M_len = 0;throw;}}}namespace std{template < typename _Tp >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c ){if( __a < __b )if( __b < __c )return __b;else if( __a < __c )return __c;elsereturn __a;else if( __a < __c )return __a;else if( __b < __c )return __c;elsereturn __b;}template < typename _Tp, typename _Compare >inline const _Tp &__median( const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp ){if( __comp( __a, __b ) )if( __comp( __b, __c ) )return __b;else if( __comp( __a, __c ) )return __c;elsereturn __a;else if( __comp( __a, __c ) )return __a;else if( __comp( __b, __c ) )return __c;elsereturn __b;}template < typename _InputIterator, typename _Function >_Functionfor_each( _InputIterator __first, _InputIterator __last, _Function __f ){;for(;__first != __last;++ __first )__f( * __first );return __f;}template < typename _InputIterator, typename _Tp >inline _InputIterator__find( _InputIterator __first, _InputIterator __last,const _Tp & __val, input_iterator_tag ){while( __first != __last && !( * __first == __val ) )++ __first;return __first;}template < typename _InputIterator, typename _Predicate >inline _InputIterator__find_if( _InputIterator __first, _InputIterator __last,_Predicate __pred, input_iterator_tag ){while( __first != __last && ! __pred( * __first ) )++ __first;return __first;}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__find( _RandomAccessIterator __first, _RandomAccessIterator __last,const _Tp & __val, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;if( * __first == __val )return __first;++ __first;}switch( __last - __first ){case 3 :if( * __first == __val )return __first;++ __first;case 2 :if( * __first == __val )return __first;++ __first;case 1 :if( * __first == __val )return __first;++ __first;case 0 :default :return __last;}}template < typename _RandomAccessIterator, typename _Predicate >_RandomAccessIterator__find_if( _RandomAccessIterator __first, _RandomAccessIterator __last,_Predicate __pred, random_access_iterator_tag ){typename iterator_traits < _RandomAccessIterator > :: difference_type__trip_count =( __last - __first ) >> 2;for(;__trip_count > 0;-- __trip_count ){if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;if( __pred( * __first ) )return __first;++ __first;}switch( __last - __first ){case 3 :if( __pred( * __first ) )return __first;++ __first;case 2 :if( __pred( * __first ) )return __first;++ __first;case 1 :if( __pred( * __first ) )return __first;++ __first;case 0 :default :return __last;}}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT >, istreambuf_iterator < _CharT >,const _CharT & );template < typename _InputIterator, typename _Tp >inline _InputIteratorfind( _InputIterator __first, _InputIterator __last,const _Tp & __val ){;return std :: __find( __first, __last, __val,std :: __iterator_category( __first ) );}template < typename _InputIterator, typename _Predicate >inline _InputIteratorfind_if( _InputIterator __first, _InputIterator __last,_Predicate __pred ){;return std :: __find_if( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( * __first == * __next )return __first;__first = __next;}return __last;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratoradjacent_find( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;if( __first == __last )return __last;_ForwardIterator __next = __first;while( ++ __next != __last ){if( __binary_pred( * __first, * __next ) )return __first;__first = __next;}return __last;}template < typename _InputIterator, typename _Tp >typename iterator_traits < _InputIterator > :: difference_typecount( _InputIterator __first, _InputIterator __last, const _Tp & __value ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( * __first == __value )++ __n;return __n;}template < typename _InputIterator, typename _Predicate >typename iterator_traits < _InputIterator > :: difference_typecount_if( _InputIterator __first, _InputIterator __last, _Predicate __pred ){;typename iterator_traits < _InputIterator > :: difference_type __n = 0;for(;__first != __last;++ __first )if( __pred( * __first ) )++ __n;return __n;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 )return std :: find( __first1, __last1, * __first2 );_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){__first1 = std :: find( __first1, __last1, * __first2 );if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( * __current == * __p ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1search( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __predicate ){;;if( __first1 == __last1 || __first2 == __last2 )return __first1;_ForwardIterator2 __tmp( __first2 );++ __tmp;if( __tmp == __last2 ){while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;return __first1;}_ForwardIterator2 __p1, __p;__p1 = __first2;++ __p1;_ForwardIterator1 __current = __first1;while( __first1 != __last1 ){while( __first1 != __last1 ){if( __predicate( * __first1, * __first2 ) )break;++ __first1;}while( __first1 != __last1 && ! __predicate( * __first1, * __first2 ) )++ __first1;if( __first1 == __last1 )return __last1;__p = __p1;__current = __first1;if( ++ __current == __last1 )return __last1;while( __predicate( * __current, * __p ) ){if( ++ __p == __last2 )return __first1;if( ++ __current == __last1 )return __last1;}++ __first1;}return __first1;}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,std :: forward_iterator_tag ){__first = std :: find( __first, __last, __val );while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && * __i == __val ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = std :: find( ++ __i, __last, __val );}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( !( * __lookAhead == __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;* __backTrack == __val;-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val ){;if( __count <= 0 )return __first;if( __count == 1 )return std :: find( __first, __last, __val );return std :: __search_n( __first, __last, __count, __val,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIterator__search_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: forward_iterator_tag ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;while( __first != __last ){typename iterator_traits < _ForwardIterator > :: difference_type__n = __count;_ForwardIterator __i = __first;++ __i;while( __i != __last && __n != 1 && __binary_pred( * __i, __val ) ){++ __i;-- __n;}if( __n == 1 )return __first;if( __i == __last )return __last;__first = ++ __i;while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;}return __last;}template < typename _RandomAccessIter, typename _Integer, typename _Tp,typename _BinaryPredicate >_RandomAccessIter__search_n( _RandomAccessIter __first, _RandomAccessIter __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred, std :: random_access_iterator_tag ){typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type_DistanceType;_DistanceType __tailSize = __last - __first;const _DistanceType __pattSize = __count;if( __tailSize < __pattSize )return __last;const _DistanceType __skipOffset = __pattSize - 1;_RandomAccessIter __lookAhead = __first + __skipOffset;__tailSize -= __pattSize;while( 1 ){while( ! __binary_pred( * __lookAhead, __val ) ){if( __tailSize < __pattSize )return __last;__lookAhead += __pattSize;__tailSize -= __pattSize;}_DistanceType __remainder = __skipOffset;for( _RandomAccessIter __backTrack = __lookAhead - 1;__binary_pred( * __backTrack, __val );-- __backTrack ){if( -- __remainder == 0 )return( __lookAhead - __skipOffset );}if( __remainder > __tailSize )return __last;__lookAhead += __remainder;__tailSize -= __remainder;}}template < typename _ForwardIterator, typename _Integer, typename _Tp,typename _BinaryPredicate >_ForwardIteratorsearch_n( _ForwardIterator __first, _ForwardIterator __last,_Integer __count, const _Tp & __val,_BinaryPredicate __binary_pred ){;if( __count <= 0 )return __first;if( __count == 1 ){while( __first != __last && ! __binary_pred( * __first, __val ) )++ __first;return __first;}return std :: __search_n( __first, __last, __count, __val, __binary_pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator2swap_ranges( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2 ){;for(;__first1 != __last1;++ __first1, ++ __first2 )std :: iter_swap( __first1, __first2 );return __first2;}template < typename _InputIterator, typename _OutputIterator,typename _UnaryOperation >_OutputIteratortransform( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _UnaryOperation __unary_op ){;for(;__first != __last;++ __first, ++ __result )* __result = __unary_op( * __first );return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _BinaryOperation >_OutputIteratortransform( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _OutputIterator __result,_BinaryOperation __binary_op ){;for(;__first1 != __last1;++ __first1, ++ __first2, ++ __result )* __result = __binary_op( * __first1, * __first2 );return __result;}template < typename _ForwardIterator, typename _Tp >voidreplace( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( * __first == __old_value )* __first = __new_value;}template < typename _ForwardIterator, typename _Predicate, typename _Tp >voidreplace_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first )if( __pred( * __first ) )* __first = __new_value;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorreplace_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,const _Tp & __old_value, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( * __first == __old_value )* __result = __new_value;else* __result = * __first;return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate, typename _Tp >_OutputIteratorreplace_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_Predicate __pred, const _Tp & __new_value ){;for(;__first != __last;++ __first, ++ __result )if( __pred( * __first ) )* __result = __new_value;else* __result = * __first;return __result;}template < typename _ForwardIterator, typename _Generator >voidgenerate( _ForwardIterator __first, _ForwardIterator __last,_Generator __gen ){;for(;__first != __last;++ __first )* __first = __gen( );}template < typename _OutputIterator, typename _Size, typename _Generator >_OutputIteratorgenerate_n( _OutputIterator __first, _Size __n, _Generator __gen ){for(;__n > 0;-- __n, ++ __first )* __first = __gen( );return __first;}template < typename _InputIterator, typename _OutputIterator, typename _Tp >_OutputIteratorremove_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, const _Tp & __value ){;for(;__first != __last;++ __first )if( !( * __first == __value ) ){* __result = * __first;++ __result;}return __result;}template < typename _InputIterator, typename _OutputIterator,typename _Predicate >_OutputIteratorremove_copy_if( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _Predicate __pred ){;for(;__first != __last;++ __first )if( ! __pred( * __first ) ){* __result = * __first;++ __result;}return __result;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorremove( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __value ){;__first = std :: find( __first, __last, __value );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy( ++ __i, __last,__first, __value );}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorremove_if( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;__first = std :: find_if( __first, __last, __pred );_ForwardIterator __i = __first;return __first == __last ? __first: std :: remove_copy_if( ++ __i, __last,__first, __pred );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( !( * __first == * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( !( __value == * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( !( * __result == * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _ForwardIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _ForwardIterator __first, _ForwardIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,forward_iterator_tag, output_iterator_tag ){_ForwardIterator __next = __first;* __result = * __first;while( ++ __next != __last )if( ! __binary_pred( * __first, * __next ) ){__first = __next;* ++ __result = * __first;}return ++ __result;}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >_OutputIterator__unique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, output_iterator_tag ){typename iterator_traits < _InputIterator > :: value_type __value = * __first;* __result = __value;while( ++ __first != __last )if( ! __binary_pred( __value, * __first ) ){__value = * __first;* ++ __result = __value;}return ++ __result;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_ForwardIterator__unique_copy( _InputIterator __first, _InputIterator __last,_ForwardIterator __result, _BinaryPredicate __binary_pred,input_iterator_tag, forward_iterator_tag ){* __result = * __first;while( ++ __first != __last )if( ! __binary_pred( * __result, * __first ) )* ++ __result = * __first;return ++ __result;}template < typename _InputIterator, typename _OutputIterator >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _InputIterator, typename _OutputIterator,typename _BinaryPredicate >inline _OutputIteratorunique_copy( _InputIterator __first, _InputIterator __last,_OutputIterator __result,_BinaryPredicate __binary_pred ){;if( __first == __last )return __result;return std :: __unique_copy( __first, __last, __result, __binary_pred,std :: __iterator_category( __first ),std :: __iterator_category( __result ) );}template < typename _ForwardIterator >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last ){;__first = std :: adjacent_find( __first, __last );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( !( * __dest == * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _ForwardIterator, typename _BinaryPredicate >_ForwardIteratorunique( _ForwardIterator __first, _ForwardIterator __last,_BinaryPredicate __binary_pred ){;__first = std :: adjacent_find( __first, __last, __binary_pred );if( __first == __last )return __last;_ForwardIterator __dest = __first;++ __first;while( ++ __first != __last )if( ! __binary_pred( * __dest, * __first ) )* ++ __dest = * __first;return ++ __dest;}template < typename _BidirectionalIterator >void__reverse( _BidirectionalIterator __first, _BidirectionalIterator __last,bidirectional_iterator_tag ){while( true )if( __first == __last || __first == -- __last )return;else{std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator >void__reverse( _RandomAccessIterator __first, _RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __last )return;-- __last;while( __first < __last ){std :: iter_swap( __first, __last );++ __first;-- __last;}}template < typename _BidirectionalIterator >inline voidreverse( _BidirectionalIterator __first, _BidirectionalIterator __last ){;std :: __reverse( __first, __last, std :: __iterator_category( __first ) );}template < typename _BidirectionalIterator, typename _OutputIterator >_OutputIteratorreverse_copy( _BidirectionalIterator __first, _BidirectionalIterator __last,_OutputIterator __result ){;while( __first != __last ){-- __last;* __result = * __last;++ __result;}return __result;}template < typename _EuclideanRingElement >_EuclideanRingElement__gcd( _EuclideanRingElement __m, _EuclideanRingElement __n ){while( __n != 0 ){_EuclideanRingElement __t = __m % __n;__m = __n;__n = __t;}return __m;}template < typename _ForwardIterator >void__rotate( _ForwardIterator __first,_ForwardIterator __middle,_ForwardIterator __last,forward_iterator_tag ){if( __first == __middle || __last == __middle )return;_ForwardIterator __first2 = __middle;do{swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;}while( __first2 != __last );__first2 = __middle;while( __first2 != __last ){swap( * __first, * __first2 );++ __first;++ __first2;if( __first == __middle )__middle = __first2;else if( __first2 == __last )__first2 = __middle;}}template < typename _BidirectionalIterator >void__rotate( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,bidirectional_iterator_tag ){if( __first == __middle || __last == __middle )return;std :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );while( __first != __middle && __middle != __last ){swap( * __first, * -- __last );++ __first;}if( __first == __middle )std :: __reverse( __middle, __last, bidirectional_iterator_tag( ) );elsestd :: __reverse( __first, __middle, bidirectional_iterator_tag( ) );}template < typename _RandomAccessIterator >void__rotate( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,random_access_iterator_tag ){if( __first == __middle || __last == __middle )return;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;const _Distance __n = __last - __first;const _Distance __k = __middle - __first;const _Distance __l = __n - __k;if( __k == __l ){std :: swap_ranges( __first, __middle, __middle );return;}const _Distance __d = __gcd( __n, __k );for( _Distance __i = 0;__i < __d;__i ++ ){_ValueType __tmp = * __first;_RandomAccessIterator __p = __first;if( __k < __l ){for( _Distance __j = 0;__j < __l / __d;__j ++ ){if( __p > __first + __l ){* __p = *( __p - __l );__p -= __l;}* __p = *( __p + __k );__p += __k;}}else{for( _Distance __j = 0;__j < __k / __d - 1;__j ++ ){if( __p < __last - __k ){* __p = *( __p + __k );__p += __k;}* __p = *( __p - __l );__p -= __l;}}* __p = __tmp;++ __first;}}template < typename _ForwardIterator >inline voidrotate( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last ){;;typedef typename iterator_traits < _ForwardIterator > :: iterator_category_IterType;std :: __rotate( __first, __middle, __last, _IterType( ) );}template < typename _ForwardIterator, typename _OutputIterator >_OutputIteratorrotate_copy( _ForwardIterator __first, _ForwardIterator __middle,_ForwardIterator __last, _OutputIterator __result ){;;return std :: copy( __first, __middle,std :: copy( __middle, __last, __result ) );}template < typename _RandomAccessIterator >inline voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last ){;if( __first != __last )for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first +( std :: rand( ) %(( __i - __first ) + 1 ) ) );}template < typename _RandomAccessIterator, typename _RandomNumberGenerator >voidrandom_shuffle( _RandomAccessIterator __first, _RandomAccessIterator __last,_RandomNumberGenerator & __rand ){;if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i )std :: iter_swap( __i, __first + __rand(( __i - __first ) + 1 ) );}template < typename _ForwardIterator, typename _Predicate >_ForwardIterator__partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred,forward_iterator_tag ){if( __first == __last )return __first;while( __pred( * __first ) )if( ++ __first == __last )return __first;_ForwardIterator __next = __first;while( ++ __next != __last )if( __pred( * __next ) ){swap( * __first, * __next );++ __first;}return __first;}template < typename _BidirectionalIterator, typename _Predicate >_BidirectionalIterator__partition( _BidirectionalIterator __first, _BidirectionalIterator __last,_Predicate __pred,bidirectional_iterator_tag ){while( true ){while( true )if( __first == __last )return __first;else if( __pred( * __first ) )++ __first;elsebreak;-- __last;while( true )if( __first == __last )return __first;else if( ! __pred( * __last ) )-- __last;elsebreak;std :: iter_swap( __first, __last );++ __first;}}template < typename _ForwardIterator, typename _Predicate >inline _ForwardIteratorpartition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;return std :: __partition( __first, __last, __pred,std :: __iterator_category( __first ) );}template < typename _ForwardIterator, typename _Predicate, typename _Distance >_ForwardIterator__inplace_stable_partition( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len ){if( __len == 1 )return __pred( * __first ) ? __last : __first;_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin = std :: __inplace_stable_partition( __first,__middle,__pred,__len / 2 );_ForwardIterator __end = std :: __inplace_stable_partition( __middle, __last,__pred,__len- __len / 2 );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}template < typename _ForwardIterator, typename _Pointer, typename _Predicate,typename _Distance >_ForwardIterator__stable_partition_adaptive( _ForwardIterator __first,_ForwardIterator __last,_Predicate __pred, _Distance __len,_Pointer __buffer,_Distance __buffer_size ){if( __len <= __buffer_size ){_ForwardIterator __result1 = __first;_Pointer __result2 = __buffer;for(;__first != __last;++ __first )if( __pred( * __first ) ){* __result1 = * __first;++ __result1;}else{* __result2 = * __first;++ __result2;}std :: copy( __buffer, __result2, __result1 );return __result1;}else{_ForwardIterator __middle = __first;std :: advance( __middle, __len / 2 );_ForwardIterator __begin =std :: __stable_partition_adaptive( __first, __middle, __pred,__len / 2, __buffer,__buffer_size );_ForwardIterator __end =std :: __stable_partition_adaptive( __middle, __last, __pred,__len - __len / 2,__buffer, __buffer_size );std :: rotate( __begin, __middle, __end );std :: advance( __begin, std :: distance( __middle, __end ) );return __begin;}}template < typename _ForwardIterator, typename _Predicate >_ForwardIteratorstable_partition( _ForwardIterator __first, _ForwardIterator __last,_Predicate __pred ){;if( __first == __last )return __first;else{typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;_Temporary_buffer < _ForwardIterator, _ValueType > __buf( __first,__last );if( __buf . size( ) > 0 )returnstd :: __stable_partition_adaptive( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ),__buf . begin( ), __buf . size( ) );elsereturnstd :: __inplace_stable_partition( __first, __last, __pred,_DistanceType( __buf . requested_size( ) ) );}}template < typename _RandomAccessIterator, typename _Tp >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last, _Tp __pivot ){while( true ){while( * __first < __pivot )++ __first;-- __last;while( __pivot < * __last )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >_RandomAccessIterator__unguarded_partition( _RandomAccessIterator __first,_RandomAccessIterator __last,_Tp __pivot, _Compare __comp ){while( true ){while( __comp( * __first, __pivot ) )++ __first;-- __last;while( __comp( __pivot, * __last ) )-- __last;if( !( __first < __last ) )return __first;std :: iter_swap( __first, __last );++ __first;}}enum __unnamed_enum___F92_L2296_C3__S_threshold {_S_threshold=16};template < typename _RandomAccessIterator, typename _Tp >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val ){_RandomAccessIterator __next = __last;-- __next;while( __val < * __next ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator, typename _Tp, typename _Compare >void__unguarded_linear_insert( _RandomAccessIterator __last, _Tp __val,_Compare __comp ){_RandomAccessIterator __next = __last;-- __next;while( __comp( __val, * __next ) ){* __last = * __next;__last = __next;-- __next;}* __last = __val;}template < typename _RandomAccessIterator >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __first == __last )return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __val < * __first ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val );}}template < typename _RandomAccessIterator, typename _Compare >void__insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __first == __last ) return;for( _RandomAccessIterator __i = __first + 1;__i != __last;++ __i ){typename iterator_traits < _RandomAccessIterator > :: value_type__val = * __i;if( __comp( __val, * __first ) ){std :: copy_backward( __first, __i, __i + 1 );* __first = __val;}elsestd :: __unguarded_linear_insert( __i, __val, __comp );}}template < typename _RandomAccessIterator >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >inline void__unguarded_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;for( _RandomAccessIterator __i = __first;__i != __last;++ __i )std :: __unguarded_linear_insert( __i, _ValueType( * __i ), __comp );}template < typename _RandomAccessIterator >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ) );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last );}elsestd :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Compare >void__final_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first > int( _S_threshold ) ){std :: __insertion_sort( __first, __first + int( _S_threshold ), __comp );std :: __unguarded_insertion_sort( __first + int( _S_threshold ), __last,__comp );}elsestd :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( * __i < * __first )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ) );}template < typename _RandomAccessIterator, typename _Compare >void__heap_select( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;std :: make_heap( __first, __middle, __comp );for( _RandomAccessIterator __i = __middle;__i < __last;++ __i )if( __comp( * __i, * __first ) )std :: __pop_heap( __first, __middle, __i, _ValueType( * __i ), __comp );}template < typename _Size >inline _Size__lg( _Size __n ){_Size __k;for( __k = 0;__n != 1;__n >>= 1 )++ __k;return __k;}template < typename _RandomAccessIterator >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last );std :: sort_heap( __first, __middle );}template < typename _RandomAccessIterator, typename _Compare >inline voidpartial_sort( _RandomAccessIterator __first,_RandomAccessIterator __middle,_RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;std :: __heap_select( __first, __middle, __last, __comp );std :: sort_heap( __first, __middle, __comp );}template < typename _InputIterator, typename _RandomAccessIterator >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last );while( __first != __last ){if( * __first < * __result_first )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ) );++ __first;}std :: sort_heap( __result_first, __result_real_last );return __result_real_last;}template < typename _InputIterator, typename _RandomAccessIterator, typename _Compare >_RandomAccessIteratorpartial_sort_copy( _InputIterator __first, _InputIterator __last,_RandomAccessIterator __result_first,_RandomAccessIterator __result_last,_Compare __comp ){typedef typename iterator_traits < _InputIterator > :: value_type_InputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: value_type_OutputValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;;if( __result_first == __result_last )return __result_last;_RandomAccessIterator __result_real_last = __result_first;while( __first != __last && __result_real_last != __result_last ){* __result_real_last = * __first;++ __result_real_last;++ __first;}std :: make_heap( __result_first, __result_real_last, __comp );while( __first != __last ){if( __comp( * __first, * __result_first ) )std :: __adjust_heap( __result_first, _DistanceType( 0 ),_DistanceType( __result_real_last- __result_first ),_InputValueType( * __first ),__comp );++ __first;}std :: sort_heap( __result_first, __result_real_last, __comp );return __result_real_last;}template < typename _RandomAccessIterator, typename _Size >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );std :: __introsort_loop( __cut, __last, __depth_limit );__last = __cut;}}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introsort_loop( _RandomAccessIterator __first,_RandomAccessIterator __last,_Size __depth_limit, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > int( _S_threshold ) ){if( __depth_limit == 0 ){std :: partial_sort( __first, __last, __last, __comp );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );std :: __introsort_loop( __cut, __last, __depth_limit, __comp );__last = __cut;}}template < typename _RandomAccessIterator >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2 );std :: __final_insertion_sort( __first, __last );}}template < typename _RandomAccessIterator, typename _Compare >inline voidsort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;if( __first != __last ){std :: __introsort_loop( __first, __last,std :: __lg( __last - __first ) * 2, __comp );std :: __final_insertion_sort( __first, __last, __comp );}}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorlower_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else__len = __half;}return __first;}template < typename _ForwardIterator, typename _Tp >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __val < * __middle )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _ForwardIterator, typename _Tp, typename _Compare >_ForwardIteratorupper_bound( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( __val, * __middle ) )__len = __half;else{__first = __middle;++ __first;__len = __len - __half - 1;}}return __first;}template < typename _BidirectionalIterator, typename _Distance >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2 ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( * __middle < * __first )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22 );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22 );}template < typename _BidirectionalIterator, typename _Distance,typename _Compare >void__merge_without_buffer( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Compare __comp ){if( __len1 == 0 || __len2 == 0 )return;if( __len1 + __len2 == 2 ){if( __comp( * __middle, * __first ) )std :: iter_swap( __first, __middle );return;}_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}std :: rotate( __first_cut, __middle, __second_cut );_BidirectionalIterator __new_middle = __first_cut;std :: advance( __new_middle, std :: distance( __middle, __second_cut ) );std :: __merge_without_buffer( __first, __first_cut, __new_middle,__len11, __len22, __comp );std :: __merge_without_buffer( __new_middle, __second_cut, __last,__len1 - __len11, __len2 - __len22, __comp );}template < typename _RandomAccessIterator >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle );std :: __inplace_stable_sort( __middle, __last );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle );}template < typename _RandomAccessIterator, typename _Compare >void__inplace_stable_sort( _RandomAccessIterator __first,_RandomAccessIterator __last, _Compare __comp ){if( __last - __first < 15 ){std :: __insertion_sort( __first, __last, __comp );return;}_RandomAccessIterator __middle = __first +( __last - __first ) / 2;std :: __inplace_stable_sort( __first, __middle, __comp );std :: __inplace_stable_sort( __middle, __last, __comp );std :: __merge_without_buffer( __first, __middle, __last,__middle - __first,__last - __middle,__comp );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratormerge( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result,_Distance __step_size ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size, __first + __step_size, __last,__result );}template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,typename _Distance, typename _Compare >void__merge_sort_loop( _RandomAccessIterator1 __first,_RandomAccessIterator1 __last,_RandomAccessIterator2 __result, _Distance __step_size,_Compare __comp ){const _Distance __two_step = 2 * __step_size;while( __last - __first >= __two_step ){__result = std :: merge( __first, __first + __step_size,__first + __step_size, __first + __two_step,__result,__comp );__first += __two_step;}__step_size = std :: min( _Distance( __last - __first ), __step_size );std :: merge( __first, __first + __step_size,__first + __step_size, __last,__result,__comp );}enum __unnamed_enum___F92_L3379_C3__S_chunk_size {_S_chunk_size=7};template < typename _RandomAccessIterator, typename _Distance >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size );__first += __chunk_size;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Distance, typename _Compare >void__chunk_insertion_sort( _RandomAccessIterator __first,_RandomAccessIterator __last,_Distance __chunk_size, _Compare __comp ){while( __last - __first >= __chunk_size ){std :: __insertion_sort( __first, __first + __chunk_size, __comp );__first += __chunk_size;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator, typename _Pointer >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer, __step_size );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first, __step_size );__step_size *= 2;}}template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >void__merge_sort_with_buffer( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_Distance;const _Distance __len = __last - __first;const _Pointer __buffer_last = __buffer + __len;_Distance __step_size = _S_chunk_size;std :: __chunk_insertion_sort( __first, __last, __step_size, __comp );while( __step_size < __len ){std :: __merge_sort_loop( __first, __last, __buffer,__step_size, __comp );__step_size *= 2;std :: __merge_sort_loop( __buffer, __buffer_last, __first,__step_size, __comp );__step_size *= 2;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3 >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( * __last2 < * __last1 ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BidirectionalIterator3, typename _Compare >_BidirectionalIterator3__merge_backward( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,_BidirectionalIterator3 __result,_Compare __comp ){if( __first1 == __last1 )return std :: copy_backward( __first2, __last2, __result );if( __first2 == __last2 )return std :: copy_backward( __first1, __last1, __result );-- __last1;-- __last2;while( true ){if( __comp( * __last2, * __last1 ) ){* -- __result = * __last1;if( __first1 == __last1 )return std :: copy_backward( __first2, ++ __last2, __result );-- __last1;}else{* -- __result = * __last2;if( __first2 == __last2 )return std :: copy_backward( __first1, ++ __last1, __result );-- __last2;}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _Distance >_BidirectionalIterator1__rotate_adaptive( _BidirectionalIterator1 __first,_BidirectionalIterator1 __middle,_BidirectionalIterator1 __last,_Distance __len1, _Distance __len2,_BidirectionalIterator2 __buffer,_Distance __buffer_size ){_BidirectionalIterator2 __buffer_end;if( __len1 > __len2 && __len2 <= __buffer_size ){__buffer_end = std :: copy( __middle, __last, __buffer );std :: copy_backward( __first, __middle, __last );return std :: copy( __buffer, __buffer_end, __first );}else if( __len1 <= __buffer_size ){__buffer_end = std :: copy( __first, __middle, __buffer );std :: copy( __middle, __last, __first );return std :: copy_backward( __buffer, __buffer_end, __last );}else{std :: rotate( __first, __middle, __last );std :: advance( __first, std :: distance( __middle, __last ) );return __first;}}template < typename _BidirectionalIterator, typename _Distance,typename _Pointer >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer,__buffer_end, __last );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last,* __first_cut );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle,* __second_cut );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer, __buffer_size );}}template < typename _BidirectionalIterator, typename _Distance, typename _Pointer,typename _Compare >void__merge_adaptive( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Distance __len1, _Distance __len2,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){if( __len1 <= __len2 && __len1 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __first, __middle, __buffer );std :: merge( __buffer, __buffer_end, __middle, __last, __first, __comp );}else if( __len2 <= __buffer_size ){_Pointer __buffer_end = std :: copy( __middle, __last, __buffer );std :: __merge_backward( __first, __middle, __buffer, __buffer_end,__last, __comp );}else{_BidirectionalIterator __first_cut = __first;_BidirectionalIterator __second_cut = __middle;_Distance __len11 = 0;_Distance __len22 = 0;if( __len1 > __len2 ){__len11 = __len1 / 2;std :: advance( __first_cut, __len11 );__second_cut = std :: lower_bound( __middle, __last, * __first_cut,__comp );__len22 = std :: distance( __middle, __second_cut );}else{__len22 = __len2 / 2;std :: advance( __second_cut, __len22 );__first_cut = std :: upper_bound( __first, __middle, * __second_cut,__comp );__len11 = std :: distance( __first, __first_cut );}_BidirectionalIterator __new_middle =std :: __rotate_adaptive( __first_cut, __middle, __second_cut,__len1 - __len11, __len22, __buffer,__buffer_size );std :: __merge_adaptive( __first, __first_cut, __new_middle, __len11,__len22, __buffer, __buffer_size, __comp );std :: __merge_adaptive( __new_middle, __second_cut, __last,__len1 - __len11,__len2 - __len22, __buffer,__buffer_size, __comp );}}template < typename _BidirectionalIterator >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;_DistanceType __len1 = std :: distance( __first, __middle );_DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1, __len2 );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ) );}template < typename _BidirectionalIterator, typename _Compare >voidinplace_merge( _BidirectionalIterator __first,_BidirectionalIterator __middle,_BidirectionalIterator __last,_Compare __comp ){typedef typename iterator_traits < _BidirectionalIterator > :: value_type_ValueType;typedef typename iterator_traits < _BidirectionalIterator > :: difference_type_DistanceType;;;if( __first == __middle || __middle == __last )return;const _DistanceType __len1 = std :: distance( __first, __middle );const _DistanceType __len2 = std :: distance( __middle, __last );_Temporary_buffer < _BidirectionalIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __merge_without_buffer( __first, __middle, __last, __len1,__len2, __comp );elsestd :: __merge_adaptive( __first, __middle, __last, __len1, __len2,__buf . begin( ), _DistanceType( __buf . size( ) ),__comp );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle,__buffer, __buffer_size );std :: __stable_sort_adaptive( __middle, __last,__buffer, __buffer_size );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer );std :: __merge_sort_with_buffer( __middle, __last, __buffer );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size );}template < typename _RandomAccessIterator, typename _Pointer,typename _Distance, typename _Compare >void__stable_sort_adaptive( _RandomAccessIterator __first,_RandomAccessIterator __last,_Pointer __buffer, _Distance __buffer_size,_Compare __comp ){const _Distance __len =( __last - __first + 1 ) / 2;const _RandomAccessIterator __middle = __first + __len;if( __len > __buffer_size ){std :: __stable_sort_adaptive( __first, __middle, __buffer,__buffer_size, __comp );std :: __stable_sort_adaptive( __middle, __last, __buffer,__buffer_size, __comp );}else{std :: __merge_sort_with_buffer( __first, __middle, __buffer, __comp );std :: __merge_sort_with_buffer( __middle, __last, __buffer, __comp );}std :: __merge_adaptive( __first, __middle, __last,_Distance( __middle - __first ),_Distance( __last - __middle ),__buffer, __buffer_size,__comp );}template < typename _RandomAccessIterator >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ) );}template < typename _RandomAccessIterator, typename _Compare >inline voidstable_sort( _RandomAccessIterator __first, _RandomAccessIterator __last,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;typedef typename iterator_traits < _RandomAccessIterator > :: difference_type_DistanceType;;_Temporary_buffer < _RandomAccessIterator, _ValueType > __buf( __first,__last );if( __buf . begin( ) == 0 )std :: __inplace_stable_sort( __first, __last, __comp );elsestd :: __stable_sort_adaptive( __first, __last, __buf . begin( ),_DistanceType( __buf . size( ) ), __comp );}template < typename _RandomAccessIterator, typename _Size >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last- 1 ) ) ) );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last );}template < typename _RandomAccessIterator, typename _Size, typename _Compare >void__introselect( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Size __depth_limit,_Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;while( __last - __first > 3 ){if( __depth_limit == 0 ){std :: __heap_select( __first, __nth + 1, __last, __comp );std :: iter_swap( __first, __nth );return;}-- __depth_limit;_RandomAccessIterator __cut =std :: __unguarded_partition( __first, __last,_ValueType( std :: __median( * __first,*( __first+( __last- __first )/ 2 ),*( __last - 1 ),__comp ) ),__comp );if( __cut <= __nth )__first = __cut;else__last = __cut;}std :: __insertion_sort( __first, __last, __comp );}template < typename _RandomAccessIterator >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2 );}template < typename _RandomAccessIterator, typename _Compare >inline voidnth_element( _RandomAccessIterator __first, _RandomAccessIterator __nth,_RandomAccessIterator __last, _Compare __comp ){typedef typename iterator_traits < _RandomAccessIterator > :: value_type_ValueType;;;if( __first == __last || __nth == __last )return;std :: __introselect( __first, __nth, __last,std :: __lg( __last - __first ) * 2, __comp );}template < typename _ForwardIterator, typename _Tp >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( * __middle < __val ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __val < * __middle )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp, typename _Compare >pair < _ForwardIterator, _ForwardIterator >equal_range( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val,_Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;typedef typename iterator_traits < _ForwardIterator > :: difference_type_DistanceType;;_DistanceType __len = std :: distance( __first, __last );_DistanceType __half;_ForwardIterator __middle, __left, __right;while( __len > 0 ){__half = __len >> 1;__middle = __first;std :: advance( __middle, __half );if( __comp( * __middle, __val ) ){__first = __middle;++ __first;__len = __len - __half - 1;}else if( __comp( __val, * __middle ) )__len = __half;else{__left = std :: lower_bound( __first, __middle, __val, __comp );std :: advance( __first, __len );__right = std :: upper_bound( ++ __middle, __first, __val, __comp );return pair < _ForwardIterator, _ForwardIterator >( __left, __right );}}return pair < _ForwardIterator, _ForwardIterator >( __first, __first );}template < typename _ForwardIterator, typename _Tp >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val );return __i != __last && !( __val < * __i );}template < typename _ForwardIterator, typename _Tp, typename _Compare >boolbinary_search( _ForwardIterator __first, _ForwardIterator __last,const _Tp & __val, _Compare __comp ){typedef typename iterator_traits < _ForwardIterator > :: value_type_ValueType;;_ForwardIterator __i = std :: lower_bound( __first, __last, __val, __comp );return __i != __last && ! __comp( __val, * __i );}template < typename _InputIterator1, typename _InputIterator2 >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2 ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first2 < * __first1 )return false;else if( * __first1 < * __first2 )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _Compare >boolincludes( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first2, * __first1 ) )return false;else if( __comp( * __first1, * __first2 ) )++ __first1;else++ __first1, ++ __first2;return __first2 == __last2;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_union( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 ){if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;}else{* __result = * __first1;++ __first1;++ __first2;}++ __result;}return std :: copy( __first2, __last2, std :: copy( __first1, __last1,__result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 )++ __first1;else if( * __first2 < * __first1 )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_intersection( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) )++ __first1;else if( __comp( * __first2, * __first1 ) )++ __first2;else{* __result = * __first1;++ __first1;++ __first2;++ __result;}return __result;}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result, _Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) )++ __first2;else{++ __first1;++ __first2;}return std :: copy( __first1, __last1, __result );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( * __first1 < * __first2 ){* __result = * __first1;++ __first1;++ __result;}else if( * __first2 < * __first1 ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _InputIterator1, typename _InputIterator2,typename _OutputIterator, typename _Compare >_OutputIteratorset_symmetric_difference( _InputIterator1 __first1, _InputIterator1 __last1,_InputIterator2 __first2, _InputIterator2 __last2,_OutputIterator __result,_Compare __comp ){typedef typename iterator_traits < _InputIterator1 > :: value_type_ValueType1;typedef typename iterator_traits < _InputIterator2 > :: value_type_ValueType2;;;while( __first1 != __last1 && __first2 != __last2 )if( __comp( * __first1, * __first2 ) ){* __result = * __first1;++ __first1;++ __result;}else if( __comp( * __first2, * __first1 ) ){* __result = * __first2;++ __first2;++ __result;}else{++ __first1;++ __first2;}return std :: copy( __first2, __last2, std :: copy( __first1,__last1, __result ) );}template < typename _ForwardIterator >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __result < * __first )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormax_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last ) return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __result, * __first ) ) __result = __first;return __result;}template < typename _ForwardIterator >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( * __first < * __result )__result = __first;return __result;}template < typename _ForwardIterator, typename _Compare >_ForwardIteratormin_element( _ForwardIterator __first, _ForwardIterator __last,_Compare __comp ){;if( __first == __last )return __first;_ForwardIterator __result = __first;while( ++ __first != __last )if( __comp( * __first, * __result ) )__result = __first;return __result;}template < typename _BidirectionalIterator >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __i < * __ii ){_BidirectionalIterator __j = __last;while( !( * __i < * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolnext_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __i, * __ii ) ){_BidirectionalIterator __j = __last;while( ! __comp( * __i, * -- __j ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( * __ii < * __i ){_BidirectionalIterator __j = __last;while( !( * -- __j < * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _BidirectionalIterator, typename _Compare >boolprev_permutation( _BidirectionalIterator __first,_BidirectionalIterator __last, _Compare __comp ){;if( __first == __last )return false;_BidirectionalIterator __i = __first;++ __i;if( __i == __last )return false;__i = __last;-- __i;for(;;){_BidirectionalIterator __ii = __i;-- __i;if( __comp( * __ii, * __i ) ){_BidirectionalIterator __j = __last;while( ! __comp( * -- __j, * __i ) ){}std :: iter_swap( __i, __j );std :: reverse( __ii, __last );return true;}if( __i == __first ){std :: reverse( __first, __last );return false;}}}template < typename _InputIterator, typename _ForwardIterator >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2 ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( * __first1 == * __iter )return __first1;return __last1;}template < typename _InputIterator, typename _ForwardIterator,typename _BinaryPredicate >_InputIteratorfind_first_of( _InputIterator __first1, _InputIterator __last1,_ForwardIterator __first2, _ForwardIterator __last2,_BinaryPredicate __comp ){;;for(;__first1 != __last1;++ __first1 )for( _ForwardIterator __iter = __first2;__iter != __last2;++ __iter )if( __comp( * __first1, * __iter ) )return __first1;return __last1;}template < typename _ForwardIterator1, typename _ForwardIterator2 >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2 );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >_ForwardIterator1__find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,forward_iterator_tag, forward_iterator_tag,_BinaryPredicate __comp ){if( __first2 == __last2 )return __last1;else{_ForwardIterator1 __result = __last1;while( 1 ){_ForwardIterator1 __new_result= std :: search( __first1, __last1, __first2, __last2, __comp );if( __new_result == __last1 )return __result;else{__result = __new_result;__first1 = __new_result;++ __first1;}}}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2 >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2 );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,typename _BinaryPredicate >_BidirectionalIterator1__find_end( _BidirectionalIterator1 __first1,_BidirectionalIterator1 __last1,_BidirectionalIterator2 __first2,_BidirectionalIterator2 __last2,bidirectional_iterator_tag, bidirectional_iterator_tag,_BinaryPredicate __comp ){typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;_RevIterator1 __rlast1( __first1 );_RevIterator2 __rlast2( __first2 );_RevIterator1 __rresult = std :: search( _RevIterator1( __last1 ), __rlast1,_RevIterator2( __last2 ), __rlast2,__comp );if( __rresult == __rlast1 )return __last1;else{_BidirectionalIterator1 __result = __rresult . base( );std :: advance( __result, - std :: distance( __first2, __last2 ) );return __result;}}template < typename _ForwardIterator1, typename _ForwardIterator2 >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2 ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ) );}template < typename _ForwardIterator1, typename _ForwardIterator2,typename _BinaryPredicate >inline _ForwardIterator1find_end( _ForwardIterator1 __first1, _ForwardIterator1 __last1,_ForwardIterator2 __first2, _ForwardIterator2 __last2,_BinaryPredicate __comp ){;;return std :: __find_end( __first1, __last1, __first2, __last2,std :: __iterator_category( __first1 ),std :: __iterator_category( __first2 ),__comp );}}#pragma GCC system_headernamespace std{template < typename _Type >inline bool__is_null_pointer( _Type * __ptr ){return __ptr == 0;}template < typename _Type >inline bool__is_null_pointer( _Type ){return false;}template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_max_size =((( npos - sizeof( _Rep_base ) ) / sizeof( _CharT ) ) - 1 ) / 4;template < typename _CharT, typename _Traits, typename _Alloc >const _CharTbasic_string < _CharT, _Traits, _Alloc > ::_Rep :: _S_terminal = _CharT( );template < typename _CharT, typename _Traits, typename _Alloc >const typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: npos;template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > :: _Rep :: _S_empty_rep_storage [( sizeof( _Rep_base ) + sizeof( _CharT ) + sizeof( size_type ) - 1 ) /sizeof( size_type ) ];template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_CharT __buf [ 128 ];size_type __len = 0;while( __beg != __end && __len < sizeof( __buf ) / sizeof( _CharT ) ){__buf [ __len ++ ] = * __beg;++ __beg;}_Rep * __r = _Rep :: _S_create( __len, size_type( 0 ), __a );_M_copy( __r -> _M_refdata( ), __buf, __len );try{while( __beg != __end ){if( __len == __r -> _M_capacity ){_Rep * __another = _Rep :: _S_create( __len + 1, __len, __a );_M_copy( __another -> _M_refdata( ), __r -> _M_refdata( ), __len );__r -> _M_destroy( __a );__r = __another;}__r -> _M_refdata( ) [ __len ++ ] = * __beg;++ __beg;}}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __len );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InIterator >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,forward_iterator_tag ){if( __beg == __end && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );if( __builtin_expect( __is_null_pointer( __beg ) && __beg != __end, 0 ) )__throw_logic_error(( "basic_string::_S_construct NULL not valid" ) );const size_type __dnew = static_cast < size_type >( std :: distance( __beg,__end ) );_Rep * __r = _Rep :: _S_create( __dnew, size_type( 0 ), __a );try{_S_copy_chars( __r -> _M_refdata( ), __beg, __end );}catch( ... ){__r -> _M_destroy( __a );throw;}__r -> _M_set_length_and_sharable( __dnew );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > ::_S_construct( size_type __n, _CharT __c, const _Alloc & __a ){if( __n == 0 && __a == _Alloc( ) )return _S_empty_rep( ) . _M_refdata( );_Rep * __r = _Rep :: _S_create( __n, size_type( 0 ), __a );if( __n )_M_assign( __r -> _M_refdata( ), __n, __c );__r -> _M_set_length_and_sharable( __n );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str ): _M_dataplus( __str . _M_rep( ) -> _M_grab( _Alloc( __str . get_allocator( ) ),__str . get_allocator( ) ),__str . get_allocator( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _Alloc & __a ): _M_dataplus( _S_construct( size_type( ), _CharT( ), __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos, size_type __n ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, _Alloc( ) ), _Alloc( ) ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const basic_string & __str, size_type __pos,size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __str . _M_data( )+ __str . _M_check( __pos,"basic_string::basic_string" ),__str . _M_data( ) + __str . _M_limit( __pos, __n )+ __pos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, size_type __n, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s + __n, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( const _CharT * __s, const _Alloc & __a ): _M_dataplus( _S_construct( __s, __s ? __s + traits_type :: length( __s ) :__s + npos, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > ::basic_string( size_type __n, _CharT __c, const _Alloc & __a ): _M_dataplus( _S_construct( __n, __c, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > ::basic_string( _InputIterator __beg, _InputIterator __end, const _Alloc & __a ): _M_dataplus( _S_construct( __beg, __end, __a ), __a ){}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const basic_string & __str ){if( _M_rep( ) != __str . _M_rep( ) ){const allocator_type __a = this -> get_allocator( );_CharT * __tmp = __str . _M_rep( ) -> _M_grab( __a, __str . get_allocator( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::assign( const _CharT * __s, size_type __n ){;_M_check_length( this -> size( ), __n, "basic_string::assign" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( size_type( 0 ), this -> size( ), __s, __n );else{const size_type __pos = __s - _M_data( );if( __pos >= __n )_M_copy( _M_data( ), __s, __n );else if( __pos )_M_move( _M_data( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __n );return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( size_type __n, _CharT __c ){if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_assign( _M_data( ) + this -> size( ), __n, __c );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const _CharT * __s, size_type __n ){;if( __n ){_M_check_length( size_type( 0 ), __n, "basic_string::append" );const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( _M_disjunct( __s ) )this -> reserve( __len );else{const size_type __off = __s - _M_data( );this -> reserve( __len );__s = _M_data( ) + __off;}}_M_copy( _M_data( ) + this -> size( ), __s, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str ){const size_type __size = __str . size( );if( __size ){const size_type __len = __size + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ), __size );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::append( const basic_string & __str, size_type __pos, size_type __n ){__str . _M_check( __pos, "basic_string::append" );__n = __str . _M_limit( __pos, __n );if( __n ){const size_type __len = __n + this -> size( );if( __len > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) )this -> reserve( __len );_M_copy( _M_data( ) + this -> size( ), __str . _M_data( ) + __pos, __n );_M_rep( ) -> _M_set_length_and_sharable( __len );}return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::insert( size_type __pos, const _CharT * __s, size_type __n ){;_M_check( __pos, "basic_string::insert" );_M_check_length( size_type( 0 ), __n, "basic_string::insert" );if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, size_type( 0 ), __s, __n );else{const size_type __off = __s - _M_data( );_M_mutate( __pos, 0, __n );__s = _M_data( ) + __off;_CharT * __p = _M_data( ) + __pos;if( __s + __n <= __p )_M_copy( __p, __s, __n );else if( __s >= __p )_M_copy( __p, __s + __n, __n );else{const size_type __nleft = __p - __s;_M_copy( __p, __s, __nleft );_M_copy( __p + __nleft, __p + __n, __n - __nleft );}return * this;}}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::replace( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ){;_M_check( __pos, "basic_string::replace" );__n1 = _M_limit( __pos, __n1 );_M_check_length( __n1, __n2, "basic_string::replace" );bool __left;if( _M_disjunct( __s ) || _M_rep( ) -> _M_is_shared( ) )return _M_replace_safe( __pos, __n1, __s, __n2 );else if(( __left = __s + __n2 <= _M_data( ) + __pos )|| _M_data( ) + __pos + __n1 <= __s ){size_type __off = __s - _M_data( );__left ? __off :( __off += __n2 - __n1 );_M_mutate( __pos, __n1, __n2 );_M_copy( _M_data( ) + __pos, _M_data( ) + __off, __n2 );return * this;}else{const basic_string __tmp( __s, __n2 );return _M_replace_safe( __pos, __n1, __tmp . _M_data( ), __n2 );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_destroy( const _Alloc & __a ) throw( ){const size_type __size = sizeof( _Rep_base ) +( this -> _M_capacity + 1 ) * sizeof( _CharT );_Raw_bytes_alloc( __a ) . deallocate( reinterpret_cast < char * >( this ), __size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_leak_hard( ){if( _M_rep( ) == & _S_empty_rep( ) )return;if( _M_rep( ) -> _M_is_shared( ) )_M_mutate( 0, 0, 0 );_M_rep( ) -> _M_set_leaked( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::_M_mutate( size_type __pos, size_type __len1, size_type __len2 ){const size_type __old_size = this -> size( );const size_type __new_size = __old_size + __len2 - __len1;const size_type __how_much = __old_size - __pos - __len1;if( __new_size > this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){const allocator_type __a = get_allocator( );_Rep * __r = _Rep :: _S_create( __new_size, this -> capacity( ), __a );if( __pos )_M_copy( __r -> _M_refdata( ), _M_data( ), __pos );if( __how_much )_M_copy( __r -> _M_refdata( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );_M_rep( ) -> _M_dispose( __a );_M_data( __r -> _M_refdata( ) );}else if( __how_much && __len1 != __len2 ){_M_move( _M_data( ) + __pos + __len2,_M_data( ) + __pos + __len1, __how_much );}_M_rep( ) -> _M_set_length_and_sharable( __new_size );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::reserve( size_type __res ){if( __res != this -> capacity( ) || _M_rep( ) -> _M_is_shared( ) ){if( __res < this -> size( ) )__res = this -> size( );const allocator_type __a = get_allocator( );_CharT * __tmp = _M_rep( ) -> _M_clone( __a, __res - this -> size( ) );_M_rep( ) -> _M_dispose( __a );_M_data( __tmp );}}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::swap( basic_string & __s ){if( _M_rep( ) -> _M_is_leaked( ) )_M_rep( ) -> _M_set_sharable( );if( __s . _M_rep( ) -> _M_is_leaked( ) )__s . _M_rep( ) -> _M_set_sharable( );if( this -> get_allocator( ) == __s . get_allocator( ) ){_CharT * __tmp = _M_data( );_M_data( __s . _M_data( ) );__s . _M_data( __tmp );}else{const basic_string __tmp1( _M_ibegin( ), _M_iend( ),__s . get_allocator( ) );const basic_string __tmp2( __s . _M_ibegin( ), __s . _M_iend( ),this -> get_allocator( ) );* this = __tmp2;__s = __tmp1;}}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: _Rep *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_S_create( size_type __capacity, size_type __old_capacity,const _Alloc & __alloc ){if( __capacity > _S_max_size )__throw_length_error(( "basic_string::_S_create" ) );const size_type __pagesize = 4096;const size_type __malloc_header_size = 4 * sizeof( void * );if( __capacity > __old_capacity && __capacity < 2 * __old_capacity )__capacity = 2 * __old_capacity;size_type __size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );const size_type __adj_size = __size + __malloc_header_size;if( __adj_size > __pagesize && __capacity > __old_capacity ){const size_type __extra = __pagesize - __adj_size % __pagesize;__capacity += __extra / sizeof( _CharT );if( __capacity > _S_max_size )__capacity = _S_max_size;__size =( __capacity + 1 ) * sizeof( _CharT ) + sizeof( _Rep );}void * __place = _Raw_bytes_alloc( __alloc ) . allocate( __size );_Rep * __p = new( __place ) _Rep;__p -> _M_capacity = __capacity;__p -> _M_set_sharable( );return __p;}template < typename _CharT, typename _Traits, typename _Alloc >_CharT *basic_string < _CharT, _Traits, _Alloc > :: _Rep ::_M_clone( const _Alloc & __alloc, size_type __res ){const size_type __requested_cap = this -> _M_length + __res;_Rep * __r = _Rep :: _S_create( __requested_cap, this -> _M_capacity,__alloc );if( this -> _M_length )_M_copy( __r -> _M_refdata( ), _M_refdata( ), this -> _M_length );__r -> _M_set_length_and_sharable( this -> _M_length );return __r -> _M_refdata( );}template < typename _CharT, typename _Traits, typename _Alloc >voidbasic_string < _CharT, _Traits, _Alloc > ::resize( size_type __n, _CharT __c ){const size_type __size = this -> size( );_M_check_length( __size, __n, "basic_string::resize" );if( __size < __n )this -> append( __n - __size, __c );else if( __n < __size )this -> erase( __n );}template < typename _CharT, typename _Traits, typename _Alloc >template < typename _InputIterator >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type ){const basic_string __s( __k1, __k2 );const size_type __n1 = __i2 - __i1;_M_check_length( __n1, __s . size( ), "basic_string::_M_replace_dispatch" );return _M_replace_safe( __i1 - _M_ibegin( ), __n1, __s . _M_data( ),__s . size( ) );}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_aux( size_type __pos1, size_type __n1, size_type __n2,_CharT __c ){_M_check_length( __n1, __n2, "basic_string::_M_replace_aux" );_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_assign( _M_data( ) + __pos1, __n2, __c );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc > &basic_string < _CharT, _Traits, _Alloc > ::_M_replace_safe( size_type __pos1, size_type __n1, const _CharT * __s,size_type __n2 ){_M_mutate( __pos1, __n1, __n2 );if( __n2 )_M_copy( _M_data( ) + __pos1, __s, __n2 );return * this;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( const _CharT * __lhs,const basic_string < _CharT, _Traits, _Alloc > & __rhs ){;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;const __size_type __len = _Traits :: length( __lhs );__string_type __str;__str . reserve( __len + __rhs . size( ) );__str . append( __lhs, __len );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >basic_string < _CharT, _Traits, _Alloc >operator +( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs ){typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__string_type __str;const __size_type __len = __rhs . size( );__str . reserve( __len + 1 );__str . append( __size_type( 1 ), __lhs );__str . append( __rhs );return __str;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::copy( _CharT * __s, size_type __n, size_type __pos ) const{_M_check( __pos, "basic_string::copy" );__n = _M_limit( __pos, __n );;if( __n )_M_copy( __s, _M_data( ) + __pos, __n );return __n;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );const _CharT * __data = _M_data( );if( __n == 0 )return __pos <= __size ? __pos : npos;if( __n <= __size ){for(;__pos <= __size - __n;++ __pos )if( traits_type :: eq( __data [ __pos ], __s [ 0 ] )&& traits_type :: compare( __data + __pos + 1,__s + 1, __n - 1 ) == 0 )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find( _CharT __c, size_type __pos ) const{size_type __ret = npos;const size_type __size = this -> size( );if( __pos < __size ){const _CharT * __data = _M_data( );const size_type __n = __size - __pos;const _CharT * __p = traits_type :: find( __data + __pos, __n, __c );if( __p )__ret = __p - __data;}return __ret;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( const _CharT * __s, size_type __pos, size_type __n ) const{;const size_type __size = this -> size( );if( __n <= __size ){__pos = std :: min( size_type( __size - __n ), __pos );const _CharT * __data = _M_data( );do{if( traits_type :: compare( __data + __pos, __s, __n ) == 0 )return __pos;}while( __pos -- > 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::rfind( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;for( ++ __size;__size -- > 0;)if( traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__n && __pos < this -> size( );++ __pos ){const _CharT * __p = traits_type :: find( __s, __n, _M_data( ) [ __pos ] );if( __p )return __pos;}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size && __n ){if( -- __size > __pos )__size = __pos;do{if( traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- != 0 );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;for(;__pos < this -> size( );++ __pos )if( ! traits_type :: find( __s, __n, _M_data( ) [ __pos ] ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_first_not_of( _CharT __c, size_type __pos ) const{for(;__pos < this -> size( );++ __pos )if( ! traits_type :: eq( _M_data( ) [ __pos ], __c ) )return __pos;return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( const _CharT * __s, size_type __pos, size_type __n ) const{;size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: find( __s, __n, _M_data( ) [ __size ] ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >typename basic_string < _CharT, _Traits, _Alloc > :: size_typebasic_string < _CharT, _Traits, _Alloc > ::find_last_not_of( _CharT __c, size_type __pos ) const{size_type __size = this -> size( );if( __size ){if( -- __size > __pos )__size = __pos;do{if( ! traits_type :: eq( _M_data( ) [ __size ], __c ) )return __size;}while( __size -- );}return npos;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n, const basic_string & __str ) const{_M_check( __pos, "basic_string::compare" );__n = _M_limit( __pos, __n );const size_type __osize = __str . size( );const size_type __len = std :: min( __n, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __str . data( ), __len );if( ! __r )__r = _S_compare( __n, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos1, size_type __n1, const basic_string & __str,size_type __pos2, size_type __n2 ) const{_M_check( __pos1, "basic_string::compare" );__str . _M_check( __pos2, "basic_string::compare" );__n1 = _M_limit( __pos1, __n1 );__n2 = __str . _M_limit( __pos2, __n2 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos1,__str . data( ) + __pos2, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( const _CharT * __s ) const{;const size_type __size = this -> size( );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __size, __osize );int __r = traits_type :: compare( _M_data( ), __s, __len );if( ! __r )__r = _S_compare( __size, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __osize = traits_type :: length( __s );const size_type __len = std :: min( __n1, __osize );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __osize );return __r;}template < typename _CharT, typename _Traits, typename _Alloc >intbasic_string < _CharT, _Traits, _Alloc > ::compare( size_type __pos, size_type __n1, const _CharT * __s,size_type __n2 ) const{;_M_check( __pos, "basic_string::compare" );__n1 = _M_limit( __pos, __n1 );const size_type __len = std :: min( __n1, __n2 );int __r = traits_type :: compare( _M_data( ) + __pos, __s, __len );if( ! __r )__r = _S_compare( __n1, __n2 );return __r;}}namespace std{class locale {public: typedef int category;class facet ;class id ;class _Impl ;friend class facet ;friend class _Impl ;template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;static const category none = 0;static const category ctype = 1;static const category numeric = 2;static const category collate = 4;static const category time = 8;static const category monetary = 16;static const category messages = 32;static const category all = 63;locale() throw();locale(const class locale &__other) throw();explicit locale(const char *__s);locale(const class locale &__base,const char *__s,category __cat);locale(const class locale &__base,const class locale &__add,category __cat);template < typename _Facet >locale( const locale & __other, _Facet * __f );~locale() throw();const locale &operator=(const class locale &__other) throw();template < typename _Facet >localecombine( const locale & __other ) const;string name() const;bool operator==(const class locale &__other) const throw();inline bool operator!=(const class locale &__other) const throw(){return !((*(this)) == __other);}template < typename _Char, typename _Traits, typename _Alloc >booloperator( )( const basic_string < _Char, _Traits, _Alloc > & __s1,const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;static locale global(const class locale &);static const locale &classic();private: class _Impl *_M_impl;static class _Impl *_S_classic;static class _Impl *_S_global;static const char *const *const _S_categories;enum __unnamed_enum___F76_L309_C5__S_categories_size {_S_categories_size=6};static __gthread_once_t _S_once;explicit locale(class _Impl *) throw();static void _S_initialize();static void _S_initialize_once();static category _S_normalize_category(category );void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);};class facet {private: friend class locale ;friend class _Impl ;mutable _Atomic_word _M_refcount;static __c_locale _S_c_locale;static const char _S_c_name[2UL];static __gthread_once_t _S_once;static void _S_initialize_once();protected: inline facet(size_t __refs = 0UL) throw() : _M_refcount(__refs?1 : 0){}virtual ~facet();static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);static __c_locale _S_clone_c_locale(__c_locale &__cloc);static void _S_destroy_c_locale(__c_locale &__cloc);static __c_locale _S_get_c_locale();static const char *_S_get_c_name();private: inline void _M_add_reference() const throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() const throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}facet(const class facet &);facet &operator=(const class facet &);};class id {private: friend class locale ;friend class _Impl ;public: template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Facet >friend boolhas_facet( const locale & ) throw( );private: mutable size_t _M_index;static _Atomic_word _S_refcount;void operator=(const class id &);id(const class id &);public: inline id(){}size_t _M_id() const;};class _Impl {private: friend class locale ;friend class facet ;public: template < typename _Facet >friend boolhas_facet( const locale & ) throw( );template < typename _Facet >friend const _Facet &use_facet( const locale & );template < typename _Cache >friend struct __use_cache;private: _Atomic_word _M_refcount;const class facet **_M_facets;size_t _M_facets_size;const class facet **_M_caches;char **_M_names;static const class id *const _S_id_ctype[];static const class id *const _S_id_numeric[];static const class id *const _S_id_collate[];static const class id *const _S_id_time[];static const class id *const _S_id_monetary[];static const class id *const _S_id_messages[];static const class id *const *const _S_facet_categories[];inline void _M_add_reference() throw(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline void _M_remove_reference() throw(){if(__exchange_and_add_dispatch(&(this) -> _M_refcount,-1) == 1) {try {delete(this);}catch(... ){}}}_Impl(const class _Impl &,size_t );_Impl(const char *,size_t );_Impl(size_t ) throw();~_Impl() throw();_Impl(const class _Impl &);void operator=(const class _Impl &);inline bool _M_check_same_name(){bool __ret = true;if(((this) -> _M_names)[1]) for(size_t __i = 0UL;__ret &&(__i < 5UL);++__i) __ret =(strcmp(((this) -> _M_names)[__i],((this) -> _M_names)[__i + 1UL]) == 0);return __ret;}void _M_replace_categories(const class _Impl *,category );void _M_replace_category(const class _Impl *,const class id *const *);void _M_replace_facet(const class _Impl *,const class id *);void _M_install_facet(const class id *,const class facet *);template < typename _Facet >inline void_M_init_facet( _Facet * __facet ){_M_install_facet( & _Facet :: id, __facet );}void _M_install_cache(const class facet *,size_t );};template < typename _Facet >locale :: locale( const locale & __other, _Facet * __f ){_M_impl = new _Impl( * __other . _M_impl, 1 );try{_M_impl -> _M_install_facet( & _Facet :: id, __f );}catch( ... ){_M_impl -> _M_remove_reference( );throw;}delete [ ] _M_impl -> _M_names [ 0 ];_M_impl -> _M_names [ 0 ] = 0;}}namespace std{enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536};inline enum _Ios_Fmtflags operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) &((int )__b));}inline enum _Ios_Fmtflags operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) |((int )__b));}inline enum _Ios_Fmtflags operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b){return(_Ios_Fmtflags )(((int )__a) ^((int )__b));}inline enum _Ios_Fmtflags &operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a|__b;}inline enum _Ios_Fmtflags &operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a&__b;}inline enum _Ios_Fmtflags &operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b){return __a = __a^__b;}inline enum _Ios_Fmtflags operator~(enum _Ios_Fmtflags __a){return(_Ios_Fmtflags )(~((int )__a));}enum _Ios_Openmode {_S_app=1,_S_ate,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536};inline enum _Ios_Openmode operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) &((int )__b));}inline enum _Ios_Openmode operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) |((int )__b));}inline enum _Ios_Openmode operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b){return(_Ios_Openmode )(((int )__a) ^((int )__b));}inline enum _Ios_Openmode &operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a|__b;}inline enum _Ios_Openmode &operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a&__b;}inline enum _Ios_Openmode &operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b){return __a = __a^__b;}inline enum _Ios_Openmode operator~(enum _Ios_Openmode __a){return(_Ios_Openmode )(~((int )__a));}enum _Ios_Iostate {_S_goodbit,_S_badbit,_S_eofbit,_S_failbit=4,_S_ios_iostate_end=65536};inline enum _Ios_Iostate operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) &((int )__b));}inline enum _Ios_Iostate operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) |((int )__b));}inline enum _Ios_Iostate operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b){return(_Ios_Iostate )(((int )__a) ^((int )__b));}inline enum _Ios_Iostate &operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a|__b;}inline enum _Ios_Iostate &operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a&__b;}inline enum _Ios_Iostate &operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b){return __a = __a^__b;}inline enum _Ios_Iostate operator~(enum _Ios_Iostate __a){return(_Ios_Iostate )(~((int )__a));}enum _Ios_Seekdir {_S_beg,_S_cur,_S_end,_S_ios_seekdir_end=65536};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >new_allocator( const new_allocator < _Tp1 > & ) throw( );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class allocator < char > : public new_allocator < char > {public: typedef size_t size_type;typedef ptrdiff_t difference_type;typedef char *pointer;typedef const char *const_pointer;typedef char &reference;typedef const char &const_reference;typedef char value_type;template < typename _Tp1 >struct rebind;template < typename _Tp1 >allocator( const allocator < _Tp1 > & ) throw( );};}template<> struct rebind < char > {typedef class allocator< char > other;};namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace __gnu_cxx /* temporary fix for g++ bug in namespace name qualification */ {template<> class __normal_iterator < const_pointer , basic_string< char , char_traits< char > , allocator< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < const_iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class reverse_iterator < iterator > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_string < char , char_traits< char > , allocator< char > > {private: typedef other _CharT_alloc_type;public: typedef struct char_traits< char > traits_type;typedef char_type value_type;typedef class allocator< char > allocator_type;typedef size_type size_type;typedef difference_type difference_type;typedef reference reference;typedef const_reference const_reference;typedef pointer pointer;typedef const_pointer const_pointer;typedef class __normal_iterator< pointer , basic_string< char , char_traits< char > , allocator< char > > > iterator;typedef class __normal_iterator< const_pointer , basic_string< char , char_traits< char > , allocator< char > > > const_iterator;typedef class reverse_iterator< const_iterator > const_reverse_iterator;typedef class reverse_iterator< iterator > reverse_iterator;private: struct _Rep_base ;struct _Rep ;struct _Alloc_hider ;public: static const size_type npos = 18446744073709551615UL;private: struct _Alloc_hider : public allocator < char > {char *_M_p;};private: mutable struct _Alloc_hider _M_dataplus;template < class _Iterator >static void_S_copy_chars( _CharT * __p, _Iterator __k1, _Iterator __k2 );public: template < class _InputIterator >basic_string( _InputIterator __beg, _InputIterator __end,const _Alloc & __a = _Alloc( ) );template < class _InputIterator >basic_string &append( _InputIterator __first, _InputIterator __last );template < class _InputIterator >basic_string &assign( _InputIterator __first, _InputIterator __last );template < class _InputIterator >voidinsert( iterator __p, _InputIterator __beg, _InputIterator __end );template < class _InputIterator >basic_string &replace( iterator __i1, iterator __i2,_InputIterator __k1, _InputIterator __k2 );private: template < class _Integer >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _Integer __n,_Integer __val, __true_type );template < class _InputIterator >basic_string &_M_replace_dispatch( iterator __i1, iterator __i2, _InputIterator __k1,_InputIterator __k2, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __false_type );template < class _InIterator >static _CharT *_S_construct_aux( _InIterator __beg, _InIterator __end,const _Alloc & __a, __true_type );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a );template < class _InIterator >static _CharT *_S_construct( _InIterator __beg, _InIterator __end, const _Alloc & __a,input_iterator_tag );template < class _FwdIterator >static _CharT *_S_construct( _FwdIterator __beg, _FwdIterator __end, const _Alloc & __a,forward_iterator_tag );};}class ios_base {public: class failure : public exception{public: explicit failure(const string &__str) throw();virtual ~failure() throw();virtual const char *what() const throw();private: string _M_msg;};public: typedef enum _Ios_Fmtflags fmtflags;static const fmtflags boolalpha =(fmtflags )1;static const fmtflags dec =(fmtflags )2;static const fmtflags fixed =(fmtflags )4;static const fmtflags hex =(fmtflags )8;static const fmtflags internal =(fmtflags )16;static const fmtflags left =(fmtflags )32;static const fmtflags oct =(fmtflags )64;static const fmtflags right =(fmtflags )128;static const fmtflags scientific =(fmtflags )256;static const fmtflags showbase =(fmtflags )512;static const fmtflags showpoint =(fmtflags )1024;static const fmtflags showpos =(fmtflags )2048;static const fmtflags skipws =(fmtflags )4096;static const fmtflags unitbuf =(fmtflags )8192;static const fmtflags uppercase =(fmtflags )16384;static const fmtflags adjustfield =(fmtflags )176;static const fmtflags basefield =(fmtflags )74;static const fmtflags floatfield =(fmtflags )260;typedef enum _Ios_Iostate iostate;static const iostate badbit =(iostate )1;static const iostate eofbit =(iostate )2;static const iostate failbit =(iostate )4;static const iostate goodbit =(iostate )0;typedef enum _Ios_Openmode openmode;static const openmode app =(openmode )1;static const openmode ate =(openmode )2;static const openmode binary =(openmode )4;static const openmode in =(openmode )8;static const openmode out =(openmode )16;static const openmode trunc =(openmode )32;typedef enum _Ios_Seekdir seekdir;static const seekdir beg =(seekdir )0;static const seekdir cur =(seekdir )1;static const seekdir end =(seekdir )2;typedef int io_state;typedef int open_mode;typedef int seek_dir;typedef streampos streampos;typedef streamoff streamoff;enum event {erase_event,imbue_event,copyfmt_event};typedef void(*event_callback)(event , class ios_base &, int );void register_callback(event_callback __fn,int __index);protected: streamsize _M_precision;streamsize _M_width;fmtflags _M_flags;iostate _M_exception;iostate _M_streambuf_state;struct _Callback_list {struct _Callback_list *_M_next;event_callback _M_fn;int _M_index;_Atomic_word _M_refcount;inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0){}inline void _M_add_reference(){__atomic_add_dispatch(&(this) -> _M_refcount,1);}inline int _M_remove_reference(){return __exchange_and_add_dispatch(&(this) -> _M_refcount,-1);}};struct _Callback_list *_M_callbacks;void _M_call_callbacks(enum event __ev) throw();void _M_dispose_callbacks();struct _Words {void *_M_pword;long _M_iword;inline _Words() : _M_pword(0), _M_iword(0L){}};struct _Words _M_word_zero;enum __unnamed_enum___F73_L508_C5__S_local_word_size {_S_local_word_size=8};struct _Words _M_local_word[8UL];int _M_word_size;struct _Words *_M_word;_Words &_M_grow_words(int __index,bool __iword);class locale _M_ios_locale;void _M_init();public: class Init {private: friend class ios_base ;public: Init();~Init();private: static _Atomic_word _S_refcount;static bool _S_synced_with_stdio;};public: inline fmtflags flags() const{return(this) -> _M_flags;}inline fmtflags flags(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags = __fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags|=__fmtfl;return __old;}inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask){fmtflags __old =((this) -> _M_flags);(this) -> _M_flags&=~(__mask);(this) -> _M_flags|=__fmtfl&__mask;return __old;}inline void unsetf(fmtflags __mask){(this) -> _M_flags&=~(__mask);}inline streamsize precision() const{return(this) -> _M_precision;}inline streamsize precision(streamsize __prec){streamsize __old =((this) -> _M_precision);(this) -> _M_precision = __prec;return __old;}inline streamsize width() const{return(this) -> _M_width;}inline streamsize width(streamsize __wide){streamsize __old =((this) -> _M_width);(this) -> _M_width = __wide;return __old;}static bool sync_with_stdio(bool __sync = true);locale imbue(const class locale &__loc);inline locale getloc() const{return((this) -> _M_ios_locale);}inline const locale &_M_getloc() const{return(this) -> _M_ios_locale;}static int xalloc() throw();inline long &iword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,true));return __word._M_iword;}inline void *&pword(int __ix){struct _Words &__word =((__ix <((this) -> _M_word_size))?((this) -> _M_word)[__ix] :(this) -> _M_grow_words(__ix,false));return __word._M_pword;}virtual ~ios_base();protected: ios_base();private: ios_base(const class ios_base &);ios_base &operator=(const class ios_base &);};inline class ios_base &boolalpha(class ios_base &__base){__base. setf(((fmtflags )1));return __base;}inline class ios_base &noboolalpha(class ios_base &__base){__base. unsetf(((fmtflags )1));return __base;}inline class ios_base &showbase(class ios_base &__base){__base. setf(((fmtflags )512));return __base;}inline class ios_base &noshowbase(class ios_base &__base){__base. unsetf(((fmtflags )512));return __base;}inline class ios_base &showpoint(class ios_base &__base){__base. setf(((fmtflags )1024));return __base;}inline class ios_base &noshowpoint(class ios_base &__base){__base. unsetf(((fmtflags )1024));return __base;}inline class ios_base &showpos(class ios_base &__base){__base. setf(((fmtflags )2048));return __base;}inline class ios_base &noshowpos(class ios_base &__base){__base. unsetf(((fmtflags )2048));return __base;}inline class ios_base &skipws(class ios_base &__base){__base. setf(((fmtflags )4096));return __base;}inline class ios_base &noskipws(class ios_base &__base){__base. unsetf(((fmtflags )4096));return __base;}inline class ios_base &uppercase(class ios_base &__base){__base. setf(((fmtflags )16384));return __base;}inline class ios_base &nouppercase(class ios_base &__base){__base. unsetf(((fmtflags )16384));return __base;}inline class ios_base &unitbuf(class ios_base &__base){__base. setf(((fmtflags )8192));return __base;}inline class ios_base &nounitbuf(class ios_base &__base){__base. unsetf(((fmtflags )8192));return __base;}inline class ios_base &internal(class ios_base &__base){__base. setf(((fmtflags )16),((fmtflags )176));return __base;}inline class ios_base &left(class ios_base &__base){__base. setf(((fmtflags )32),((fmtflags )176));return __base;}inline class ios_base &right(class ios_base &__base){__base. setf(((fmtflags )128),((fmtflags )176));return __base;}inline class ios_base &dec(class ios_base &__base){__base. setf(((fmtflags )2),((fmtflags )74));return __base;}inline class ios_base &hex(class ios_base &__base){__base. setf(((fmtflags )8),((fmtflags )74));return __base;}inline class ios_base &oct(class ios_base &__base){__base. setf(((fmtflags )64),((fmtflags )74));return __base;}inline class ios_base &fixed(class ios_base &__base){__base. setf(((fmtflags )4),((fmtflags )260));return __base;}inline class ios_base &scientific(class ios_base &__base){__base. setf(((fmtflags )256),((fmtflags )260));return __base;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > *,basic_streambuf < _CharT, _Traits > *, bool & );template < typename _CharT, typename _Traits >class basic_streambuf{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename traits_type :: int_type int_type;typedef typename traits_type :: pos_type pos_type;typedef typename traits_type :: off_type off_type;typedef basic_streambuf < char_type, traits_type > __streambuf_type;friend class basic_ios < char_type, traits_type >;friend class basic_istream < char_type, traits_type >;friend class basic_ostream < char_type, traits_type >;friend class istreambuf_iterator < char_type, traits_type >;friend class ostreambuf_iterator < char_type, traits_type >;friend streamsize__copy_streambufs_eof < >( __streambuf_type *, __streambuf_type *, bool & );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected :char_type * _M_in_beg;char_type * _M_in_cur;char_type * _M_in_end;char_type * _M_out_beg;char_type * _M_out_cur;char_type * _M_out_end;locale _M_buf_locale;public :virtual~ basic_streambuf( );localepubimbue( const locale & __loc );localegetloc( ) const;__streambuf_type *pubsetbuf( char_type * __s, streamsize __n );pos_typepubseekoff( off_type __off, ios_base :: seekdir __way,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );pos_typepubseekpos( pos_type __sp,ios_base :: openmode __mode = ios_base :: in | ios_base :: out );intpubsync( );streamsizein_avail( );int_typesnextc( );int_typesbumpc( );int_typesgetc( );streamsizesgetn( char_type * __s, streamsize __n );int_typesputbackc( char_type __c );int_typesungetc( );int_typesputc( char_type __c );streamsizesputn( const char_type * __s, streamsize __n );protected :basic_streambuf( );char_type *eback( ) const;char_type *gptr( ) const;char_type *egptr( ) const;voidgbump( int __n );voidsetg( char_type * __gbeg, char_type * __gnext, char_type * __gend );char_type *pbase( ) const;char_type *pptr( ) const;char_type *epptr( ) const;voidpbump( int __n );voidsetp( char_type * __pbeg, char_type * __pend );virtual voidimbue( const locale & );virtual basic_streambuf < char_type, _Traits > *setbuf( char_type *, streamsize );virtual pos_typeseekoff( off_type, ios_base :: seekdir,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual pos_typeseekpos( pos_type,ios_base :: openmode = ios_base :: in | ios_base :: out );virtual intsync( );virtual streamsizeshowmanyc( );virtual streamsizexsgetn( char_type * __s, streamsize __n );virtual int_typeunderflow( );virtual int_typeuflow( );virtual int_typepbackfail( int_type = traits_type :: eof( ) );virtual streamsizexsputn( const char_type * __s, streamsize __n );virtual int_typeoverflow( int_type = traits_type :: eof( ) );private :basic_streambuf( const __streambuf_type & __sb );__streambuf_type &operator =( const __streambuf_type & );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsgetn( char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> egptr( ) - this -> gptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( __s, this -> gptr( ), __len );__ret += __len;__s += __len;this -> gbump( __len );}if( __ret < __n ){const int_type __c = this -> uflow( );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){traits_type :: assign( * __s ++, traits_type :: to_char_type( __c ) );++ __ret;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsizebasic_streambuf < _CharT, _Traits > ::xsputn( const char_type * __s, streamsize __n ){streamsize __ret = 0;while( __ret < __n ){const streamsize __buf_len = this -> epptr( ) - this -> pptr( );if( __buf_len ){const streamsize __remaining = __n - __ret;const streamsize __len = std :: min( __buf_len, __remaining );traits_type :: copy( this -> pptr( ), __s, __len );__ret += __len;__s += __len;this -> pbump( __len );}if( __ret < __n ){int_type __c = this -> overflow( traits_type :: to_int_type( * __s ) );if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){++ __ret;++ __s;}elsebreak;}}return __ret;}template < typename _CharT, typename _Traits >streamsize__copy_streambufs_eof( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout,bool & __ineof ){streamsize __ret = 0;__ineof = true;typename _Traits :: int_type __c = __sbin -> sgetc( );while( ! _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__c = __sbout -> sputc( _Traits :: to_char_type( __c ) );if( _Traits :: eq_int_type( __c, _Traits :: eof( ) ) ){__ineof = false;break;}++ __ret;__c = __sbin -> snextc( );}return __ret;}template < typename _CharT, typename _Traits >inline streamsize__copy_streambufs( basic_streambuf < _CharT, _Traits > * __sbin,basic_streambuf < _CharT, _Traits > * __sbout ){bool __ineof;return __copy_streambufs_eof( __sbin, __sbout, __ineof );}}#pragma GCC system_header#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class istreambuf_iterator: public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,_CharT *, _CharT & >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef typename _Traits :: int_type int_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_istream < _CharT, _Traits > istream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,_CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );private :mutable streambuf_type * _M_sbuf;mutable int_type _M_c;public :istreambuf_iterator( ) throw( );istreambuf_iterator( istream_type & __s ) throw( );istreambuf_iterator( streambuf_type * __s ) throw( );char_typeoperator *( ) const;istreambuf_iterator &operator ++( );istreambuf_iteratoroperator ++( int );boolequal( const istreambuf_iterator & __b ) const;private :int_type_M_get( ) const;bool_M_at_eof( ) const;};template < typename _CharT, typename _Traits >inline booloperator ==( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return __a . equal( __b );}template < typename _CharT, typename _Traits >inline booloperator !=( const istreambuf_iterator < _CharT, _Traits > & __a,const istreambuf_iterator < _CharT, _Traits > & __b ){return ! __a . equal( __b );}template < typename _CharT, typename _Traits >class ostreambuf_iterator: public iterator < output_iterator_tag, void, void, void, void >{public :typedef _CharT char_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > streambuf_type;typedef basic_ostream < _CharT, _Traits > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private :streambuf_type * _M_sbuf;bool _M_failed;public :ostreambuf_iterator( ostream_type & __s ) throw( );ostreambuf_iterator( streambuf_type * __s ) throw( );ostreambuf_iterator &operator =( _CharT __c );ostreambuf_iterator &operator *( );ostreambuf_iterator &operator ++( int );ostreambuf_iterator &operator ++( );boolfailed( ) const throw( );ostreambuf_iterator &_M_put( const _CharT * __ws, streamsize __len );};template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __typecopy( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last,ostreambuf_iterator < _CharT > __result ){if( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed ){bool __ineof;__copy_streambufs_eof( __first . _M_sbuf, __result . _M_sbuf, __ineof );if( ! __ineof )__result . _M_failed = true;}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( _CharT * __first, _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,ostreambuf_iterator < _CharT > > :: __type__copy_aux( const _CharT * __first, const _CharT * __last,ostreambuf_iterator < _CharT > __result ){const streamsize __num = __last - __first;if( __num > 0 )__result . _M_put( __first, __num );return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,_CharT * > :: __type__copy_aux( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, _CharT * __result ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) ){const streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){traits_type :: copy( __result, __sb -> gptr( ), __n );__sb -> gbump( __n );__result += __n;__c = __sb -> underflow( );}else{* __result ++ = traits_type :: to_char_type( __c );__c = __sb -> snextc( );}}}return __result;}template < typename _CharT >typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,istreambuf_iterator < _CharT > > :: __typefind( istreambuf_iterator < _CharT > __first,istreambuf_iterator < _CharT > __last, const _CharT & __val ){typedef istreambuf_iterator < _CharT > __is_iterator_type;typedef typename __is_iterator_type :: traits_type traits_type;typedef typename __is_iterator_type :: streambuf_type streambuf_type;typedef typename traits_type :: int_type int_type;if( __first . _M_sbuf && ! __last . _M_sbuf ){const int_type __ival = traits_type :: to_int_type( __val );streambuf_type * __sb = __first . _M_sbuf;int_type __c = __sb -> sgetc( );while( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) )&& ! traits_type :: eq_int_type( __c, __ival ) ){streamsize __n = __sb -> egptr( ) - __sb -> gptr( );if( __n > 1 ){const _CharT * __p = traits_type :: find( __sb -> gptr( ),__n, __val );if( __p )__n = __p - __sb -> gptr( );__sb -> gbump( __n );__c = __sb -> sgetc( );}else__c = __sb -> snextc( );}if( ! traits_type :: eq_int_type( __c, traits_type :: eof( ) ) )__first . _M_c = __c;else__first . _M_sbuf = 0;}return __first;}}#pragma GCC system_header#pragma GCC system_headertypedef __darwin_wctrans_t wctrans_t;inline static int iswblank(wint_t _wc){return __istype(_wc,131072UL);}inline static int iswascii(wint_t _wc){return((_wc & -128) == 0);}inline static int iswhexnumber(wint_t _wc){return __istype(_wc,65536UL);}inline static int iswideogram(wint_t _wc){return __istype(_wc,524288UL);}inline static int iswnumber(wint_t _wc){return __istype(_wc,1024UL);}inline static int iswphonogram(wint_t _wc){return __istype(_wc,2097152UL);}inline static int iswrune(wint_t _wc){return __istype(_wc,4294967280UL);}inline static int iswspecial(wint_t _wc){return __istype(_wc,1048576UL);}extern "C" {wint_t nextwctype(wint_t ,wctype_t );}extern "C" {wint_t towctrans(wint_t ,wctrans_t );}extern "C" {wctrans_t wctrans(const char *);}namespace std{using wctype_t;using wctrans_t;using iswalnum;using iswalpha;using iswblank;using iswcntrl;using iswctype;using iswdigit;using iswgraph;using iswlower;using iswprint;using iswpunct;using iswspace;using iswupper;using iswxdigit;using towctrans;using towlower;using towupper;using wctrans;using wctype;}namespace std{struct ctype_base {typedef const int *__to_type;typedef unsigned long mask;static const mask upper = 32768UL;static const mask lower = 4096UL;static const mask alpha = 256UL;static const mask digit = 1024UL;static const mask xdigit = 65536UL;static const mask space = 16384UL;static const mask print = 262144UL;static const mask graph = 9472UL;static const mask cntrl = 512UL;static const mask punct = 8192UL;static const mask alnum = 1280UL;};}namespace std{template < typename _Tv >void__convert_to_v( const char * __in, _Tv & __out, ios_base :: iostate & __err,const __c_locale & __cloc );template < typename _CharT, typename _Traits >struct __pad{static void_S_pad( ios_base & __io, _CharT __fill, _CharT * __news,const _CharT * __olds, const streamsize __newlen,const streamsize __oldlen, const bool __num );};template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last );template < typename _CharT >inlineostreambuf_iterator < _CharT >__write( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len ){__s . _M_put( __ws, __len );return __s;}template < typename _CharT, typename _OutIter >inline_OutIter__write( _OutIter __s, const _CharT * __ws, int __len ){for( int __j = 0;__j < __len;__j ++, ++ __s )* __s = __ws [ __j ];return __s;}template < typename _CharT >class __ctype_abstract_base : public locale :: facet, public ctype_base{public :typedef _CharT char_type;boolis( mask __m, char_type __c ) const;const char_type *is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;const char_type *scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;const char_type *scan_not( mask __m, const char_type * __lo, const char_type * __hi ) const;char_typetoupper( char_type __c ) const;const char_type *toupper( char_type * __lo, const char_type * __hi ) const;char_typetolower( char_type __c ) const;const char_type *tolower( char_type * __lo, const char_type * __hi ) const;char_typewiden( char __c ) const;const char *widen( const char * __lo, const char * __hi, char_type * __to ) const;charnarrow( char_type __c, char __dfault ) const;const char_type *narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __to ) const;protected :explicit__ctype_abstract_base( size_t __refs = 0 );virtual~ __ctype_abstract_base( );virtual booldo_is( mask __m, char_type __c ) const = 0;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi,mask * __vec ) const = 0;virtual const char_type *do_scan_is( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const = 0;virtual char_typedo_toupper( char_type ) const = 0;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_tolower( char_type ) const = 0;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const = 0;virtual char_typedo_widen( char ) const = 0;virtual const char *do_widen( const char * __lo, const char * __hi,char_type * __dest ) const = 0;virtual chardo_narrow( char_type, char __dfault ) const = 0;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const = 0;};template < typename _CharT >class ctype : public __ctype_abstract_base < _CharT >{public :typedef _CharT char_type;typedef typename __ctype_abstract_base < _CharT > :: mask mask;static locale :: id id;explicitctype( size_t __refs = 0 );protected :virtual~ ctype( );virtual booldo_is( mask __m, char_type __c ) const;virtual const char_type *do_is( const char_type * __lo, const char_type * __hi, mask * __vec ) const;virtual const char_type *do_scan_is( mask __m, const char_type * __lo, const char_type * __hi ) const;virtual const char_type *do_scan_not( mask __m, const char_type * __lo,const char_type * __hi ) const;virtual char_typedo_toupper( char_type __c ) const;virtual const char_type *do_toupper( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_tolower( char_type __c ) const;virtual const char_type *do_tolower( char_type * __lo, const char_type * __hi ) const;virtual char_typedo_widen( char __c ) const;virtual const char *do_widen( const char * __lo, const char * __hi, char_type * __dest ) const;virtual chardo_narrow( char_type, char __dfault ) const;virtual const char_type *do_narrow( const char_type * __lo, const char_type * __hi,char __dfault, char * __dest ) const;};template < typename _CharT >locale :: id ctype < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < char > : public facet,public ctype_base{public: typedef char char_type;protected: __c_locale _M_c_locale_ctype;bool _M_del;__to_type _M_toupper;__to_type _M_tolower;const mask *_M_table;mutable char _M_widen_ok;mutable char _M_widen[(1 +((unsigned char )(-1)))];mutable char _M_narrow[(1 +((unsigned char )(-1)))];mutable char _M_narrow_ok;public: static class id id;static const size_t table_size = 256UL;explicit ctype(const mask *__table = 0,bool __del = false,size_t __refs = 0UL);explicit ctype(__c_locale __cloc,const mask *__table = 0,bool __del = false,size_t __refs = 0UL);inline bool is(mask __m,char __c) const;inline const char *is(const char *__lo,const char *__hi,mask *__vec) const;inline const char *scan_is(mask __m,const char *__lo,const char *__hi) const;inline const char *scan_not(mask __m,const char *__lo,const char *__hi) const;inline char_type toupper(char_type __c) const{return(this) -> do_toupper(__c);}inline const char_type *toupper(char_type *__lo,const char_type *__hi) const{return(this) -> do_toupper(__lo,__hi);}inline char_type tolower(char_type __c) const{return(this) -> do_tolower(__c);}inline const char_type *tolower(char_type *__lo,const char_type *__hi) const{return(this) -> do_tolower(__lo,__hi);}inline char_type widen(char __c) const{if(((this) -> _M_widen_ok)) return((this) -> _M_widen)[(unsigned char )__c];(this) -> _M_widen_init();return(this) -> do_widen(__c);}inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const{if(((this) -> _M_widen_ok) == 1) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_widen_ok)) (this) -> _M_widen_init();return(this) -> do_widen(__lo,__hi,__to);}inline char narrow(char_type __c,char __dfault) const{if(((this) -> _M_narrow)[(unsigned char )__c]) return((this) -> _M_narrow)[(unsigned char )__c];const char __t =(this) -> do_narrow(__c,__dfault);if(__t != __dfault) ((this) -> _M_narrow)[(unsigned char )__c] = __t;return __t;}inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const{if((__builtin_expect((((this) -> _M_narrow_ok) == 1),1L))) {memcpy(__to,__lo,(__hi - __lo));return __hi;}if(!((this) -> _M_narrow_ok)) (this) -> _M_narrow_init();return(this) -> do_narrow(__lo,__hi,__dfault,__to);}protected: inline const mask *table() const throw(){return(this) -> _M_table;}static const mask *classic_table() throw();virtual ~ctype();virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual inline char_type do_widen(char __c) const{return __c;}virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}virtual inline char do_narrow(char_type __c,char ) const{return __c;}virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char ,char *__dest) const{memcpy(__dest,__lo,(__hi - __lo));return __hi;}private: inline void _M_widen_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_widen(__tmp,(__tmp + 256ULL),((this) -> _M_widen));(this) -> _M_widen_ok = '\1';if((memcmp(__tmp,((this) -> _M_widen),256UL))) (this) -> _M_widen_ok = '\2';}inline void _M_narrow_init() const{char __tmp[(1 +((unsigned char )(-1)))];for(size_t __i = 0UL;__i < 256ULL;++__i) __tmp[__i] = __i;(this) -> do_narrow(__tmp,(__tmp + 256ULL),'\0',((this) -> _M_narrow));(this) -> _M_narrow_ok = '\1';if((memcmp(__tmp,((this) -> _M_narrow),256UL))) (this) -> _M_narrow_ok = '\2';else {char __c;(this) -> do_narrow(__tmp,(__tmp + 1),'\1',&__c);if(__c == 1) (this) -> _M_narrow_ok = '\2';}}};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __ctype_abstract_base < wchar_t > : public facet,public ctype_base{public: typedef wchar_t char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype < wchar_t > : public __ctype_abstract_base < wchar_t > {public: typedef wchar_t char_type;typedef wctype_t __wmask_type;protected: __c_locale _M_c_locale_ctype;bool _M_narrow_ok;char _M_narrow[128UL];wint_t _M_widen[(1 +((unsigned char )(-1)))];mask _M_bit[16UL];__wmask_type _M_wmask[16UL];public: static class id id;explicit ctype(size_t __refs = 0UL);explicit ctype(__c_locale __cloc,size_t __refs = 0UL);protected: __wmask_type _M_convert_to_wmask(const mask __m) const;virtual ~ctype();virtual inline bool do_is(mask __m,char_type __c) const;virtual inline const char_type *do_is(const char_type *__lo,const char_type *__hi,mask *__vec) const;virtual inline const char_type *do_scan_is(mask __m,const char_type *__lo,const char_type *__hi) const;virtual inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const;virtual char_type do_toupper(char_type ) const;virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;virtual char_type do_tolower(char_type ) const;virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;virtual char_type do_widen(char ) const;virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__dest) const;virtual char do_narrow(char_type ,char __dfault) const;virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__dest) const;void _M_initialize_ctype();};}template < typename _CharT >class ctype_byname : public ctype < _CharT >{public :typedef _CharT char_type;explicitctype_byname( const char * __s, size_t __refs = 0 );protected :virtual~ ctype_byname( );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < char > : public ctype < char > {public: typedef char char_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ctype_byname < wchar_t > : public ctype < wchar_t > {public: typedef wchar_t char_type;};}}namespace std{inline bool is(mask __m,char __c) const{if(((this) -> _M_table)) return(((this) -> _M_table)[(unsigned char )__c] & __m);else return(__istype(__c,__m));}inline const char *is(const char *__low,const char *__high,mask *__vec) const{if(((this) -> _M_table)) while(1){if(!(__low < __high)) break;*(__vec++) =((this) -> _M_table)[(unsigned char )( *(__low++))];}else for(;__low < __high;(++__vec , ++__low)) {*__vec =(__maskrune(( *__low),390912UL));}return __high;}inline const char *scan_is(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) && !(((this) -> _M_table)[(unsigned char )( *__low)] & __m))) break;++__low;}else while(1){if(!((__low < __high) && !(this) -> is(__m, *__low))) break;++__low;}return __low;}inline const char *scan_not(mask __m,const char *__low,const char *__high) const{if(((this) -> _M_table)) while(1){if(!((__low < __high) &&((((this) -> _M_table)[(unsigned char )( *__low)] & __m) != 0UL))) break;++__low;}else while(1){if(!((__low < __high) &&(((this) -> is(__m, *__low)) != 0))) break;++__low;}return __low;}inline bool do_is(mask __m,wchar_t __c) const{return(__istype(__c,__m));}inline const char_type *do_is(const wchar_t *__lo,const wchar_t *__hi,mask *__vec) const{for(;__lo < __hi;(++__vec , ++__lo)) *__vec =(__maskrune(( *__lo),390912UL));return __hi;}inline const char_type *do_scan_is(mask __m,const wchar_t *__lo,const wchar_t *__hi) const{while(1){if(!((__lo < __hi) && !(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}inline const char_type *do_scan_not(mask __m,const char_type *__lo,const char_type *__hi) const{while(1){if(!((__lo < __hi) &&(__istype(( *__lo),__m)))) break;++__lo;}return __lo;}}#pragma GCC system_headernamespace std{class codecvt_base {public: enum result {ok,partial,error,noconv};};template < typename _InternT, typename _ExternT, typename _StateT >class __codecvt_abstract_base: public locale :: facet, public codecvt_base{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;resultout( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultunshift( state_type & __state, extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;resultin( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;intencoding( ) const throw( );boolalways_noconv( ) const throw( );intlength( state_type & __state, const extern_type * __from,const extern_type * __end, size_t __max ) const;intmax_length( ) const throw( );protected :explicit__codecvt_abstract_base( size_t __refs = 0 );virtual~ __codecvt_abstract_base( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const = 0;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const = 0;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const = 0;virtual intdo_encoding( ) const throw( ) = 0;virtual booldo_always_noconv( ) const throw( ) = 0;virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const = 0;virtual intdo_max_length( ) const throw( ) = 0;};template < typename _InternT, typename _ExternT, typename _StateT >class codecvt: public __codecvt_abstract_base < _InternT, _ExternT, _StateT >{public :typedef codecvt_base :: result result;typedef _InternT intern_type;typedef _ExternT extern_type;typedef _StateT state_type;protected :__c_locale _M_c_locale_codecvt;public :static locale :: id id;explicitcodecvt( size_t __refs = 0 );explicitcodecvt( __c_locale __cloc, size_t __refs = 0 );protected :virtual~ codecvt( );virtual resultdo_out( state_type & __state, const intern_type * __from,const intern_type * __from_end, const intern_type * & __from_next,extern_type * __to, extern_type * __to_end,extern_type * & __to_next ) const;virtual resultdo_unshift( state_type & __state, extern_type * __to,extern_type * __to_end, extern_type * & __to_next ) const;virtual resultdo_in( state_type & __state, const extern_type * __from,const extern_type * __from_end, const extern_type * & __from_next,intern_type * __to, intern_type * __to_end,intern_type * & __to_next ) const;virtual intdo_encoding( ) const throw( );virtual booldo_always_noconv( ) const throw( );virtual intdo_length( state_type &, const extern_type * __from,const extern_type * __end, size_t __max ) const;virtual intdo_max_length( ) const throw( );};template < typename _InternT, typename _ExternT, typename _StateT >locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < char , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < char , char , mbstate_t > : public __codecvt_abstract_base < char , char , mbstate_t > {public: typedef char intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __codecvt_abstract_base < wchar_t , char , mbstate_t > : public facet,public codecvt_base{public: typedef enum result result;typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class codecvt < wchar_t , char , mbstate_t > : public __codecvt_abstract_base < wchar_t , char , mbstate_t > {public: typedef wchar_t intern_type;typedef char extern_type;typedef mbstate_t state_type;protected: __c_locale _M_c_locale_codecvt;public: static class id id;explicit codecvt(size_t __refs = 0UL);explicit codecvt(__c_locale __cloc,size_t __refs = 0UL);protected: virtual ~codecvt();virtual result do_out(state_type &__state,const intern_type *__from,const intern_type *__from_end,const intern_type *&__from_next,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_unshift(state_type &__state,extern_type *__to,extern_type *__to_end,extern_type *&__to_next) const;virtual result do_in(state_type &__state,const extern_type *__from,const extern_type *__from_end,const extern_type *&__from_next,intern_type *__to,intern_type *__to_end,intern_type *&__to_next) const;virtual int do_encoding() const throw();virtual bool do_always_noconv() const throw();virtual int do_length(state_type &,const extern_type *__from,const extern_type *__end,size_t __max) const;virtual int do_max_length() const throw();};}template < typename _InternT, typename _ExternT, typename _StateT >class codecvt_byname : public codecvt < _InternT, _ExternT, _StateT >{public :explicitcodecvt_byname( const char * __s, size_t __refs = 0 );protected :virtual~ codecvt_byname( );};}namespace std{class __num_base {public: enum __unnamed_enum___F71_L1546_C5__S_ominus__COMMA___S_oplus__COMMA___S_ox__COMMA___S_oX__COMMA___S_odigits__COMMA___S_odigits_end__COMMA___S_oudigits__COMMA___S_oudigits_end__COMMA___S_oe__COMMA___S_oE__COMMA___S_oend {_S_ominus,_S_oplus,_S_ox,_S_oX,_S_odigits,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36};static const char *_S_atoms_out;static const char *_S_atoms_in;enum __unnamed_enum___F71_L1572_C5__S_iminus__COMMA___S_iplus__COMMA___S_ix__COMMA___S_iX__COMMA___S_izero__COMMA___S_ie__COMMA___S_iE__COMMA___S_iend {_S_iminus,_S_iplus,_S_ix,_S_iX,_S_izero,_S_ie=18,_S_iE=24,_S_iend=26};static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod);};template < typename _CharT >struct __numpunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;const _CharT * _M_truename;size_t _M_truename_size;const _CharT * _M_falsename;size_t _M_falsename_size;_CharT _M_decimal_point;_CharT _M_thousands_sep;_CharT _M_atoms_out [ __num_base :: _S_oend ];_CharT _M_atoms_in [ __num_base :: _S_iend ];bool _M_allocated;__numpunct_cache( size_t __refs = 0 );~ __numpunct_cache( );void_M_cache( const locale & __loc );private :__numpunct_cache &operator =( const __numpunct_cache & );explicit__numpunct_cache( const __numpunct_cache & );};template < typename _CharT >__numpunct_cache < _CharT > :: ~ __numpunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_truename;delete [ ] _M_falsename;}}template < typename _CharT >class numpunct : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __numpunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;public :static locale :: id id;explicitnumpunct( size_t __refs = 0 );explicitnumpunct( __cache_type * __cache, size_t __refs = 0 );explicitnumpunct( __c_locale __cloc, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typetruename( ) const;string_typefalsename( ) const;protected :virtual~ numpunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_truename( ) const;virtual string_typedo_falsename( ) const;void_M_initialize_numpunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id numpunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < char > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __numpunct_cache< char > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __numpunct_cache < wchar_t > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class numpunct < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __numpunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;public: static class id id;};}template < typename _CharT >class numpunct_byname : public numpunct < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitnumpunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ numpunct_byname( );};template < typename _CharT, typename _InIter >class num_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;static locale :: id id;explicitnum_get( size_t __refs = 0 );iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const;iter_typeget( iter_type __in, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const;protected :virtual ~ num_get( );iter_type_M_extract_float( iter_type, iter_type, ios_base &, ios_base :: iostate &,string & __xtrc ) const;template < typename _ValueT >iter_type_M_extract_int( iter_type, iter_type, ios_base &, ios_base :: iostate &,_ValueT & __v ) const;template < typename _CharT2 >typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type_M_find( const _CharT2 *, size_t __len, _CharT2 __c ) const{int __ret = - 1;if( __len <= 10 ){if( __c >= _CharT2( '0' ) && __c < _CharT2( _CharT2( '0' ) + __len ) )__ret = __c - _CharT2( '0' );}else{if( __c >= _CharT2( '0' ) && __c <= _CharT2( '9' ) )__ret = __c - _CharT2( '0' );else if( __c >= _CharT2( 'a' ) && __c <= _CharT2( 'f' ) )__ret = 10 +( __c - _CharT2( 'a' ) );else if( __c >= _CharT2( 'A' ) && __c <= _CharT2( 'F' ) )__ret = 10 +( __c - _CharT2( 'A' ) );}return __ret;}template < typename _CharT2 >typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,int > :: __type_M_find( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const{int __ret = - 1;const char_type * __q = char_traits < _CharT2 > :: find( __zero, __len, __c );if( __q ){__ret = __q - __zero;if( __ret > 15 )__ret -= 6;}return __ret;}virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate &, long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned short & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned int & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,unsigned long long & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,float & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,long double & ) const;virtual iter_typedo_get( iter_type, iter_type, ios_base &, ios_base :: iostate & __err,void * & ) const;};template < typename _CharT, typename _InIter >locale :: id num_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class num_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicitnum_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __f, char_type __fill, bool __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,unsigned long long __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill, double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,long double __v ) const;iter_typeput( iter_type __s, ios_base & __f, char_type __fill,const void * __v ) const;protected :template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;void_M_group_float( const char * __grouping, size_t __grouping_size,char_type __sep, const char_type * __p, char_type * __new,char_type * __cs, int & __len ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;void_M_group_int( const char * __grouping, size_t __grouping_size,char_type __sep, ios_base & __io, char_type * __new,char_type * __cs, int & __len ) const;void_M_pad( char_type __fill, streamsize __w, ios_base & __io,char_type * __new, const char_type * __cs, int & __len ) const;virtual~ num_put( );virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, bool __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long long __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, unsigned long long ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, long double __v ) const;virtual iter_typedo_put( iter_type, ios_base &, char_type __fill, const void * __v ) const;};template < typename _CharT, typename _OutIter >locale :: id num_put < _CharT, _OutIter > :: id;template < typename _CharT >class collate : public locale :: facet{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_collate;public :static locale :: id id;explicitcollate( size_t __refs = 0 );explicitcollate( __c_locale __cloc, size_t __refs = 0 );intcompare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;string_typetransform( const _CharT * __lo, const _CharT * __hi ) const;longhash( const _CharT * __lo, const _CharT * __hi ) const;int_M_compare( const _CharT *, const _CharT * ) const;size_t_M_transform( _CharT *, const _CharT *, size_t ) const;protected :virtual~ collate( );virtual intdo_compare( const _CharT * __lo1, const _CharT * __hi1,const _CharT * __lo2, const _CharT * __hi2 ) const;virtual string_typedo_transform( const _CharT * __lo, const _CharT * __hi ) const;virtual longdo_hash( const _CharT * __lo, const _CharT * __hi ) const;};template < typename _CharT >locale :: id collate < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < char > : public facet{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class collate < wchar_t > : public facet{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_collate;public: static class id id;};}template < typename _CharT >class collate_byname : public collate < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitcollate_byname( const char * __s, size_t __refs = 0 );protected :virtual~ collate_byname( );};class time_base {public: enum dateorder {no_order,dmy,mdy,ymd,ydm};};template < typename _CharT >struct __timepunct_cache : public locale :: facet{static const _CharT * _S_timezones [ 14 ];const _CharT * _M_date_format;const _CharT * _M_date_era_format;const _CharT * _M_time_format;const _CharT * _M_time_era_format;const _CharT * _M_date_time_format;const _CharT * _M_date_time_era_format;const _CharT * _M_am;const _CharT * _M_pm;const _CharT * _M_am_pm_format;const _CharT * _M_day1;const _CharT * _M_day2;const _CharT * _M_day3;const _CharT * _M_day4;const _CharT * _M_day5;const _CharT * _M_day6;const _CharT * _M_day7;const _CharT * _M_aday1;const _CharT * _M_aday2;const _CharT * _M_aday3;const _CharT * _M_aday4;const _CharT * _M_aday5;const _CharT * _M_aday6;const _CharT * _M_aday7;const _CharT * _M_month01;const _CharT * _M_month02;const _CharT * _M_month03;const _CharT * _M_month04;const _CharT * _M_month05;const _CharT * _M_month06;const _CharT * _M_month07;const _CharT * _M_month08;const _CharT * _M_month09;const _CharT * _M_month10;const _CharT * _M_month11;const _CharT * _M_month12;const _CharT * _M_amonth01;const _CharT * _M_amonth02;const _CharT * _M_amonth03;const _CharT * _M_amonth04;const _CharT * _M_amonth05;const _CharT * _M_amonth06;const _CharT * _M_amonth07;const _CharT * _M_amonth08;const _CharT * _M_amonth09;const _CharT * _M_amonth10;const _CharT * _M_amonth11;const _CharT * _M_amonth12;bool _M_allocated;__timepunct_cache( size_t __refs = 0 );~ __timepunct_cache( );void_M_cache( const locale & __loc );private :__timepunct_cache &operator =( const __timepunct_cache & );explicit__timepunct_cache( const __timepunct_cache & );};template < typename _CharT >__timepunct_cache < _CharT > :: ~ __timepunct_cache( ){if( _M_allocated ){}}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < char > : public facet{static const char *_S_timezones[14UL];const char *_M_date_format;const char *_M_date_era_format;const char *_M_time_format;const char *_M_time_era_format;const char *_M_date_time_format;const char *_M_date_time_era_format;const char *_M_am;const char *_M_pm;const char *_M_am_pm_format;const char *_M_day1;const char *_M_day2;const char *_M_day3;const char *_M_day4;const char *_M_day5;const char *_M_day6;const char *_M_day7;const char *_M_aday1;const char *_M_aday2;const char *_M_aday3;const char *_M_aday4;const char *_M_aday5;const char *_M_aday6;const char *_M_aday7;const char *_M_month01;const char *_M_month02;const char *_M_month03;const char *_M_month04;const char *_M_month05;const char *_M_month06;const char *_M_month07;const char *_M_month08;const char *_M_month09;const char *_M_month10;const char *_M_month11;const char *_M_month12;const char *_M_amonth01;const char *_M_amonth02;const char *_M_amonth03;const char *_M_amonth04;const char *_M_amonth05;const char *_M_amonth06;const char *_M_amonth07;const char *_M_amonth08;const char *_M_amonth09;const char *_M_amonth10;const char *_M_amonth11;const char *_M_amonth12;bool _M_allocated;};}const char *_S_timezones[14UL];namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> struct __timepunct_cache < wchar_t > : public facet{static const wchar_t *_S_timezones[14UL];const wchar_t *_M_date_format;const wchar_t *_M_date_era_format;const wchar_t *_M_time_format;const wchar_t *_M_time_era_format;const wchar_t *_M_date_time_format;const wchar_t *_M_date_time_era_format;const wchar_t *_M_am;const wchar_t *_M_pm;const wchar_t *_M_am_pm_format;const wchar_t *_M_day1;const wchar_t *_M_day2;const wchar_t *_M_day3;const wchar_t *_M_day4;const wchar_t *_M_day5;const wchar_t *_M_day6;const wchar_t *_M_day7;const wchar_t *_M_aday1;const wchar_t *_M_aday2;const wchar_t *_M_aday3;const wchar_t *_M_aday4;const wchar_t *_M_aday5;const wchar_t *_M_aday6;const wchar_t *_M_aday7;const wchar_t *_M_month01;const wchar_t *_M_month02;const wchar_t *_M_month03;const wchar_t *_M_month04;const wchar_t *_M_month05;const wchar_t *_M_month06;const wchar_t *_M_month07;const wchar_t *_M_month08;const wchar_t *_M_month09;const wchar_t *_M_month10;const wchar_t *_M_month11;const wchar_t *_M_month12;const wchar_t *_M_amonth01;const wchar_t *_M_amonth02;const wchar_t *_M_amonth03;const wchar_t *_M_amonth04;const wchar_t *_M_amonth05;const wchar_t *_M_amonth06;const wchar_t *_M_amonth07;const wchar_t *_M_amonth08;const wchar_t *_M_amonth09;const wchar_t *_M_amonth10;const wchar_t *_M_amonth11;const wchar_t *_M_amonth12;bool _M_allocated;};}const wchar_t *_S_timezones[14UL];template < typename _CharT >const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];template < typename _CharT >class __timepunct : public locale :: facet{public :typedef _CharT __char_type;typedef basic_string < _CharT > __string_type;typedef __timepunct_cache < _CharT > __cache_type;protected :__cache_type * _M_data;__c_locale _M_c_locale_timepunct;const char * _M_name_timepunct;public :static locale :: id id;explicit__timepunct( size_t __refs = 0 );explicit__timepunct( __cache_type * __cache, size_t __refs = 0 );explicit__timepunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );void_M_put( _CharT * __s, size_t __maxlen, const _CharT * __format,const tm * __tm ) const;void_M_date_formats( const _CharT * * __date ) const;void_M_time_formats( const _CharT * * __time ) const;void_M_date_time_formats( const _CharT * * __dt ) const;void_M_am_pm_format( const _CharT * __ampm ) const;void_M_am_pm( const _CharT * * __ampm ) const;void_M_days( const _CharT * * __days ) const;void_M_days_abbreviated( const _CharT * * __days ) const;void_M_months( const _CharT * * __months ) const;void_M_months_abbreviated( const _CharT * * __months ) const;protected :virtual~ __timepunct( );void_M_initialize_timepunct( __c_locale __cloc = __null );};template < typename _CharT >locale :: id __timepunct < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < char > : public facet{public: typedef char __char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > __string_type;typedef struct __timepunct_cache< char > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __timepunct < wchar_t > : public facet{public: typedef wchar_t __char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > __string_type;typedef struct __timepunct_cache< wchar_t > __cache_type;protected: __cache_type *_M_data;__c_locale _M_c_locale_timepunct;const char *_M_name_timepunct;public: static class id id;};}}namespace std{}namespace std{template < typename _CharT, typename _InIter >class time_get : public locale :: facet, public time_base{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > __string_type;static locale :: id id;explicittime_get( size_t __refs = 0 );dateorderdate_order( ) const;iter_typeget_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_monthname( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_typeget_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;protected :virtual~ time_get( );virtual dateorderdo_date_order( ) const;virtual iter_typedo_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_weekday( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_monthname( iter_type __beg, iter_type __end, ios_base &,ios_base :: iostate & __err, tm * __tm ) const;virtual iter_typedo_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const;iter_type_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const;iter_type_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const;};template < typename _CharT, typename _InIter >locale :: id time_get < _CharT, _InIter > :: id;template < typename _CharT, typename _InIter >class time_get_byname : public time_get < _CharT, _InIter >{public :typedef _CharT char_type;typedef _InIter iter_type;explicittime_get_byname( const char *, size_t __refs = 0 );protected :virtual~ time_get_byname( );};template < typename _CharT, typename _OutIter >class time_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;static locale :: id id;explicittime_put( size_t __refs = 0 );iter_typeput( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const;iter_typeput( iter_type __s, ios_base & __io, char_type __fill,const tm * __tm, char __format, char __mod = 0 ) const;protected :virtual~ time_put( );virtual iter_typedo_put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,char __format, char __mod ) const;};template < typename _CharT, typename _OutIter >locale :: id time_put < _CharT, _OutIter > :: id;template < typename _CharT, typename _OutIter >class time_put_byname : public time_put < _CharT, _OutIter >{public :typedef _CharT char_type;typedef _OutIter iter_type;explicittime_put_byname( const char *, size_t __refs = 0 );protected :virtual~ time_put_byname( );};class money_base {public: enum part {none,space,symbol,sign,value};struct pattern {char field[4UL];};static const struct pattern _S_default_pattern;enum __unnamed_enum___F71_L3530_C5__S_minus__COMMA___S_zero__COMMA___S_end {_S_minus,_S_zero,_S_end=11};static const char *_S_atoms;static pattern _S_construct_pattern(char __precedes,char __space,char __posn);};template < typename _CharT, bool _Intl >struct __moneypunct_cache : public locale :: facet{const char * _M_grouping;size_t _M_grouping_size;bool _M_use_grouping;_CharT _M_decimal_point;_CharT _M_thousands_sep;const _CharT * _M_curr_symbol;size_t _M_curr_symbol_size;const _CharT * _M_positive_sign;size_t _M_positive_sign_size;const _CharT * _M_negative_sign;size_t _M_negative_sign_size;int _M_frac_digits;money_base :: pattern _M_pos_format;money_base :: pattern _M_neg_format;_CharT _M_atoms [ money_base :: _S_end ];bool _M_allocated;__moneypunct_cache( size_t __refs = 0 );~ __moneypunct_cache( );void_M_cache( const locale & __loc );private :__moneypunct_cache &operator =( const __moneypunct_cache & );explicit__moneypunct_cache( const __moneypunct_cache & );};template < typename _CharT, bool _Intl >__moneypunct_cache < _CharT, _Intl > :: ~ __moneypunct_cache( ){if( _M_allocated ){delete [ ] _M_grouping;delete [ ] _M_curr_symbol;delete [ ] _M_positive_sign;delete [ ] _M_negative_sign;}}template < typename _CharT, bool _Intl >class moneypunct : public locale :: facet, public money_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;private :__cache_type * _M_data;public :static const bool intl = _Intl;static locale :: id id;explicitmoneypunct( size_t __refs = 0 );explicitmoneypunct( __cache_type * __cache, size_t __refs = 0 );explicitmoneypunct( __c_locale __cloc, const char * __s, size_t __refs = 0 );char_typedecimal_point( ) const;char_typethousands_sep( ) const;stringgrouping( ) const;string_typecurr_symbol( ) const;string_typepositive_sign( ) const;string_typenegative_sign( ) const;intfrac_digits( ) const;patternpos_format( ) const;patternneg_format( ) const;protected :virtual~ moneypunct( );virtual char_typedo_decimal_point( ) const;virtual char_typedo_thousands_sep( ) const;virtual stringdo_grouping( ) const;virtual string_typedo_curr_symbol( ) const;virtual string_typedo_positive_sign( ) const;virtual string_typedo_negative_sign( ) const;virtual intdo_frac_digits( ) const;virtual patterndo_pos_format( ) const;virtual patterndo_neg_format( ) const;void_M_initialize_moneypunct( __c_locale __cloc = __null,const char * __name = __null );};template < typename _CharT, bool _Intl >locale :: id moneypunct < _CharT, _Intl > :: id;template < typename _CharT, bool _Intl >const bool moneypunct < _CharT, _Intl > :: intl;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , true > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < char , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < char , false > : public facet,public money_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;typedef class __moneypunct_cache< char , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , true > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , true > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , true > __cache_type;private: __cache_type *_M_data;public: static const bool intl = true;static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class __moneypunct_cache < wchar_t , false > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class moneypunct < wchar_t , false > : public facet,public money_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;typedef class __moneypunct_cache< wchar_t , false > __cache_type;private: __cache_type *_M_data;public: static const bool intl = false;static class id id;};}template < typename _CharT, bool _Intl >class moneypunct_byname : public moneypunct < _CharT, _Intl >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;static const bool intl = _Intl;explicitmoneypunct_byname( const char * __s, size_t __refs = 0 );protected :virtual~ moneypunct_byname( );};template < typename _CharT, bool _Intl >const bool moneypunct_byname < _CharT, _Intl > :: intl;template < typename _CharT, typename _InIter >class money_get : public locale :: facet{public :typedef _CharT char_type;typedef _InIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_get( size_t __refs = 0 );iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;iter_typeget( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;protected :virtual~ money_get( );virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const;virtual iter_typedo_get( iter_type __s, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const;template < bool _Intl >iter_type_M_extract( iter_type __s, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __digits ) const;};template < typename _CharT, typename _InIter >locale :: id money_get < _CharT, _InIter > :: id;template < typename _CharT, typename _OutIter >class money_put : public locale :: facet{public :typedef _CharT char_type;typedef _OutIter iter_type;typedef basic_string < _CharT > string_type;static locale :: id id;explicitmoney_put( size_t __refs = 0 );iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, long double __units ) const;iter_typeput( iter_type __s, bool __intl, ios_base & __io,char_type __fill, const string_type & __digits ) const;protected :virtual~ money_put( );virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const;virtual iter_typedo_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const;template < bool _Intl >iter_type_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const;};template < typename _CharT, typename _OutIter >locale :: id money_put < _CharT, _OutIter > :: id;struct messages_base {typedef int catalog;};template < typename _CharT >class messages : public locale :: facet, public messages_base{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;protected :__c_locale _M_c_locale_messages;const char * _M_name_messages;public :static locale :: id id;explicitmessages( size_t __refs = 0 );explicitmessages( __c_locale __cloc, const char * __s, size_t __refs = 0 );catalogopen( const basic_string < char > & __s, const locale & __loc ) const;catalogopen( const basic_string < char > &, const locale &, const char * ) const;string_typeget( catalog __c, int __set, int __msgid, const string_type & __s ) const;voidclose( catalog __c ) const;protected :virtual~ messages( );virtual catalogdo_open( const basic_string < char > &, const locale & ) const;virtual string_typedo_get( catalog, int, int, const string_type & __dfault ) const;virtual voiddo_close( catalog ) const;char *_M_convert_to_char( const string_type & __msg ) const;string_type_M_convert_from_char( char * ) const;};template < typename _CharT >locale :: id messages < _CharT > :: id;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < char > : public facet,public messages_base{public: typedef char char_type;typedef class basic_string< char , char_traits< char > , allocator< char > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class messages < wchar_t > : public facet,public messages_base{public: typedef wchar_t char_type;typedef class basic_string< wchar_t , char_traits< wchar_t > , allocator< wchar_t > > string_type;protected: __c_locale _M_c_locale_messages;const char *_M_name_messages;public: static class id id;};}template < typename _CharT >class messages_byname : public messages < _CharT >{public :typedef _CharT char_type;typedef basic_string < _CharT > string_type;explicitmessages_byname( const char * __s, size_t __refs = 0 );protected :virtual~ messages_byname( );};}namespace std{template < typename _CharT >messages_byname < _CharT > :: messages_byname( const char * __s, size_t __refs ): messages < _CharT >( __refs ){if( std :: strcmp( __s, "C" ) != 0 && std :: strcmp( __s, "POSIX" ) != 0 ){this -> _S_destroy_c_locale( this -> _M_c_locale_messages );this -> _S_create_c_locale( this -> _M_c_locale_messages, __s );}}}namespace std{template < typename _CharT >inline boolisspace( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: space, __c );}template < typename _CharT >inline boolisprint( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: print, __c );}template < typename _CharT >inline booliscntrl( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: cntrl, __c );}template < typename _CharT >inline boolisupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: upper, __c );}template < typename _CharT >inline boolislower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: lower, __c );}template < typename _CharT >inline boolisalpha( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alpha, __c );}template < typename _CharT >inline boolisdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: digit, __c );}template < typename _CharT >inline boolispunct( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: punct, __c );}template < typename _CharT >inline boolisxdigit( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: xdigit, __c );}template < typename _CharT >inline boolisalnum( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: alnum, __c );}template < typename _CharT >inline boolisgraph( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . is( ctype_base :: graph, __c );}template < typename _CharT >inline _CharTtoupper( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . toupper( __c );}template < typename _CharT >inline _CharTtolower( _CharT __c, const locale & __loc ){return use_facet < ctype < _CharT > >( __loc ) . tolower( __c );}}namespace std{template < typename _CharT, typename _Traits >class basic_ios : public ios_base{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef ctype < _CharT > __ctype_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;protected :basic_ostream < _CharT, _Traits > * _M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;basic_streambuf < _CharT, _Traits > * _M_streambuf;const __ctype_type * _M_ctype;const __num_put_type * _M_num_put;const __num_get_type * _M_num_get;public :operator void *( ) const;booloperator !( ) const;iostaterdstate( ) const;voidclear( iostate __state = goodbit );voidsetstate( iostate __state );void_M_setstate( iostate __state );boolgood( ) const;booleof( ) const;boolfail( ) const;boolbad( ) const;iostateexceptions( ) const;voidexceptions( iostate __except );explicitbasic_ios( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_ios( );basic_ostream < _CharT, _Traits > *tie( ) const;basic_ostream < _CharT, _Traits > *tie( basic_ostream < _CharT, _Traits > * __tiestr );basic_streambuf < _CharT, _Traits > *rdbuf( ) const;basic_streambuf < _CharT, _Traits > *rdbuf( basic_streambuf < _CharT, _Traits > * __sb );basic_ios &copyfmt( const basic_ios & __rhs );char_typefill( ) const;char_typefill( char_type __ch );localeimbue( const locale & __loc );charnarrow( char_type __c, char __dfault ) const;char_typewiden( char __c ) const;protected :basic_ios( );voidinit( basic_streambuf < _CharT, _Traits > * __sb );void_M_cache_locale( const locale & __loc );};}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: clear( iostate __state ){if( this -> rdbuf( ) )_M_streambuf_state = __state;else_M_streambuf_state = __state | badbit;if( this -> exceptions( ) & this -> rdstate( ) )__throw_ios_failure(( "basic_ios::clear" ) );}template < typename _CharT, typename _Traits >basic_streambuf < _CharT, _Traits > *basic_ios < _CharT, _Traits > :: rdbuf( basic_streambuf < _CharT, _Traits > * __sb ){basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;_M_streambuf = __sb;this -> clear( );return __old;}template < typename _CharT, typename _Traits >basic_ios < _CharT, _Traits > &basic_ios < _CharT, _Traits > :: copyfmt( const basic_ios & __rhs ){if( this != & __rhs ){_Words * __words =( __rhs . _M_word_size <= _S_local_word_size ) ?_M_local_word : new _Words [ __rhs . _M_word_size ];_Callback_list * __cb = __rhs . _M_callbacks;if( __cb )__cb -> _M_add_reference( );_M_call_callbacks( erase_event );if( _M_word != _M_local_word ){delete [ ] _M_word;_M_word = 0;}_M_dispose_callbacks( );_M_callbacks = __cb;for( int __i = 0;__i < __rhs . _M_word_size;++ __i )__words [ __i ] = __rhs . _M_word [ __i ];_M_word = __words;_M_word_size = __rhs . _M_word_size;this -> flags( __rhs . flags( ) );this -> width( __rhs . width( ) );this -> precision( __rhs . precision( ) );this -> tie( __rhs . tie( ) );this -> fill( __rhs . fill( ) );_M_ios_locale = __rhs . getloc( );_M_cache_locale( _M_ios_locale );_M_call_callbacks( copyfmt_event );this -> exceptions( __rhs . exceptions( ) );}return * this;}template < typename _CharT, typename _Traits >charbasic_ios < _CharT, _Traits > :: narrow( char_type __c, char __dfault ) const{return __check_facet( _M_ctype ) . narrow( __c, __dfault );}template < typename _CharT, typename _Traits >_CharTbasic_ios < _CharT, _Traits > :: widen( char __c ) const{return __check_facet( _M_ctype ) . widen( __c );}template < typename _CharT, typename _Traits >localebasic_ios < _CharT, _Traits > :: imbue( const locale & __loc ){locale __old( this -> getloc( ) );ios_base :: imbue( __loc );_M_cache_locale( __loc );if( this -> rdbuf( ) != 0 )this -> rdbuf( ) -> pubimbue( __loc );return __old;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: init( basic_streambuf < _CharT, _Traits > * __sb ){ios_base :: _M_init( );_M_cache_locale( _M_ios_locale );_M_fill = _CharT( );_M_fill_init = false;_M_tie = 0;_M_exception = goodbit;_M_streambuf = __sb;_M_streambuf_state = __sb ? goodbit : badbit;}template < typename _CharT, typename _Traits >voidbasic_ios < _CharT, _Traits > :: _M_cache_locale( const locale & __loc ){if( __builtin_expect( has_facet < __ctype_type >( __loc ), true ) )_M_ctype = & use_facet < __ctype_type >( __loc );else_M_ctype = 0;if( __builtin_expect( has_facet < __num_put_type >( __loc ), true ) )_M_num_put = & use_facet < __num_put_type >( __loc );else_M_num_put = 0;if( __builtin_expect( has_facet < __num_get_type >( __loc ), true ) )_M_num_get = & use_facet < __num_get_type >( __loc );else_M_num_get = 0;}}namespace std{template < typename _CharT, typename _Traits >class basic_ostream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >__num_put_type;typedef ctype < _CharT > __ctype_type;explicitbasic_ostream( __streambuf_type * __sb );virtual~ basic_ostream( );class sentry;friend class sentry;__ostream_type &operator <<( __ostream_type &( * __pf )( __ostream_type & ) );__ostream_type &operator <<( __ios_type &( * __pf )( __ios_type & ) );__ostream_type &operator <<( ios_base &( * __pf )( ios_base & ) );__ostream_type &operator <<( long __n );__ostream_type &operator <<( unsigned long __n );__ostream_type &operator <<( bool __n );__ostream_type &operator <<( short __n );__ostream_type &operator <<( unsigned short __n );__ostream_type &operator <<( int __n );__ostream_type &operator <<( unsigned int __n );__ostream_type &operator <<( long long __n );__ostream_type &operator <<( unsigned long long __n );__ostream_type &operator <<( double __f );__ostream_type &operator <<( float __f );__ostream_type &operator <<( long double __f );__ostream_type &operator <<( const void * __p );__ostream_type &operator <<( __streambuf_type * __sb );__ostream_type &put( char_type __c );void_M_write( const char_type * __s, streamsize __n );__ostream_type &write( const char_type * __s, streamsize __n );__ostream_type &flush( );pos_typetellp( );__ostream_type &seekp( pos_type );__ostream_type &seekp( off_type, ios_base :: seekdir );protected :explicitbasic_ostream( );template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};template < typename _CharT, typename _Traits >class basic_ostream < _CharT, _Traits > :: sentry{bool _M_ok;basic_ostream < _CharT, _Traits > & _M_os;public :explicitsentry( basic_ostream < _CharT, _Traits > & __os );~ sentry( );operator bool( ) const;};template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, _CharT __c ){return __ostream_insert( __out, & __c, 1 );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, char __c ){return( __out << __out . widen( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, char __c ){return __ostream_insert( __out, & __c, 1 );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, signed char __c ){return( __out << static_cast < char >( __c ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, unsigned char __c ){return( __out << static_cast < char >( __c ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s );template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else__ostream_insert( __out, __s,static_cast < streamsize >( _Traits :: length( __s ) ) );return __out;}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const signed char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < class _Traits >inline basic_ostream < char, _Traits > &operator <<( basic_ostream < char, _Traits > & __out, const unsigned char * __s ){return( __out << reinterpret_cast < const char * >( __s ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &endl( basic_ostream < _CharT, _Traits > & __os ){return flush( __os . put( __os . widen( '\n' ) ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &ends( basic_ostream < _CharT, _Traits > & __os ){return __os . put( _CharT( ) );}template < typename _CharT, typename _Traits >inline basic_ostream < _CharT, _Traits > &flush( basic_ostream < _CharT, _Traits > & __os ){return __os . flush( );}}#pragma GCC system_header#pragma GCC system_header#pragma GCC system_header#pragma GCC visibility push( default )namespace __cxxabiv1{class __class_type_info ;}namespace std{class type_info {public: virtual ~type_info();inline const char *name() const{return(this) -> __name;}bool before(const class type_info &__arg) const;bool operator==(const class type_info &__arg) const;inline bool operator!=(const class type_info &__arg) const{return !((*(this)) == __arg);}virtual bool __is_pointer_p() const;virtual bool __is_function_p() const;virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;virtual bool __do_upcast(const class __class_type_info *__target,void **__obj_ptr) const;protected: const char *__name;inline type_info(const char *__n) : __name(__n){}private: type_info &operator=(const class type_info &);type_info(const class type_info &);};class bad_cast : public exception{public: inline bad_cast() throw(){}virtual ~bad_cast() throw();virtual const char *what() const throw();};class bad_typeid : public exception{public: inline bad_typeid() throw(){}virtual ~bad_typeid() throw();virtual const char *what() const throw();};}#pragma GCC visibility popnamespace std{template < typename _Facet >localelocale :: combine( const locale & __other ) const{_Impl * __tmp = new _Impl( * _M_impl, 1 );try{__tmp -> _M_replace_facet( __other . _M_impl, & _Facet :: id );}catch( ... ){__tmp -> _M_remove_reference( );throw;}return locale( __tmp );}template < typename _CharT, typename _Traits, typename _Alloc >boollocale :: operator( )( const basic_string < _CharT, _Traits, _Alloc > & __s1,const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const{typedef std :: collate < _CharT > __collate_type;const __collate_type & __collate = use_facet < __collate_type >( * this );return( __collate . compare( __s1 . data( ), __s1 . data( ) + __s1 . length( ),__s2 . data( ), __s2 . data( ) + __s2 . length( ) ) < 0 );}template < typename _Facet >inline boolhas_facet( const locale & __loc ) throw( ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;return( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] );}template < typename _Facet >inline const _Facet &use_facet( const locale & __loc ){const size_t __i = _Facet :: id . _M_id( );const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;if( !( __i < __loc . _M_impl -> _M_facets_size && __facets [ __i ] ) )__throw_bad_cast( );return static_cast < const _Facet & >( * __facets [ __i ] );}template < typename _Facet >struct __use_cache{const _Facet *operator( )( const locale & __loc ) const;};template < typename _CharT >struct __use_cache < __numpunct_cache < _CharT > >{const __numpunct_cache < _CharT > *operator( )( const locale & __loc ) const;};template < typename _CharT, bool _Intl >struct __use_cache < __moneypunct_cache < _CharT, _Intl > >{const __moneypunct_cache < _CharT, _Intl > *operator( )( const locale & __loc ) const;};template < typename _CharT >void__numpunct_cache < _CharT > :: _M_cache( const locale & __loc ){_M_allocated = true;const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > >( __loc );_M_grouping_size = __np . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__np . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __np . grouping( ) [ 0 ] ) > 0 );_M_truename_size = __np . truename( ) . size( );_CharT * __truename = new _CharT [ _M_truename_size ];__np . truename( ) . copy( __truename, _M_truename_size );_M_truename = __truename;_M_falsename_size = __np . falsename( ) . size( );_CharT * __falsename = new _CharT [ _M_falsename_size ];__np . falsename( ) . copy( __falsename, _M_falsename_size );_M_falsename = __falsename;_M_decimal_point = __np . decimal_point( );_M_thousands_sep = __np . thousands_sep( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( __num_base :: _S_atoms_out,__num_base :: _S_atoms_out + __num_base :: _S_oend, _M_atoms_out );__ct . widen( __num_base :: _S_atoms_in,__num_base :: _S_atoms_in + __num_base :: _S_iend, _M_atoms_in );}template < typename _CharT, bool _Intl >void__moneypunct_cache < _CharT, _Intl > :: _M_cache( const locale & __loc ){_M_allocated = true;const moneypunct < _CharT, _Intl > & __mp =use_facet < moneypunct < _CharT, _Intl > >( __loc );_M_grouping_size = __mp . grouping( ) . size( );char * __grouping = new char [ _M_grouping_size ];__mp . grouping( ) . copy( __grouping, _M_grouping_size );_M_grouping = __grouping;_M_use_grouping =( _M_grouping_size&& static_cast < signed char >( __mp . grouping( ) [ 0 ] ) > 0 );_M_decimal_point = __mp . decimal_point( );_M_thousands_sep = __mp . thousands_sep( );_M_frac_digits = __mp . frac_digits( );_M_curr_symbol_size = __mp . curr_symbol( ) . size( );_CharT * __curr_symbol = new _CharT [ _M_curr_symbol_size ];__mp . curr_symbol( ) . copy( __curr_symbol, _M_curr_symbol_size );_M_curr_symbol = __curr_symbol;_M_positive_sign_size = __mp . positive_sign( ) . size( );_CharT * __positive_sign = new _CharT [ _M_positive_sign_size ];__mp . positive_sign( ) . copy( __positive_sign, _M_positive_sign_size );_M_positive_sign = __positive_sign;_M_negative_sign_size = __mp . negative_sign( ) . size( );_CharT * __negative_sign = new _CharT [ _M_negative_sign_size ];__mp . negative_sign( ) . copy( __negative_sign, _M_negative_sign_size );_M_negative_sign = __negative_sign;_M_pos_format = __mp . pos_format( );_M_neg_format = __mp . neg_format( );const ctype < _CharT > & __ct = use_facet < ctype < _CharT > >( __loc );__ct . widen( money_base :: _S_atoms,money_base :: _S_atoms + money_base :: _S_end, _M_atoms );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp);template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::_M_extract_float( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, string & __xtrc ) const{typedef char_traits < _CharT > __traits_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );bool __testeof = __beg == __end;if( ! __testeof ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){__xtrc += __plus ? '+' : '-';if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_mantissa = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ] ){if( ! __found_mantissa ){__xtrc += '0';__found_mantissa = true;}++ __sep_pos;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsebreak;}bool __found_dec = false;bool __found_sci = false;string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){const int __digit = _M_find( __lit_zero, 10, __c );if( __digit != - 1 ){__xtrc += '0' + __digit;__found_mantissa = true;}else if( __c == __lc -> _M_decimal_point&& ! __found_dec && ! __found_sci ){__xtrc += '.';__found_dec = true;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if( __plus || __c == __lit [ __num_base :: _S_iminus ] )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( ! __found_dec && ! __found_sci ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__xtrc . clear( );break;}}elsebreak;}else if( __c == __lc -> _M_decimal_point ){if( ! __found_dec && ! __found_sci ){if( __found_grouping . size( ) )__found_grouping += static_cast < char >( __sep_pos );__xtrc += '.';__found_dec = true;}elsebreak;}else{const char_type * __q =__traits_type :: find( __lit_zero, 10, __c );if( __q ){__xtrc += '0' +( __q - __lit_zero );__found_mantissa = true;++ __sep_pos;}else if(( __c == __lit [ __num_base :: _S_ie ]|| __c == __lit [ __num_base :: _S_iE ] )&& ! __found_sci && __found_mantissa ){if( __found_grouping . size( ) && ! __found_dec )__found_grouping += static_cast < char >( __sep_pos );__xtrc += 'e';__found_sci = true;if( ++ __beg != __end ){__c = * __beg;const bool __plus = __c == __lit [ __num_base :: _S_iplus ];if(( __plus || __c == __lit [ __num_base :: _S_iminus ] )&& !( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) )__xtrc += __plus ? '+' : '-';elsecontinue;}else{__testeof = true;break;}}elsebreak;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){if( ! __found_dec && ! __found_sci )__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >template < typename _ValueT >_InIternum_get < _CharT, _InIter > ::_M_extract_int( _InIter __beg, _InIter __end, ios_base & __io,ios_base :: iostate & __err, _ValueT & __v ) const{typedef char_traits < _CharT > __traits_type;using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_in;char_type __c = char_type( );const ios_base :: fmtflags __basefield = __io . flags( )& ios_base :: basefield;const bool __oct = __basefield == ios_base :: oct;int __base = __oct ? 8 :( __basefield == ios_base :: hex ? 16 : 10 );bool __testeof = __beg == __end;bool __negative = false;if( ! __testeof ){__c = * __beg;if( numeric_limits < _ValueT > :: is_signed )__negative = __c == __lit [ __num_base :: _S_iminus ];if(( __negative || __c == __lit [ __num_base :: _S_iplus ] )&& !( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )&& !( __c == __lc -> _M_decimal_point ) ){if( ++ __beg != __end )__c = * __beg;else__testeof = true;}}bool __found_zero = false;int __sep_pos = 0;while( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep|| __c == __lc -> _M_decimal_point )break;else if( __c == __lit [ __num_base :: _S_izero ]&&( ! __found_zero || __base == 10 ) ){__found_zero = true;++ __sep_pos;if( __basefield == 0 )__base = 8;if( __base == 8 )__sep_pos = 0;}else if( __found_zero&&( __c == __lit [ __num_base :: _S_ix ]|| __c == __lit [ __num_base :: _S_iX ] ) ){if( __basefield == 0 )__base = 16;if( __base == 16 ){__found_zero = false;__sep_pos = 0;}elsebreak;}elsebreak;if( ++ __beg != __end ){__c = * __beg;if( ! __found_zero )break;}else__testeof = true;}const size_t __len =( __base == 16 ? __num_base :: _S_iend- __num_base :: _S_izero : __base );string __found_grouping;if( __lc -> _M_use_grouping )__found_grouping . reserve( 32 );bool __testfail = false;const __unsigned_type __max = __negative ?- numeric_limits < _ValueT > :: min( ) : numeric_limits < _ValueT > :: max( );const __unsigned_type __smax = __max / __base;__unsigned_type __result = 0;int __digit = 0;const char_type * __lit_zero = __lit + __num_base :: _S_izero;if( ! __lc -> _M_allocated )while( ! __testeof ){__digit = _M_find( __lit_zero, __len, __c );if( __digit == - 1 )break;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}elsewhile( ! __testeof ){if( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep ){if( __sep_pos ){__found_grouping += static_cast < char >( __sep_pos );__sep_pos = 0;}else{__testfail = true;break;}}else if( __c == __lc -> _M_decimal_point )break;else{const char_type * __q =__traits_type :: find( __lit_zero, __len, __c );if( ! __q )break;__digit = __q - __lit_zero;if( __digit > 15 )__digit -= 6;if( __result > __smax )__testfail = true;else{__result *= __base;__testfail |= __result > __max - __digit;__result += __digit;++ __sep_pos;}}if( ++ __beg != __end )__c = * __beg;else__testeof = true;}if( __found_grouping . size( ) ){__found_grouping += static_cast < char >( __sep_pos );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__found_grouping ) )__err |= ios_base :: failbit;}if( ! __testfail &&( __sep_pos || __found_zero|| __found_grouping . size( ) ) )__v = __negative ? - __result : __result;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, bool & __v ) const{if( !( __io . flags( ) & ios_base :: boolalpha ) ){long __l = - 1;__beg = _M_extract_int( __beg, __end, __io, __err, __l );if( __l == 0 || __l == 1 )__v = __l;else__err |= ios_base :: failbit;}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );bool __testf = true;bool __testt = true;size_t __n;bool __testeof = __beg == __end;for( __n = 0;! __testeof;++ __n ){const char_type __c = * __beg;if( __testf )if( __n < __lc -> _M_falsename_size )__testf = __c == __lc -> _M_falsename [ __n ];elsebreak;if( __testt )if( __n < __lc -> _M_truename_size )__testt = __c == __lc -> _M_truename [ __n ];elsebreak;if( ! __testf && ! __testt )break;if( ++ __beg == __end )__testeof = true;}if( __testf && __n == __lc -> _M_falsename_size )__v = 0;else if( __testt && __n == __lc -> _M_truename_size )__v = 1;else__err |= ios_base :: failbit;if( __testeof )__err |= ios_base :: eofbit;}return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned short & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned int & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, unsigned long long & __v ) const{return _M_extract_int( __beg, __end, __io, __err, __v );}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, float & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, long double & __v ) const{string __xtrc;__xtrc . reserve( 32 );__beg = _M_extract_float( __beg, __end, __io, __err, __xtrc );std :: __convert_to_v( __xtrc . c_str( ), __v, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InIternum_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, void * & __v ) const{typedef ios_base :: fmtflags fmtflags;const fmtflags __fmt = __io . flags( );__io . flags( __fmt & ~ ios_base :: basefield | ios_base :: hex );unsigned long __ul;__beg = _M_extract_int( __beg, __end, __io, __err, __ul );__io . flags( __fmt );if( !( __err & ios_base :: failbit ) )__v = reinterpret_cast < void * >( __ul );return __beg;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_pad( _CharT __fill, streamsize __w, ios_base & __io,_CharT * __new, const _CharT * __cs, int & __len ) const{__pad < _CharT, char_traits < _CharT > > :: _S_pad( __io, __fill, __new, __cs,__w, __len, true );__len = static_cast < int >( __w );}template < typename _CharT, typename _ValueT >int__int_to_char( _CharT * __bufend, _ValueT __v, const _CharT * __lit,ios_base :: fmtflags __flags, bool __dec ){_CharT * __buf = __bufend;if( __builtin_expect( __dec, true ) ){do{* -- __buf = __lit [( __v % 10 ) + __num_base :: _S_odigits ];__v /= 10;}while( __v != 0 );}else if(( __flags & ios_base :: basefield ) == ios_base :: oct ){do{* -- __buf = __lit [( __v & 7 ) + __num_base :: _S_odigits ];__v >>= 3;}while( __v != 0 );}else{const bool __uppercase = __flags & ios_base :: uppercase;const int __case_offset = __uppercase ? __num_base :: _S_oudigits: __num_base :: _S_odigits;do{* -- __buf = __lit [( __v & 15 ) + __case_offset ];__v >>= 4;}while( __v != 0 );}return __bufend - __buf;}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_int( const char * __grouping, size_t __grouping_size, _CharT __sep,ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const{_CharT * __p = std :: __add_grouping( __new, __sep, __grouping,__grouping_size, __cs, __cs + __len );__len = __p - __new;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_int( _OutIter __s, ios_base & __io, _CharT __fill,_ValueT __v ) const{using __gnu_cxx :: __add_unsigned;typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __lit = __lc -> _M_atoms_out;const ios_base :: fmtflags __flags = __io . flags( );const int __ilen = 5 * sizeof( _ValueT );_CharT * __cs = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __ilen ) );const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;const bool __dec =( __basefield != ios_base :: oct&& __basefield != ios_base :: hex );const __unsigned_type __u =( __v > 0 || ! __dec ) ? __v : - __v;int __len = __int_to_char( __cs + __ilen, __u, __lit, __flags, __dec );__cs += __ilen - __len;if( __lc -> _M_use_grouping ){_CharT * __cs2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )*( __len + 1 )* 2 ) );_M_group_int( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );__cs = __cs2 + 2;}if( __builtin_expect( __dec, true ) ){if( __v > 0 ){if( __flags & ios_base :: showpos&& numeric_limits < _ValueT > :: is_signed )* -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;}else if( __v )* -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;}else if( __flags & ios_base :: showbase && __v ){if( __basefield == ios_base :: oct )* -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;else{const bool __uppercase = __flags & ios_base :: uppercase;* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];* -- __cs = __lit [ __num_base :: _S_odigits ];__len += 2;}}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs3, __cs, __len );__cs = __cs3;}__io . width( 0 );return std :: __write( __s, __cs, __len );}template < typename _CharT, typename _OutIter >voidnum_put < _CharT, _OutIter > ::_M_group_float( const char * __grouping, size_t __grouping_size,_CharT __sep, const _CharT * __p, _CharT * __new,_CharT * __cs, int & __len ) const{const int __declen = __p ? __p - __cs : __len;_CharT * __p2 = std :: __add_grouping( __new, __sep, __grouping,__grouping_size,__cs, __cs + __declen );int __newlen = __p2 - __new;if( __p ){char_traits < _CharT > :: copy( __p2, __p, __len - __declen );__newlen += __len - __declen;}__len = __newlen;}template < typename _CharT, typename _OutIter >template < typename _ValueT >_OutIternum_put < _CharT, _OutIter > ::_M_insert_float( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,_ValueT __v ) const{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const streamsize __prec = __io . precision( ) < 0 ? 6 : __io . precision( );const int __max_digits = numeric_limits < _ValueT > :: digits10;int __len;char __fbuf [ 16 ];__num_base :: _S_format_float( __io, __fbuf, __mod );int __cs_size = __max_digits * 3;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,__fbuf, __prec, __v );}const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );_CharT * __ws = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len ) );__ctype . widen( __cs, __cs + __len, __ws );_CharT * __wp = 0;const char * __p = char_traits < char > :: find( __cs, __len, '.' );if( __p ){__wp = __ws +( __p - __cs );* __wp = __lc -> _M_decimal_point;}if( __lc -> _M_use_grouping&&( __wp || __len < 3 ||( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) ){_CharT * __ws2 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __len * 2 ) );streamsize __off = 0;if( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' ){__off = 1;__ws2 [ 0 ] = __ws [ 0 ];__len -= 1;}_M_group_float( __lc -> _M_grouping, __lc -> _M_grouping_size,__lc -> _M_thousands_sep, __wp, __ws2 + __off,__ws + __off, __len );__len += __off;__ws = __ws2;}const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __ws3 = static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __ws3, __ws, __len );__ws = __ws3;}__io . width( 0 );return std :: __write( __s, __ws, __len );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const{const ios_base :: fmtflags __flags = __io . flags( );if(( __flags & ios_base :: boolalpha ) == 0 ){const long __l = __v;__s = _M_insert_int( __s, __io, __fill, __l );}else{typedef __numpunct_cache < _CharT > __cache_type;__use_cache < __cache_type > __uc;const locale & __loc = __io . _M_getloc( );const __cache_type * __lc = __uc( __loc );const _CharT * __name = __v ? __lc -> _M_truename: __lc -> _M_falsename;int __len = __v ? __lc -> _M_truename_size: __lc -> _M_falsename_size;const streamsize __w = __io . width( );if( __w > static_cast < streamsize >( __len ) ){_CharT * __cs= static_cast < _CharT * >( __builtin_alloca( sizeof( _CharT )* __w ) );_M_pad( __fill, __w, __io, __cs, __name, __len );__name = __cs;}__io . width( 0 );__s = std :: __write( __s, __name, __len );}return __s;}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,unsigned long long __v ) const{return _M_insert_int( __s, __io, __fill, __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill, double __v ) const{return _M_insert_float( __s, __io, __fill, char( ), __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,long double __v ) const{return _M_insert_float( __s, __io, __fill, 'L', __v );}template < typename _CharT, typename _OutIter >_OutIternum_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type __fill,const void * __v ) const{const ios_base :: fmtflags __flags = __io . flags( );const ios_base :: fmtflags __fmt = ~( ios_base :: basefield| ios_base :: uppercase| ios_base :: internal );__io . flags( __flags & __fmt |( ios_base :: hex | ios_base :: showbase ) );__s = _M_insert_int( __s, __io, __fill,reinterpret_cast < unsigned long >( __v ) );__io . flags( __flags );return __s;}template < typename _CharT, typename _InIter >template < bool _Intl >_InItermoney_get < _CharT, _InIter > ::_M_extract( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, string & __units ) const{typedef char_traits < _CharT > __traits_type;typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;bool __negative = false;size_type __sign_size = 0;const bool __mandatory_sign =( __lc -> _M_positive_sign_size&& __lc -> _M_negative_sign_size );string __grouping_tmp;if( __lc -> _M_use_grouping )__grouping_tmp . reserve( 32 );int __last_pos = 0;int __n = 0;bool __testvalid = true;bool __testdecfound = false;string __res;__res . reserve( 32 );const char_type * __lit_zero = __lit + money_base :: _S_zero;const money_base :: pattern __p = __lc -> _M_neg_format;for( int __i = 0;__i < 4 && __testvalid;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase || __sign_size > 1|| __i == 0||( __i == 1 &&( __mandatory_sign||( static_cast < part >( __p . field [ 0 ] )== money_base :: sign )||( static_cast < part >( __p . field [ 2 ] )== money_base :: space ) ) )||( __i == 2 &&(( static_cast < part >( __p . field [ 3 ] )== money_base :: value )|| __mandatory_sign&&( static_cast < part >( __p . field [ 3 ] )== money_base :: sign ) ) ) ){const size_type __len = __lc -> _M_curr_symbol_size;size_type __j = 0;for(;__beg != __end && __j < __len&& * __beg == __lc -> _M_curr_symbol [ __j ];++ __beg, ++ __j );if( __j != __len&&( __j || __io . flags( ) & ios_base :: showbase ) )__testvalid = false;}break;case money_base :: sign :if( __lc -> _M_positive_sign_size && __beg != __end&& * __beg == __lc -> _M_positive_sign [ 0 ] ){__sign_size = __lc -> _M_positive_sign_size;++ __beg;}else if( __lc -> _M_negative_sign_size && __beg != __end&& * __beg == __lc -> _M_negative_sign [ 0 ] ){__negative = true;__sign_size = __lc -> _M_negative_sign_size;++ __beg;}else if( __lc -> _M_positive_sign_size&& ! __lc -> _M_negative_sign_size )__negative = true;else if( __mandatory_sign )__testvalid = false;break;case money_base :: value :for(;__beg != __end;++ __beg ){const char_type __c = * __beg;const char_type * __q = __traits_type :: find( __lit_zero,10, __c );if( __q != 0 ){__res += money_base :: _S_atoms [ __q - __lit ];++ __n;}else if( __c == __lc -> _M_decimal_point&& ! __testdecfound ){__last_pos = __n;__n = 0;__testdecfound = true;}else if( __lc -> _M_use_grouping&& __c == __lc -> _M_thousands_sep&& ! __testdecfound ){if( __n ){__grouping_tmp += static_cast < char >( __n );__n = 0;}else{__testvalid = false;break;}}elsebreak;}if( __res . empty( ) )__testvalid = false;break;case money_base :: space :if( __beg != __end && __ctype . is( ctype_base :: space, * __beg ) )++ __beg;else__testvalid = false;case money_base :: none :if( __i != 3 )for(;__beg != __end&& __ctype . is( ctype_base :: space, * __beg );++ __beg );break;}}if( __sign_size > 1 && __testvalid ){const char_type * __sign = __negative ? __lc -> _M_negative_sign: __lc -> _M_positive_sign;size_type __i = 1;for(;__beg != __end && __i < __sign_size&& * __beg == __sign [ __i ];++ __beg, ++ __i );if( __i != __sign_size )__testvalid = false;}if( __testvalid ){if( __res . size( ) > 1 ){const size_type __first = __res . find_first_not_of( '0' );const bool __only_zeros = __first == string :: npos;if( __first )__res . erase( 0, __only_zeros ? __res . size( ) - 1 : __first );}if( __negative && __res [ 0 ] != '0' )__res . insert( __res . begin( ), '-' );if( __grouping_tmp . size( ) ){__grouping_tmp += static_cast < char >( __testdecfound ? __last_pos: __n );if( ! std :: __verify_grouping( __lc -> _M_grouping,__lc -> _M_grouping_size,__grouping_tmp ) )__err |= ios_base :: failbit;}if( __testdecfound && __lc -> _M_frac_digits > 0&& __n != __lc -> _M_frac_digits )__testvalid = false;}if( ! __testvalid )__err |= ios_base :: failbit;else__units . swap( __res );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, long double & __units ) const{string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );std :: __convert_to_v( __str . c_str( ), __units, __err, _S_get_c_locale( ) );return __beg;}template < typename _CharT, typename _InIter >_InItermoney_get < _CharT, _InIter > ::do_get( iter_type __beg, iter_type __end, bool __intl, ios_base & __io,ios_base :: iostate & __err, string_type & __digits ) const{typedef typename string :: size_type size_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );string __str;__beg = __intl ? _M_extract < true >( __beg, __end, __io, __err, __str ): _M_extract < false >( __beg, __end, __io, __err, __str );const size_type __len = __str . size( );if( __len ){__digits . resize( __len );__ctype . widen( __str . data( ), __str . data( ) + __len, & __digits [ 0 ] );}return __beg;}template < typename _CharT, typename _OutIter >template < bool _Intl >_OutItermoney_put < _CharT, _OutIter > ::_M_insert( iter_type __s, ios_base & __io, char_type __fill,const string_type & __digits ) const{typedef typename string_type :: size_type size_type;typedef money_base :: part part;typedef __moneypunct_cache < _CharT, _Intl > __cache_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );__use_cache < __cache_type > __uc;const __cache_type * __lc = __uc( __loc );const char_type * __lit = __lc -> _M_atoms;const char_type * __beg = __digits . data( );money_base :: pattern __p;const char_type * __sign;size_type __sign_size;if( !( * __beg == __lit [ money_base :: _S_minus ] ) ){__p = __lc -> _M_pos_format;__sign = __lc -> _M_positive_sign;__sign_size = __lc -> _M_positive_sign_size;}else{__p = __lc -> _M_neg_format;__sign = __lc -> _M_negative_sign;__sign_size = __lc -> _M_negative_sign_size;if( __digits . size( ) )++ __beg;}size_type __len = __ctype . scan_not( ctype_base :: digit, __beg,__beg + __digits . size( ) ) - __beg;if( __len ){string_type __value;__value . reserve( 2 * __len );long __paddec = __len - __lc -> _M_frac_digits;if( __paddec > 0 ){if( __lc -> _M_frac_digits < 0 )__paddec = __len;if( __lc -> _M_grouping_size ){__value . assign( 2 * __paddec, char_type( ) );_CharT * __vend =std :: __add_grouping( & __value [ 0 ], __lc -> _M_thousands_sep,__lc -> _M_grouping,__lc -> _M_grouping_size,__beg, __beg + __paddec );__value . erase( __vend - & __value [ 0 ] );}else__value . assign( __beg, __paddec );}if( __lc -> _M_frac_digits > 0 ){__value += __lc -> _M_decimal_point;if( __paddec >= 0 )__value . append( __beg + __paddec, __lc -> _M_frac_digits );else{__value . append( - __paddec, __lit [ money_base :: _S_zero ] );__value . append( __beg, __len );}}const ios_base :: fmtflags __f = __io . flags( )& ios_base :: adjustfield;__len = __value . size( ) + __sign_size;__len +=(( __io . flags( ) & ios_base :: showbase )? __lc -> _M_curr_symbol_size : 0 );string_type __res;__res . reserve( 2 * __len );const size_type __width = static_cast < size_type >( __io . width( ) );const bool __testipad =( __f == ios_base :: internal&& __len < __width );for( int __i = 0;__i < 4;++ __i ){const part __which = static_cast < part >( __p . field [ __i ] );switch( __which ){case money_base :: symbol :if( __io . flags( ) & ios_base :: showbase )__res . append( __lc -> _M_curr_symbol,__lc -> _M_curr_symbol_size );break;case money_base :: sign :if( __sign_size )__res += __sign [ 0 ];break;case money_base :: value :__res += __value;break;case money_base :: space :if( __testipad )__res . append( __width - __len, __fill );else__res += __fill;break;case money_base :: none :if( __testipad )__res . append( __width - __len, __fill );break;}}if( __sign_size > 1 )__res . append( __sign + 1, __sign_size - 1 );__len = __res . size( );if( __width > __len ){if( __f == ios_base :: left )__res . append( __width - __len, __fill );else__res . insert( 0, __width - __len, __fill );__len = __width;}__s = std :: __write( __s, __res . data( ), __len );}__io . width( 0 );return __s;}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,long double __units ) const{const locale __loc = __io . getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __cs_size = 64;char * __cs = static_cast < char * >( __builtin_alloca( __cs_size ) );int __len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );if( __len >= __cs_size ){__cs_size = __len + 1;__cs = static_cast < char * >( __builtin_alloca( __cs_size ) );__len = std :: __convert_from_v( _S_get_c_locale( ), __cs, __cs_size,"%.*Lf", 0, __units );}string_type __digits( __len, char_type( ) );__ctype . widen( __cs, __cs + __len, & __digits [ 0 ] );return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _OutIter >_OutItermoney_put < _CharT, _OutIter > ::do_put( iter_type __s, bool __intl, ios_base & __io, char_type __fill,const string_type & __digits ) const{return __intl ? _M_insert < true >( __s, __io, __fill, __digits ): _M_insert < false >( __s, __io, __fill, __digits );}template < typename _CharT, typename _InIter >time_base :: dateordertime_get < _CharT, _InIter > :: do_date_order( ) const{return time_base :: no_order;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_via_format( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm,const _CharT * __format ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const size_t __len = char_traits < _CharT > :: length( __format );ios_base :: iostate __tmperr = ios_base :: goodbit;for( size_t __i = 0;__beg != __end && __i < __len && ! __tmperr;++ __i ){if( __ctype . narrow( __format [ __i ], 0 ) == '%' ){char __c = __ctype . narrow( __format [ ++ __i ], 0 );int __mem = 0;if( __c == 'E' || __c == 'O' )__c = __ctype . narrow( __format [ ++ __i ], 0 );switch( __c ){const char * __cs;_CharT __wcs [ 10 ];case 'a' :const char_type * __days1 [ 7 ];__tp . _M_days_abbreviated( __days1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days1,7, __io, __tmperr );break;case 'A' :const char_type * __days2 [ 7 ];__tp . _M_days( __days2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_wday, __days2,7, __io, __tmperr );break;case 'h' :case 'b' :const char_type * __months1 [ 12 ];__tp . _M_months_abbreviated( __months1 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months1, 12, __io, __tmperr );break;case 'B' :const char_type * __months2 [ 12 ];__tp . _M_months( __months2 );__beg = _M_extract_name( __beg, __end, __tm -> tm_mon,__months2, 12, __io, __tmperr );break;case 'c' :const char_type * __dt [ 2 ];__tp . _M_date_time_formats( __dt );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dt [ 0 ] );break;case 'd' :__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 1, 31, 2,__io, __tmperr );break;case 'e' :if( __ctype . is( ctype_base :: space, * __beg ) )__beg = _M_extract_num( ++ __beg, __end, __tm -> tm_mday, 1, 9,1, __io, __tmperr );else__beg = _M_extract_num( __beg, __end, __tm -> tm_mday, 10, 31,2, __io, __tmperr );break;case 'D' :__cs = "%m/%d/%y";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'H' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 0, 23, 2,__io, __tmperr );break;case 'I' :__beg = _M_extract_num( __beg, __end, __tm -> tm_hour, 1, 12, 2,__io, __tmperr );break;case 'm' :__beg = _M_extract_num( __beg, __end, __mem, 1, 12, 2,__io, __tmperr );if( ! __tmperr )__tm -> tm_mon = __mem - 1;break;case 'M' :__beg = _M_extract_num( __beg, __end, __tm -> tm_min, 0, 59, 2,__io, __tmperr );break;case 'n' :if( __ctype . narrow( * __beg, 0 ) == '\n' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'R' :__cs = "%H:%M";__ctype . widen( __cs, __cs + 6, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'S' :__beg = _M_extract_num( __beg, __end, __tm -> tm_sec, 0, 60, 2,__io, __tmperr );break;case 't' :if( __ctype . narrow( * __beg, 0 ) == '\t' )++ __beg;else__tmperr |= ios_base :: failbit;break;case 'T' :__cs = "%H:%M:%S";__ctype . widen( __cs, __cs + 9, __wcs );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __wcs );break;case 'x' :const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __dates [ 0 ] );break;case 'X' :const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __tmperr,__tm, __times [ 0 ] );break;case 'y' :case 'C' :__beg = _M_extract_num( __beg, __end, __tm -> tm_year, 0, 99, 2,__io, __tmperr );break;case 'Y' :__beg = _M_extract_num( __beg, __end, __mem, 0, 9999, 4,__io, __tmperr );if( ! __tmperr )__tm -> tm_year = __mem - 1900;break;case 'Z' :if( __ctype . is( ctype_base :: upper, * __beg ) ){int __tmp;__beg = _M_extract_name( __beg, __end, __tmp,__timepunct_cache < _CharT > :: _S_timezones,14, __io, __tmperr );if( __beg != __end && ! __tmperr && __tmp == 0&&( * __beg == __ctype . widen( '-' )|| * __beg == __ctype . widen( '+' ) ) ){__beg = _M_extract_num( __beg, __end, __tmp, 0, 23, 2,__io, __tmperr );__beg = _M_extract_num( __beg, __end, __tmp, 0, 59, 2,__io, __tmperr );}}else__tmperr |= ios_base :: failbit;break;default :__tmperr |= ios_base :: failbit;}}else{if( __format [ __i ] == * __beg )++ __beg;else__tmperr |= ios_base :: failbit;}}if( __tmperr )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_num( iter_type __beg, iter_type __end, int & __member,int __min, int __max, size_t __len,ios_base & __io, ios_base :: iostate & __err ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int __mult = __len == 2 ? 10 :( __len == 4 ? 1000 : 1 );++ __min;size_t __i = 0;int __value = 0;for(;__beg != __end && __i < __len;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' ){__value = __value * 10 +( __c - '0' );const int __valuec = __value * __mult;if( __valuec > __max || __valuec + __mult < __min )break;__mult /= 10;}elsebreak;}if( __i == __len )__member = __value;else__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::_M_extract_name( iter_type __beg, iter_type __end, int & __member,const _CharT * * __names, size_t __indexlen,ios_base & __io, ios_base :: iostate & __err ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );int * __matches = static_cast < int * >( __builtin_alloca( sizeof( int )* __indexlen ) );size_t __nmatches = 0;size_t __pos = 0;bool __testvalid = true;const char_type * __name;if( __beg != __end ){const char_type __c = * __beg;for( size_t __i1 = 0;__i1 < __indexlen;++ __i1 )if( __c == __names [ __i1 ] [ 0 ]|| __c == __ctype . toupper( __names [ __i1 ] [ 0 ] ) )__matches [ __nmatches ++ ] = __i1;}while( __nmatches > 1 ){size_t __minlen = __traits_type :: length( __names [ __matches [ 0 ] ] );for( size_t __i2 = 1;__i2 < __nmatches;++ __i2 )__minlen = std :: min( __minlen,__traits_type :: length( __names [ __matches [ __i2 ] ] ) );++ __beg, ++ __pos;if( __pos < __minlen && __beg != __end )for( size_t __i3 = 0;__i3 < __nmatches;){__name = __names [ __matches [ __i3 ] ];if( !( __name [ __pos ] == * __beg ) )__matches [ __i3 ] = __matches [ -- __nmatches ];else++ __i3;}elsebreak;}if( __nmatches == 1 ){++ __beg, ++ __pos;__name = __names [ __matches [ 0 ] ];const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end && __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len == __pos )__member = __matches [ 0 ];else__testvalid = false;}else__testvalid = false;if( ! __testvalid )__err |= ios_base :: failbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_time( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __times [ 2 ];__tp . _M_time_formats( __times );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __times [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_date( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const char_type * __dates [ 2 ];__tp . _M_date_formats( __dates );__beg = _M_extract_via_format( __beg, __end, __io, __err,__tm, __dates [ 0 ] );if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_weekday( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __days [ 7 ];__tp . _M_days_abbreviated( __days );int __tmpwday;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpwday, __days, 7,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __days [ __tmpwday ] );__tp . _M_days( __days );const char_type * __name = __days [ __tmpwday ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_wday = __tmpwday;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_monthname( iter_type __beg, iter_type __end,ios_base & __io, ios_base :: iostate & __err, tm * __tm ) const{typedef char_traits < _CharT > __traits_type;const locale & __loc = __io . _M_getloc( );const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > >( __loc );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const char_type * __months [ 12 ];__tp . _M_months_abbreviated( __months );int __tmpmon;ios_base :: iostate __tmperr = ios_base :: goodbit;__beg = _M_extract_name( __beg, __end, __tmpmon, __months, 12,__io, __tmperr );if( ! __tmperr && __beg != __end ){size_t __pos = __traits_type :: length( __months [ __tmpmon ] );__tp . _M_months( __months );const char_type * __name = __months [ __tmpmon ];if( __name [ __pos ] == * __beg ){const size_t __len = __traits_type :: length( __name );while( __pos < __len && __beg != __end&& __name [ __pos ] == * __beg )++ __beg, ++ __pos;if( __len != __pos )__tmperr |= ios_base :: failbit;}}if( ! __tmperr )__tm -> tm_mon = __tmpmon;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _InIter >_InItertime_get < _CharT, _InIter > ::do_get_year( iter_type __beg, iter_type __end, ios_base & __io,ios_base :: iostate & __err, tm * __tm ) const{const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );size_t __i = 0;int __value = 0;for(;__beg != __end && __i < 4;++ __beg, ++ __i ){const char __c = __ctype . narrow( * __beg, '*' );if( __c >= '0' && __c <= '9' )__value = __value * 10 +( __c - '0' );elsebreak;}if( __i == 2 || __i == 4 )__tm -> tm_year = __i == 2 ? __value : __value - 1900;else__err |= ios_base :: failbit;if( __beg == __end )__err |= ios_base :: eofbit;return __beg;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::put( iter_type __s, ios_base & __io, char_type __fill, const tm * __tm,const _CharT * __beg, const _CharT * __end ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );for(;__beg != __end;++ __beg )if( __ctype . narrow( * __beg, 0 ) != '%' ){* __s = * __beg;++ __s;}else if( ++ __beg != __end ){char __format;char __mod = 0;const char __c = __ctype . narrow( * __beg, 0 );if( __c != 'E' && __c != 'O' )__format = __c;else if( ++ __beg != __end ){__mod = __c;__format = __ctype . narrow( * __beg, 0 );}elsebreak;__s = this -> do_put( __s, __io, __fill, __tm, __format, __mod );}elsebreak;return __s;}template < typename _CharT, typename _OutIter >_OutItertime_put < _CharT, _OutIter > ::do_put( iter_type __s, ios_base & __io, char_type, const tm * __tm,char __format, char __mod ) const{const locale & __loc = __io . _M_getloc( );ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > >( __loc );__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > >( __loc );const size_t __maxlen = 128;char_type * __res =static_cast < char_type * >( __builtin_alloca( sizeof( char_type ) * __maxlen ) );char_type __fmt [ 4 ];__fmt [ 0 ] = __ctype . widen( '%' );if( ! __mod ){__fmt [ 1 ] = __format;__fmt [ 2 ] = char_type( );}else{__fmt [ 1 ] = __mod;__fmt [ 2 ] = __format;__fmt [ 3 ] = char_type( );}__tp . _M_put( __res, __maxlen, __fmt, __tm );return std :: __write( __s, __res, char_traits < char_type > :: length( __res ) );}template < typename _CharT, typename _Traits >void__pad < _CharT, _Traits > :: _S_pad( ios_base & __io, _CharT __fill,_CharT * __news, const _CharT * __olds,const streamsize __newlen,const streamsize __oldlen, const bool __num ){const size_t __plen = static_cast < size_t >( __newlen - __oldlen );const ios_base :: fmtflags __adjust = __io . flags( ) & ios_base :: adjustfield;if( __adjust == ios_base :: left ){_Traits :: copy( __news, const_cast < _CharT * >( __olds ), __oldlen );_Traits :: assign( __news + __oldlen, __plen, __fill );return;}size_t __mod = 0;if( __adjust == ios_base :: internal && __num ){const locale & __loc = __io . _M_getloc( );const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > >( __loc );const bool __testsign =( __ctype . widen( '-' ) == __olds [ 0 ]|| __ctype . widen( '+' ) == __olds [ 0 ] );const bool __testhex =( __ctype . widen( '0' ) == __olds [ 0 ]&& __oldlen > 1&&( __ctype . widen( 'x' ) == __olds [ 1 ]|| __ctype . widen( 'X' ) == __olds [ 1 ] ) );if( __testhex ){__news [ 0 ] = __olds [ 0 ];__news [ 1 ] = __olds [ 1 ];__mod = 2;__news += 2;}else if( __testsign ){__news [ 0 ] = __olds [ 0 ];__mod = 1;++ __news;}}_Traits :: assign( __news, __plen, __fill );_Traits :: copy( __news + __plen, const_cast < _CharT * >( __olds + __mod ),__oldlen - __mod );}static bool __verify_grouping(const char *__grouping,size_t __grouping_size,const string &__grouping_tmp){const size_t __n =(__grouping_tmp. size() - 1UL);const size_t __min = min< unsigned long >(__n,((__grouping_size - 1UL)));size_t __i = __n;bool __test = true;for(size_t __j = 0UL;(__j < __min) && __test;(--__i , ++__j)) __test =((__grouping_tmp[__i]) == __grouping[__j]);for(;__i && __test;--__i) __test =((__grouping_tmp[__i]) == __grouping[__min]);if(((signed char )__grouping[__min]) > 0) __test &=((__grouping_tmp[0UL]) <= __grouping[__min]);return __test;}template < typename _CharT >_CharT *__add_grouping( _CharT * __s, _CharT __sep,const char * __gbeg, size_t __gsize,const _CharT * __first, const _CharT * __last ){size_t __idx = 0;size_t __ctr = 0;while( __last - __first > __gbeg [ __idx ]&& static_cast < signed char >( __gbeg [ __idx ] ) > 0 ){__last -= __gbeg [ __idx ];__idx < __gsize - 1 ? ++ __idx : ++ __ctr;}while( __first != __last )* __s ++ = * __first ++;while( __ctr -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}while( __idx -- ){* __s ++ = __sep;for( char __i = __gbeg [ __idx ];__i > 0;-- __i )* __s ++ = * __first ++;}return __s;}}namespace std{template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > :: sentry ::sentry( basic_ostream < _CharT, _Traits > & __os ): _M_ok( false ), _M_os( __os ){if( __os . tie( ) && __os . good( ) )__os . tie( ) -> flush( );if( __os . good( ) )_M_ok = true;else__os . setstate( ios_base :: failbit );}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::_M_insert( _ValueT __v ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_put_type & __np = __check_facet( this -> _M_num_put );if( __np . put( * this, * this, this -> fill( ), __v ) . failed( ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( short __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned short >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( int __n ){const ios_base :: fmtflags __fmt = this -> flags( ) & ios_base :: basefield;if( __fmt == ios_base :: oct || __fmt == ios_base :: hex )return _M_insert( static_cast < long >( static_cast < unsigned int >( __n ) ) );elsereturn _M_insert( static_cast < long >( __n ) );}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::operator <<( __streambuf_type * __sbin ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );sentry __cerb( * this );if( __cerb && __sbin ){try{if( ! __copy_streambufs( __sbin, this -> rdbuf( ) ) )__err |= ios_base :: failbit;}catch( ... ){this -> _M_setstate( ios_base :: failbit );}}else if( ! __sbin )__err |= ios_base :: badbit;if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::put( char_type __c ){sentry __cerb( * this );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const int_type __put = this -> rdbuf( ) -> sputc( __c );if( traits_type :: eq_int_type( __put, traits_type :: eof( ) ) )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::write( const _CharT * __s, streamsize __n ){sentry __cerb( * this );if( __cerb ){try{_M_write( __s, __n );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}}return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::flush( ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( this -> rdbuf( ) && this -> rdbuf( ) -> pubsync( ) == - 1 )__err |= ios_base :: badbit;}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >typename basic_ostream < _CharT, _Traits > :: pos_typebasic_ostream < _CharT, _Traits > ::tellp( ){pos_type __ret = pos_type( - 1 );try{if( ! this -> fail( ) )__ret = this -> rdbuf( ) -> pubseekoff( 0, ios_base :: cur, ios_base :: out );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}return __ret;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( pos_type __pos ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekpos( __pos,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &basic_ostream < _CharT, _Traits > ::seekp( off_type __off, ios_base :: seekdir __dir ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{if( ! this -> fail( ) ){const pos_type __p = this -> rdbuf( ) -> pubseekoff( __off, __dir,ios_base :: out );if( __p == pos_type( off_type( - 1 ) ) )__err |= ios_base :: failbit;}}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );return * this;}template < typename _CharT, typename _Traits >basic_ostream < _CharT, _Traits > &operator <<( basic_ostream < _CharT, _Traits > & __out, const char * __s ){if( ! __s )__out . setstate( ios_base :: badbit );else{const size_t __clen = char_traits < char > :: length( __s );_CharT * __ws = 0;try{__ws = new _CharT [ __clen ];for( size_t __i = 0;__i < __clen;++ __i )__ws [ __i ] = __out . widen( __s [ __i ] );}catch( ... ){delete [ ] __ws;__out . _M_setstate( ios_base :: badbit );return __out;}try{__ostream_insert( __out, __ws, __clen );delete [ ] __ws;}catch( ... ){delete [ ] __ws;throw;}}return __out;}}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >class basic_istream : virtual public basic_ios < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_ios < _CharT, _Traits > __ios_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >__num_get_type;typedef ctype < _CharT > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected :streamsize _M_gcount;public :explicitbasic_istream( __streambuf_type * __sb );virtual~ basic_istream( );class sentry;friend class sentry;__istream_type &operator >>( __istream_type &( * __pf )( __istream_type & ) );__istream_type &operator >>( __ios_type &( * __pf )( __ios_type & ) );__istream_type &operator >>( ios_base &( * __pf )( ios_base & ) );__istream_type &operator >>( bool & __n );__istream_type &operator >>( short & __n );__istream_type &operator >>( unsigned short & __n );__istream_type &operator >>( int & __n );__istream_type &operator >>( unsigned int & __n );__istream_type &operator >>( long & __n );__istream_type &operator >>( unsigned long & __n );__istream_type &operator >>( long long & __n );__istream_type &operator >>( unsigned long long & __n );__istream_type &operator >>( float & __f );__istream_type &operator >>( double & __f );__istream_type &operator >>( long double & __f );__istream_type &operator >>( void * & __p );__istream_type &operator >>( __streambuf_type * __sb );streamsizegcount( ) const;int_typeget( );__istream_type &get( char_type & __c );__istream_type &get( char_type * __s, streamsize __n, char_type __delim );__istream_type &get( char_type * __s, streamsize __n );__istream_type &get( __streambuf_type & __sb, char_type __delim );__istream_type &get( __streambuf_type & __sb );__istream_type &getline( char_type * __s, streamsize __n, char_type __delim );__istream_type &getline( char_type * __s, streamsize __n );__istream_type &ignore( );__istream_type &ignore( streamsize __n );__istream_type &ignore( streamsize __n, int_type __delim );int_typepeek( );__istream_type &read( char_type * __s, streamsize __n );streamsizereadsome( char_type * __s, streamsize __n );__istream_type &putback( char_type __c );__istream_type &unget( );intsync( );pos_typetellg( );__istream_type &seekg( pos_type );__istream_type &seekg( off_type, ios_base :: seekdir );protected :explicitbasic_istream( );template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < char , istreambuf_iterator< char , char_traits< char > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < char , char_traits< char > > : public ios_base{public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class ctype< char > __ctype_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;protected: class basic_ostream< char , char_traits< char > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< char , char_traits< char > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_istream< char , char_traits< char > > __istream_type;typedef class num_get< char , istreambuf_iterator< char , char_traits< char > > > __num_get_type;typedef class ctype< char > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class istreambuf_iterator < wchar_t , char_traits< wchar_t > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_get < wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ios < wchar_t , char_traits< wchar_t > > : public ios_base{public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class ctype< wchar_t > __ctype_type;typedef class num_put< wchar_t , ostreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_put_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;protected: class basic_ostream< wchar_t , char_traits< wchar_t > > *_M_tie;mutable char_type _M_fill;mutable bool _M_fill_init;class basic_streambuf< wchar_t , char_traits< wchar_t > > *_M_streambuf;const __ctype_type *_M_ctype;const __num_put_type *_M_num_put;const __num_get_type *_M_num_get;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_istream < wchar_t , char_traits< wchar_t > > : virtual public basic_ios < wchar_t , char_traits< wchar_t > > {public: typedef wchar_t char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< wchar_t > traits_type;typedef class basic_streambuf< wchar_t , char_traits< wchar_t > > __streambuf_type;typedef class basic_ios< wchar_t , char_traits< wchar_t > > __ios_type;typedef class basic_istream< wchar_t , char_traits< wchar_t > > __istream_type;typedef class num_get< wchar_t , istreambuf_iterator< wchar_t , char_traits< wchar_t > > > __num_get_type;typedef class ctype< wchar_t > __ctype_type;template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );protected: streamsize _M_gcount;public: class sentry ;friend class sentry ;protected: template < typename _ValueT >__istream_type &_M_extract( _ValueT & __v );};}template < typename _CharT, typename _Traits >class basic_istream < _CharT, _Traits > :: sentry{public :typedef _Traits traits_type;typedef basic_streambuf < _CharT, _Traits > __streambuf_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename _Traits :: int_type __int_type;explicitsentry( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );operator bool( ) const;private :bool _M_ok;};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char & __c ){return( __in >> reinterpret_cast < char & >( __c ) );}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s );template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, unsigned char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < class _Traits >inline basic_istream < char, _Traits > &operator >>( basic_istream < char, _Traits > & __in, signed char * __s ){return( __in >> reinterpret_cast < char * >( __s ) );}template < typename _CharT, typename _Traits >class basic_iostream: public basic_istream < _CharT, _Traits >,public basic_ostream < _CharT, _Traits >{public :typedef _CharT char_type;typedef typename _Traits :: int_type int_type;typedef typename _Traits :: pos_type pos_type;typedef typename _Traits :: off_type off_type;typedef _Traits traits_type;typedef basic_istream < _CharT, _Traits > __istream_type;typedef basic_ostream < _CharT, _Traits > __ostream_type;explicitbasic_iostream( basic_streambuf < _CharT, _Traits > * __sb );virtual~ basic_iostream( );protected :explicitbasic_iostream( );};template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __is );}#pragma GCC system_headernamespace std{template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > :: sentry ::sentry( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok( false ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );if( __in . good( ) ){if( __in . tie( ) )__in . tie( ) -> flush( );if( ! __noskip &&( __in . flags( ) & ios_base :: skipws ) ){const __int_type __eof = traits_type :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );const __ctype_type & __ct = __check_facet( __in . _M_ctype );while( ! traits_type :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space,traits_type :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( traits_type :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;}}if( __in . good( ) && __err == ios_base :: goodbit )_M_ok = true;else{__err |= ios_base :: failbit;__in . setstate( __err );}}template < typename _CharT, typename _Traits >template < typename _ValueT >basic_istream < _CharT, _Traits > &basic_istream < _CharT, _Traits > ::_M_extract( _ValueT & __v ){sentry __cerb( * this, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __num_get_type & __ng = __check_facet( this -> _M_num_get );__ng . get( * this, 0, * this, __err, __v );}catch( ... ){this -> _M_setstate( ios_base :: badbit );}if( __err )this -> setstate( __err );}return * this;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT & __c ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );try{const __int_type __cb = __in . rdbuf( ) -> sbumpc( );if( ! _Traits :: eq_int_type( __cb, _Traits :: eof( ) ) )__c = _Traits :: to_char_type( __cb );else__err |=( ios_base :: eofbit | ios_base :: failbit );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}if( __err )__in . setstate( __err );}return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in, _CharT * __s ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename _Traits :: int_type int_type;typedef _CharT char_type;typedef ctype < _CharT > __ctype_type;streamsize __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{streamsize __num = __in . width( );if( __num <= 0 )__num = numeric_limits < streamsize > :: max( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );int_type __c = __sb -> sgetc( );while( __extracted < __num - 1&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space,_Traits :: to_char_type( __c ) ) ){* __s ++ = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;* __s = char_type( );__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits >basic_istream < _CharT, _Traits > &ws( basic_istream < _CharT, _Traits > & __in ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef typename __istream_type :: int_type __int_type;const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( ! _Traits :: eq_int_type( __c, __eof )&& __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) )__c = __sb -> snextc( );if( _Traits :: eq_int_type( __c, __eof ) )__in . setstate( ios_base :: eofbit );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &operator >>( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, false );if( __cerb ){try{__str . erase( );_CharT __buf [ 128 ];__size_type __len = 0;const streamsize __w = __in . width( );const __size_type __n = __w > 0 ? static_cast < __size_type >( __w ): __str . max_size( );const __ctype_type & __ct = use_facet < __ctype_type >( __in . getloc( ) );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! __ct . is( ctype_base :: space, _Traits :: to_char_type( __c ) ) ){if( __len == sizeof( __buf ) / sizeof( _CharT ) ){__str . append( __buf, sizeof( __buf ) / sizeof( _CharT ) );__len = 0;}__buf [ __len ++ ] = _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}__str . append( __buf, __len );if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;__in . width( 0 );}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}template < typename _CharT, typename _Traits, typename _Alloc >basic_istream < _CharT, _Traits > &getline( basic_istream < _CharT, _Traits > & __in,basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim ){typedef basic_istream < _CharT, _Traits > __istream_type;typedef typename __istream_type :: int_type __int_type;typedef typename __istream_type :: __streambuf_type __streambuf_type;typedef typename __istream_type :: __ctype_type __ctype_type;typedef basic_string < _CharT, _Traits, _Alloc > __string_type;typedef typename __string_type :: size_type __size_type;__size_type __extracted = 0;const __size_type __n = __str . max_size( );ios_base :: iostate __err = ios_base :: iostate( ios_base :: goodbit );typename __istream_type :: sentry __cerb( __in, true );if( __cerb ){try{__str . erase( );const __int_type __idelim = _Traits :: to_int_type( __delim );const __int_type __eof = _Traits :: eof( );__streambuf_type * __sb = __in . rdbuf( );__int_type __c = __sb -> sgetc( );while( __extracted < __n&& ! _Traits :: eq_int_type( __c, __eof )&& ! _Traits :: eq_int_type( __c, __idelim ) ){__str += _Traits :: to_char_type( __c );++ __extracted;__c = __sb -> snextc( );}if( _Traits :: eq_int_type( __c, __eof ) )__err |= ios_base :: eofbit;else if( _Traits :: eq_int_type( __c, __idelim ) ){++ __extracted;__sb -> sbumpc( );}else__err |= ios_base :: failbit;}catch( ... ){__in . _M_setstate( ios_base :: badbit );}}if( ! __extracted )__err |= ios_base :: failbit;if( __err )__in . setstate( __err );return __in;}}namespace std{extern istream cin;extern ostream cout;extern ostream cerr;extern ostream clog;extern wistream wcin;extern wostream wcout;extern wostream wcerr;extern wostream wclog;static class Init __ioinit;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_ostream < char , char_traits< char > > : virtual public basic_ios < char , char_traits< char > > {public: typedef char char_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;typedef class basic_ios< char , char_traits< char > > __ios_type;typedef class basic_ostream< char , char_traits< char > > __ostream_type;typedef class num_put< char , ostreambuf_iterator< char , char_traits< char > > > __num_put_type;typedef class ctype< char > __ctype_type;class sentry ;friend class sentry ;protected: template < typename _ValueT >__ostream_type &_M_insert( _ValueT __v );};}int main(){int a = 5;(( *((class basic_ostream< char , char_traits< char > > *)(&cout))<<("Test case ")) << a) << endl< char , char_traits< char > > ;return 0;}struct _Rep_base {size_type _M_length;size_type _M_capacity;_Atomic_word _M_refcount;};struct _Rep : public _Rep_base{typedef other _Raw_bytes_alloc;static const size_type _S_max_size;static const char _S_terminal;static size_type _S_empty_rep_storage[];};class sentry {private: bool _M_ok;class basic_ostream< char , char_traits< char > > &_M_os;};namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class basic_streambuf < char , char_traits< char > > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef int_type int_type;typedef pos_type pos_type;typedef off_type off_type;typedef class basic_streambuf< char , char_traits< char > > __streambuf_type;namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ios < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_istream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class basic_ostream < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class istreambuf_iterator < char , char_traits< char > > ;}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> friend class ostreambuf_iterator < char , char_traits< char > > ;}template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,_CharT2 * > :: __type__copy_aux( istreambuf_iterator < _CharT2 >,istreambuf_iterator < _CharT2 >, _CharT2 * );template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,istreambuf_iterator < _CharT2 > > :: __typefind( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,const _CharT2 & );template < typename _CharT2, typename _Traits2 >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &operator >>( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > & );template < typename _CharT2, typename _Traits2, typename _Alloc >friend basic_istream < _CharT2, _Traits2 > &getline( basic_istream < _CharT2, _Traits2 > &,basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );protected: char_type *_M_in_beg;char_type *_M_in_cur;char_type *_M_in_end;char_type *_M_out_beg;char_type *_M_out_cur;char_type *_M_out_end;class locale _M_buf_locale;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class ostreambuf_iterator < char , char_traits< char > > : public iterator < output_iterator_tag , void , void , void , void > {public: typedef char char_type;typedef struct char_traits< char > traits_type;typedef class basic_streambuf< char , char_traits< char > > streambuf_type;typedef class basic_ostream< char , char_traits< char > > ostream_type;template < typename _CharT2 >friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,ostreambuf_iterator < _CharT2 > > :: __typecopy( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,ostreambuf_iterator < _CharT2 > );private: streambuf_type *_M_sbuf;bool _M_failed;};}namespace std /* temporary fix for g++ bug in namespace name qualification */ {template<> class num_put < char , ostreambuf_iterator< char , char_traits< char > > > : public facet{public: typedef char char_type;typedef class ostreambuf_iterator< char , char_traits< char > > iter_type;static class id id;protected: template < typename _ValueT >iter_type_M_insert_float( iter_type, ios_base & __io, char_type __fill,char __mod, _ValueT __v ) const;template < typename _ValueT >iter_type_M_insert_int( iter_type, ios_base & __io, char_type __fill,_ValueT __v ) const;};}
Is variable declaration? No
is variable reference? No
is function ref? No
Is it a function call?No
is it a deref exp?No
is it a pntr arr ref exp? No
is it a dot exp? No
is it an arrow exp? No
is it a cast exp? No
is address of op? No
is comma op?No
is it a conditional op?No
is it a param list?No
is it a func decl?No
is it a return stmt?No
is it an assign stmt?No
is it an overloadable op?No
Propagating NOT_STR_TYPE
runAllTests
runAllTests - done
backend/unparser
Warning: type names should not be this long... typeNameString.length() = 2518 
backend/unparser - done
