/**
 * \file DCL.C
 *
 * \note As written, these tests catch template declarations only if
 * instantiated.
 *
 * Copyright (c) 2007 Carnegie Mellon University.
 * All rights reserved.

 * Permission to use this software and its documentation for any purpose is
 * hereby granted, provided that the above copyright notice appear and that
 * both that copyright notice and this permission notice appear in supporting
 * documentation, and that the name of CMU not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WSTRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL CMU BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, RISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "rose.h"
#include "utilities.h"
#include <boost/regex.hpp>


/**
 * Const-qualify immutable objects
 *
 * \todo count assignments, if only one, report violation
 */
bool DCL00_C( const SgNode *node ) {
	const SgInitializedName *varName = isSgInitializedName(node);
	if (!varName)
		return false;

	/**
	 * Ignore variables generated by macros
	 */
	if ((varName->get_name().getString().substr(0,2) == "__")
	||  isCompilerGeneratedNode(node))
		return false;

	/**
	 * Ignore global variables
	 */
	if (isGlobalVar(varName))
		return false;

	/**
	 * Ignore variables that are already const, are function pointers, or are
	 * declared inside of a struct, enum, or as an argument to a function
	 */
	SgType *varType = varName->get_type();
	if (isConstType(varType)
	|| isConstType(varType->dereference())
	|| isConstType(varType->dereference()->dereference())
	|| isSgFunctionType(varType)
	|| isSgClassType(varType)
	|| findParentOfType(varName, SgCtorInitializerList)
	|| findParentOfType(varName, SgEnumDeclaration)
	|| findParentOfType(varName, SgClassDeclaration))
		return false;

	/**
	 * DCL13-C is a subset of this rule, figure out which rule we are dealing
	 * with here
	 */
	std::string ruleStr;
	std::string errStr;
	if (findParentOfType(varName, SgFunctionParameterList)) {
		/** ignore function prototypes, just worry about the definitions */
		const SgFunctionDeclaration *fnDecl = findParentOfType(varName, SgFunctionDeclaration);
		/**
		 * Disabling assertion due to C++ code
		 */
		if (!fnDecl)
			return false;
//		assert(fnDecl);
		if (!fnDecl->get_definition())
			return false;
		if (isSgPointerType(varName->get_type())
		||  isSgArrayType(varName->get_type())) {
			ruleStr = "DCL13-C";
			errStr = "Declare function parameters that are pointers to values not changed by the function as const: ";
		} else {
			return false;
		}
	} else {
		ruleStr = "DCL00-C";
		errStr = "Const-qualify immutable objects: ";
	}

	/**
	 * Ignore global variables or variables declared as extern
	 */
	const SgScopeStatement *varScope = varName->get_scope();
	if (isSgGlobal(varScope) || isExternVar(varName))
		return false;

	FOREACH_SUBNODE(varScope, nodes, i, V_SgVarRefExp) {
		const SgVarRefExp *iVar = isSgVarRefExp(*i);
		assert(iVar);
		if (getRefDecl(iVar) != varName)
			continue;

		const SgNode *parent = iVar->get_parent();
		while(isSgCastExp(parent)) {
			parent = parent->get_parent();
		}
		assert(parent);

		/**
		 * If the variable is written to or it's address is taken, we can no
		 * longer be sure it should be const, if it's a struct and gets
		 * dereferenced, who knows what's getting written there :/
		 */
		if (varWrittenTo(iVar)
		||  isSgArrowExp(parent)
		||  findParentOfType(iVar, SgAddressOfOp))
			return false;

		/**
		 * If the variable is a pointer or array, and we pass it to a function
		 * or as an argument to pointer arithmetic, or assign it's value
		 * somewhere, we can longer be sure it should be const
		 */
		if ((isSgPointerType(varType) || isSgArrayType(varType))
		&& (findParentOfType(iVar, SgFunctionCallExp)
			|| isSgAddOp(parent)
			|| isSgSubtractOp(parent)
			|| isSgAssignOp(parent)
			|| isSgPntrArrRefExp(parent)
			|| isSgPointerDerefExp(parent)
			|| isSgAssignInitializer(parent)))
			return false;
	}

	const std::string msg =  errStr + varName->get_name().getString();
	print_error(node, ruleStr.c_str(), msg.c_str(), true);
	return true;
}

/**
 * Do not reuse variable names in subscopes
 */
bool DCL01_C( const SgNode *node ) {
	const SgInitializedName *varInitName = isSgInitializedName(node);
	if (!varInitName)
		return false;
	const SgName varName = varInitName->get_name();
	const SgScopeStatement *varScope = varInitName->get_scope();
	assert(varScope);
	while(!isSgGlobal(varScope)) {
		varScope = varScope->get_scope();
		if(varScope->symbol_exists(varName)) {
			print_error(node, "DCL01-C", ("Do not reuse variable names in subscopes: " + varName.getString()).c_str(), true);
			return true;
		}
	}

	return false;
}

std::string normalize_string(std::string str, bool isExtern) {
	size_t found;

	while((found = str.find_first_of("1")) != std::string::npos)
		str[found] = 'l';
	while((found = str.find_first_of("0")) != std::string::npos)
		str[found] = 'O';
	while((found = str.find_first_of("2")) != std::string::npos)
		str[found] = 'Z';
	while((found = str.find_first_of("5")) != std::string::npos)
		str[found] = 'S';
	while((found = str.find_first_of("8")) != std::string::npos)
		str[found] = 'B';

	unsigned int len = isExtern ? 31 : 63;

	if (str.size() > len)
		str = str.substr(0,len);

	return str;
}

void DCL02_report_error(const SgInitializedName *var) {
	unsigned int len = isExternVar(var) ? 31 : 63;
	std::string varStr = var->get_name().str();
	std::string ruleStr;
	std::string errStr;
	bool warning;
	if (varStr.size() > len) {
		ruleStr = "DCL31-C";
		errStr = "Guarantee that mutually visible identifiers are unique";
		warning = false;
	} else {
		ruleStr = "DCL02-C";
		errStr = "Use visually distinct identifiers";
		warning = true;
	}
	const std::string msg = errStr + ": " + varStr;
	print_error(var, ruleStr.c_str(), msg.c_str(), warning);
}

/**
 * Use visually distinct identifiers 
 *
 * \note also checks DCL31-C
 */
bool DCL02_C( const SgNode *node ) {
	static std::map<const SgScopeStatement *, std::set<std::string> > scopeMap;
	static std::map<std::string, const SgInitializedName *> strVarMap;

	const SgScopeStatement *scope = isSgScopeStatement(node);
	if (!scope)
		return false;

	bool violation = false;

	if (isSgGlobal(scope)) {
		std::set<std::string> externNames;

		/** populate scopeMap */
		FOREACH_SUBNODE(scope, nodes, i, V_SgInitializedName) {
			SgInitializedName *var = isSgInitializedName(*i);
			assert(var);
			if (isCompilerGeneratedNode(var)
			|| !isSgDeclarationStatement(var->get_parent())
			|| findParentOfType(var, SgCtorInitializerList)
			|| findParentOfType(var, SgClassDeclaration) // Might be too strong
			|| var->get_name().getString().empty()
			|| (var->get_name().getString().substr(0,2) == "__"))
				continue;

			/** Ignore function prototypes */
			const SgFunctionDeclaration * fnDecl = findParentOfType(var, SgFunctionDeclaration);
			if (fnDecl && !fnDecl->get_definition())
				continue;

			if (isExternVar(var)) {
				if (externNames.find(var->get_name().getString()) != externNames.end())
					continue;

				externNames.insert(var->get_name().getString());
			}

			const SgScopeStatement *varScope = var->get_scope();
			std::string str (normalize_string(var->get_name().str(), isExternVar(var)));
			if (scopeMap[varScope].find(str) != scopeMap[varScope].end()) {
				DCL02_report_error(var);
				violation = true;
			} else {
				scopeMap[varScope].insert(str);
				strVarMap[str] = var;
			}
		}
		return false;
	}

	std::set<std::string> ids;
	do {
		if (isCompilerGeneratedNode(scope))
			continue;
		for (std::set<std::string>::iterator i = scopeMap[scope].begin(); i != scopeMap[scope].end(); i++) {
			if (ids.find(*i) != ids.end()) {
				DCL02_report_error(strVarMap[*i]);
				violation = true;
			} else {
				ids.insert(*i);
			}
		}
	} while (!isSgGlobal(scope) && (scope = scope->get_scope()));

	return violation;
}

/**
 * Do not declare more than one variable per declaration 
 */
bool DCL04_C( const SgNode *node ) {
	const SgVariableDeclaration *varDec = isSgVariableDeclaration(node);
	if (!varDec)
		return false;

	/**
	 * \note Due to a bug in ROSE this comparison will always be false
	 */
	if (varDec->get_variables().size() > 1) {
		print_error(node, "DCL04-C", "Do not declare more than one variable per declaration", true);
		return true;
	}

	return false;
}

static unsigned int DCL05_score(const SgType *t) {
	unsigned int score = 0;
	unsigned int modifiers = 0;
	const SgType *d = NULL;
	do {
		/** score modifiers because they add clutter */
		if (t->get_modifiers())
			modifiers += t->get_modifiers()->get_nodes().size();
		t = stripModifiers(t);

		/** obviously, typedefs should break us out */
		if (t != stripTypedefs(t))
			break;
		/** Count functions as two points */
		if (isSgFunctionType(t)) {
			SgTypePtrList &args = isSgFunctionType(t)->get_argument_list()->get_arguments();
			for (SgTypePtrList::iterator i = args.begin(); i != args.end(); i++) {
				score += DCL05_score(*i);
			}
			score+=2;
		}
		/** Arrays will derefence twice, so let's only score them once */
//		if (isSgArrayType(t))
//			score;
		/** score all other pointers as one point */
		if (isSgPointerType(t)) {
			score++;
		}
		/**
		 * \bug ROSE is missing the const version of derefence()
		 */
		d = const_cast<SgType *>(t)->dereference();
	} while ((t != d) && (t = d));
	return score + modifiers;
//	return score;
}

/**
 * Use typedefs to improve code readability
 *
 * \note our algorithm is to count open parens/brackets... if there are more
 * than 2, we flag
 */
bool DCL05_C( const SgNode *node ) {
	const SgInitializedName *var = isSgInitializedName(node);
	const SgFunctionDeclaration *fn = isSgFunctionDeclaration(node);
	if (!(var || fn))
		return false;

	/**
	 * Ignore function definitions
	 */
//	const SgDeclarationStatement *varDecl = var->get_declaration();
//	assert(varDecl);
//	if (isSgFunctionDeclaration(varDecl) && isSgFunctionDeclaration(varDecl)->get_definition())
//		return false;

	const SgType *t = var ? var->get_type() : fn->get_type();
	assert(t);
	const unsigned int threshold = 5;
	unsigned int score = DCL05_score(t);
	if (score  >= threshold) {
		print_error(node, "DCL05-C", "Use typedefs to improve code readability", true);
		return true;
	}
	return false;
}

bool DCL(const SgNode *node) {
  bool violation = false;
  violation |= DCL00_C(node);
  violation |= DCL01_C(node);
  violation |= DCL02_C(node);
  violation |= DCL04_C(node);
  violation |= DCL05_C(node);
  return violation;
}
