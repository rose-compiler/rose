// -- -*- haskell; folding-mode -*- (Fake Emacs mode for syntax highlighting)
// -- vim: syntax=fula
// -- ------------------------------------------------------------------------
// -- Authors: Gergo Barany, 2006/2009 (original constprop/points-to info)
// --          Adrian Prantl, 2008-2010 (interval extensions)
// --          
// -- Contact: adrian@complang.tuwien.ac.at
// --
// -- TOP: Variable is not analyzABLE
// -- (min,max): Variable has the interval min =< v =< max
// -- BOT: Variable is not yet analyzED
// -- Please note that, however, the values min and max are again _lifted_
// -- integers, where bot = -inf and top = +inf.// -- 
// -- 
// -- remaining problems:
// -- * type casts are ignored
// -- * interval arithmetic needs to be checked for correctness (esp. | and &)
// -- * wraparound is untestet
// -- * structures are not handled correctly yet
// -- 
// -- This program is free software; you can redistribute it and/or modify
// -- it under the terms of the GNU General Public License as published by
// -- the Free Software Foundation; version 3 of the License.
// -- 
// -- This program is distributed in the hope that it will be useful,
// -- but WITHOUT ANY WARRANTY; without even the implied warranty of
// -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// -- GNU General Public License for more details.
// -- 
// -- ------------------------------------------------------------------------

SET
    VarIdList = list(VariableId)
DOMAIN
    BoolL = flat(bool) 
ENDDOMAIN

PROBLEM Interval_Analysis
  direction:  forward
  carrier:    itvl_State
  init:       bot
  init_start: lift(initialize_globals([->top], globals))
  combine:    comb
  retfunc:    ret
  widening:   wide
  equal:      eq
  prefix:     intvl_

TRANSFER

FunctionEntry(name), _: 
  let result = 
  if @ != bot then
    @
  else
    bot // -- top
  ; in // -- println("entering function ", val-aststring(name)) 
       result
  ;

ExprStatement(exp), _:
  if @ != bot then
    let state = eval(exp, @, context)!2!2 ; in
      // -- println("\neval => ", state) 
      state
  else
    bot
  ;

ArgumentAssignment(VarRefExp(_) as var, exp), _:
  if @ != bot then
   // -- In order to kill all tmpvars, we must here use the state returned
   // -- by eval.
      let e = eval(exp, @, context); in
      let value = e!1!2;
          state <= e!2!2; in
      lift(state\[varref_varid(var) -> value])
  else
    bot
  ;

ParamAssignment(VariableSymbol(_) as var, VariableSymbol(_) as param), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(param)!}]
    // -- kill rhs
    \[varsym_varid(param) -> top])
  else
    bot
  ;

ReturnAssignment(VariableSymbol(_) as var, VariableSymbol(_) as retvar), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(retvar)!}]
    // -- kill rhs
    \[varsym_varid(retvar) -> top])
  else
    bot
  ;

ScopeStatement(IfStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, false, context);

ScopeStatement(IfStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, false, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, true, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, true, context);
  // -- let result = branch(cond, @, false, true, context);
  // -- in println(label,": ",@," -> ",result) result;
  
LogicalIf(cond), true_edge:
  branch(cond, @, true, false, context);

LogicalIf(cond), false_edge:
  branch(cond, @, false, false, context);

UndeclareStmt(vars), _:
  kill_vars(@, vars);

FunctionExit(_, vars), _:
  kill_vars(@, vars);

// -- Local edge handling is somewhat obscure. We need to remove global and
// -- aliased variables from the local analysis info because the called
// -- function may modify them. We used to "remove" them by setting their
// -- values to top, but since top wins out in the combination operator,
// -- this meant information loss if the local edge's analysis value was
// -- propagated first (rather than evaluating the path through the function
// -- first, applying the retfunc, and propagating that result). Solution:
// -- Remove globals by setting their values to bot; the analysis can come
// -- back later and fill in some interval. Hope this works now.
FunctionCall(name,_), local_edge:
  if @ != bot then
    let f <= @; in
      let result =
   /* lift([(v,i)->top !! (v,i) <- f\top,
                          if islocal(v) && !isaliasedlocal(v, context)]) */
      let locals = ([(v,i)->top !! (v,i) <- f\top,
                     if islocal(v) && !isaliasedlocal(v, context)]);
          globals = [(v,bot)->top !! (v,_) <- f\top,
                     if isglobal(v) || isaliasedlocal(v, context)];
      in  lift(override(locals, globals))
      ; in /*println(val-aststring(name), " local: ", result)*/ result
  else
    bot
  ;

FunctionCall(name,_), call_edge:
  if @ != bot then
    let f <= @; in
    // -- GB: values of (possibly) aliased locals must also be passed to the
    // -- function since they might be accessed there
      lift([(v,i)->top !! (v,i) <- f\top, if isglobal(v)
                                          || isaliasedlocal(v, context)])
  else
    bot
  ;

// -- external calls (which include function pointer calls, even if resolved
// -- with the --resolve-funcptr-calls command line flag) are treated like
// -- normal calls
ExternalCall(_,_,_), local_edge:
  if @ != bot then
    let f <= @; in
      let locals = ([(v,i)->top !! (v,i) <- f\top,
                     if islocal(v) && !isaliasedlocal(v, context)]);
          globals = [(v,bot)->top !! (v,_) <- f\top,
                     if isglobal(v) || isaliasedlocal(v, context)];
      in  lift(override(locals, globals))
  else
    bot
  ;

ExternalCall(_,_,_), call_edge:
  if @ != bot then
    let f <= @; in
      lift([(v,i)->top !! (v,i) <- f\top, if isglobal(v)
                                          || isaliasedlocal(v, context)])
  else
    bot
  ;

_, _: @;

SUPPORT

dup(a) = (a, a);
duplift(a) = dup(lift(a));

// -- create a "lifted tuple"
ltup :: snum,snum -> itvl_Interval;
ltup(a,b) = (lift(a), lift(b));

eval :: Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
eval(_, bot, _) = bot;
eval(_, top, _) = top;
eval(exp, state, context) =  
  // -- println("eval(", exp, ",", state)
  let s <= state; in

  case exp of 
    CommaOpExp(exp1, exp2) => let state1 = 
                                eval(exp1, state, context)!2!2; in
                                eval(exp2, state1, context);
    AssignOp(VarRefExp(_) as var, AggregateInitializer(_) as i)
                           => let st = initialize(s, varref_varid(var),
                                                     expr_type(var), i,
                                                     context);
                              in  (top, lift(st));
    AssignOp(VarRefExp(_) as var, ExprListExp(_) as i)
                           => let st = initialize(s, varref_varid(var),
                                                     expr_type(var), i,
                                                     context);
                              in  (top, lift(st));
    ConditionalExp(cond, t, f) =>
        // -- Evaluate the condition twice, once for truth and once for
        // -- falsity; if only one of these holds, use that state, otherwise
        // -- use a merged state.
        let tb = branch(cond, state, true, false, context); in
        let fb = branch(cond, state, false, false, context); in
        let cs = (if   tb = bot then fb else
                  if   fb = bot then tb
                  else comb(tb, fb)); in
        // -- Now we have the state after the evaluation of the condition.
        // -- Evaluate one or both of the "true" and "false" expressions.
        let tt = eval(t, cs, context);
            ff = eval(f, cs, context);
        in  if   tb = bot then ff else
            if   fb = bot then tt
            else (combi(tt!1!2, ff!1!2), comb(tt!2!2, ff!2!2));

    _ =>
      if is_unary(exp) then
        unary(unary_get_child(exp), exp, state, context)
      else if is_binary(exp) then
        let r = binary(binary_get_left_child(exp), binary_get_right_child(exp),
          exp, state, context); in r // --print("BINARY <----", r, "\n") r
      else if is_value(exp) then
        (value_interval(exp), state)
    else case exp of
      VarRefExp(name)       =>  // --print("###is_VARREF") 
                                // --print(val-aststring(name), "\n") 
                                let id = varref_varid(exp); in
                                if is_tmpvarid(id) then
                                    let s2 = s\[id -> top]; in
                              // -- println("killing tmp var ref ", exp,
                              // --         ":\n    old state = ", s,
                              // --         ",\n    new state = ", s2)
                                    (s{!id!}, lift(s2))
                              // -- The interval analysis is easily extended
                              // -- to pointers ranging over arrays by
                              // -- simply treating an array's name as (an
                              // -- offset value of) 0; pointer arithmetic
                              // -- then automagically maps to offset
                              // -- interval arithmetic.
                                else if is_array_type(expr_type(exp)) then
                                    (duplift(0), state)
                                else
                                    (s{!id!}, state);
      AssignInitializer(e1) => eval(e1, state, context);
      NewExp(_,_,_)         => (top, state);
      FunctionRefExp()      => (top, state);
      NullExpression()      => (duplift(1), state); // -- treat for (;;) as always true
      _                     => println("**WARNING: ignoring unknown exp: ",
                                       exp, ": ", expr_asttext(exp))
                               (top, state); 
                                      // --(top, lift([-> top]));
    endcase   ;
  endcase;


binary :: Expression, Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
binary(left, right, exp, state, context) =
  // -- Evaluate the right child expression, yielding a (value, state)
  // -- pair assigned to rlifted and rs, respectively. Evaluate the left
  // -- child in state rs and assign to llifted and ls. Note that we may not
  // -- in all cases drop llifted or rlifted! Even if the lhs has an unknown
  // -- value, we can evaluate plain assignments. Conversely, if the rhs has
  // -- an unknown value, we must be careful with op-assign operators.
  // --println("BINARY(", exp, " :: ", expr_asttext(exp), ") in state ", state)
  let rr = eval(right, state, context); in
  let rlifted = rr!1!2; rs = rr!2!2; in
  let ll = eval(left, rs, context); in
  let llifted = ll!1!2; ls = ll!2!2; in
  let dontknow = (top, state); in
  // -- Factored out handling of op-assign operators.
  if is_op_assign(exp) then
    op_assign_effects(ls, exp, llifted, rlifted, context)
  else 
      let lr1 = rlifted!1!2; lr2 = rlifted!2!2;
          ll1 = llifted!1!2; ll2 = llifted!2!2; in      
      case exp of
    // -- If this is a plain assignment operation, update the state without
    // -- regard for the old value of the lhs.
    AssignOp(_, _) => // --println("ASSIGNOP: ", left, "=", rr!1!2, " in state ", rr!2!2, " ...")
      updatestate(ls, left,
                  if rlifted = top || rlifted = bot then top else rlifted,
                  context);

    // -- PntrArrRefExp is special in that we can also derive some
    // -- information if not all operands have known interval values.
    PntrArrRefExp(_, _) =>
      // -- println("ARRAY: ", exp, " :: ", expr_asttext(exp), ")")
      let id = expr_exprid(exp); in
      let l = exprid_location_cs(id, context); in
      let syms = location_varsyms(l); in
      let s2 = constrain_array_index(ls, expr_type(left), right); in
      let result =
          if is_array_type(expr_type(exp)) then
            (top, s2)  // -- multidim array not fully dereferenced, no value
          else
            (merged_var_values(s2, syms), s2);
      in  // println("arr ", exp, " result: ", result)
          result;

    // -- arithmetic binary operators w/o bad checking
    AddOp(_, _)      => (plus(ll1,ll2,lr1,lr2), ls);
    SubtractOp(_, _) => (minus(ll1,ll2,lr1,lr2), ls);
    MultiplyOp(_, _) => (multiply(ll1,ll2,lr1,lr2), ls);
    IntegerDivideOp(_, _) => (divide(ll1,ll2,lr1,lr2), ls);
    ModOp(_, _)     => (modulo(ll1,ll2,lr1,lr2), ls);
    LshiftOp(_, _)  => (lshift(ll1,ll2,lr1,lr2), ls);
    RshiftOp(_, _)  => (rshift(ll1,ll2,lr1,lr2), ls);
    BitAndOp(_, _)  => (and(ll1,ll2,lr1,lr2), ls);
    BitOrOp(_, _)   => (or(ll1,ll2,lr1,lr2), ls);
    BitXorOp(_, _)  => (xor(ll1,ll2,lr1,lr2), ls);

    // -- other arithmetic, logical, comparison operators
    _ => 
      if bad(rlifted) then dontknow else
      if bad(llifted) then dontknow else
      let r1 <= rlifted!1!2; r2 <= rlifted!2!2;
          l1 <= llifted!1!2; l2 <= llifted!2!2; in
      let constp = (l1=l2) && (r1=r2);
          pointerp = is_pointer_type(expr_type(left))
                  || is_pointer_type(expr_type(right)); in
      // -- println("evalbin(", exp, ";;; ", llifted, ", ", rlifted, ")")
      
      case exp of
        EqualityOp(_, _) =>
          if !pointerp && constp then (duplift(bool_int(l1=r1)), ls) else
          if !pointerp && (l2 < r1 || l1 > r2) then (duplift(0), ls) else
          dontknow  ;

        LessThanOp(_, _)  =>
          if !pointerp && l2 < r1 then (duplift(1), ls) else
          if !pointerp && l1 >=r2 then (duplift(0), ls) else
          dontknow  ;

        GreaterThanOp(_, _) =>
          if !pointerp && l1 > r2 then (duplift(1), ls) else
          if !pointerp && l2 <=r1 then (duplift(0), ls) else
          dontknow  ;

        NotEqualOp(_, _) =>
          if !pointerp && l2 < r1 || (l1 > r2) then (duplift(1), ls) else
          if !pointerp && constp  then (duplift(bool_int(l1!=r1)), ls) else
          dontknow ;

        LessOrEqualOp(_, _) =>
          if !pointerp && l2 <= r1 then (duplift(1), ls) else
          if !pointerp && r2 <  l1 then (duplift(0), ls) else
          dontknow  ;

        GreaterOrEqualOp(_, _) =>
          if !pointerp && l1 >= r2 then (duplift(1), ls) else
          if !pointerp && r1 >  l2 then (duplift(0), ls) else
          dontknow  ;

        AndOp(_, _) => if constp then
                        (duplift(bool_int((l1 != 0) && (r1 != 0))), ls)
                       else dontknow ;

        OrOp(_, _)  => if constp then
                        (duplift(bool_int((l1 != 0) || (r1 != 0))), ls)
                       else dontknow ;

        DivideOp(_, _)  => dontknow;

        ScopeOp(_, _)       => (ltup(r1, r2), ls);
        _ => println("**WARNING: unsupported binary: ", exp)
             (top, lift([-> top]));
      endcase
     ;
  endcase;

unary :: Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
unary(child, exp, state, context) = 
  // --print("UNARY(", exp, ")\n")
  let ee = eval(child, state, context); in
  let er = ee!1!2; es = ee!2!2; in
    // -- if child node is a dereference expression, consult pointer analysis
    case exp of
      PointerDerefExp(_)  => // -- println("PointerDerefExp in context ", context)
                             let id = expr_exprid(exp); in
                             let l = exprid_location_cs(id, context); in
                             let syms = location_varsyms(l); in
                             if is_array_type(expr_type(exp)) then
                               (top, es)
                             else
                                (merged_var_values(es, syms), es);
      // -- special handling for additive unary operators
      MinusMinusOp(_) => if unary_is_prefix(exp) then
                            updatestate(es, child,
                                        (liftminus(er!1!2, lift(1)),
                                         liftminus(er!2!2, lift(1))),
                                        context)
                         else
                            let st = updatestate(es, child,
                                                 (liftminus(er!1!2, lift(1)),
                                                  liftminus(er!2!2, lift(1))),
                                                 context);
                            in  (er, st!2!2);  // -- old value, new state
      PlusPlusOp(_)   => if unary_is_prefix(exp) then
                            updatestate(es, child,
                                        (liftplus(er!1!2, lift(1)),
                                         liftplus(er!2!2, lift(1))),
                                        context)
                         else
                            let st = updatestate(es, child,
                                                 (liftplus(er!1!2, lift(1)),
                                                  liftplus(er!2!2, lift(1))),
                                                 context);
                            in  (er, st!2!2);  // -- old value, new state
      MinusOp(_)    => ((liftminus(lift(0), er!2!2),
                         liftminus(lift(0), er!1!2)), es);
      UnaryAddOp(_) => (er, es);
    // -- otherwise, see if this is some arithmetic node
      _ =>
    // -- if child node is not analyzable, bail out
      if bad(er) then (top, es) else // BUG!
      let e1 <= er!1!2; e2 <= er!2!2; in
        case exp of
          NotOp(_)      => (ltup(bool_int(e2 = 0), bool_int(e1 = 0)), es);
          CastExp(_, _) => eval(child, es, context);
          // -- an address-of operation does not yield a useful value;
          // -- ignore it here, the pointer analysis knows how to handle it;
          // -- however, we use state es to reflect possible side effects of
          // -- evaluating the operand
          AddressOfOp(_)  => (top, es);
          BitComplementOp(_) => (complement(e1, e2), es);

          _ => println("unsupported unary: ", exp)
               (top, lift([-> top]));
        endcase;
    endcase
  ;

bad((top, _)) = true;
bad((bot, _)) = true;
bad((_, top)) = true;
bad((_, bot)) = true;
bad((_,_)) = false;

bool_int :: bool -> snum;
bool_int(b) =
  if b then 1 else 0 ;

int_bool :: snum -> bool;
int_bool(0) = false;
int_bool(_) = true;

lvalue(VarRefExp(_)) = true;
lvalue(PointerDerefExp(_)) = true;
lvalue(PntrArrRefExp(_,_)) = true;
lvalue(DotExp(_,_)) = true;
lvalue(ArrowExp(_,_)) = true;
lvalue(_) = false;

updatestate :: itvl_State, Expression, itvl_Interval, ContextInfo -> itvl_IntervalStatePair;
updatestate(bot, _, _, _) = (top,bot);
// -- Global variables passed through calls may become bot. However, we
// -- don't want to drag bot values all the way through the analysis. In any
// -- computation based on a bot value, kill the result by turning it into
// -- top instead.
updatestate(state, exp, bot, context) =
    updatestate(state, exp, top, context);
// -- Update state state by assigning the value value to the variable
// -- referenced by expression exp (if any). Yields a pair of the value
// -- and the new state.
updatestate(state, exp, value, context) = 
// -- print("updatestate(", state, ", ", exp, ", ", value, ")\n") 
  let s <= state; in 
  let newstate =
    case exp of
      VarRefExp(var) => lift(s\[varref_varid(exp) -> value]);
   // -- ignore comparisons against null pointer constants, which due to
   // -- complex issues have location assigned by the points-to analysis
      CastExp(IntVal(_), _) => state;
      _ => let exprid = expr_exprid(exp);
           in  if exprid_has_location(exprid) then
               let loc = exprid_location_cs(exprid, context); in
               let syms = location_varsyms(loc);
               in  // -- println("updating location ", loc, " with vars: ", syms)
                   case syms of
                // -- no var: could be an error; could also be harmless, if
                // -- this updatestate call resulted from an equality check
                   [!]    => if lvalue(exp) then 
                                 println("**ERROR: no varsyms for exp in updatestate: ", exp, " :: ", expr_asttext(exp))
                                 error("Exiting")
                             else state;
                // -- singleton var, may be an array name: strong update of
                // -- scalar variables, weak update of arrays
                   v::[!] => if is_array_location(loc) then
                                 lift(weak_update_v(s, varsym_varid(v), value))
                             else
                                 lift(s\[varsym_varid(v) -> value]);
                // -- otherwise: more than one var, weak update
                   _      => // -- println("info: weak update ", syms, " := ", value)
                             lift(weak_update(s, syms, value));
               endcase
           else
               println("info: cannot updatestate for lhs expression: ",
                       exp, " :: ", expr_asttext(exp))
               state;
    endcase;
  in // --print("\n=> ", state, "\n") 
     (value, newstate);

weak_update :: itvl_fState, *VariableSymbolNT, itvl_Interval -> itvl_fState;
weak_update(s, [!], _) = // -- println("weak update result: ", s)
    s;
weak_update(s, vsym::vs, value) =
    let v = varsym_varid(vsym); in
    let newstate = weak_update_v(s, v, value);
    in  weak_update(newstate, vs, value);

weak_update_v(s, v, value) =
    let v_old_val = s{!v!}; in
    let v_new_val = combi(v_old_val, value);
    in  s\[v -> v_new_val];

// merged_var_values(s, vsyms): Look up an interval that covers the values
// of all variables in vsyms in state s.
merged_var_values :: itvl_State, *VariableSymbolNT -> itvl_Interval;
merged_var_values(top, _) = top;
merged_var_values(_, [!]) =
    // -- println("in merged_var_values: merging empty variable list!")
    top;
merged_var_values(lift(s), v::[!]) = s{!varsym_varid(v)!};
merged_var_values(lift(s) as ls, v::vs) =
    let merged = merged_var_values(ls, vs);
    in  combi(s{!varsym_varid(v)!}, merged);

initialize :: itvl_fState, VariableId, Type, Expression, ContextInfo -> itvl_fState;
initialize(s, v, ArrayType(BasicType(_), _) as t, // -- TODO: use array size
                 AggregateInitializer(initexpr), context) =
    initialize(s, v, t, initexpr, context);
initialize(s, v, ArrayType(BasicType(_), _), // -- TODO: use array size
                 ExprListExp(exprs), context) =
 // default value: 0 (missing initializers default to 0)
    initialize_array(s\[v -> duplift(0)], v, exprs, context);
// ignore unknown initializer
initialize(s, _, _, _, _) = s;

initialize_array :: itvl_fState, VariableId, *Expression, ContextInfo -> itvl_fState;
initialize_array(s, _, [!], _) = s;
initialize_array(s, var, expr::exprs, ctx) =
    let value = eval(expr, lift(s), ctx)!1!2; // -- FIXME: assumes pure exprs
    in  initialize_array(weak_update_v(s, var, value), var, exprs, ctx);

is_op_assign :: Expression -> bool;
is_op_assign(PlusAssignOp(_,_)) = true;
is_op_assign(MinusAssignOp(_,_)) = true;
is_op_assign(MultAssignOp(_,_)) = true;
is_op_assign(DivAssignOp(_,_)) = true;
is_op_assign(ModAssignOp(_,_)) = true;
is_op_assign(LshiftAssignOp(_,_)) = true;
is_op_assign(RshiftAssignOp(_,_)) = true;
is_op_assign(IorAssignOp(_,_)) = true;
is_op_assign(AndAssignOp(_,_)) = true;
is_op_assign(XorAssignOp(_,_)) = true;
is_op_assign(_) = false;

// -- Assign-op operators: If either operand is unknown, kill the lhs.
op_assign_effects :: itvl_State, Expression, itvl_Interval, itvl_Interval,
                     ContextInfo -> itvl_IntervalStatePair;
op_assign_effects(state, exp, llifted, rlifted, context) =
  let left = binary_get_left_child(exp); 
      lr1 = rlifted!1!2; lr2 = rlifted!2!2;
      ll1 = llifted!1!2; ll2 = llifted!2!2; 
  in
  case exp of
  // -- We have special lifted arithmetic for + and -, which means that we
  // -- can be more precise here than if we required all four involved
  // -- values to be known.
    PlusAssignOp(_, _)  => updatestate(state, left,  plus(ll1,ll2,lr1,lr2), context);
    MinusAssignOp(_, _) => updatestate(state, left, minus(ll1,ll2,lr1,lr2), context);
    MultAssignOp(_, _)  => updatestate(state, left, multiply(ll1,ll2,lr1,lr2), context);
    DivAssignOp(_, _)   => updatestate(state, left, divide(ll1,ll2,lr1,lr2), context);
    ModAssignOp(_, _)   => updatestate(state, left, modulo(ll1,ll2,lr1,lr2), context);
    LshiftAssignOp(_, _)=> updatestate(state, left, lshift(ll1,ll2,lr1,lr2), context);
    RshiftAssignOp(_, _)=> updatestate(state, left, rshift(ll1,ll2,lr1,lr2), context);
    IorAssignOp(_, _)   => updatestate(state, left,  or(ll1,ll2,lr1,lr2), context);
    AndAssignOp(_, _)   => updatestate(state, left, and(ll1,ll2,lr1,lr2), context);
    XorAssignOp(_, _)   => updatestate(state, left, xor(ll1,ll2,lr1,lr2), context);
    _ => error("unexpected assign-op expression");
  endcase;

// -- constrain_array_index: If an array with a known size is indexed with a
// -- varref expression, force the variable's interval to be at most the
// -- array's valid index range (0..size-1).
constrain_array_index :: itvl_State, Type, Expression -> itvl_State;
constrain_array_index(s, ArrayType(_, size), VarRefExp(_) as varref) =
    let state <= s; in
    if val-astint(size) > 0 then  // size is -1 if unknown
        let var = varref_varid(varref); in
        let index_range = ltup(0, val-astint(size) - 1);
            known_range = state{!var!}; in
        let constrained_range = intersect_itvls(known_range, index_range);
        in  // -- println("constrained ", var, " from ", known_range,
            // --         ", with ", index_range, ", to ", constrained_range)
            lift(state\[var -> constrained_range])
    else
        s;
constrain_array_index(s, _, _) = s;

branch :: Expression, itvl_State, bool, bool, ContextInfo -> itvl_State;
branch(exp, state, edge, isLoopBody, context) =
  // --println("branching... exp: ", exp, "\tstate: ", state, "\tedge: ", edge)

  let pair = eval(exp, state, context); in
  let c = interval_to_bool(pair!1!2); 
          newstate = pair!2!2; in
  // --println("pair = ", pair, ", c = ", c, ", newstate = ", newstate)
  if (isLoopBody && c != top && drop(c) = false && edge = true) then
    // -- Finished loop
    // --print("bot\n") 
    // --print("Never\n") 
    top
  else if (c = top || (isLoopBody && value_interval(exp) = top)) then
    // -- We don't know for sure which edge will be taken, or this is a loop
    // -- condition. Given our widening operator, we must always look at the
    // -- effects of loop conditions and "pre-widen" information on loop
    // -- variables. See the comment block above the adjust_* functions for
    // -- more details.
    // -- print("c=top\n") 
    // -- print("Maybe\n") 
    // -- let result = 
    branch_condition_effects(exp, state, newstate, edge, isLoopBody, context)
    // --; in println(">>>> ", result) result
  else if c = bot then 
    // -- Ignore this branch anyway 
    // --print("c=bot\n")
    state
  else if drop(c) = edge then  
    // -- This edge will ALWAYS be taken
    // -- println(newstate) 
    // -- print("Always\n") 
    newstate
  else 
    // -- This edge will NEVER be taken
    // --print("bot\n") 
    // --print("Never\n") 
    bot
    ;

branch_condition_effects :: Expression, itvl_State, itvl_State, bool, bool,
                            ContextInfo -> itvl_State;
branch_condition_effects(exp, state, newstate, edge, isLoopBody, context) =
  // -- println("branch_condition_effects ", exp)
  if is_binary(exp) then
    if is_comparison(exp) then
      comparison_effects(exp, state, newstate, edge, isLoopBody, context)
    else
      case exp of
        AndOp(exp1, exp2) => // -- println("AND: ", state)
          let state1 =
            branch_condition_effects(
                exp1, state, newstate, edge, isLoopBody, context);
          in // -- println(state1)
            branch_condition_effects(
                exp2, state1, newstate, edge, isLoopBody, context);
        _ => newstate;
      endcase
  else
    case exp of
      NullExpression()     => state;
      // -- TODO: is_constant_value(exp) => state
      _                    => lift([-> top]);
    endcase
    //newstate
  ;

is_comparison :: Expression -> bool;
is_comparison(LessThanOp(_,_)) = true;
is_comparison(LessOrEqualOp(_,_)) = true;
is_comparison(GreaterThanOp(_,_)) = true;
is_comparison(GreaterOrEqualOp(_,_)) = true;
is_comparison(EqualityOp(_,_)) = true;
is_comparison(NotEqualOp(_,_)) = true;
is_comparison(_) = false;

comparison_effects :: Expression, itvl_State, itvl_State, bool, bool,
                      ContextInfo -> itvl_State;
comparison_effects(exp, oldstate, state, edge, isLoopBody, context) =
  if !is_binary(exp) || !is_comparison(exp) then
    println("*** comparison_effects called with non-comparison ", exp,
            " :: ", expr_asttext(exp))
    error("*** fatal error")
  else
  let lhsexp = binary_get_left_child(exp);
      rhsexp = binary_get_right_child(exp); in
  let newstate =
    case exp of
      LessThanOp(_, _) =>
        if edge = true then
          less_effects(state, lhsexp, rhsexp, isLoopBody, context)
        else
          less_or_equal_effects(state, rhsexp, lhsexp, isLoopBody, context)
        ;
      LessOrEqualOp(_, _) =>
        if edge = true then
          less_or_equal_effects(state, lhsexp, rhsexp, isLoopBody, context)
        else
          less_effects(state, rhsexp, lhsexp, isLoopBody, context)
        ;
      GreaterThanOp(_, _) =>
        if edge = true then
          less_effects(state, rhsexp, lhsexp, isLoopBody, context)
        else
          less_or_equal_effects(state, lhsexp, rhsexp, isLoopBody, context)
        ;
      GreaterOrEqualOp(_, _) =>
        if edge = true then
          less_or_equal_effects(state, rhsexp, lhsexp, isLoopBody, context)
        else
        less_effects(state, lhsexp, rhsexp, isLoopBody, context)
      ;
      EqualityOp(_, _) =>
        if edge = true then
          equal_effects(state, lhsexp, rhsexp, isLoopBody, context)
        else
          state
        ;
      NotEqualOp(_, _) =>
        if edge = true then
          state
        else
          equal_effects(state, lhsexp, rhsexp, isLoopBody, context)
        ;
    endcase;
  // -- Now, in newstate, we have the effects of evaluating the comparison
  // -- operator. We need to look at its operands again to possibly adjust
  // -- variable values. For example, in  while (10 > i++)  the comparison
  // -- first restricts i to some range with upper bound 9, but after the
  // -- increment, the upper bound for i is actually 10!
  // -- Does this actually make too many updates? newstate comes from state,
  // -- which itself comes from oldstate. Investigate this if a critical case
  // -- comes up.
  in eval(lhsexp, eval(rhsexp, newstate, context)!2!2, context)!2!2;

less_effects :: itvl_State, Expression, Expression, bool, ContextInfo
                -> itvl_State;
less_effects(state, lhsexp, rhsexp, isLoopBody, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2;
  in  cond_update(
        cond_update(state,
            lhsexp, adjust_max_plus(lhs, rhs, -1, isLoopBody), context),
            rhsexp, adjust_min_plus(rhs, lhs,  1, isLoopBody), context);

less_or_equal_effects :: itvl_State, Expression, Expression, bool, ContextInfo
                         -> itvl_State;
less_or_equal_effects(state, lhsexp, rhsexp, isLoopBody, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2;
  in  cond_update(
        cond_update(state, lhsexp, adjust_max(lhs, rhs, isLoopBody), context),
                           rhsexp, adjust_min(rhs, lhs, isLoopBody), context);

equal_effects :: itvl_State, Expression, Expression, bool, ContextInfo
                 -> itvl_State;
equal_effects(state, lhsexp, rhsexp, isLoopBody, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2; in
  let intersection = intersect_itvls(lhs, rhs);
  in  cond_update(
        cond_update(state, lhsexp, intersection, context),
                           rhsexp, intersection, context);

// -- cond_update: Update a state with new value for the object(s)
// -- represented by the expression, if any; if the expression does not
// -- refer to any object(s), nothing is changed.
cond_update :: itvl_State, Expression, itvl_Interval, ContextInfo
               -> itvl_State;
cond_update(state, exp, value, context) =
  if exprid_has_location(expr_exprid(exp)) then
     updatestate(state, exp, value, context)!2!2
  else
     state;

// -- adjust_*: update some portion of some interval, possibly with an
// -- offset. This family of functions takes the isLoopBody flag because we
// -- treat "if" conditions differently from loop conditions. The arcane
// -- reason is the following: Consider a mapping  i->[0,2], j->[1,5]  and a
// -- branch statement  if (i < j). Here, we want to propagate the
// -- information  i->[0,2], since that's more exact than extending i's
// -- upper limit to 5.
// -- However, given the same mapping and the loop head  while (i < j), we
// -- want to actually extend the interval to  i->[0,5]  if we want to keep
// -- our current widening operator; otherwise, if i is incremented in the
// -- loop,  widen([0,2], [0,3]) = [0,TOP]  would completely destroy our
// -- information about i's value. Extending it to  [0,5]  right away keeps
// -- the widening from throwing stuff away. Anyway, this is the reason to
// -- treat loop conditions more imprecisely than if statements.

// -- update the min portion of an interval
adjust_min :: itvl_Interval, itvl_Interval, bool -> itvl_Interval;
adjust_min((a1, a2), (m, _), isLoopBody) =
  if (a1 = a2) then
    (a1, a2) // -- skip this if (a) is a constant value
  else
    if isLoopBody then (m, max(m, a2)) else (intersect_max(a1, m), max(m, a2));

// -- update the max portion of an interval
adjust_max :: itvl_Interval, itvl_Interval, bool -> itvl_Interval;
adjust_max((a1, a2), (_, m), isLoopBody) =
  if (a1 = a2) then
    (a1, a2) // -- skip this if (a) is a constant value
  else
    if isLoopBody then (min(a1, m), m) else (min(a1, m), intersect_min(a2, m));

// -- update the min portion of an interval and add c
adjust_min_plus :: itvl_Interval, itvl_Interval, snum, bool -> itvl_Interval;
adjust_min_plus((a1, a2), (m, _), c, isLoopBody) =
  if (a1 = a2) then
    (a1, a2) // -- skip this if (a) is a constant value
  else
    let m1 <= m; in
    let n = lift(m1+c); in
      if isLoopBody then (n, max(n,a2)) else (intersect_max(a1, n), max(n, a2));

// -- update the max portion of an interval and add c
adjust_max_plus :: itvl_Interval, itvl_Interval, snum, bool -> itvl_Interval;
adjust_max_plus((a1, a2), (_, m), c, isLoopBody) =
  if (a1 = a2) then
    (a1, a2) // -- skip this if (a) is a constant value
  else
    let m1 <= m; in
    let n = lift(m1+c); in
      if isLoopBody then (min(a1,n), n) else (min(a1, n), intersect_min(a2, n));


kill_vars :: itvl_State, *VariableSymbolNT -> itvl_State;
kill_vars(s, [!]) =
  s;
kill_vars(s, v::vars) =
  let ss <= s; in
  kill_vars(lift(ss\[varsym_varid(v) -> top]), vars);

interval_to_bool :: itvl_Interval -> BoolL;
interval_to_bool((l, r)) =
  // --println("interval_to_bool(", (l,r), ")")
  let lo <= l;
      hi <= r;
  in
      if (lo < 0 && hi < 0) || (lo > 0 && hi > 0) then
        lift(true)
      else if lo = 0 && hi = 0 then
        lift(false)
      else
        top;

// --shiftleft :: snum, snum -> snum;
// --shiftleft(a, 0) = a;
// --shiftleft(a, b) = shiftleft(a*2, b-1);

// --shiftright :: snum, snum -> snum;
// --shiftright(a, 0) = a;
// --shiftright(a, b) = shiftright(a/2, b-1);

comb(a, bot) = a;
comb(bot, b) = b;
comb(_, top) = top;
comb(top, _) = top;
comb(a, b) =
  let res = lift(crunch(drop(a), drop(b), combi)); // -- a glb b
  in
  // --println("comb a: ", a)
  // --println("comb b: ", b)
  // --println("result: ", res, "\n")
  res;

combi((a1, a2), (b1, b2)) = 
  (min(a1, b1), max(a2, b2));

// -- intersect_itvls: compute *intersection* of two intervals, e.g. if we
// -- know that both are valid
intersect_itvls((a1, a2), (b1, b2)) =
    (intersect_max(a1, b1), intersect_min(a2, b2));

// -- intersect_max, intersect_min: like max and min, but a number always
// -- wins against top or bot
intersect_max(a, top) = a;
intersect_max(a, bot) = a;
intersect_max(top, b) = b;
intersect_max(bot, b) = b;
intersect_max(a, b) = if drop(a) > drop(b) then a else b;

intersect_min(a, top) = a;
intersect_min(a, bot) = a;
intersect_min(top, b) = b;
intersect_min(bot, b) = b;
intersect_min(a, b) = if drop(a) < drop(b) then a else b;

ret(a, bot) = a; // -- bot; // -- a;
ret(bot, b) = b;
ret(_, top) = top;
ret(top, _) = top;
ret(local, exit) = 
  let returnvar = [(v,i)->top !! (v,i) <- drop(exit)\top, if is_tmpvarid(v)];
   // -- Here, we compute the set of locals or globals that come back from
   // -- the function. Their new values override any ones before the call!
      modified_vars = [(v,i)->top !! (v,i) <- drop(exit)\top,
                                     if !is_tmpvarid(v)];
  in (let localstate <= local;
      in  // -- println("return locals: ", modified_vars)
          lift(override(localstate, modified_vars))
      ) glb lift(returnvar);

// -- override(locals, modified): "locals" and "modified" are two maps,
// -- typically with some shared domain objects; yield a map in which
// -- definitions from "modified" override ones from "locals", i.e.
// -- (Haskell syntax):
// --   \x -> if modified(x) != top then modified(x) else locals(x)
override(locals, modified) = crunch(locals, modified, second_if_present);

second_if_present(a, b) =
 // -- should this also check for b != bot?
    if b != top then b else a;

// -- for lifted integers, we use top as +infty and -infty
min(a, top) = top;
min(top, a) = top;
min(a, bot) = a;
min(bot, b) = b;
min(a, b) = if drop(a) < drop(b) then a else b ;

// -- all glory to polymorphism (... and the hypnotoad!)
mini(a, b) = if a < b then a else b ;

max(_, top) = top;
max(top, _) = top;
max(a, bot) = a;
max(bot, b) = b;
max(a, b) = if drop(a) > drop(b) then a else b ;

maxi(a, b) = if a > b then a else b ;

// -- liftminus, liftplus: Arithmetic on lifted numbers. The idea is that
// -- checking  !bad(a) && !bad(b)  before doing arithmetic on intervals a
// -- and b is too coarse: the bad function will reject intervals where even
// -- one of the bounds is unknown, although we could still perform some
// -- meaningful arithmetic, for instance  (TOP,10) + (1,1) = (TOP,11).
// -- These lifted arithmetic functions can be used to try to add the bounds
// -- independently. Additive operators are probably the most important
// -- (partly because of ++ and --), but it might make sense to implement
// -- liftmult, liftdiv, etc. as well.
liftminus :: cp_Const, cp_Const -> cp_Const;
liftminus(a, b) = let aa <= a; bb <= b; in lift(aa - bb);

liftplus :: cp_Const, cp_Const -> cp_Const;
liftplus(a, b) = let aa <= a; bb <= b; in lift(aa + bb);

// -- Lots of auxiliary interval arithmetic functions.
// -- ------------------------------------------------
// -- General comments: 
// -- * If the general case is precise enough, there is no need to
// --   implement a special rule for the neutral element.
// --
// -- * The zero divisor, on the other hand, can also neutralize TOP.
// --
// -- {{{ http://www.emacswiki.org/cgi-bin/wiki/FoldingMode }}}
plus(la1,la2,lb1,lb2)  =  (liftplus(la1,lb1), liftplus(la2,lb2));
minus(la1,la2,lb1,lb2) = (liftminus(la1,lb2), liftminus(la2,lb1));

multiply(lift(0),lift(0),_,_) = duplift(0); // -- zero divisor
multiply(_,_,lift(0),lift(0)) = duplift(0);
multiply(la1,la2,lb1,lb2) = 
    (let a1<=la1; a2<=la2; b1<=lb1; b2<=lb2; in lift(mini(mini(a1*b1, a1*b2), mini(a2*b1, a2*b2))),
     let a1<=la1; a2<=la2; b1<=lb1; b2<=lb2; in lift(maxi(maxi(a1*b1, a1*b2), maxi(a2*b1, a2*b2))))
;
// -- Integer division /
// -- neutral element, still more precise than what follows
divide(la1,la2,lift(1),lift(1)) = (la1,la2); 
divide(la1,la2,lb1,lb2) = 
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    let x = maxi(maxi(abs(a1), abs(b1)),
                 maxi(abs(a2), abs(b2)));
    in ltup(-x, x)
;

// -- Modulo %
modulo(la1,la2,lb1,lb2) = 
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
   let bmax = maxi(abs(b1), abs(b2));
   in if strict_equal_sign(a1,a2,b1,b2) then
          if b1 > 0 then ltup(0, bmax -1)
          else ltup(1-bmax, 0)
      else ltup(1-bmax, bmax-1)
;

// -- Bitwise shift left <<
lshift(la1,la2,lb1,lb2) = 
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    if a1<0 || b1<0 then top
    else ltup(a1 << unum(b1), a2 << unum(b2))
;

// -- Bitwise shift right >>
// -- according to ISO C99 right-shift of a negative number is compiler-specific
rshift(la1,la2,lb1,lb2) = 
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    if a1<0 || b1<0 then top
    else ltup(a1 >> unum(b2), a2 >> unum(b1))
;

// -- Bitwise and &
and(la1,la2,lift(-1),lift(-1)) = (la1,la2);
and(lift(-1),lift(-1),lb1,lb2) = (lb1,lb2);
and(la1,la2,lb1,lb2) =
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    if (a1=0 && a2=0) || (b1=0 && b2=0)
    then ltup(0,0)
    else or(la1,la2,lb1,lb2)
;

// -- Bitwise shift or |
or(la1,la2,lift(-1),lift(-1)) = duplift(-1);
or(lift(-1),lift(-1),lb1,lb2) = duplift(-1);
or(la1, la2, lb1, lb2) =
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    let x = next_higher_power_of_2(maxi(maxi(abs(a1), abs(b1)),
                                        maxi(abs(a2), abs(b2))));
    in if strict_positive(a1, a2, b1, b2) then
           ltup(0, x-1) 
       else ltup(-x,x-1)
;

// -- Bitwise shift xor ^
xor(la1, la2, lb1, lb2) =
//{{{
    if bad((la1,la2)) || bad((lb1,lb2)) then top else 
        let a1=drop(la1); a2=drop(la2); b1=drop(lb1); b2=drop(lb2); in
//}}}
    if a1=a2 && a2=b1 && b1=b2 then 
        ltup(0,0)
    else
        let amax = maxi(abs(a1), abs(a2));
            bmax = maxi(abs(b1), abs(b2)); in
        let x = next_higher_power_of_2(amax | bmax);
        in if strict_equal_sign(a1, a2, b1, b2) then
               ltup(0, x-1)
           else ltup(-x,x-1)
;

// -- xor(a1, a2, b1, b2) =
// -- // -- If the sign bit is set on both intervals, the xor's result will be
// -- // -- non-negative. Otherwise, the lower limit is -inf.
// --    if (a2 & b2) < 0 then
// --        ltup(lowest_power_of_2(a1 | b1), next_higher_power_of_2(a2 | b2) - 1)
// --    else
// --        ltup(1 << unum(31), next_higher_power_of_2(a2 | b2) - 1);
// -- 
// -- and(a1, a2, b1, b2) =
// -- // -- If the sign bit is not set on *both* intervals, the and's result will
// -- // -- be non-negative. We make wild guesses regarding the limits.
// -- // -- Otherwise, the result is negative, and we don't even try to be clever.
// --    if a2 >= 0 || b2 >= 0 then
// --        ltup(0, (1 << unum(31)) - 1)
// --    else
// --        ltup(1 << unum(31), -1);

complement(a1, a2) =
 // -- If the sign bit is set on the interval, the complement's sign bit is
 // -- not set. Otherwise, we don't know anything.
    if a2 < 0 then
        ltup(0, (1 << unum(31)) - 1)
    else
        ltup(1 << unum(31), (1 << unum(31)) - 1);

// -- return True if all values in both intervals have the same sign
strict_equal_sign(a1,a2,b1,b2) =
    (a1 > 0 && a2 > 0 && b1 > 0 && b2 > 0) ||
    (a1 < 0 && a2 < 0 && b1 < 0 && b2 < 0)
;

strict_positive(a1,a2,b1,b2) = (a1 > 0 && a2 > 0 && b1 > 0 && b2 > 0);
strict_negative(a1,a2,b1,b2) = (a1 < 0 && a2 < 0 && b1 < 0 && b2 < 0);


lowest_bit :: snum -> unum;
lowest_bit(0) = unum(0);
lowest_bit(n) =
    if n = (1 << unum(31)) then unum(32) else  // -- the critical negative case
    if (n & 1) = 1         then unum(1)
                           else unum(1) + lowest_bit(n >> unum(1));

highest_bit :: snum -> unum;
highest_bit(0) = unum(0);
highest_bit(n) =
    if n < 0 then unum(32)  // -- sign bit is set
             else unum(1) + highest_bit(n >> unum(1));

lowest_power_of_2 :: snum -> snum;
lowest_power_of_2(0) = 0;
lowest_power_of_2(n) = (1 << (lowest_bit(n) - unum(1)));

highest_power_of_2 :: snum -> snum;
highest_power_of_2(0) = 0;
highest_power_of_2(n) = (1 << (highest_bit(n) - unum(1)));

next_higher_power_of_2 :: snum -> snum;
next_higher_power_of_2(0) = 0;
next_higher_power_of_2(n) = (1 << highest_bit(n));

// -- default widening operator:
//wide(_, b) = b;

wide(bot, b) = b;
wide(a, bot) = a;
wide(_, top) = top;
wide(top, _) = top;
wide(a, b) = lift(crunch(drop(a), drop(b), widen));
             // --let result=lift(crunch(drop(a), drop(b), widen)); in
             // --println(a) println(b) println(result) println("")  result;

widen((top, top), b) = b;
widen((a1, a2), (b1, b2)) =
  ( if a1=b1 then a1 else top /* clamp(shrink(min(a1, b1))) */ ,
    if a2=b2 then a2 else top /* clamp(embiggen(max(a1, b1))) */  );

//widen((a1, a2), (b1, b2)) = let v1 <= b1 ;
//                                v2 <= b2 ; in 
//                            ( if v2-v1 > 10 then top else b1 ,
//                              if v2-v1 > 10 then top else b2 ) ;


eq(a, b)   = //println("eq a: ", a)
             //println("eq b: ", b, "\n")
             (a = b);

// -- Let too small/large values diverge to ±infty
shrink(bot) = bot;
shrink(top) = top;
shrink(a)   = let aa = drop(a); in 
              if aa = 0 
              then lift(0) 
              else if aa > 0 
                   then lift(aa / 2)
                   else lift(aa * 2);

embiggen(bot)= bot;
embiggen(top)= top;
embiggen(a)  = let aa <= a; in 
               if aa = 0 
               then lift(0) 
               else if aa < 0
                    then lift(aa / 2)
                    else lift(aa * 2) ;
 
clamp(bot)  = bot;
clamp(top)  = top; 
clamp(a)    = let aa <= a; in if aa < -1048576 || aa > 1048576 then top else a;

// -- isglobalprogramvar: any global variable in the original program
isglobalprogramvar(var) = varmember(var, globals);
// -- isglobal: any global variable at all, including tmpvars introduced by
// -- the ICFG builder
isglobal(var) = is_tmpvarid(var) || isglobalprogramvar(var);
islocal(var) = !isglobal(var);
isaliasedlocal(var, ctx) =
    let result = islocal(var) && varid_has_location_cs(var, ctx)
                              && may_be_aliased(varid_location_cs(var, ctx));
    in  // -- println("checking aliasing of var ", var, " in context ", ctx,
        // --         " -> ", result)
        result;

varmember(_, [!]) = false;
varmember(v, g::gs) = 
    if varsym_varid(g) = v 
    then true 
    else varmember(v, gs);
    
is_array_type :: Type -> bool;
is_array_type(type) =
    case type of
        ArrayType(_, _) => true;
        ModifierType(t) => is_array_type(t);
        _               => false;
    endcase;

is_pointer_type :: Type -> bool;
is_pointer_type(type) =
  case type of
    PointerType(_)  => true;
    ModifierType(t) => is_pointer_type(t);
    _               => false;
  endcase;


// -- initialization of global variables
initialize_globals :: itvl_fState, *VariableSymbolNT -> itvl_fState;
initialize_globals(state, [!]) = state;
initialize_globals(state, g::gs) =
  let newstate =
    let variable = varsym_varid(g); in
    if global_has_initializer(g) then
      let initexpr = global_get_initializer(g); in
      let value = eval_constant_initializer(initexpr);
      in  state\[variable -> value]
    else if global_has_defining_declaration(g) then
    // -- global variable with a defining declaration (i.e., not extern) but
    // -- no explicit initializer: initialize with 0, if appropriate
      let t = global_get_type(g); in
      if is_integer_type(t) || is_array_type(t) then
        state\[variable -> duplift(0)]
      else
        state
    else
      state;
  in  initialize_globals(newstate, gs);

eval_constant_initializer :: Expression -> itvl_Interval;
eval_constant_initializer(exp) =
  if is_value(exp) then
    value_interval(exp)
  else case exp of
    AssignInitializer(ini)  => eval_constant_initializer(ini);
    AggregateInitializer(e) => eval_constant_initializer(e);
    ExprListExp(exprs)      => eval_constant_array(exprs);
    CastExp(e, _ /*type*/)  => eval_constant_initializer(e);
    _                       => println("* unknown initializer value for ", exp,
                                       " :: ", expr_asttext(exp))
                               top;
  endcase;

eval_constant_array :: *Expression -> itvl_Interval;
eval_constant_array([!]) = duplift(0);
eval_constant_array(e::es) =
  let v = eval_constant_initializer(e);
  in  combi(v, eval_constant_array(es));

value_interval :: Expression -> itvl_Interval;
value_interval(exp) =
  case exp of
    BoolValExp(value) => duplift(val-astint(value));
    EnumVal(value)    => duplift(val-astint(value));
    IntVal(value)     => duplift(val-astint(value));
    ShortVal(value)   => duplift(val-astshort(value));
    LongIntVal(value) => duplift(val-astlong(value));
    LongLongIntVal(value) => duplift(val-astllong(value));

    CharVal(value)  => duplift(snum(val-astchar(value)));
    // -- FIXME: incorrect type conversions
    UnsignedCharVal(value) => duplift(snum(val-astuchar(value)));
    UnsignedIntVal(value)  => duplift(snum(val-astuint(value)));
    UnsignedShortVal(value)=> duplift(snum(val-astushort(value)));
    UnsignedLongVal(value) => duplift(snum(val-astulong(value)));
    UnsignedLongLongIntVal(value) => duplift(snum(val-astullong(value)));
    // -- NOT IMPLEMENTED
    FloatVal(_) => top;
    DoubleVal(_) => top;
    StringVal(_) => top;
    _         => // --println("unsupported value exp: ", exp)
                 top;
  endcase;
