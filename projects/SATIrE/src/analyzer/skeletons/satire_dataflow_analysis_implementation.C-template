// -*- C++ -*-
// vim: syntax=cpp

#include <satire.h>

// Include stuff generated by PAG.
#include "iterate.h"

/*
 * Macros used in this file:
 * - ANALYSIS: The identifier of the analysis.
 * - PREFIX_SET: A true value iff a prefix is set for this analysis.
 * - PREFIX: The prefix itself (identifier syntax) iff PREFIX_SET is true.
 * - CARRIER: The name of the carrier type of the analysis.
 * The definition of ANALYSIS is generated by the newanalysis script, the
 * others are expected to be passed via the command line.
 *                  
 * Macros defined in this file (with their intended arguments):
 * - stringize(ANALYSIS): A string constant containing the analysis name.
 * - doit(ANALYSIS): The name of the analysis_doit function generated by PAG.
 * - carrier_type_o(CARRIER): The C type name of the carrier type.
 * - carrier_printfunc(CARRIER): The name of the carrier's print function.
 *                  
 * Macros possibly defined in this file: These are defined iff PREFIX_SET
 * expands to a true value, which should be the case iff PREFIX expands to
 * some identifier. In this case, the following function and object names
 * defined by PAG are hidden behind macros of the same name that expand to
 * prefixed versions of the identifiers:
 * - DFI_STORE
 * - gdl_create
 * - debug_stat
 * - global_retfunc
 * - dfi_get_pre
 * - dfi_get_pre_info
 * - dfi_get_post
 * - dfi_get_post_info_all
 * - WEDGES
 */

#define stringize(analysis) xstringize(analysis)
#define xstringize(analysis) #analysis

#define doit(analysis) xdoit(analysis)
#define xdoit(analysis) analysis##_doit

#define carrier_type_o(type) xcarrier_type(type)
#define xcarrier_type(type) o_##type

#define carrier_printfunc(type) xcarrier_printfunc(type)
#define xcarrier_printfunc(type) o_##type##_print

#if PREFIX_SET
    #define prefixed_DFI_STORE(P) p2_DFI_STORE(P)
    #define prefixed_gdl_create(P) p2_gdl_create(P)
    #define prefixed_debug_stat(P) p2_debug_stat(P)
    #define prefixed_global_retfunc(P) p2_global_retfunc(P)
    #define prefixed_dfi_get_pre(P) p2_dfi_get_pre(P)
    #define prefixed_dfi_get_pre_info(P) p2_dfi_get_pre_info(P)
    #define prefixed_dfi_get_post(P) p2_dfi_get_post(P)
    #define prefixed_dfi_get_post_info_all(P) p2_dfi_get_post_info_all(P)
    #define prefixed_WEDGES(P) p2_WEDGES(P)

    #define p2_DFI_STORE(P) o_##P##DFI_STORE
    #define p2_gdl_create(P) o_##P##gdl_create
    #define p2_debug_stat(P) o_##P##debug_stat
    #define p2_global_retfunc(P) o_##P##global_retfunc
    #define p2_dfi_get_pre(P) o_##P##dfi_get_pre
    #define p2_dfi_get_pre_info(P) o_##P##dfi_get_pre_info
    #define p2_dfi_get_post(P) o_##P##dfi_get_post
    #define p2_dfi_get_post_info_all(P) o_##P##dfi_get_post_info_all
    #define p2_WEDGES(P) o_##P##WEDGES

    #define DFI_STORE prefixed_DFI_STORE(PREFIX)
    #define gdl_create prefixed_gdl_create(PREFIX)
    #define debug_stat prefixed_debug_stat(PREFIX)
    #define global_retfunc prefixed_global_retfunc(PREFIX)
    #define dfi_get_pre prefixed_dfi_get_pre(PREFIX)
    #define dfi_get_pre_info prefixed_dfi_get_pre_info(PREFIX)
    #define dfi_get_post prefixed_dfi_get_post(PREFIX)
    #define dfi_get_post_info_all prefixed_dfi_get_post_info_all(PREFIX)
    #define WEDGES prefixed_WEDGES(PREFIX)
#endif

// "persistent" is apparently always prefixed with the analysis name.
#define prefixed_persistent(A) p2_persistent(A)
#define p2_persistent(A) A##_persistent
#define persistent prefixed_persistent(ANALYSIS)

using namespace std;

// Variables defined by PAG.
extern int debug_stat;
extern int global_retfunc;
// Functions generated by PAG.
extern "C" DFI_STORE doit(ANALYSIS)(void *);
extern "C" void persistent(void);


// A more readable name for the carrier type.
typedef carrier_type_o(CARRIER_TYPE) CarrierType;
// And for the print function.
char *carrierPrintFunction(CarrierType c)
{
    return carrier_printfunc(CARRIER_TYPE)(c);
}


// Global variable holding the analysis direction, determined from PAG.
enum AnalysisDirection { D_Forward, D_Backward };
static AnalysisDirection analysisDirection;

static void
determineAnalysisDirection(CFG *icfg)
{
    if (!icfg->procedures->empty())
    {
        BasicBlock *block = (*icfg->procedures)[0]->entry;
     // The idea here is the following: The entry block's outgoing edges are
     // always normal, while its incoming edges are always calls (if any).
     // So the in_edges and out_edges are always different, and we can check
     // which one PAG's WEDGES function returns.
        if (kfg_which_out_edges(block) == WEDGES(block))
            analysisDirection = D_Forward;
        else if (kfg_which_in_edges(block) == WEDGES(block))
            analysisDirection = D_Backward;
        else
        {
            std::cerr
                << __FILE__ << ":" << __LINE__ << ": can't happen!"
                << std::endl;
            std::abort();
        }
    }
}


// Definitions of a few functions for retrieving and stringizing analysis
// results.
CarrierType
select_info(DFI_STORE store, SgStatement *stmt, std::string attrName)
{
    if (stmt->attributeExists(attrName))
    {
        StatementAttribute* stmtAttr
            = dynamic_cast<StatementAttribute *>(stmt->getAttribute(attrName));
        BasicBlock* block=stmtAttr->get_bb();
        int pos=stmtAttr->get_pos();
        switch (pos)
        {
        case POS_PRE:
            return dfi_get_pre_info(store, block->id);
        case POS_POST:
            return dfi_get_post_info_all(store, block->id);
        }
    }
    return NULL;
}

CarrierType
get_statement_pre_info(DFI_STORE store, SgStatement *stmt)
{
    return select_info(store, stmt, "PAG statement start");
}

CarrierType
get_statement_post_info(DFI_STORE store, SgStatement *stmt)
{
    return select_info(store, stmt, "PAG statement end");
}

#if 0
std::string
get_statement_pre_info_string(DFI_STORE store, SgStatement* stmt)
{
    CarrierType info = get_statement_pre_info(store, stmt);
    if (info != NULL)
        return carrierPrintFunction(info);
    else
        return "<undefined dfi>";
}

std::string
get_statement_post_info_string(DFI_STORE store, SgStatement* stmt)
{
    CarrierType info = get_statement_post_info(store, stmt);
    if (info != NULL)
        return carrierPrintFunction(info);
    else
        return "<undefined dfi>";
}
#else

static
std::string
contextString(CFG *icfg, int procnum, int pos)
{
    std::stringstream str;

    if (icfg->analyzerOptions->outputCallStrings())
    {
     // If --output-context-strings is given, output the context as a list
     // of most recent callers: [foo, bar, baz]
        ContextInformation::Context context(procnum, pos, icfg);
        ContextInformation::CallString callstring
            = icfg->contextInformation->contextCallString(context);
        str << callstring.toDotString();
    }
    else
        str << "Context(" << procnum << "," << pos << ")";

    return str.str();
}

std::string
statement_info_string(DFI_STORE store, SgStatement *stmt, std::string attrName)
{
    if (!stmt->attributeExists(attrName))
        return "<undefined dfi>";

    std::stringstream str;

    CFG *icfg = get_global_cfg();
    const std::set<int> &labels = icfg->statementAllLabels(stmt);
    if (!labels.empty())
    {
        int min = *labels.begin();
        int max = *labels.rbegin();
        str << "labels " << min << ".." << max << ": ";
    }

    CarrierType info;
    StatementAttribute *stmtAttr
        = dynamic_cast<StatementAttribute *>(stmt->getAttribute(attrName));
    BasicBlock *block = stmtAttr->get_bb();
    int procnum = block->procnum;
    int arity = kfg_arity_id(block->id);  // number of contexts
    int prePost = stmtAttr->get_pos();
    if (prePost == POS_PRE)
    {
        for (int ctx = 0; ctx < arity; ctx++)
        {
            info = dfi_get_pre(store, block->id, ctx);
            str << contextString(icfg, procnum, ctx) << ":"
                << carrierPrintFunction(info) << " ";
        }
        str << "Merged:"
            << carrierPrintFunction(dfi_get_pre_info(store, block->id));
    }
    else
    {
     // outedges is a bitmask with a 1 bit for each type of edge leaving
     // this block
        unsigned int outedges
            = (analysisDirection == D_Forward ? kfg_which_out_edges(block)
                                              : kfg_which_in_edges(block));
        unsigned int edge;
        for(edge = 0; outedges != 0; edge++, outedges >>= 1)
        {
            if (outedges & 1 != 0)
            {
                for (int ctx = 0; ctx < arity; ctx++)
                {
                    info = dfi_get_post(store, block->id, ctx,
                                        (KFG_EDGE_TYPE) edge);
                    str << "Edge(" << edgetypenames[edge] << "):"
                        << contextString(icfg, procnum, ctx) << ":"
                        << carrierPrintFunction(info) << " ";
                }
                str << "Merged:"
                    << carrierPrintFunction(dfi_get_post_info_all(store,
                                                                  block->id))
                    << " ";
            }
        }
    }

    return str.str();
}

std::string
get_statement_pre_info_string(DFI_STORE store, SgStatement* stmt)
{
    return statement_info_string(store, stmt, "PAG statement start");
}

std::string
get_statement_post_info_string(DFI_STORE store, SgStatement* stmt)
{
    return statement_info_string(store, stmt, "PAG statement end");
}
#endif


// Now PAG's identifiers are as they should be; we can now include template
// definitions that use these. These are the PagDfiTextPrinter,
// PagDfiCommentAnnotator, and TermPrinter classes.
#include <PagDfiTextPrinter.h>
#include <PagDfiCommentAnnotator.h>
#include <TermPrinter.h>


namespace SATIrE
{

namespace ANALYSIS
{

// ---- Definition of Implementation class
std::string
Implementation::identifier() const
{
    return stringize(ANALYSIS);
}

std::string
Implementation::description() const
{
    return "A data-flow analysis called " + identifier()
         + " for use with SATIrE.";
}

void
Implementation::analysisDoit(CFG *cfg)
{
    analysisInfo = doit(ANALYSIS)(cfg);
 // After having run the analysis, prepare for annotation by determining the
 // direction of the analysis.
    determineAnalysisDirection(cfg);
}

void
Implementation::makePersistent() const
{
    persistent();
}

void
Implementation::createGDL(const char *filename) const
{
    gdl_create((char *) filename, 0);
}

void
Implementation::setDebugStat(int debugStat) const
{
    debug_stat = debugStat;
}

void
Implementation::setGlobalRetfunc(int globalRetfunc) const
{
    global_retfunc = globalRetfunc;
}

void
Implementation::annotateProgram(Program *program)
{
    /* Handle command line option --analysis-annotation. */
    if (program->options->analysisAnnotation())
    {
        TimingPerformance timer("Annotate source code with comments:");
        PagDfiCommentAnnotator<DFI_STORE> ca((DFI_STORE) analysisInfo);

        if (program->options->analysisWholeProgram())
            ca.traverse(program->astRoot, preorder);
        else
            ca.traverseInputFiles(program->astRoot, preorder);
    }
}

void
Implementation::outputAnnotatedProgram(Program *program, bool prefixFiles)
{
    /* Handle command line option --output-text. */
    if (program->options->outputText())
    {
        TimingPerformance timer("Generate text output:");
        PagDfiTextPrinter<DFI_STORE> p((DFI_STORE) analysisInfo);

        if (program->options->analysisWholeProgram())
            p.traverse(program->astRoot, preorder);
        else
            p.traverseInputFiles(program->astRoot, preorder);
    }

    /* Handle command line option --output-term. */
    if (program->options->outputTerm())
    {
        if (program->prologTerm == NULL)
        {
            TimingPerformance timer("Output Termite term:");
            TermPrinter<DFI_STORE> tp((DFI_STORE) analysisInfo, program->icfg);

            if (program->options->analysisWholeProgram())
                tp.traverse(program->astRoot);
            else
                tp.traverseInputFiles(program->astRoot);

            ofstream termfile;
            string prefix = (prefixFiles ? identifier() : "");
            string filename
                = prefixedFileName(program->options->getOutputTermFileName(),
                                   prefix);
            if (!openFileForWriting(termfile, filename))
            {
                std::cerr
                    << "*** error: could not open term file " << filename
                    << std::endl;
                std::exit(EXIT_FAILURE);
            }
            termfile << "% Termite term representation" << endl;
            termfile << tp.getTerm()->getRepresentation() << "." << endl;
            termfile.close();
            program->prologTerm = tp.getTerm();
        }
    }
}

void
Implementation::outputAnalysisVisualization(Program *program, bool prefixFiles)
{
    AnalyzerOptions *options = program->options;
    bool verbose = options->verbose();

    /* Handle command line options --output-gdl and --output-gdlanim. */
    std::string outputGdlFile;
    std::string outputGdlAnimDir;
    std::string prefix = (prefixFiles ? identifier() : "");
    if (options->outputGdl())
    {
        outputGdlFile
            = prefixedFileName(program->options->getOutputGdlFileName(),
                               prefix);
    }
    else if (options->outputGdlAnim())
    {
        outputGdlAnimDir
            = prefixedFileName(program->options->getOutputGdlAnimDirName(),
                               prefix);
        setOutputGdlAnimDirName(Ir::getCharPtr(outputGdlAnimDir));
        outputGdlFile = outputGdlAnimDir + "/result.gdl";
    }

    if (options->outputGdl() || options->outputGdlAnim())
    {
        TimingPerformance timer(
                "Generate GDL visualization of analysis results:");
        if (verbose)
            std::cout << "generating ";
        if (verbose && options->outputGdl())
            std::cout << "visualization " << outputGdlFile << " ";
        if (verbose && options->outputGdl() && options->outputGdlAnim())
            std::cout << "and ";
        if (verbose && options->outputGdlAnim())
            std::cout << "animation in directory " << outputGdlAnimDir << " ";
        if (verbose)
            std::cout << "... " << std::flush;
        createGDL(outputGdlFile.c_str());
        if (verbose)
            std::cout << "done" << std::endl;
    }
}


} // namespace ANALYSIS

} // namespace SATIrE
