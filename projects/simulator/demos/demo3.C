/* Demonstrates how to perform symbolic analysis on a function that isn't called.
 *
 * Run this demo like this:
 *     $ demo3 ./demo3input
 *
 *
 *
 * This demo does the following:
 *
 * 1. Allow the specimen to execute up to a certain point in order to resolve dynamic linking.  This demo parses the ELF file
 *    to find the address of "main" and stops when it is reached.  By executing to main(), we allow the dynamic linker to run,
 *    giving us more information about the executable.
 *
 * 2. When main is reached, we will do some symbolic analysis on the "payload" function.  This function, which normally isn't
 *    called, takes one integer argument and calculates an integer result.  Our analysis gives an expression for the result in
 *    terms of the (unknown) input argument.  In other words, an expression defining the function.
 *
 * 3. Using the result from the previous step, try to determine if there's any argument that would result in a particular
 *    return value.  E.g., find N satisfying payload(N)==2067789406.
 */

#include "rose.h"
#include "RSIM_Private.h"

#ifdef ROSE_ENABLE_SIMULATOR /* protects this whole file */

#include "RSIM_Linux32.h"
#include "SymbolicSemantics.h"
#include "YicesSolver.h"

/* Monitors the CPU instruction pointer.  When it reaches a specified value analyze the function at the specified location. */
class Analysis: public RSIM_Callbacks::InsnCallback {
public:
    rose_addr_t trigger_addr, analysis_addr;

    Analysis(rose_addr_t trigger_addr, rose_addr_t analysis_addr)
        : trigger_addr(trigger_addr), analysis_addr(analysis_addr) {}

    /* This analysis is intended to run in a single thread, so clone is a no-op. */
    virtual Analysis *clone() { return this; }

    /* The actual analysis, triggered when we reach the specified execution address... */
    virtual bool operator()(bool enabled, const Args &args) {
        if (enabled && args.insn->get_address()==trigger_addr) {

            /* An SMT solver is necessary for this example to work correctly. ROSE uses the SMT solver to try to figure out
             * when memory addres expressions might be aliases.  Since we're initializing some memory (the function argument)
             * using an address expression that we build here, ROSE needs to be able to figure out when the program also tries
             * to access the same memory but using an address expression that is generated by the analysis itself.  ROSE should
             * have been configured with "--with-yices=/full/path/to/yices/installation".  If not, you'll get a failed
             * assertion when ROSE tries to use the solver. */
            YicesSolver smt_solver;
            smt_solver.set_linkage(YicesSolver::LM_EXECUTABLE);

            /* We deactive the simulator while we're doing this analysis.  If the simulator remains activated, then the SIGCHLD
             * that are generated from running the Yices executable will be sent to the specimen.  That wouldn't cause problems
             * for the demo3input program, but it would result in signal arrival messages from the simulator. */
            args.thread->get_process()->get_simulator()->deactivate();

            /* Create the policy that holds the analysis state which is modified by each instruction.  Then plug the policy
             * into the X86InstructionSemantics to which we'll feed each instruction. */
            SymbolicSemantics::Policy policy(&smt_solver);
            X86InstructionSemantics<SymbolicSemantics::Policy, SymbolicSemantics::ValueType> semantics(policy);

            /* The top of the stack contains the (unknown) return address.  The value above that is the function's first
             * argument, which we print for reference.  It will be an unkown value, like "v62[32]". */
            SymbolicSemantics::ValueType<32> arg1_va = policy.add(policy.readGPR(x86_gpr_sp), policy.number<32>(4));
            SymbolicSemantics::ValueType<32> arg1 = policy.readMemory<32>(x86_segreg_ss, arg1_va, policy.true_());
            std::cout <<"function argument = " <<arg1 <<"\n";
            std::cout <<"  (Note: \"vN[M]\" is a variable (the Nth variable) of type M-bit vector.)\n";

            /* Run the analysis until we can't figure out what instruction is next.  If we set things up correctly, the
             * simulation will stop when we hit the RET instruction to return from this function. */
            policy.writeIP(SymbolicSemantics::ValueType<32>(analysis_addr));
            while (policy.readIP().is_known()) {
                uint64_t va = policy.readIP().known_value();
                SgAsmx86Instruction *insn = isSgAsmx86Instruction(args.thread->get_process()->get_instruction(va));
                assert(insn!=NULL);
                semantics.processInstruction(insn);
            }

            /* Show the value of the EAX register since this is where GCC puts the function's return value.  If we did things
             * right, the return value should depend only on the functions first argument, which we printed above. */
            std::cout <<"return value = " <<policy.readGPR(x86_gpr_ax) <<"\n";
            std::cout <<"  (Note: format is LISP-like; \"[M]\" notation means type is an M-bit vector.)\n";

            /* Is there some way this function can be called in order to generate a particular value? */
            if (!arg1.is_known()) {
                using namespace InsnSemanticsExpr;
                LeafNode *target = LeafNode::create_integer(32, 2067789406);
                uint64_t arg1_varno = dynamic_cast<LeafNode*>(arg1.expr)->get_name();
                InternalNode expr(32, OP_EQ, policy.readGPR(x86_gpr_ax).expr, target);
                std::cout <<"using an SMT solver to find a solution to f(x) = " <<target <<"...\n";
                if (smt_solver.satisfiable(&expr)) {
                    LeafNode *arg1_value = dynamic_cast<LeafNode*>(smt_solver.get_definition(arg1_varno));
                    if (arg1_value) {
                        std::cout <<"  solution is x = " <<arg1_value <<"\n";
                    } else {
                        std::cout <<"  satisfiable, but no solution found\n";
                    }
                } else {
                    std::cout <<"  not satisfiable.\n";
                }
            }

            /* Reactivate the simulator in case we want to continue simulating. */
            args.thread->get_process()->get_simulator()->activate();
            throw this; // Optional: will exit simulator, caught in main(), which then deactivates the simulator
        }
        return enabled;
    }
};

int main(int argc, char *argv[], char *envp[])
{
    /* Configure the simulator by parsing command-line switches. The return value is the index of the executable name in argv. */
    RSIM_Linux32 sim;
    int n = sim.configure(argc, argv, envp);

    /* Parse the ELF container so we can get to the symbol table. */
    char *rose_argv[4];
    int rose_argc=0;
    rose_argv[rose_argc++] = argv[0];
    rose_argv[rose_argc++] = strdup("-rose:read_executable_file_format_only");
    rose_argv[rose_argc++] = argv[n];
    rose_argv[rose_argc] = NULL;
    SgProject *project = frontend(rose_argc, rose_argv);

    /* Find the address of "main" and "payload" functions. */
    rose_addr_t main_addr = FunctionFinder().address(project, "main");
    assert(main_addr!=0);
    rose_addr_t payload_addr = FunctionFinder().address(project, "payload");
    assert(payload_addr!=0);

    /* Register the analysis callback. */
    Analysis analysis(main_addr, payload_addr);
    sim.install_callback(&analysis);

    /* Create the initial process object by loading a program and initializing the stack.   This also creates the main thread,
     * but does not start executing it. */
    sim.exec(argc-n, argv+n);

    /* Get ready to execute by making the specified simulator active. This sets up signal handlers, etc.  We probably don't
     * really need it for this demo since the specimen doesn't do anything with signals.  In fact, if we're using the Yices
     * executable (rather than its library), ROSE will generate spurious SIGCHLD which the simulator will forward to the
     * specimen.  Of course, in that case, the analysis could temporarily deactivate the simulator. */
    sim.activate();

    /* Allow executor threads to run and return when the simulated process terminates. */
    try {
        sim.main_loop();
    } catch (Analysis*) {
    }

    /* Not really necessary since we're not doing anything else. */
    sim.deactivate();
    return 0;
}





#else
int main(int, char *argv[])
{
    std::cerr <<argv[0] <<": not supported on this platform" <<std::endl;
    return 0;
}

#endif /* ROSE_ENABLE_SIMULATOR */
