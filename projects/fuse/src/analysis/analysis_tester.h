#pragma once

#include "compose.h"
#include "composed_analysis.h"
#include "partitions.h"
#include <map>
#include <list>
#include <set>
#include <string>

namespace fuse {
  
// A datastructure that maintains parts generated by a sequence of analyses that implement increasingly
// precise parts. Each Part at a coarser abstraction level is mapped to the Part(s) in the finer level
// that refine it. This representation makes it possible to operate on multiple levels of the Abstract
// Transition System refinement hierarchy, such as walking along multiple ATS's while keeping track
// of the refinement relation between the different corresponding Parts in different refinement 
// hierarchy levels.
template <class EdgeTypePtr>
class HierEdge;

template <class EdgeTypePtr>
class HierEdge_Leaf;

// Protype for a functor that can be applied to every hierarchical sequence of edges within a given HierEdge
template <class EdgeTypePtr>
class HierEdgeMapFunctor {
  public:
    virtual void operator()(const std::list<EdgeTypePtr>& hpe)=0;
};

template <class EdgeTypePtr>
class HierEdge : public dbglog::printable {
  typedef CompSharedPtr<HierEdge<EdgeTypePtr> > HierEdgePtr;
  typedef CompSharedPtr<HierEdge_Leaf<EdgeTypePtr> > HierEdge_LeafPtr;
  
  // Indicates whether during the traversal each leaf edge should be visited just once
  bool singleVisit;
  
  // Maintains the final edge in a hierarhical edge
  HierEdge_LeafPtr l;
  
  // Maintains the portions of hierarchical edges that have more than one additional sub-edge after the current level
  std::map<EdgeTypePtr, HierEdgePtr > m;
  
  
  public:
  HierEdge(bool singleVisit=false);
  HierEdge(const std::list<EdgeTypePtr>& hPEdge, bool singleVisit=false);
  HierEdge(const std::set<std::list<EdgeTypePtr> >& hPEdges, bool singleVisit=false);
  
  void operator=(HierEdgePtr that);
  
  // Stores the given PartEdge (single-level Hierarchical PartEdge) into this map's leaf
  void insert(EdgeTypePtr pEdge);
  
  // Stores the given PartEdge (single-level Hierarchical PartEdge) into the visited set of this map's leaf
  void insertVisited(EdgeTypePtr pEdge);
  
  // Stores the given Hierarchical Part into this map
  void insert(const std::list<EdgeTypePtr>& hPEdge);
  
  // Given a parent PartEdge and a HierEdge_Leaf that holds its children PartEdges,
  // insert all these Hierarchical PartsEdges into this map.
  void insert(EdgeTypePtr parent, const HierEdge_Leaf<EdgeTypePtr> & hpel);
  
  // Given a parent PartEdge and a HierEdge_Leaf that holds its children PartEdges,
  // insert all these Hierarchical PartsEdges into this map.
  void insert(EdgeTypePtr parent, const HierEdge<EdgeTypePtr> & hpe);
  
  // Returns the number of leaf edges mapped within this hierarchical edge
  int size() const;
  
  // Iterates hierarchically through all the sequence of edges from the root of this HierEdge to its leaves.
  // Applies the given functor to lists of EdgeTypePtrs, where every element in the list is the parent
  // of the subsequent element. The functor may be applied to hierarhical edges from different levels 
  // of this map.
  void mapf(HierEdgeMapFunctor<EdgeTypePtr>& f) const;
  
  private:
  // Recursive component of map, used internally
  void mapf_rec(HierEdgeMapFunctor<EdgeTypePtr>& f, std::list<EdgeTypePtr>& hpeL) const;
    
  public:
    
  // Advances all the Hierarchical Edges within this Map along the outgoing edges of their target Parts.
  // Since the resulting PartEdges may have different parents, the function breaks the outgoing
  // edges up by their parent PartEdge. It returns a map where the keys are the parent PartEdges 
  // of the outgoing PartEdges and the values are pointers to HierEdge that contain
  // of this parent's children Hierarchical PartEdges.
  std::map<EdgeTypePtr, HierEdgePtr> outEdges();
  
  void advanceOut();
  
  // Returns true if this edge is at the end of the graph and thus cannot advance further
  bool end() const;
  
  std::string str(std::string indent="");
};

template <class EdgeTypePtr>
class HierEdge_Leaf : public dbglog::printable {
  typedef CompSharedPtr<HierEdge_Leaf<EdgeTypePtr> > HierEdge_LeafPtr;
  
  // Indicates whether during the traversal each leaf edge should be visited just once
  bool singleVisit;
  
  // The current members of this HierEdge leaf node
  std::set<EdgeTypePtr> s;
  
  // Keeps track of all the edges that have already been visited, for use where the singleVisit flag is true
  std::set<EdgeTypePtr> visited;
  
  friend class HierEdge<EdgeTypePtr>;
  
  public:
  HierEdge_Leaf(bool singleVisit=false) : singleVisit(singleVisit) { }
  HierEdge_Leaf(EdgeTypePtr hPEdge, bool singleVisit=false);
  
  // Stores the given Hierarchical Part into this map
  void insert(EdgeTypePtr pEdge);
  
  // Stores the given Hierarchical Part into this map's visited set
  void insertVisited(EdgeTypePtr pEdge);
  
  // Advances all the Edges within this Map along the outgoing edges of their target Parts.
  // Since the resulting PartEdges may have different parents, the function breaks the outgoing
  // edges up by their parent PartEdge. It returns a map where the keys are the parent PartEdges 
  // of the outgoing PartEdges and the values are pointers to HierEdge_Leafs that contain
  // of this parent's children PartEdges.
  std::map<EdgeTypePtr, HierEdge_LeafPtr > outEdges();
  
  // Returns true if this edge is at the end of the graph and thus cannot advance further
  bool end() const;
  
  std::string str(std::string indent="");
};

void AnalysisTester_selfTest();
  
class ComposedAnalysisSelfTester {
  // The analysis that needs to be tested, both the copy that is executed in low-precision and high-precision.
  ComposedAnalysisPtr analysisToTestLP;
  ComposedAnalysisPtr analysisToTestHP;
  
  // The analyses that may be executed before analysisToTest to vary the precision of the Abstract Transition
  // System on which it runs. It is assumed that the analyses on this list may have already been executed
  // in some context and thus, the ComposedAnalysisSelfTester only runs copies of these analyses.
  std::set<ComposedAnalysisPtr> precisionAnalyses;
  
  // The syntactic analysis to run before all other to represent the information available from the application's
  // syntax in terms of Fuse abstractions
  ComposedAnalysisPtr stxAnalysis;
  
  public:
  
  ComposedAnalysisSelfTester(ComposedAnalysisPtr analysisToTest, 
                             const std::set<ComposedAnalysisPtr>& precisionAnalyses,
                             ComposedAnalysisPtr stxAnalysis);
  
  private:
  // Creates a Composer that creates an Abstract Transition System using the analyses in precisionAnalyses
  // and runs analysisToTest on top of it
  ChainComposer* createTestComposer(ComposedAnalysisPtr analysisToTest, 
                                    const std::set<ComposedAnalysisPtr>& precisionAnalyses);
  
  public:
  // Perform the self-test, return true on success, false on failure
  bool testAnalysis();
};

} // namespace fuse


