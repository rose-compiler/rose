/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStaticDataManagingClassSource.macro" */
/* JH (01/01/2006) This file is generated using ROSETTA. It should never be 
   manipulated by hand. The generation is located in buildStorageClasses.C!

    This file contains all decfinitions for the StorageClasses used for the ast file IO.
*/

#ifndef STORAGE_CLASSES_H
#define STORAGE_CLASSES_H

#include "sage3basic.hhh" // static data managing

/* JH (02/02/2006) REMARK: Since the declarations, definitions and use of the static member functions of 
   the templated EasyStorage classes is spread over the files below, we need to compile them all together 
   at this point. The splitting into several files is just to simplify and separate their contents! 
*/

#include "rosedefs.h"
#include "Cxx_Grammar.h"

#include "AST_FILE_IO.h"
#include "Cxx_GrammarMemoryPoolSupport.h"
#include "StorageClasses.h"

// DQ (3/7/2010): Added to support debugging.
#include "AstDiagnostics.h"

#include "StorageClassMemoryManagement.C"
#include "SourcesOfIRNodesAstFileIOSupport.C"


SgProject* 
AstSpecificDataManagingClass::getRootOfAst () const
   {
     return rootOfAst;
   }

unsigned long 
AstSpecificDataManagingClass::getNumberOfAccumulatedNodes (const int position) const
   {
     return listOfAccumulatedPoolSizes[position];
   }

unsigned long
AstSpecificDataManagingClass::getMemoryPoolSize (const int position) const
   {
     return listOfAccumulatedPoolSizes[position + 1] - listOfAccumulatedPoolSizes[position];
   }

unsigned long 
AstSpecificDataManagingClass::getTotalNumberOfASTIRNodes ( ) const
   {
     return listOfAccumulatedPoolSizes[ 666 ] ;
   }

int 
AstSpecificDataManagingClass::get_AstIndex() const
   {
     return astIndex;
   }


/* #line 64 "../../../src/frontend/SageIII//StorageClasses.C" */
SgFunctionTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalFunctionTypeTable() const
  {
    return SgNode_globalFunctionTypeTable;
  }

SgTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalTypeTable() const
  {
    return SgNode_globalTypeTable;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalMangledNameMap() const
  {
    return SgNode_globalMangledNameMap;
  }

std::map<std::string, int>
AstSpecificDataManagingClass::get_SgNode_shortMangledNameCache() const
  {
    return SgNode_shortMangledNameCache;
  }

std::map<int, std::string>
AstSpecificDataManagingClass::get_Sg_File_Info_fileidtoname_map() const
  {
    return Sg_File_Info_fileidtoname_map;
  }

std::map<std::string, int>
AstSpecificDataManagingClass::get_Sg_File_Info_nametofileid_map() const
  {
    return Sg_File_Info_nametofileid_map;
  }

SgTypePtrList
AstSpecificDataManagingClass::get_SgUnparse_Info_structureTagProcessingList() const
  {
    return SgUnparse_Info_structureTagProcessingList;
  }

bool
AstSpecificDataManagingClass::get_SgUnparse_Info_forceDefaultConstructorToTriggerError() const
  {
    return SgUnparse_Info_forceDefaultConstructorToTriggerError;
  }

int
AstSpecificDataManagingClass::get_SgGraph_index_counter() const
  {
    return SgGraph_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphNode_index_counter() const
  {
    return SgGraphNode_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphEdge_index_counter() const
  {
    return SgGraphEdge_index_counter;
  }

SgTypeUnknown*
AstSpecificDataManagingClass::get_SgTypeUnknown_builtin_type() const
  {
    return SgTypeUnknown_builtin_type;
  }

SgTypeChar*
AstSpecificDataManagingClass::get_SgTypeChar_builtin_type() const
  {
    return SgTypeChar_builtin_type;
  }

SgTypeSignedChar*
AstSpecificDataManagingClass::get_SgTypeSignedChar_builtin_type() const
  {
    return SgTypeSignedChar_builtin_type;
  }

SgTypeUnsignedChar*
AstSpecificDataManagingClass::get_SgTypeUnsignedChar_builtin_type() const
  {
    return SgTypeUnsignedChar_builtin_type;
  }

SgTypeShort*
AstSpecificDataManagingClass::get_SgTypeShort_builtin_type() const
  {
    return SgTypeShort_builtin_type;
  }

SgTypeSignedShort*
AstSpecificDataManagingClass::get_SgTypeSignedShort_builtin_type() const
  {
    return SgTypeSignedShort_builtin_type;
  }

SgTypeUnsignedShort*
AstSpecificDataManagingClass::get_SgTypeUnsignedShort_builtin_type() const
  {
    return SgTypeUnsignedShort_builtin_type;
  }

SgTypeInt*
AstSpecificDataManagingClass::get_SgTypeInt_builtin_type() const
  {
    return SgTypeInt_builtin_type;
  }

SgTypeSignedInt*
AstSpecificDataManagingClass::get_SgTypeSignedInt_builtin_type() const
  {
    return SgTypeSignedInt_builtin_type;
  }

SgTypeUnsignedInt*
AstSpecificDataManagingClass::get_SgTypeUnsignedInt_builtin_type() const
  {
    return SgTypeUnsignedInt_builtin_type;
  }

SgTypeLong*
AstSpecificDataManagingClass::get_SgTypeLong_builtin_type() const
  {
    return SgTypeLong_builtin_type;
  }

SgTypeSignedLong*
AstSpecificDataManagingClass::get_SgTypeSignedLong_builtin_type() const
  {
    return SgTypeSignedLong_builtin_type;
  }

SgTypeUnsignedLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLong_builtin_type() const
  {
    return SgTypeUnsignedLong_builtin_type;
  }

SgTypeVoid*
AstSpecificDataManagingClass::get_SgTypeVoid_builtin_type() const
  {
    return SgTypeVoid_builtin_type;
  }

SgTypeGlobalVoid*
AstSpecificDataManagingClass::get_SgTypeGlobalVoid_builtin_type() const
  {
    return SgTypeGlobalVoid_builtin_type;
  }

SgTypeWchar*
AstSpecificDataManagingClass::get_SgTypeWchar_builtin_type() const
  {
    return SgTypeWchar_builtin_type;
  }

SgTypeFloat*
AstSpecificDataManagingClass::get_SgTypeFloat_builtin_type() const
  {
    return SgTypeFloat_builtin_type;
  }

SgTypeDouble*
AstSpecificDataManagingClass::get_SgTypeDouble_builtin_type() const
  {
    return SgTypeDouble_builtin_type;
  }

SgTypeLongLong*
AstSpecificDataManagingClass::get_SgTypeLongLong_builtin_type() const
  {
    return SgTypeLongLong_builtin_type;
  }

SgTypeSignedLongLong*
AstSpecificDataManagingClass::get_SgTypeSignedLongLong_builtin_type() const
  {
    return SgTypeSignedLongLong_builtin_type;
  }

SgTypeUnsignedLongLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLongLong_builtin_type() const
  {
    return SgTypeUnsignedLongLong_builtin_type;
  }

SgTypeLongDouble*
AstSpecificDataManagingClass::get_SgTypeLongDouble_builtin_type() const
  {
    return SgTypeLongDouble_builtin_type;
  }

SgTypeBool*
AstSpecificDataManagingClass::get_SgTypeBool_builtin_type() const
  {
    return SgTypeBool_builtin_type;
  }

SgNamedType*
AstSpecificDataManagingClass::get_SgNamedType_builtin_type() const
  {
    return SgNamedType_builtin_type;
  }

SgPartialFunctionModifierType*
AstSpecificDataManagingClass::get_SgPartialFunctionModifierType_builtin_type() const
  {
    return SgPartialFunctionModifierType_builtin_type;
  }

SgTypeEllipse*
AstSpecificDataManagingClass::get_SgTypeEllipse_builtin_type() const
  {
    return SgTypeEllipse_builtin_type;
  }

SgTypeDefault*
AstSpecificDataManagingClass::get_SgTypeDefault_builtin_type() const
  {
    return SgTypeDefault_builtin_type;
  }

SgTypeCAFTeam*
AstSpecificDataManagingClass::get_SgTypeCAFTeam_builtin_type() const
  {
    return SgTypeCAFTeam_builtin_type;
  }

SgTypeCrayPointer*
AstSpecificDataManagingClass::get_SgTypeCrayPointer_builtin_type() const
  {
    return SgTypeCrayPointer_builtin_type;
  }

SgTypeLabel*
AstSpecificDataManagingClass::get_SgTypeLabel_builtin_type() const
  {
    return SgTypeLabel_builtin_type;
  }

SgAsmTypeByte*
AstSpecificDataManagingClass::get_SgAsmTypeByte_builtin_type() const
  {
    return SgAsmTypeByte_builtin_type;
  }

SgAsmTypeWord*
AstSpecificDataManagingClass::get_SgAsmTypeWord_builtin_type() const
  {
    return SgAsmTypeWord_builtin_type;
  }

SgAsmTypeDoubleWord*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleWord_builtin_type() const
  {
    return SgAsmTypeDoubleWord_builtin_type;
  }

SgAsmTypeQuadWord*
AstSpecificDataManagingClass::get_SgAsmTypeQuadWord_builtin_type() const
  {
    return SgAsmTypeQuadWord_builtin_type;
  }

SgAsmTypeDoubleQuadWord*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleQuadWord_builtin_type() const
  {
    return SgAsmTypeDoubleQuadWord_builtin_type;
  }

SgAsmType80bitFloat*
AstSpecificDataManagingClass::get_SgAsmType80bitFloat_builtin_type() const
  {
    return SgAsmType80bitFloat_builtin_type;
  }

SgAsmType128bitFloat*
AstSpecificDataManagingClass::get_SgAsmType128bitFloat_builtin_type() const
  {
    return SgAsmType128bitFloat_builtin_type;
  }

SgAsmTypeSingleFloat*
AstSpecificDataManagingClass::get_SgAsmTypeSingleFloat_builtin_type() const
  {
    return SgAsmTypeSingleFloat_builtin_type;
  }

SgAsmTypeDoubleFloat*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleFloat_builtin_type() const
  {
    return SgAsmTypeDoubleFloat_builtin_type;
  }

AstSpecificDataManagingClass::AstSpecificDataManagingClass( SgProject* root )
   {
     rootOfAst = root;
     astIndex = AST_FILE_IO::getNumberOfAsts(); 
     SgNode_globalFunctionTypeTable = SgNode::p_globalFunctionTypeTable;
     SgNode_globalTypeTable = SgNode::p_globalTypeTable;
     SgNode_globalMangledNameMap = SgNode::p_globalMangledNameMap;
     SgNode_shortMangledNameCache = SgNode::p_shortMangledNameCache;
     Sg_File_Info_fileidtoname_map = Sg_File_Info::p_fileidtoname_map;
     Sg_File_Info_nametofileid_map = Sg_File_Info::p_nametofileid_map;
     SgUnparse_Info_structureTagProcessingList = SgUnparse_Info::p_structureTagProcessingList;
     SgUnparse_Info_forceDefaultConstructorToTriggerError = SgUnparse_Info::p_forceDefaultConstructorToTriggerError;
     SgGraph_index_counter = SgGraph::p_index_counter;
     SgGraphNode_index_counter = SgGraphNode::p_index_counter;
     SgGraphEdge_index_counter = SgGraphEdge::p_index_counter;
     SgTypeUnknown_builtin_type = SgTypeUnknown::p_builtin_type;
     SgTypeChar_builtin_type = SgTypeChar::p_builtin_type;
     SgTypeSignedChar_builtin_type = SgTypeSignedChar::p_builtin_type;
     SgTypeUnsignedChar_builtin_type = SgTypeUnsignedChar::p_builtin_type;
     SgTypeShort_builtin_type = SgTypeShort::p_builtin_type;
     SgTypeSignedShort_builtin_type = SgTypeSignedShort::p_builtin_type;
     SgTypeUnsignedShort_builtin_type = SgTypeUnsignedShort::p_builtin_type;
     SgTypeInt_builtin_type = SgTypeInt::p_builtin_type;
     SgTypeSignedInt_builtin_type = SgTypeSignedInt::p_builtin_type;
     SgTypeUnsignedInt_builtin_type = SgTypeUnsignedInt::p_builtin_type;
     SgTypeLong_builtin_type = SgTypeLong::p_builtin_type;
     SgTypeSignedLong_builtin_type = SgTypeSignedLong::p_builtin_type;
     SgTypeUnsignedLong_builtin_type = SgTypeUnsignedLong::p_builtin_type;
     SgTypeVoid_builtin_type = SgTypeVoid::p_builtin_type;
     SgTypeGlobalVoid_builtin_type = SgTypeGlobalVoid::p_builtin_type;
     SgTypeWchar_builtin_type = SgTypeWchar::p_builtin_type;
     SgTypeFloat_builtin_type = SgTypeFloat::p_builtin_type;
     SgTypeDouble_builtin_type = SgTypeDouble::p_builtin_type;
     SgTypeLongLong_builtin_type = SgTypeLongLong::p_builtin_type;
     SgTypeSignedLongLong_builtin_type = SgTypeSignedLongLong::p_builtin_type;
     SgTypeUnsignedLongLong_builtin_type = SgTypeUnsignedLongLong::p_builtin_type;
     SgTypeLongDouble_builtin_type = SgTypeLongDouble::p_builtin_type;
     SgTypeBool_builtin_type = SgTypeBool::p_builtin_type;
     SgNamedType_builtin_type = SgNamedType::p_builtin_type;
     SgPartialFunctionModifierType_builtin_type = SgPartialFunctionModifierType::p_builtin_type;
     SgTypeEllipse_builtin_type = SgTypeEllipse::p_builtin_type;
     SgTypeDefault_builtin_type = SgTypeDefault::p_builtin_type;
     SgTypeCAFTeam_builtin_type = SgTypeCAFTeam::p_builtin_type;
     SgTypeCrayPointer_builtin_type = SgTypeCrayPointer::p_builtin_type;
     SgTypeLabel_builtin_type = SgTypeLabel::p_builtin_type;
     SgAsmTypeByte_builtin_type = SgAsmTypeByte::p_builtin_type;
     SgAsmTypeWord_builtin_type = SgAsmTypeWord::p_builtin_type;
     SgAsmTypeDoubleWord_builtin_type = SgAsmTypeDoubleWord::p_builtin_type;
     SgAsmTypeQuadWord_builtin_type = SgAsmTypeQuadWord::p_builtin_type;
     SgAsmTypeDoubleQuadWord_builtin_type = SgAsmTypeDoubleQuadWord::p_builtin_type;
     SgAsmType80bitFloat_builtin_type = SgAsmType80bitFloat::p_builtin_type;
     SgAsmType128bitFloat_builtin_type = SgAsmType128bitFloat::p_builtin_type;
     SgAsmTypeSingleFloat_builtin_type = SgAsmTypeSingleFloat::p_builtin_type;
     SgAsmTypeDoubleFloat_builtin_type = SgAsmTypeDoubleFloat::p_builtin_type;
   }

void
AstSpecificDataManagingClass::setStaticDataMembersOfIRNodes ( ) const
   {
     if ( SgNode_globalFunctionTypeTable != NULL ) 
        {
          if (SgNode::p_globalFunctionTypeTable == NULL)
             {
               SgNode::p_globalFunctionTypeTable = SgNode_globalFunctionTypeTable;
             }
        }
     if ( SgNode_globalTypeTable != NULL ) 
        {
          if (SgNode::p_globalTypeTable == NULL)
             {
               SgNode::p_globalTypeTable = SgNode_globalTypeTable;
             }
        }
     SgNode::p_globalMangledNameMap = SgNode_globalMangledNameMap;
     SgNode::p_shortMangledNameCache = SgNode_shortMangledNameCache;
     Sg_File_Info::p_fileidtoname_map = Sg_File_Info_fileidtoname_map;
     Sg_File_Info::p_nametofileid_map = Sg_File_Info_nametofileid_map;
     SgUnparse_Info::p_structureTagProcessingList = SgUnparse_Info_structureTagProcessingList;
     SgUnparse_Info::p_forceDefaultConstructorToTriggerError = SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgGraph::p_index_counter = SgGraph_index_counter;
     SgGraphNode::p_index_counter = SgGraphNode_index_counter;
     SgGraphEdge::p_index_counter = SgGraphEdge_index_counter;
     if ( SgTypeUnknown_builtin_type != NULL ) 
        {
          if (SgTypeUnknown::p_builtin_type == NULL)
             {
               SgTypeUnknown::p_builtin_type = SgTypeUnknown_builtin_type;
             }
        }
     if ( SgTypeChar_builtin_type != NULL ) 
        {
          if (SgTypeChar::p_builtin_type == NULL)
             {
               SgTypeChar::p_builtin_type = SgTypeChar_builtin_type;
             }
        }
     if ( SgTypeSignedChar_builtin_type != NULL ) 
        {
          if (SgTypeSignedChar::p_builtin_type == NULL)
             {
               SgTypeSignedChar::p_builtin_type = SgTypeSignedChar_builtin_type;
             }
        }
     if ( SgTypeUnsignedChar_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedChar::p_builtin_type == NULL)
             {
               SgTypeUnsignedChar::p_builtin_type = SgTypeUnsignedChar_builtin_type;
             }
        }
     if ( SgTypeShort_builtin_type != NULL ) 
        {
          if (SgTypeShort::p_builtin_type == NULL)
             {
               SgTypeShort::p_builtin_type = SgTypeShort_builtin_type;
             }
        }
     if ( SgTypeSignedShort_builtin_type != NULL ) 
        {
          if (SgTypeSignedShort::p_builtin_type == NULL)
             {
               SgTypeSignedShort::p_builtin_type = SgTypeSignedShort_builtin_type;
             }
        }
     if ( SgTypeUnsignedShort_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedShort::p_builtin_type == NULL)
             {
               SgTypeUnsignedShort::p_builtin_type = SgTypeUnsignedShort_builtin_type;
             }
        }
     if ( SgTypeInt_builtin_type != NULL ) 
        {
          if (SgTypeInt::p_builtin_type == NULL)
             {
               SgTypeInt::p_builtin_type = SgTypeInt_builtin_type;
             }
        }
     if ( SgTypeSignedInt_builtin_type != NULL ) 
        {
          if (SgTypeSignedInt::p_builtin_type == NULL)
             {
               SgTypeSignedInt::p_builtin_type = SgTypeSignedInt_builtin_type;
             }
        }
     if ( SgTypeUnsignedInt_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedInt::p_builtin_type == NULL)
             {
               SgTypeUnsignedInt::p_builtin_type = SgTypeUnsignedInt_builtin_type;
             }
        }
     if ( SgTypeLong_builtin_type != NULL ) 
        {
          if (SgTypeLong::p_builtin_type == NULL)
             {
               SgTypeLong::p_builtin_type = SgTypeLong_builtin_type;
             }
        }
     if ( SgTypeSignedLong_builtin_type != NULL ) 
        {
          if (SgTypeSignedLong::p_builtin_type == NULL)
             {
               SgTypeSignedLong::p_builtin_type = SgTypeSignedLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLong_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedLong::p_builtin_type == NULL)
             {
               SgTypeUnsignedLong::p_builtin_type = SgTypeUnsignedLong_builtin_type;
             }
        }
     if ( SgTypeVoid_builtin_type != NULL ) 
        {
          if (SgTypeVoid::p_builtin_type == NULL)
             {
               SgTypeVoid::p_builtin_type = SgTypeVoid_builtin_type;
             }
        }
     if ( SgTypeGlobalVoid_builtin_type != NULL ) 
        {
          if (SgTypeGlobalVoid::p_builtin_type == NULL)
             {
               SgTypeGlobalVoid::p_builtin_type = SgTypeGlobalVoid_builtin_type;
             }
        }
     if ( SgTypeWchar_builtin_type != NULL ) 
        {
          if (SgTypeWchar::p_builtin_type == NULL)
             {
               SgTypeWchar::p_builtin_type = SgTypeWchar_builtin_type;
             }
        }
     if ( SgTypeFloat_builtin_type != NULL ) 
        {
          if (SgTypeFloat::p_builtin_type == NULL)
             {
               SgTypeFloat::p_builtin_type = SgTypeFloat_builtin_type;
             }
        }
     if ( SgTypeDouble_builtin_type != NULL ) 
        {
          if (SgTypeDouble::p_builtin_type == NULL)
             {
               SgTypeDouble::p_builtin_type = SgTypeDouble_builtin_type;
             }
        }
     if ( SgTypeLongLong_builtin_type != NULL ) 
        {
          if (SgTypeLongLong::p_builtin_type == NULL)
             {
               SgTypeLongLong::p_builtin_type = SgTypeLongLong_builtin_type;
             }
        }
     if ( SgTypeSignedLongLong_builtin_type != NULL ) 
        {
          if (SgTypeSignedLongLong::p_builtin_type == NULL)
             {
               SgTypeSignedLongLong::p_builtin_type = SgTypeSignedLongLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLongLong_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedLongLong::p_builtin_type == NULL)
             {
               SgTypeUnsignedLongLong::p_builtin_type = SgTypeUnsignedLongLong_builtin_type;
             }
        }
     if ( SgTypeLongDouble_builtin_type != NULL ) 
        {
          if (SgTypeLongDouble::p_builtin_type == NULL)
             {
               SgTypeLongDouble::p_builtin_type = SgTypeLongDouble_builtin_type;
             }
        }
     if ( SgTypeBool_builtin_type != NULL ) 
        {
          if (SgTypeBool::p_builtin_type == NULL)
             {
               SgTypeBool::p_builtin_type = SgTypeBool_builtin_type;
             }
        }
     if ( SgNamedType_builtin_type != NULL ) 
        {
          if (SgNamedType::p_builtin_type == NULL)
             {
               SgNamedType::p_builtin_type = SgNamedType_builtin_type;
             }
        }
     if ( SgPartialFunctionModifierType_builtin_type != NULL ) 
        {
          if (SgPartialFunctionModifierType::p_builtin_type == NULL)
             {
               SgPartialFunctionModifierType::p_builtin_type = SgPartialFunctionModifierType_builtin_type;
             }
        }
     if ( SgTypeEllipse_builtin_type != NULL ) 
        {
          if (SgTypeEllipse::p_builtin_type == NULL)
             {
               SgTypeEllipse::p_builtin_type = SgTypeEllipse_builtin_type;
             }
        }
     if ( SgTypeDefault_builtin_type != NULL ) 
        {
          if (SgTypeDefault::p_builtin_type == NULL)
             {
               SgTypeDefault::p_builtin_type = SgTypeDefault_builtin_type;
             }
        }
     if ( SgTypeCAFTeam_builtin_type != NULL ) 
        {
          if (SgTypeCAFTeam::p_builtin_type == NULL)
             {
               SgTypeCAFTeam::p_builtin_type = SgTypeCAFTeam_builtin_type;
             }
        }
     if ( SgTypeCrayPointer_builtin_type != NULL ) 
        {
          if (SgTypeCrayPointer::p_builtin_type == NULL)
             {
               SgTypeCrayPointer::p_builtin_type = SgTypeCrayPointer_builtin_type;
             }
        }
     if ( SgTypeLabel_builtin_type != NULL ) 
        {
          if (SgTypeLabel::p_builtin_type == NULL)
             {
               SgTypeLabel::p_builtin_type = SgTypeLabel_builtin_type;
             }
        }
     if ( SgAsmTypeByte_builtin_type != NULL ) 
        {
          if (SgAsmTypeByte::p_builtin_type == NULL)
             {
               SgAsmTypeByte::p_builtin_type = SgAsmTypeByte_builtin_type;
             }
        }
     if ( SgAsmTypeWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeWord::p_builtin_type == NULL)
             {
               SgAsmTypeWord::p_builtin_type = SgAsmTypeWord_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleWord::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleWord::p_builtin_type = SgAsmTypeDoubleWord_builtin_type;
             }
        }
     if ( SgAsmTypeQuadWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeQuadWord::p_builtin_type == NULL)
             {
               SgAsmTypeQuadWord::p_builtin_type = SgAsmTypeQuadWord_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleQuadWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleQuadWord::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleQuadWord::p_builtin_type = SgAsmTypeDoubleQuadWord_builtin_type;
             }
        }
     if ( SgAsmType80bitFloat_builtin_type != NULL ) 
        {
          if (SgAsmType80bitFloat::p_builtin_type == NULL)
             {
               SgAsmType80bitFloat::p_builtin_type = SgAsmType80bitFloat_builtin_type;
             }
        }
     if ( SgAsmType128bitFloat_builtin_type != NULL ) 
        {
          if (SgAsmType128bitFloat::p_builtin_type == NULL)
             {
               SgAsmType128bitFloat::p_builtin_type = SgAsmType128bitFloat_builtin_type;
             }
        }
     if ( SgAsmTypeSingleFloat_builtin_type != NULL ) 
        {
          if (SgAsmTypeSingleFloat::p_builtin_type == NULL)
             {
               SgAsmTypeSingleFloat::p_builtin_type = SgAsmTypeSingleFloat_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleFloat_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleFloat::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleFloat::p_builtin_type = SgAsmTypeDoubleFloat_builtin_type;
             }
        }
   }

void
AstSpecificDataManagingClassStorageClass::pickOutIRNodeData ( AstSpecificDataManagingClass* source )
   {
     for(int i =  0; i < 666 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source->listOfAccumulatedPoolSizes[i];
        }
     rootOfAst =  AST_FILE_IO::getGlobalIndexFromSgClassPointer (source->rootOfAst);
     storageOf_SgNode_globalFunctionTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalFunctionTypeTable );
     storageOf_SgNode_globalTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalTypeTable );
     storageOf_SgNode_globalMangledNameMap.storeDataInEasyStorageClass( source->SgNode_globalMangledNameMap);
     storageOf_SgNode_shortMangledNameCache.storeDataInEasyStorageClass( source->SgNode_shortMangledNameCache);
     storageOf_Sg_File_Info_fileidtoname_map.storeDataInEasyStorageClass( source->Sg_File_Info_fileidtoname_map);
     storageOf_Sg_File_Info_nametofileid_map.storeDataInEasyStorageClass( source->Sg_File_Info_nametofileid_map);
     SgTypePtrList::iterator i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     unsigned int tempListCountSgUnparse_Info = 0; 
     SgTypePtrList::value_type *  tempListSgUnparse_Info = new SgTypePtrList::value_type[ source->SgUnparse_Info_structureTagProcessingList.size() ]; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          tempListSgUnparse_Info[tempListCountSgUnparse_Info] = *i_SgUnparse_Info;
          tempListCountSgUnparse_Info++; 
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_SgUnparse_Info ) );
        }
     storageOf_SgUnparse_Info_structureTagProcessingList.storeDataInEasyStorageClass(source->SgUnparse_Info_structureTagProcessingList);
     tempListCountSgUnparse_Info = 0; 
     i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          *i_SgUnparse_Info = tempListSgUnparse_Info[tempListCountSgUnparse_Info] ;
          tempListCountSgUnparse_Info++; 
        }
      delete [] tempListSgUnparse_Info; 
     storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError =  source->SgUnparse_Info_forceDefaultConstructorToTriggerError ;
     storageOf_SgGraph_index_counter =  source->SgGraph_index_counter ;
     storageOf_SgGraphNode_index_counter =  source->SgGraphNode_index_counter ;
     storageOf_SgGraphEdge_index_counter =  source->SgGraphEdge_index_counter ;
     storageOf_SgTypeUnknown_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnknown_builtin_type );
     storageOf_SgTypeChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeChar_builtin_type );
     storageOf_SgTypeSignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedChar_builtin_type );
     storageOf_SgTypeUnsignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedChar_builtin_type );
     storageOf_SgTypeShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeShort_builtin_type );
     storageOf_SgTypeSignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedShort_builtin_type );
     storageOf_SgTypeUnsignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedShort_builtin_type );
     storageOf_SgTypeInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeInt_builtin_type );
     storageOf_SgTypeSignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedInt_builtin_type );
     storageOf_SgTypeUnsignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedInt_builtin_type );
     storageOf_SgTypeLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLong_builtin_type );
     storageOf_SgTypeSignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLong_builtin_type );
     storageOf_SgTypeUnsignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLong_builtin_type );
     storageOf_SgTypeVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeVoid_builtin_type );
     storageOf_SgTypeGlobalVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeGlobalVoid_builtin_type );
     storageOf_SgTypeWchar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeWchar_builtin_type );
     storageOf_SgTypeFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeFloat_builtin_type );
     storageOf_SgTypeDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDouble_builtin_type );
     storageOf_SgTypeLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongLong_builtin_type );
     storageOf_SgTypeSignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLongLong_builtin_type );
     storageOf_SgTypeUnsignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLongLong_builtin_type );
     storageOf_SgTypeLongDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongDouble_builtin_type );
     storageOf_SgTypeBool_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeBool_builtin_type );
     storageOf_SgNamedType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNamedType_builtin_type );
     storageOf_SgPartialFunctionModifierType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgPartialFunctionModifierType_builtin_type );
     storageOf_SgTypeEllipse_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeEllipse_builtin_type );
     storageOf_SgTypeDefault_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDefault_builtin_type );
     storageOf_SgTypeCAFTeam_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCAFTeam_builtin_type );
     storageOf_SgTypeCrayPointer_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCrayPointer_builtin_type );
     storageOf_SgTypeLabel_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLabel_builtin_type );
     storageOf_SgAsmTypeByte_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeByte_builtin_type );
     storageOf_SgAsmTypeWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeWord_builtin_type );
     storageOf_SgAsmTypeDoubleWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleWord_builtin_type );
     storageOf_SgAsmTypeQuadWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeQuadWord_builtin_type );
     storageOf_SgAsmTypeDoubleQuadWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleQuadWord_builtin_type );
     storageOf_SgAsmType80bitFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmType80bitFloat_builtin_type );
     storageOf_SgAsmType128bitFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmType128bitFloat_builtin_type );
     storageOf_SgAsmTypeSingleFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeSingleFloat_builtin_type );
     storageOf_SgAsmTypeDoubleFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleFloat_builtin_type );
   }

AstSpecificDataManagingClass::AstSpecificDataManagingClass(const AstSpecificDataManagingClassStorageClass& source)
   {
     for(int i =  0; i < 666 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source.listOfAccumulatedPoolSizes[i];
        }
     astIndex = AST_FILE_IO::getNumberOfAsts();
     AST_FILE_IO::addNewAst(this);

  // Note that this call is required to define the locations of IR nodes as addresses 
  // which will be used to reset pointers from global IDs to pointer valuses within the 
  // AST FILE I/O (reading binary ASTs) 
     AST_FILE_IO::extendMemoryPoolsForRebuildingAST();

     rootOfAst = (SgProject*)(AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.rootOfAst));
     SgNode_globalFunctionTypeTable = (SgFunctionTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalFunctionTypeTable ) );
     SgNode_globalTypeTable = (SgTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalTypeTable ) );
     SgNode_globalMangledNameMap = source.storageOf_SgNode_globalMangledNameMap.rebuildDataStoredInEasyStorageClass();
     SgNode_shortMangledNameCache = source.storageOf_SgNode_shortMangledNameCache.rebuildDataStoredInEasyStorageClass();
     Sg_File_Info_fileidtoname_map = source.storageOf_Sg_File_Info_fileidtoname_map.rebuildDataStoredInEasyStorageClass();
     Sg_File_Info_nametofileid_map = source.storageOf_Sg_File_Info_nametofileid_map.rebuildDataStoredInEasyStorageClass();
     SgUnparse_Info_structureTagProcessingList = source.storageOf_SgUnparse_Info_structureTagProcessingList.rebuildDataStoredInEasyStorageClass();
     SgTypePtrList::iterator i_SgUnparse_Info = SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getSgClassPointerFromGlobalIndex ( (unsigned long) (*i_SgUnparse_Info )  ) );
        }
     SgUnparse_Info_forceDefaultConstructorToTriggerError = source.storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgGraph_index_counter = source.storageOf_SgGraph_index_counter;
     SgGraphNode_index_counter = source.storageOf_SgGraphNode_index_counter;
     SgGraphEdge_index_counter = source.storageOf_SgGraphEdge_index_counter;
     SgTypeUnknown_builtin_type = (SgTypeUnknown* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnknown_builtin_type ) );
     SgTypeChar_builtin_type = (SgTypeChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeChar_builtin_type ) );
     SgTypeSignedChar_builtin_type = (SgTypeSignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedChar_builtin_type ) );
     SgTypeUnsignedChar_builtin_type = (SgTypeUnsignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedChar_builtin_type ) );
     SgTypeShort_builtin_type = (SgTypeShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeShort_builtin_type ) );
     SgTypeSignedShort_builtin_type = (SgTypeSignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedShort_builtin_type ) );
     SgTypeUnsignedShort_builtin_type = (SgTypeUnsignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedShort_builtin_type ) );
     SgTypeInt_builtin_type = (SgTypeInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeInt_builtin_type ) );
     SgTypeSignedInt_builtin_type = (SgTypeSignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedInt_builtin_type ) );
     SgTypeUnsignedInt_builtin_type = (SgTypeUnsignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedInt_builtin_type ) );
     SgTypeLong_builtin_type = (SgTypeLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLong_builtin_type ) );
     SgTypeSignedLong_builtin_type = (SgTypeSignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLong_builtin_type ) );
     SgTypeUnsignedLong_builtin_type = (SgTypeUnsignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLong_builtin_type ) );
     SgTypeVoid_builtin_type = (SgTypeVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeVoid_builtin_type ) );
     SgTypeGlobalVoid_builtin_type = (SgTypeGlobalVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeGlobalVoid_builtin_type ) );
     SgTypeWchar_builtin_type = (SgTypeWchar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeWchar_builtin_type ) );
     SgTypeFloat_builtin_type = (SgTypeFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeFloat_builtin_type ) );
     SgTypeDouble_builtin_type = (SgTypeDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDouble_builtin_type ) );
     SgTypeLongLong_builtin_type = (SgTypeLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongLong_builtin_type ) );
     SgTypeSignedLongLong_builtin_type = (SgTypeSignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLongLong_builtin_type ) );
     SgTypeUnsignedLongLong_builtin_type = (SgTypeUnsignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLongLong_builtin_type ) );
     SgTypeLongDouble_builtin_type = (SgTypeLongDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongDouble_builtin_type ) );
     SgTypeBool_builtin_type = (SgTypeBool* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeBool_builtin_type ) );
     SgNamedType_builtin_type = (SgNamedType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNamedType_builtin_type ) );
     SgPartialFunctionModifierType_builtin_type = (SgPartialFunctionModifierType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgPartialFunctionModifierType_builtin_type ) );
     SgTypeEllipse_builtin_type = (SgTypeEllipse* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeEllipse_builtin_type ) );
     SgTypeDefault_builtin_type = (SgTypeDefault* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDefault_builtin_type ) );
     SgTypeCAFTeam_builtin_type = (SgTypeCAFTeam* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCAFTeam_builtin_type ) );
     SgTypeCrayPointer_builtin_type = (SgTypeCrayPointer* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCrayPointer_builtin_type ) );
     SgTypeLabel_builtin_type = (SgTypeLabel* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLabel_builtin_type ) );
     SgAsmTypeByte_builtin_type = (SgAsmTypeByte* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeByte_builtin_type ) );
     SgAsmTypeWord_builtin_type = (SgAsmTypeWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeWord_builtin_type ) );
     SgAsmTypeDoubleWord_builtin_type = (SgAsmTypeDoubleWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleWord_builtin_type ) );
     SgAsmTypeQuadWord_builtin_type = (SgAsmTypeQuadWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeQuadWord_builtin_type ) );
     SgAsmTypeDoubleQuadWord_builtin_type = (SgAsmTypeDoubleQuadWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleQuadWord_builtin_type ) );
     SgAsmType80bitFloat_builtin_type = (SgAsmType80bitFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmType80bitFloat_builtin_type ) );
     SgAsmType128bitFloat_builtin_type = (SgAsmType128bitFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmType128bitFloat_builtin_type ) );
     SgAsmTypeSingleFloat_builtin_type = (SgAsmTypeSingleFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeSingleFloat_builtin_type ) );
     SgAsmTypeDoubleFloat_builtin_type = (SgAsmTypeDoubleFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleFloat_builtin_type ) );
   }

void
AstSpecificDataManagingClassStorageClass:: writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, int> > :: writeToFile(out);
     EasyStorage<std::map<int, std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, int> > :: writeToFile(out);
     EasyStorage<SgTypePtrList > :: writeToFile(out);
   }

void
AstSpecificDataManagingClassStorageClass:: readEasyStorageDataFromFile (std::istream& in)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, int> > :: readFromFile(in) ;
     EasyStorage<std::map<int, std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, int> > :: readFromFile(in) ;
     EasyStorage<SgTypePtrList > :: readFromFile(in) ;
   }

void
AstSpecificDataManagingClassStorageClass:: arrangeStaticDataOfEasyStorageClassesInOneBlock()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, int> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, int> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<SgTypePtrList > :: arrangeMemoryPoolInOneBlock();
   }

void
AstSpecificDataManagingClassStorageClass:: deleteStaticDataOfEasyStorageClasses()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, int> > :: deleteMemoryPool();
     EasyStorage<std::map<int, std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, int> > :: deleteMemoryPool();
     EasyStorage<SgTypePtrList > :: deleteMemoryPool();
   }



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 922 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNodeStorageClass::pickOutIRNodeData ( SgNode* pointer ) 
   { 
     SgNode* source = (SgNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 943 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 956 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSupportStorageClass::pickOutIRNodeData ( SgSupport* pointer ) 
   { 
     SgSupport* source = (SgSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 977 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 990 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierStorageClass::pickOutIRNodeData ( SgModifier* pointer ) 
   { 
     SgModifier* source = (SgModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierNodesStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierNodesStorageClass::pickOutIRNodeData ( SgModifierNodes* pointer ) 
   { 
     SgModifierNodes* source = (SgModifierNodes*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgModifierTypePtrVector::iterator i_nodes = source->p_nodes.begin() ; 
     unsigned int tempListCountnodes = 0; 
     SgModifierTypePtrVector::value_type *  tempListnodes = new SgModifierTypePtrVector::value_type[ source->p_nodes.size() ]; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          tempListnodes[tempListCountnodes] = *i_nodes;
          tempListCountnodes++; 
          (*i_nodes) = (SgModifierTypePtrVector::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_nodes ) );
        }
     storageOf_nodes.storeDataInEasyStorageClass(source->p_nodes);
     tempListCountnodes = 0; 
     i_nodes = source->p_nodes.begin() ; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          *i_nodes = tempListnodes[tempListCountnodes] ;
          tempListCountnodes++; 
        }
      delete [] tempListnodes; 
     storageOf_next = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_next );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModifierNodesStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModifierTypePtrVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierNodesStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModifierTypePtrVector > :: deleteMemoryPool() ;
   }

void
SgModifierNodesStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModifierTypePtrVector > :: writeToFile(out) ;
   }


void
SgModifierNodesStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModifierTypePtrVector > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1090 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstVolatileModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1103 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConstVolatileModifierStorageClass::pickOutIRNodeData ( SgConstVolatileModifier* pointer ) 
   { 
     SgConstVolatileModifier* source = (SgConstVolatileModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1125 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStorageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1138 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStorageModifierStorageClass::pickOutIRNodeData ( SgStorageModifier* pointer ) 
   { 
     SgStorageModifier* source = (SgStorageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_thread_local_storage =  source->p_thread_local_storage ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1161 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1174 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAccessModifierStorageClass::pickOutIRNodeData ( SgAccessModifier* pointer ) 
   { 
     SgAccessModifier* source = (SgAccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1196 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1209 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionModifierStorageClass::pickOutIRNodeData ( SgFunctionModifier* pointer ) 
   { 
     SgFunctionModifier* source = (SgFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_gnu_attribute_constructor_destructor_priority =  source->p_gnu_attribute_constructor_destructor_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_opencl_vec_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opencl_vec_type );
     storageOf_opencl_work_group_size =  source->p_opencl_work_group_size ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1266 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUPC_AccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1279 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUPC_AccessModifierStorageClass::pickOutIRNodeData ( SgUPC_AccessModifier* pointer ) 
   { 
     SgUPC_AccessModifier* source = (SgUPC_AccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_isShared =  source->p_isShared ;
     storageOf_layout =  source->p_layout ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1303 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpecialFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1316 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSpecialFunctionModifierStorageClass::pickOutIRNodeData ( SgSpecialFunctionModifier* pointer ) 
   { 
     SgSpecialFunctionModifier* source = (SgSpecialFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSpecialFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpecialFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgSpecialFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgSpecialFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1364 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElaboratedTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1377 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElaboratedTypeModifierStorageClass::pickOutIRNodeData ( SgElaboratedTypeModifier* pointer ) 
   { 
     SgElaboratedTypeModifier* source = (SgElaboratedTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1399 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinkageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1412 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLinkageModifierStorageClass::pickOutIRNodeData ( SgLinkageModifier* pointer ) 
   { 
     SgLinkageModifier* source = (SgLinkageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1434 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1447 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassModifierStorageClass::pickOutIRNodeData ( SgBaseClassModifier* pointer ) 
   { 
     SgBaseClassModifier* source = (SgBaseClassModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBaseClassModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
   }

void
SgBaseClassModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
   }

void
SgBaseClassModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
   }


void
SgBaseClassModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1492 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1505 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeModifierStorageClass::pickOutIRNodeData ( SgTypeModifier* pointer ) 
   { 
     SgTypeModifier* source = (SgTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_upcModifier.pickOutIRNodeData( &(source->p_upcModifier) );
     storageOf_constVolatileModifier.pickOutIRNodeData( &(source->p_constVolatileModifier) );
     storageOf_elaboratedTypeModifier.pickOutIRNodeData( &(source->p_elaboratedTypeModifier) );
     storageOf_gnu_extension_machine_mode =  source->p_gnu_extension_machine_mode ;
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_sentinel =  source->p_gnu_attribute_sentinel ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgTypeModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgTypeModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1559 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1572 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationModifierStorageClass::pickOutIRNodeData ( SgDeclarationModifier* pointer ) 
   { 
     SgDeclarationModifier* source = (SgDeclarationModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_storageModifier.pickOutIRNodeData( &(source->p_storageModifier) );
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeclarationModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgDeclarationModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgDeclarationModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1633 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenclAccessModeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1646 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOpenclAccessModeModifierStorageClass::pickOutIRNodeData ( SgOpenclAccessModeModifier* pointer ) 
   { 
     SgOpenclAccessModeModifier* source = (SgOpenclAccessModeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1668 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1681 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNameStorageClass::pickOutIRNodeData ( SgName* pointer ) 
   { 
     SgName* source = (SgName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_char.storeDataInEasyStorageClass(source->p_char);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1729 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1742 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolTableStorageClass::pickOutIRNodeData ( SgSymbolTable* pointer ) 
   { 
     SgSymbolTable* source = (SgSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_no_name =  source->p_no_name ;
     rose_hash_multimap::iterator it; 
     unsigned int tempListCounttable = 0; 
     SgSymbol** tempListtable = new SgSymbol* [ source->p_table->size() ]; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it)
        {
          tempListtable[tempListCounttable] = it->second;
          tempListCounttable++; 
          it->second = (SgSymbol*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(it->second) ); 
        }
     storageOf_table.storeDataInEasyStorageClass(source->p_table);
     tempListCounttable = 0; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it) 
        {
          it->second = tempListtable [ tempListCounttable ]; 
          tempListCounttable++; 
        }
      delete [] tempListtable; 
     storageOf_symbolSet.storeDataInEasyStorageClass(source->p_symbolSet);
     storageOf_case_insensitive =  source->p_case_insensitive ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage <  rose_hash_multimap* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgNodeSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage <  rose_hash_multimap* > :: deleteMemoryPool() ;
     EasyStorage < SgNodeSet > :: deleteMemoryPool() ;
   }

void
SgSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage <  rose_hash_multimap* > :: writeToFile(out) ;
     EasyStorage < SgNodeSet > :: writeToFile(out) ;
   }


void
SgSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage <  rose_hash_multimap* > :: readFromFile(in) ;
     EasyStorage < SgNodeSet > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1818 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1831 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeStorageClass::pickOutIRNodeData ( SgAttribute* pointer ) 
   { 
     SgAttribute* source = (SgAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1879 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1892 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaStorageClass::pickOutIRNodeData ( SgPragma* pointer ) 
   { 
     SgPragma* source = (SgPragma*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_printed =  source->p_printed ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPragmaStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgPragmaStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgPragmaStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1947 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1960 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitAttributeStorageClass::pickOutIRNodeData ( SgBitAttribute* pointer ) 
   { 
     SgBitAttribute* source = (SgBitAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgBitAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgBitAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2009 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFuncDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2022 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFuncDecl_attrStorageClass::pickOutIRNodeData ( SgFuncDecl_attr* pointer ) 
   { 
     SgFuncDecl_attr* source = (SgFuncDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFuncDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFuncDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFuncDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFuncDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2071 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2084 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDecl_attrStorageClass::pickOutIRNodeData ( SgClassDecl_attr* pointer ) 
   { 
     SgClassDecl_attr* source = (SgClassDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgClassDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgClassDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2133 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the Sg_File_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2146 "../../../src/frontend/SageIII//StorageClasses.C" */


void
Sg_File_InfoStorageClass::pickOutIRNodeData ( Sg_File_Info* pointer ) 
   { 
     Sg_File_Info* source = (Sg_File_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_col =  source->p_col ;
     storageOf_classificationBitField =  source->p_classificationBitField ;
     storageOf_fileIDsToUnparse.storeDataInEasyStorageClass(source->p_fileIDsToUnparse);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
Sg_File_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileIdList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
Sg_File_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileIdList > :: deleteMemoryPool() ;
   }

void
Sg_File_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileIdList > :: writeToFile(out) ;
   }


void
Sg_File_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileIdList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2198 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2211 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFileStorageClass::pickOutIRNodeData ( SgFile* pointer ) 
   { 
     SgFile* source = (SgFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2362 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSourceFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2375 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSourceFileStorageClass::pickOutIRNodeData ( SgSourceFile* pointer ) 
   { 
     SgSourceFile* source = (SgSourceFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     SgModuleStatementPtrList::iterator i_module_list = source->p_module_list.begin() ; 
     unsigned int tempListCountmodule_list = 0; 
     SgModuleStatementPtrList::value_type *  tempListmodule_list = new SgModuleStatementPtrList::value_type[ source->p_module_list.size() ]; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          tempListmodule_list[tempListCountmodule_list] = *i_module_list;
          tempListCountmodule_list++; 
          (*i_module_list) = (SgModuleStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_module_list ) );
        }
     storageOf_module_list.storeDataInEasyStorageClass(source->p_module_list);
     tempListCountmodule_list = 0; 
     i_module_list = source->p_module_list.begin() ; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          *i_module_list = tempListmodule_list[tempListCountmodule_list] ;
          tempListCountmodule_list++; 
        }
      delete [] tempListmodule_list; 
     SgTokenPtrList::iterator i_token_list = source->p_token_list.begin() ; 
     unsigned int tempListCounttoken_list = 0; 
     SgTokenPtrList::value_type *  tempListtoken_list = new SgTokenPtrList::value_type[ source->p_token_list.size() ]; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          tempListtoken_list[tempListCounttoken_list] = *i_token_list;
          tempListCounttoken_list++; 
          (*i_token_list) = (SgTokenPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_token_list ) );
        }
     storageOf_token_list.storeDataInEasyStorageClass(source->p_token_list);
     tempListCounttoken_list = 0; 
     i_token_list = source->p_token_list.begin() ; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          *i_token_list = tempListtoken_list[tempListCounttoken_list] ;
          tempListCounttoken_list++; 
        }
      delete [] tempListtoken_list; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSourceFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModuleStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTokenPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSourceFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModuleStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTokenPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSourceFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModuleStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgTokenPtrList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSourceFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModuleStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgTokenPtrList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2571 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryCompositeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2584 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryCompositeStorageClass::pickOutIRNodeData ( SgBinaryComposite* pointer ) 
   { 
     SgBinaryComposite* source = (SgBinaryComposite*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_genericFileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_genericFileList );
     storageOf_interpretations = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_interpretations );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBinaryCompositeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryCompositeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryCompositeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryCompositeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2737 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2750 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownFileStorageClass::pickOutIRNodeData ( SgUnknownFile* pointer ) 
   { 
     SgUnknownFile* source = (SgUnknownFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnknownFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2902 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2915 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProjectStorageClass::pickOutIRNodeData ( SgProject* pointer ) 
   { 
     SgProject* source = (SgProject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_fileList_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList_ptr );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_backendErrorCode =  source->p_backendErrorCode ;
     storageOf_outputFileName.storeDataInEasyStorageClass(source->p_outputFileName);
     storageOf_sourceFileNameList.storeDataInEasyStorageClass(source->p_sourceFileNameList);
     storageOf_objectFileNameList.storeDataInEasyStorageClass(source->p_objectFileNameList);
     storageOf_libraryFileList.storeDataInEasyStorageClass(source->p_libraryFileList);
     storageOf_librarySpecifierList.storeDataInEasyStorageClass(source->p_librarySpecifierList);
     storageOf_libraryDirectorySpecifierList.storeDataInEasyStorageClass(source->p_libraryDirectorySpecifierList);
     storageOf_includeDirectorySpecifierList.storeDataInEasyStorageClass(source->p_includeDirectorySpecifierList);
     storageOf_macroSpecifierList.storeDataInEasyStorageClass(source->p_macroSpecifierList);
     storageOf_preincludeFileList.storeDataInEasyStorageClass(source->p_preincludeFileList);
     storageOf_preincludeDirectoryList.storeDataInEasyStorageClass(source->p_preincludeDirectoryList);
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_wave =  source->p_wave ;
     storageOf_prelink =  source->p_prelink ;
     storageOf_template_instantiation_mode =  source->p_template_instantiation_mode ;
     storageOf_astMerge =  source->p_astMerge ;
     storageOf_astMergeCommandFile.storeDataInEasyStorageClass(source->p_astMergeCommandFile);
     storageOf_C_PreprocessorOnly =  source->p_C_PreprocessorOnly ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_compilationPerformanceFile.storeDataInEasyStorageClass(source->p_compilationPerformanceFile);
     storageOf_includePathList.storeDataInEasyStorageClass(source->p_includePathList);
     storageOf_excludePathList.storeDataInEasyStorageClass(source->p_excludePathList);
     storageOf_includeFileList.storeDataInEasyStorageClass(source->p_includeFileList);
     storageOf_excludeFileList.storeDataInEasyStorageClass(source->p_excludeFileList);
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_dataBaseFilename.storeDataInEasyStorageClass(source->p_dataBaseFilename);
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_addCppDirectivesToAST =  source->p_addCppDirectivesToAST ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3005 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOptionsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3018 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOptionsStorageClass::pickOutIRNodeData ( SgOptions* pointer ) 
   { 
     SgOptions* source = (SgOptions*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_debug_level =  source->p_debug_level ;
     storageOf_logging_level =  source->p_logging_level ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3041 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnparse_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3054 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnparse_InfoStorageClass::pickOutIRNodeData ( SgUnparse_Info* pointer ) 
   { 
     SgUnparse_Info* source = (SgUnparse_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_unparse_attribute.storeDataInEasyStorageClass(source->p_unparse_attribute);
     storageOf_access_attribute =  source->p_access_attribute ;
     storageOf_nested_expression =  source->p_nested_expression ;
     storageOf_operator_name.storeDataInEasyStorageClass(source->p_operator_name);
     storageOf_var_name.pickOutIRNodeData( &(source->p_var_name) );
     storageOf_declstatement_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declstatement_ptr );
     storageOf_current_context = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_context );
     storageOf_array_index_list.pickOutIRNodeData( &(source->p_array_index_list) );
     storageOf_current_namespace = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_namespace );
     storageOf_outputCodeGenerationFormatDelimiters =  source->p_outputCodeGenerationFormatDelimiters ;
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_current_function_call = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_function_call );
     storageOf_current_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_scope );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnparse_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnparse_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
   }

void
SgUnparse_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
   }


void
SgUnparse_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3143 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3156 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassStorageClass::pickOutIRNodeData ( SgBaseClass* pointer ) 
   { 
     SgBaseClass* source = (SgBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3180 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3193 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSeqStorageClass::pickOutIRNodeData ( SgTypedefSeq* pointer ) 
   { 
     SgTypedefSeq* source = (SgTypedefSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTypePtrList::iterator i_typedefs = source->p_typedefs.begin() ; 
     unsigned int tempListCounttypedefs = 0; 
     SgTypePtrList::value_type *  tempListtypedefs = new SgTypePtrList::value_type[ source->p_typedefs.size() ]; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          tempListtypedefs[tempListCounttypedefs] = *i_typedefs;
          tempListCounttypedefs++; 
          (*i_typedefs) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_typedefs ) );
        }
     storageOf_typedefs.storeDataInEasyStorageClass(source->p_typedefs);
     tempListCounttypedefs = 0; 
     i_typedefs = source->p_typedefs.begin() ; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          *i_typedefs = tempListtypedefs[tempListCounttypedefs] ;
          tempListCounttypedefs++; 
        }
      delete [] tempListtypedefs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgTypedefSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgTypedefSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3258 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3271 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterStorageClass::pickOutIRNodeData ( SgTemplateParameter* pointer ) 
   { 
     SgTemplateParameter* source = (SgTemplateParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parameterType =  source->p_parameterType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_defaultTypeParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTypeParameter );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_defaultExpressionParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultExpressionParameter );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_defaultTemplateDeclarationParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTemplateDeclarationParameter );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3299 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3312 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentStorageClass::pickOutIRNodeData ( SgTemplateArgument* pointer ) 
   { 
     SgTemplateArgument* source = (SgTemplateArgument*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_argumentType =  source->p_argumentType ;
     storageOf_isArrayBoundUnknownType =  source->p_isArrayBoundUnknownType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_explicitlySpecified =  source->p_explicitlySpecified ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3339 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3352 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryStorageClass::pickOutIRNodeData ( SgDirectory* pointer ) 
   { 
     SgDirectory* source = (SgDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList );
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3407 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3420 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFileListStorageClass::pickOutIRNodeData ( SgFileList* pointer ) 
   { 
     SgFileList* source = (SgFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgFilePtrList::iterator i_listOfFiles = source->p_listOfFiles.begin() ; 
     unsigned int tempListCountlistOfFiles = 0; 
     SgFilePtrList::value_type *  tempListlistOfFiles = new SgFilePtrList::value_type[ source->p_listOfFiles.size() ]; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          tempListlistOfFiles[tempListCountlistOfFiles] = *i_listOfFiles;
          tempListCountlistOfFiles++; 
          (*i_listOfFiles) = (SgFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfFiles ) );
        }
     storageOf_listOfFiles.storeDataInEasyStorageClass(source->p_listOfFiles);
     tempListCountlistOfFiles = 0; 
     i_listOfFiles = source->p_listOfFiles.begin() ; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          *i_listOfFiles = tempListlistOfFiles[tempListCountlistOfFiles] ;
          tempListCountlistOfFiles++; 
        }
      delete [] tempListlistOfFiles; 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFilePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFilePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3490 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3503 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryListStorageClass::pickOutIRNodeData ( SgDirectoryList* pointer ) 
   { 
     SgDirectoryList* source = (SgDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDirectoryPtrList::iterator i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     unsigned int tempListCountlistOfDirectories = 0; 
     SgDirectoryPtrList::value_type *  tempListlistOfDirectories = new SgDirectoryPtrList::value_type[ source->p_listOfDirectories.size() ]; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          tempListlistOfDirectories[tempListCountlistOfDirectories] = *i_listOfDirectories;
          tempListCountlistOfDirectories++; 
          (*i_listOfDirectories) = (SgDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfDirectories ) );
        }
     storageOf_listOfDirectories.storeDataInEasyStorageClass(source->p_listOfDirectories);
     tempListCountlistOfDirectories = 0; 
     i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          *i_listOfDirectories = tempListlistOfDirectories[tempListCountlistOfDirectories] ;
          tempListCountlistOfDirectories++; 
        }
      delete [] tempListlistOfDirectories; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDirectoryPtrList > :: deleteMemoryPool() ;
   }

void
SgDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDirectoryPtrList > :: writeToFile(out) ;
   }


void
SgDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDirectoryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3568 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterTypeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3581 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterTypeListStorageClass::pickOutIRNodeData ( SgFunctionParameterTypeList* pointer ) 
   { 
     SgFunctionParameterTypeList* source = (SgFunctionParameterTypeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTypePtrList::iterator i_arguments = source->p_arguments.begin() ; 
     unsigned int tempListCountarguments = 0; 
     SgTypePtrList::value_type *  tempListarguments = new SgTypePtrList::value_type[ source->p_arguments.size() ]; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          tempListarguments[tempListCountarguments] = *i_arguments;
          tempListCountarguments++; 
          (*i_arguments) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_arguments ) );
        }
     storageOf_arguments.storeDataInEasyStorageClass(source->p_arguments);
     tempListCountarguments = 0; 
     i_arguments = source->p_arguments.begin() ; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          *i_arguments = tempListarguments[tempListCountarguments] ;
          tempListCountarguments++; 
        }
      delete [] tempListarguments; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionParameterTypeListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterTypeListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterTypeListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgFunctionParameterTypeListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3646 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3659 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameStorageClass::pickOutIRNodeData ( SgQualifiedName* pointer ) 
   { 
     SgQualifiedName* source = (SgQualifiedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3681 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3694 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentListStorageClass::pickOutIRNodeData ( SgTemplateArgumentList* pointer ) 
   { 
     SgTemplateArgumentList* source = (SgTemplateArgumentList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTemplateArgumentPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListargs = new SgTemplateArgumentPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateArgumentListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateArgumentListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateArgumentListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
   }


void
SgTemplateArgumentListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3759 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3772 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterListStorageClass::pickOutIRNodeData ( SgTemplateParameterList* pointer ) 
   { 
     SgTemplateParameterList* source = (SgTemplateParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateParameterPtrList::value_type *  tempListargs = new SgTemplateParameterPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
   }


void
SgTemplateParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3837 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3850 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphStorageClass::pickOutIRNodeData ( SgGraph* pointer ) 
   { 
     SgGraph* source = (SgGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4047 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceDirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4060 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceDirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceDirectedGraph* pointer ) 
   { 
     SgIncidenceDirectedGraph* source = (SgIncidenceDirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncidenceDirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceDirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceDirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceDirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4295 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4308 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBidirectionalGraphStorageClass::pickOutIRNodeData ( SgBidirectionalGraph* pointer ) 
   { 
     SgBidirectionalGraph* source = (SgBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4543 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4556 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStringKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgStringKeyedBidirectionalGraph* pointer ) 
   { 
     SgStringKeyedBidirectionalGraph* source = (SgStringKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgStringKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4791 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4804 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgIntKeyedBidirectionalGraph* pointer ) 
   { 
     SgIntKeyedBidirectionalGraph* source = (SgIntKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIntKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5039 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceUndirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5052 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceUndirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceUndirectedGraph* pointer ) 
   { 
     SgIncidenceUndirectedGraph* source = (SgIncidenceUndirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncidenceUndirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceUndirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5249 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5262 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeStorageClass::pickOutIRNodeData ( SgGraphNode* pointer ) 
   { 
     SgGraphNode* source = (SgGraphNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_SgNode = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_SgNode );
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5322 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5335 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeStorageClass::pickOutIRNodeData ( SgGraphEdge* pointer ) 
   { 
     SgGraphEdge* source = (SgGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5396 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5409 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgDirectedGraphEdge* pointer ) 
   { 
     SgDirectedGraphEdge* source = (SgDirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgDirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgDirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5470 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5483 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUndirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgUndirectedGraphEdge* pointer ) 
   { 
     SgUndirectedGraphEdge* source = (SgUndirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUndirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgUndirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgUndirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5544 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5557 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeListStorageClass::pickOutIRNodeData ( SgGraphNodeList* pointer ) 
   { 
     SgGraphNodeList* source = (SgGraphNodeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5578 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5591 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeListStorageClass::pickOutIRNodeData ( SgGraphEdgeList* pointer ) 
   { 
     SgGraphEdgeList* source = (SgGraphEdgeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5612 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5625 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeTableStorageClass::pickOutIRNodeData ( SgTypeTable* pointer ) 
   { 
     SgTypeTable* source = (SgTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5647 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5660 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNameGroupStorageClass::pickOutIRNodeData ( SgNameGroup* pointer ) 
   { 
     SgNameGroup* source = (SgNameGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_group_name.storeDataInEasyStorageClass(source->p_group_name);
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNameGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
   }

void
SgNameGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
   }


void
SgNameGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5713 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDimensionObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5726 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDimensionObjectStorageClass::pickOutIRNodeData ( SgDimensionObject* pointer ) 
   { 
     SgDimensionObject* source = (SgDimensionObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_array = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_array );
     storageOf_shape = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shape );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5749 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5762 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemStorageClass::pickOutIRNodeData ( SgFormatItem* pointer ) 
   { 
     SgFormatItem* source = (SgFormatItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_repeat_specification =  source->p_repeat_specification ;
     storageOf_data = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_data );
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5786 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5799 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemListStorageClass::pickOutIRNodeData ( SgFormatItemList* pointer ) 
   { 
     SgFormatItemList* source = (SgFormatItemList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgFormatItemPtrList::iterator i_format_item_list = source->p_format_item_list.begin() ; 
     unsigned int tempListCountformat_item_list = 0; 
     SgFormatItemPtrList::value_type *  tempListformat_item_list = new SgFormatItemPtrList::value_type[ source->p_format_item_list.size() ]; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          tempListformat_item_list[tempListCountformat_item_list] = *i_format_item_list;
          tempListCountformat_item_list++; 
          (*i_format_item_list) = (SgFormatItemPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_format_item_list ) );
        }
     storageOf_format_item_list.storeDataInEasyStorageClass(source->p_format_item_list);
     tempListCountformat_item_list = 0; 
     i_format_item_list = source->p_format_item_list.begin() ; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          *i_format_item_list = tempListformat_item_list[tempListCountformat_item_list] ;
          tempListCountformat_item_list++; 
        }
      delete [] tempListformat_item_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFormatItemListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFormatItemPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatItemListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFormatItemPtrList > :: deleteMemoryPool() ;
   }

void
SgFormatItemListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFormatItemPtrList > :: writeToFile(out) ;
   }


void
SgFormatItemListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFormatItemPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5864 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5877 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementGroupStorageClass::pickOutIRNodeData ( SgDataStatementGroup* pointer ) 
   { 
     SgDataStatementGroup* source = (SgDataStatementGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDataStatementObjectPtrList::iterator i_object_list = source->p_object_list.begin() ; 
     unsigned int tempListCountobject_list = 0; 
     SgDataStatementObjectPtrList::value_type *  tempListobject_list = new SgDataStatementObjectPtrList::value_type[ source->p_object_list.size() ]; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          tempListobject_list[tempListCountobject_list] = *i_object_list;
          tempListCountobject_list++; 
          (*i_object_list) = (SgDataStatementObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_object_list ) );
        }
     storageOf_object_list.storeDataInEasyStorageClass(source->p_object_list);
     tempListCountobject_list = 0; 
     i_object_list = source->p_object_list.begin() ; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          *i_object_list = tempListobject_list[tempListCountobject_list] ;
          tempListCountobject_list++; 
        }
      delete [] tempListobject_list; 
     SgDataStatementValuePtrList::iterator i_value_list = source->p_value_list.begin() ; 
     unsigned int tempListCountvalue_list = 0; 
     SgDataStatementValuePtrList::value_type *  tempListvalue_list = new SgDataStatementValuePtrList::value_type[ source->p_value_list.size() ]; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          tempListvalue_list[tempListCountvalue_list] = *i_value_list;
          tempListCountvalue_list++; 
          (*i_value_list) = (SgDataStatementValuePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_value_list ) );
        }
     storageOf_value_list.storeDataInEasyStorageClass(source->p_value_list);
     tempListCountvalue_list = 0; 
     i_value_list = source->p_value_list.begin() ; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          *i_value_list = tempListvalue_list[tempListCountvalue_list] ;
          tempListCountvalue_list++; 
        }
      delete [] tempListvalue_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDataStatementGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementValuePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDataStatementGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementValuePtrList > :: deleteMemoryPool() ;
   }

void
SgDataStatementGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDataStatementObjectPtrList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementValuePtrList > :: writeToFile(out) ;
   }


void
SgDataStatementGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDataStatementObjectPtrList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementValuePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5964 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5977 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementObjectStorageClass::pickOutIRNodeData ( SgDataStatementObject* pointer ) 
   { 
     SgDataStatementObject* source = (SgDataStatementObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variableReference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variableReference_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5999 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementValueStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6012 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementValueStorageClass::pickOutIRNodeData ( SgDataStatementValue* pointer ) 
   { 
     SgDataStatementValue* source = (SgDataStatementValue*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_data_initialization_format =  source->p_data_initialization_format ;
     storageOf_initializer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializer_list );
     storageOf_repeat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_repeat_expression );
     storageOf_constant_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constant_expression );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6037 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6050 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStorageClass::pickOutIRNodeData ( SgType* pointer ) 
   { 
     SgType* source = (SgType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6105 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnknownStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6118 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnknownStorageClass::pickOutIRNodeData ( SgTypeUnknown* pointer ) 
   { 
     SgTypeUnknown* source = (SgTypeUnknown*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnknownStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnknownStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnknownStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnknownStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6173 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6186 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCharStorageClass::pickOutIRNodeData ( SgTypeChar* pointer ) 
   { 
     SgTypeChar* source = (SgTypeChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6241 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6254 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedCharStorageClass::pickOutIRNodeData ( SgTypeSignedChar* pointer ) 
   { 
     SgTypeSignedChar* source = (SgTypeSignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedCharStorageClass::pickOutIRNodeData ( SgTypeUnsignedChar* pointer ) 
   { 
     SgTypeUnsignedChar* source = (SgTypeUnsignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6377 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6390 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeShortStorageClass::pickOutIRNodeData ( SgTypeShort* pointer ) 
   { 
     SgTypeShort* source = (SgTypeShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6445 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6458 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedShortStorageClass::pickOutIRNodeData ( SgTypeSignedShort* pointer ) 
   { 
     SgTypeSignedShort* source = (SgTypeSignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6513 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6526 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedShortStorageClass::pickOutIRNodeData ( SgTypeUnsignedShort* pointer ) 
   { 
     SgTypeUnsignedShort* source = (SgTypeUnsignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6581 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6594 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIntStorageClass::pickOutIRNodeData ( SgTypeInt* pointer ) 
   { 
     SgTypeInt* source = (SgTypeInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_field_size =  source->p_field_size ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6650 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6663 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedIntStorageClass::pickOutIRNodeData ( SgTypeSignedInt* pointer ) 
   { 
     SgTypeSignedInt* source = (SgTypeSignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6718 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6731 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedIntStorageClass::pickOutIRNodeData ( SgTypeUnsignedInt* pointer ) 
   { 
     SgTypeUnsignedInt* source = (SgTypeUnsignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6786 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6799 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongStorageClass::pickOutIRNodeData ( SgTypeLong* pointer ) 
   { 
     SgTypeLong* source = (SgTypeLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6854 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6867 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongStorageClass::pickOutIRNodeData ( SgTypeSignedLong* pointer ) 
   { 
     SgTypeSignedLong* source = (SgTypeSignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6922 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6935 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLong* pointer ) 
   { 
     SgTypeUnsignedLong* source = (SgTypeUnsignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6990 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7003 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeVoidStorageClass::pickOutIRNodeData ( SgTypeVoid* pointer ) 
   { 
     SgTypeVoid* source = (SgTypeVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7058 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeGlobalVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7071 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeGlobalVoidStorageClass::pickOutIRNodeData ( SgTypeGlobalVoid* pointer ) 
   { 
     SgTypeGlobalVoid* source = (SgTypeGlobalVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeGlobalVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeGlobalVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeGlobalVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeGlobalVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7126 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeWcharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7139 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeWcharStorageClass::pickOutIRNodeData ( SgTypeWchar* pointer ) 
   { 
     SgTypeWchar* source = (SgTypeWchar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeWcharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeWcharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeWcharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeWcharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7194 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7207 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFloatStorageClass::pickOutIRNodeData ( SgTypeFloat* pointer ) 
   { 
     SgTypeFloat* source = (SgTypeFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7262 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7275 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDoubleStorageClass::pickOutIRNodeData ( SgTypeDouble* pointer ) 
   { 
     SgTypeDouble* source = (SgTypeDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7330 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7343 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongLongStorageClass::pickOutIRNodeData ( SgTypeLongLong* pointer ) 
   { 
     SgTypeLongLong* source = (SgTypeLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7398 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7411 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongLongStorageClass::pickOutIRNodeData ( SgTypeSignedLongLong* pointer ) 
   { 
     SgTypeSignedLongLong* source = (SgTypeSignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7466 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7479 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLongLong* pointer ) 
   { 
     SgTypeUnsignedLongLong* source = (SgTypeUnsignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7534 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7547 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongDoubleStorageClass::pickOutIRNodeData ( SgTypeLongDouble* pointer ) 
   { 
     SgTypeLongDouble* source = (SgTypeLongDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7602 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7615 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStringStorageClass::pickOutIRNodeData ( SgTypeString* pointer ) 
   { 
     SgTypeString* source = (SgTypeString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lengthExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lengthExpression );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7671 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeBoolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7684 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeBoolStorageClass::pickOutIRNodeData ( SgTypeBool* pointer ) 
   { 
     SgTypeBool* source = (SgTypeBool*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeBoolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeBoolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeBoolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeBoolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7739 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7752 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerTypeStorageClass::pickOutIRNodeData ( SgPointerType* pointer ) 
   { 
     SgPointerType* source = (SgPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7808 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7821 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerMemberTypeStorageClass::pickOutIRNodeData ( SgPointerMemberType* pointer ) 
   { 
     SgPointerMemberType* source = (SgPointerMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7878 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7891 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReferenceTypeStorageClass::pickOutIRNodeData ( SgReferenceType* pointer ) 
   { 
     SgReferenceType* source = (SgReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7947 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7960 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamedTypeStorageClass::pickOutIRNodeData ( SgNamedType* pointer ) 
   { 
     SgNamedType* source = (SgNamedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8017 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8030 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassTypeStorageClass::pickOutIRNodeData ( SgClassType* pointer ) 
   { 
     SgClassType* source = (SgClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8087 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8100 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumTypeStorageClass::pickOutIRNodeData ( SgEnumType* pointer ) 
   { 
     SgEnumType* source = (SgEnumType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8157 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8170 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefTypeStorageClass::pickOutIRNodeData ( SgTypedefType* pointer ) 
   { 
     SgTypedefType* source = (SgTypedefType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8228 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8241 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierTypeStorageClass::pickOutIRNodeData ( SgModifierType* pointer ) 
   { 
     SgModifierType* source = (SgModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8302 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8315 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeStorageClass::pickOutIRNodeData ( SgFunctionType* pointer ) 
   { 
     SgFunctionType* source = (SgFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8374 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8387 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionTypeStorageClass::pickOutIRNodeData ( SgMemberFunctionType* pointer ) 
   { 
     SgMemberFunctionType* source = (SgMemberFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8448 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8461 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionType* pointer ) 
   { 
     SgPartialFunctionType* source = (SgPartialFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPartialFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8522 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8535 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionModifierTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionModifierType* pointer ) 
   { 
     SgPartialFunctionModifierType* source = (SgPartialFunctionModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPartialFunctionModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8596 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8609 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrayTypeStorageClass::pickOutIRNodeData ( SgArrayType* pointer ) 
   { 
     SgArrayType* source = (SgArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_index );
     storageOf_dim_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dim_info );
     storageOf_rank =  source->p_rank ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8668 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeEllipseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8681 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeEllipseStorageClass::pickOutIRNodeData ( SgTypeEllipse* pointer ) 
   { 
     SgTypeEllipse* source = (SgTypeEllipse*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeEllipseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeEllipseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeEllipseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeEllipseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8736 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8749 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateTypeStorageClass::pickOutIRNodeData ( SgTemplateType* pointer ) 
   { 
     SgTemplateType* source = (SgTemplateType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8804 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8817 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameTypeStorageClass::pickOutIRNodeData ( SgQualifiedNameType* pointer ) 
   { 
     SgQualifiedNameType* source = (SgQualifiedNameType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgQualifiedNameTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgQualifiedNameTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgQualifiedNameTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgQualifiedNameTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8895 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeComplexStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8908 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeComplexStorageClass::pickOutIRNodeData ( SgTypeComplex* pointer ) 
   { 
     SgTypeComplex* source = (SgTypeComplex*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeComplexStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeComplexStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeComplexStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeComplexStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8964 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeImaginaryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8977 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeImaginaryStorageClass::pickOutIRNodeData ( SgTypeImaginary* pointer ) 
   { 
     SgTypeImaginary* source = (SgTypeImaginary*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeImaginaryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeImaginaryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeImaginaryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeImaginaryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9033 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDefaultStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9046 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDefaultStorageClass::pickOutIRNodeData ( SgTypeDefault* pointer ) 
   { 
     SgTypeDefault* source = (SgTypeDefault*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeDefaultStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDefaultStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDefaultStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDefaultStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9106 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCAFTeamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9119 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCAFTeamStorageClass::pickOutIRNodeData ( SgTypeCAFTeam* pointer ) 
   { 
     SgTypeCAFTeam* source = (SgTypeCAFTeam*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCAFTeamStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCAFTeamStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCAFTeamStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCAFTeamStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9174 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCrayPointerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9187 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCrayPointerStorageClass::pickOutIRNodeData ( SgTypeCrayPointer* pointer ) 
   { 
     SgTypeCrayPointer* source = (SgTypeCrayPointer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCrayPointerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCrayPointerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCrayPointerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCrayPointerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9242 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9255 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLabelStorageClass::pickOutIRNodeData ( SgTypeLabel* pointer ) 
   { 
     SgTypeLabel* source = (SgTypeLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9315 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9328 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeStorageClass::pickOutIRNodeData ( SgLocatedNode* pointer ) 
   { 
     SgLocatedNode* source = (SgLocatedNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLocatedNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9383 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9396 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeSupportStorageClass::pickOutIRNodeData ( SgLocatedNodeSupport* pointer ) 
   { 
     SgLocatedNodeSupport* source = (SgLocatedNodeSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLocatedNodeSupportStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeSupportStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeSupportStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeSupportStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9451 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9464 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockObjectStorageClass::pickOutIRNodeData ( SgCommonBlockObject* pointer ) 
   { 
     SgCommonBlockObject* source = (SgCommonBlockObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_block_name.storeDataInEasyStorageClass(source->p_block_name);
     storageOf_variable_reference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable_reference_list );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonBlockObjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockObjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockObjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockObjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9525 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9538 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInitializedNameStorageClass::pickOutIRNodeData ( SgInitializedName* pointer ) 
   { 
     SgInitializedName* source = (SgInitializedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_typeptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeptr );
     storageOf_initptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initptr );
     storageOf_prev_decl_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_prev_decl_item );
     storageOf_is_initializer =  source->p_is_initializer ;
     storageOf_declptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declptr );
     storageOf_storageModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storageModifier );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_preinitialization =  source->p_preinitialization ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_register_name_code =  source->p_register_name_code ;
     storageOf_register_name_string.storeDataInEasyStorageClass(source->p_register_name_string);
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_shapeDeferred =  source->p_shapeDeferred ;
     storageOf_initializationDeferred =  source->p_initializationDeferred ;
     storageOf_gnu_attribute_modifierVector.storeDataInEasyStorageClass(source->p_gnu_attribute_modifierVector);
     storageOf_gnu_attribute_initialization_priority =  source->p_gnu_attribute_initialization_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_gnu_attribute_cleanup_function.storeDataInEasyStorageClass(source->p_gnu_attribute_cleanup_function);
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_protected_declaration =  source->p_protected_declaration ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInitializedNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializedNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializedNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializedNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9629 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9642 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceBodyStorageClass::pickOutIRNodeData ( SgInterfaceBody* pointer ) 
   { 
     SgInterfaceBody* source = (SgInterfaceBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function_name.pickOutIRNodeData( &(source->p_function_name) );
     storageOf_functionDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionDeclaration );
     storageOf_use_function_name =  source->p_use_function_name ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9704 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenamePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9717 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRenamePairStorageClass::pickOutIRNodeData ( SgRenamePair* pointer ) 
   { 
     SgRenamePair* source = (SgRenamePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_local_name.pickOutIRNodeData( &(source->p_local_name) );
     storageOf_use_name.pickOutIRNodeData( &(source->p_use_name) );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRenamePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenamePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenamePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenamePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9778 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9791 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseStorageClass::pickOutIRNodeData ( SgOmpClause* pointer ) 
   { 
     SgOmpClause* source = (SgOmpClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9846 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9859 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedClauseStorageClass::pickOutIRNodeData ( SgOmpOrderedClause* pointer ) 
   { 
     SgOmpOrderedClause* source = (SgOmpOrderedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpOrderedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9914 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNowaitClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9927 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNowaitClauseStorageClass::pickOutIRNodeData ( SgOmpNowaitClause* pointer ) 
   { 
     SgOmpNowaitClause* source = (SgOmpNowaitClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpNowaitClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNowaitClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNowaitClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNowaitClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9982 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpUntiedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9995 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpUntiedClauseStorageClass::pickOutIRNodeData ( SgOmpUntiedClause* pointer ) 
   { 
     SgOmpUntiedClause* source = (SgOmpUntiedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpUntiedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpUntiedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpUntiedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpUntiedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10050 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDefaultClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10063 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDefaultClauseStorageClass::pickOutIRNodeData ( SgOmpDefaultClause* pointer ) 
   { 
     SgOmpDefaultClause* source = (SgOmpDefaultClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_data_sharing =  source->p_data_sharing ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpDefaultClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDefaultClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDefaultClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDefaultClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10119 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpExpressionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10132 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpExpressionClauseStorageClass::pickOutIRNodeData ( SgOmpExpressionClause* pointer ) 
   { 
     SgOmpExpressionClause* source = (SgOmpExpressionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpExpressionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpExpressionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpExpressionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpExpressionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10188 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCollapseClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10201 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCollapseClauseStorageClass::pickOutIRNodeData ( SgOmpCollapseClause* pointer ) 
   { 
     SgOmpCollapseClause* source = (SgOmpCollapseClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCollapseClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCollapseClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCollapseClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCollapseClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10257 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpIfClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10270 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpIfClauseStorageClass::pickOutIRNodeData ( SgOmpIfClause* pointer ) 
   { 
     SgOmpIfClause* source = (SgOmpIfClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpIfClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpIfClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpIfClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpIfClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10326 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNumThreadsClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10339 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNumThreadsClauseStorageClass::pickOutIRNodeData ( SgOmpNumThreadsClause* pointer ) 
   { 
     SgOmpNumThreadsClause* source = (SgOmpNumThreadsClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpNumThreadsClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNumThreadsClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNumThreadsClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNumThreadsClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10395 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpVariablesClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10408 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpVariablesClauseStorageClass::pickOutIRNodeData ( SgOmpVariablesClause* pointer ) 
   { 
     SgOmpVariablesClause* source = (SgOmpVariablesClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpVariablesClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpVariablesClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpVariablesClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpVariablesClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10485 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10498 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyprivateClauseStorageClass::pickOutIRNodeData ( SgOmpCopyprivateClause* pointer ) 
   { 
     SgOmpCopyprivateClause* source = (SgOmpCopyprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCopyprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10575 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpPrivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10588 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpPrivateClauseStorageClass::pickOutIRNodeData ( SgOmpPrivateClause* pointer ) 
   { 
     SgOmpPrivateClause* source = (SgOmpPrivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpPrivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpPrivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpPrivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpPrivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10665 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFirstprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10678 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFirstprivateClauseStorageClass::pickOutIRNodeData ( SgOmpFirstprivateClause* pointer ) 
   { 
     SgOmpFirstprivateClause* source = (SgOmpFirstprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpFirstprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFirstprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFirstprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFirstprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10755 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSharedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10768 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSharedClauseStorageClass::pickOutIRNodeData ( SgOmpSharedClause* pointer ) 
   { 
     SgOmpSharedClause* source = (SgOmpSharedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSharedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSharedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSharedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSharedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10845 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyinClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10858 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyinClauseStorageClass::pickOutIRNodeData ( SgOmpCopyinClause* pointer ) 
   { 
     SgOmpCopyinClause* source = (SgOmpCopyinClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCopyinClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyinClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyinClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyinClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10935 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpLastprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10948 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpLastprivateClauseStorageClass::pickOutIRNodeData ( SgOmpLastprivateClause* pointer ) 
   { 
     SgOmpLastprivateClause* source = (SgOmpLastprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpLastprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpLastprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpLastprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpLastprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11025 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpReductionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11038 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpReductionClauseStorageClass::pickOutIRNodeData ( SgOmpReductionClause* pointer ) 
   { 
     SgOmpReductionClause* source = (SgOmpReductionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operation =  source->p_operation ;
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpReductionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpReductionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpReductionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpReductionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11116 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpScheduleClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11129 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpScheduleClauseStorageClass::pickOutIRNodeData ( SgOmpScheduleClause* pointer ) 
   { 
     SgOmpScheduleClause* source = (SgOmpScheduleClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_chunk_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_chunk_size );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpScheduleClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpScheduleClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpScheduleClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpScheduleClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11186 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11199 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementStorageClass::pickOutIRNodeData ( SgStatement* pointer ) 
   { 
     SgStatement* source = (SgStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11256 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11269 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgScopeStatementStorageClass::pickOutIRNodeData ( SgScopeStatement* pointer ) 
   { 
     SgScopeStatement* source = (SgScopeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgScopeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11335 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGlobalStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11348 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGlobalStorageClass::pickOutIRNodeData ( SgGlobal* pointer ) 
   { 
     SgGlobal* source = (SgGlobal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGlobalStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGlobalStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGlobalStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGlobalStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11436 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBasicBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11449 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBasicBlockStorageClass::pickOutIRNodeData ( SgBasicBlock* pointer ) 
   { 
     SgBasicBlock* source = (SgBasicBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_asm_function_body.storeDataInEasyStorageClass(source->p_asm_function_body);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBasicBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBasicBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBasicBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBasicBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11542 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11555 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfStmtStorageClass::pickOutIRNodeData ( SgIfStmt* pointer ) 
   { 
     SgIfStmt* source = (SgIfStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_true_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_body );
     storageOf_false_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_body );
     storageOf_else_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_use_then_keyword =  source->p_use_then_keyword ;
     storageOf_is_else_if_statement =  source->p_is_else_if_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11634 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11647 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForStatementStorageClass::pickOutIRNodeData ( SgForStatement* pointer ) 
   { 
     SgForStatement* source = (SgForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11722 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11735 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDefinitionStorageClass::pickOutIRNodeData ( SgFunctionDefinition* pointer ) 
   { 
     SgFunctionDefinition* source = (SgFunctionDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_scope_number_list.storeDataInEasyStorageClass(source->p_scope_number_list);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgNode*,int> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgNode*,int> > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgNode*,int> > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgNode*,int> > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11807 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11820 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDefinitionStorageClass::pickOutIRNodeData ( SgClassDefinition* pointer ) 
   { 
     SgClassDefinition* source = (SgClassDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11934 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDefnStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11947 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDefnStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDefn* pointer ) 
   { 
     SgTemplateInstantiationDefn* source = (SgTemplateInstantiationDefn*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDefnStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDefnStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDefnStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDefnStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12061 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12074 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWhileStmtStorageClass::pickOutIRNodeData ( SgWhileStmt* pointer ) 
   { 
     SgWhileStmt* source = (SgWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12149 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12162 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDoWhileStmtStorageClass::pickOutIRNodeData ( SgDoWhileStmt* pointer ) 
   { 
     SgDoWhileStmt* source = (SgDoWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDoWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12230 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSwitchStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12243 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSwitchStatementStorageClass::pickOutIRNodeData ( SgSwitchStatement* pointer ) 
   { 
     SgSwitchStatement* source = (SgSwitchStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_item_selector = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_item_selector );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSwitchStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSwitchStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSwitchStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSwitchStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12317 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12330 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCatchOptionStmtStorageClass::pickOutIRNodeData ( SgCatchOptionStmt* pointer ) 
   { 
     SgCatchOptionStmt* source = (SgCatchOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_trystmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_trystmt );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCatchOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12399 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDefinitionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12412 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDefinitionStatementStorageClass::pickOutIRNodeData ( SgNamespaceDefinitionStatement* pointer ) 
   { 
     SgNamespaceDefinitionStatement* source = (SgNamespaceDefinitionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceDefinitionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDefinitionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12501 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBlockDataStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12514 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBlockDataStatementStorageClass::pickOutIRNodeData ( SgBlockDataStatement* pointer ) 
   { 
     SgBlockDataStatement* source = (SgBlockDataStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBlockDataStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBlockDataStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBlockDataStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBlockDataStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12581 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssociateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12594 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssociateStatementStorageClass::pickOutIRNodeData ( SgAssociateStatement* pointer ) 
   { 
     SgAssociateStatement* source = (SgAssociateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable_declaration );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssociateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssociateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssociateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssociateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12662 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12675 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranDoStorageClass::pickOutIRNodeData ( SgFortranDo* pointer ) 
   { 
     SgFortranDo* source = (SgFortranDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12753 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranNonblockedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12766 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranNonblockedDoStorageClass::pickOutIRNodeData ( SgFortranNonblockedDo* pointer ) 
   { 
     SgFortranNonblockedDo* source = (SgFortranNonblockedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_statement );
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranNonblockedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranNonblockedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranNonblockedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranNonblockedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12845 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12858 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForAllStatementStorageClass::pickOutIRNodeData ( SgForAllStatement* pointer ) 
   { 
     SgForAllStatement* source = (SgForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_forall_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forall_header );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12933 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12946 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcForAllStatementStorageClass::pickOutIRNodeData ( SgUpcForAllStatement* pointer ) 
   { 
     SgUpcForAllStatement* source = (SgUpcForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_affinity = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_affinity );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13017 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFWithTeamStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13030 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCAFWithTeamStatementStorageClass::pickOutIRNodeData ( SgCAFWithTeamStatement* pointer ) 
   { 
     SgCAFWithTeamStatement* source = (SgCAFWithTeamStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_endHasTeamId =  source->p_endHasTeamId ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCAFWithTeamStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFWithTeamStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFWithTeamStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFWithTeamStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13099 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13112 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeTableStorageClass::pickOutIRNodeData ( SgFunctionTypeTable* pointer ) 
   { 
     SgFunctionTypeTable* source = (SgFunctionTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type_table );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13170 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13183 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationStatementStorageClass::pickOutIRNodeData ( SgDeclarationStatement* pointer ) 
   { 
     SgDeclarationStatement* source = (SgDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13280 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13293 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterListStorageClass::pickOutIRNodeData ( SgFunctionParameterList* pointer ) 
   { 
     SgFunctionParameterList* source = (SgFunctionParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgInitializedNamePtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgInitializedNamePtrList::value_type *  tempListargs = new SgInitializedNamePtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13412 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13425 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDeclarationStorageClass::pickOutIRNodeData ( SgVariableDeclaration* pointer ) 
   { 
     SgVariableDeclaration* source = (SgVariableDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_baseTypeDefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseTypeDefiningDeclaration );
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_variableDeclarationContainsBaseTypeDefiningDeclaration =  source->p_variableDeclarationContainsBaseTypeDefiningDeclaration ;
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_initialization_priority =  source->p_gnu_extension_initialization_priority ;
     storageOf_gnu_extension_alignment =  source->p_gnu_extension_alignment ;
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_gnu_extension_declaration_attribute =  source->p_gnu_extension_declaration_attribute ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13554 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13567 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDefinitionStorageClass::pickOutIRNodeData ( SgVariableDefinition* pointer ) 
   { 
     SgVariableDefinition* source = (SgVariableDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_vardefn = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_vardefn );
     storageOf_bitfield = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bitfield );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13666 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13679 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageDeclarationStatementStorageClass::pickOutIRNodeData ( SgClinkageDeclarationStatement* pointer ) 
   { 
     SgClinkageDeclarationStatement* source = (SgClinkageDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13777 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageStartStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13790 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageStartStatementStorageClass::pickOutIRNodeData ( SgClinkageStartStatement* pointer ) 
   { 
     SgClinkageStartStatement* source = (SgClinkageStartStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageStartStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageStartStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageStartStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageStartStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13888 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageEndStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13901 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageEndStatementStorageClass::pickOutIRNodeData ( SgClinkageEndStatement* pointer ) 
   { 
     SgClinkageEndStatement* source = (SgClinkageEndStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageEndStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageEndStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageEndStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageEndStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13999 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14012 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumDeclarationStorageClass::pickOutIRNodeData ( SgEnumDeclaration* pointer ) 
   { 
     SgEnumDeclaration* source = (SgEnumDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_embedded =  source->p_embedded ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     SgInitializedNamePtrList::iterator i_enumerators = source->p_enumerators.begin() ; 
     unsigned int tempListCountenumerators = 0; 
     SgInitializedNamePtrList::value_type *  tempListenumerators = new SgInitializedNamePtrList::value_type[ source->p_enumerators.size() ]; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          tempListenumerators[tempListCountenumerators] = *i_enumerators;
          tempListCountenumerators++; 
          (*i_enumerators) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_enumerators ) );
        }
     storageOf_enumerators.storeDataInEasyStorageClass(source->p_enumerators);
     tempListCountenumerators = 0; 
     i_enumerators = source->p_enumerators.begin() ; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          *i_enumerators = tempListenumerators[tempListCountenumerators] ;
          tempListCountenumerators++; 
        }
      delete [] tempListenumerators; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14140 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14153 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStmtStorageClass::pickOutIRNodeData ( SgAsmStmt* pointer ) 
   { 
     SgAsmStmt* source = (SgAsmStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_assemblyCode.storeDataInEasyStorageClass(source->p_assemblyCode);
     storageOf_useGnuExtendedFormat =  source->p_useGnuExtendedFormat ;
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_clobberRegisterList.storeDataInEasyStorageClass(source->p_clobberRegisterList);
     storageOf_isVolatile =  source->p_isVolatile ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14280 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeSpecificationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14293 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeSpecificationStatementStorageClass::pickOutIRNodeData ( SgAttributeSpecificationStatement* pointer ) 
   { 
     SgAttributeSpecificationStatement* source = (SgAttributeSpecificationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_attribute_kind =  source->p_attribute_kind ;
     storageOf_intent =  source->p_intent ;
     storageOf_parameter_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameter_list );
     SgDataStatementGroupPtrList::iterator i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     unsigned int tempListCountdata_statement_group_list = 0; 
     SgDataStatementGroupPtrList::value_type *  tempListdata_statement_group_list = new SgDataStatementGroupPtrList::value_type[ source->p_data_statement_group_list.size() ]; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          tempListdata_statement_group_list[tempListCountdata_statement_group_list] = *i_data_statement_group_list;
          tempListCountdata_statement_group_list++; 
          (*i_data_statement_group_list) = (SgDataStatementGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_data_statement_group_list ) );
        }
     storageOf_data_statement_group_list.storeDataInEasyStorageClass(source->p_data_statement_group_list);
     tempListCountdata_statement_group_list = 0; 
     i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          *i_data_statement_group_list = tempListdata_statement_group_list[tempListCountdata_statement_group_list] ;
          tempListCountdata_statement_group_list++; 
        }
      delete [] tempListdata_statement_group_list; 
     storageOf_bind_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bind_list );
     SgDimensionObjectPtrList::iterator i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     unsigned int tempListCountdimension_object_list = 0; 
     SgDimensionObjectPtrList::value_type *  tempListdimension_object_list = new SgDimensionObjectPtrList::value_type[ source->p_dimension_object_list.size() ]; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          tempListdimension_object_list[tempListCountdimension_object_list] = *i_dimension_object_list;
          tempListCountdimension_object_list++; 
          (*i_dimension_object_list) = (SgDimensionObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dimension_object_list ) );
        }
     storageOf_dimension_object_list.storeDataInEasyStorageClass(source->p_dimension_object_list);
     tempListCountdimension_object_list = 0; 
     i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          *i_dimension_object_list = tempListdimension_object_list[tempListCountdimension_object_list] ;
          tempListCountdimension_object_list++; 
        }
      delete [] tempListdimension_object_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAttributeSpecificationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDimensionObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeSpecificationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDimensionObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAttributeSpecificationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementGroupPtrList > :: writeToFile(out) ;
     EasyStorage < SgDimensionObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAttributeSpecificationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementGroupPtrList > :: readFromFile(in) ;
     EasyStorage < SgDimensionObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14443 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14456 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatStatementStorageClass::pickOutIRNodeData ( SgFormatStatement* pointer ) 
   { 
     SgFormatStatement* source = (SgFormatStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFormatStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFormatStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFormatStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14554 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14567 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateDeclarationStorageClass::pickOutIRNodeData ( SgTemplateDeclaration* pointer ) 
   { 
     SgTemplateDeclaration* source = (SgTemplateDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14694 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14707 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDirectiveStatementStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDirectiveStatement* pointer ) 
   { 
     SgTemplateInstantiationDirectiveStatement* source = (SgTemplateInstantiationDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14805 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14818 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUseStatementStorageClass::pickOutIRNodeData ( SgUseStatement* pointer ) 
   { 
     SgUseStatement* source = (SgUseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_only_option =  source->p_only_option ;
     SgRenamePairPtrList::iterator i_rename_list = source->p_rename_list.begin() ; 
     unsigned int tempListCountrename_list = 0; 
     SgRenamePairPtrList::value_type *  tempListrename_list = new SgRenamePairPtrList::value_type[ source->p_rename_list.size() ]; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          tempListrename_list[tempListCountrename_list] = *i_rename_list;
          tempListCountrename_list++; 
          (*i_rename_list) = (SgRenamePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_rename_list ) );
        }
     storageOf_rename_list.storeDataInEasyStorageClass(source->p_rename_list);
     tempListCountrename_list = 0; 
     i_rename_list = source->p_rename_list.begin() ; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          *i_rename_list = tempListrename_list[tempListCountrename_list] ;
          tempListCountrename_list++; 
        }
      delete [] tempListrename_list; 
     storageOf_module = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_module );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgRenamePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgRenamePairPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgRenamePairPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgRenamePairPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14944 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgParameterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14957 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgParameterStatementStorageClass::pickOutIRNodeData ( SgParameterStatement* pointer ) 
   { 
     SgParameterStatement* source = (SgParameterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgParameterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgParameterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgParameterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgParameterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15054 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15067 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceDeclarationStatement* pointer ) 
   { 
     SgNamespaceDeclarationStatement* source = (SgNamespaceDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_isUnnamedNamespace =  source->p_isUnnamedNamespace ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15171 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEquivalenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15184 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEquivalenceStatementStorageClass::pickOutIRNodeData ( SgEquivalenceStatement* pointer ) 
   { 
     SgEquivalenceStatement* source = (SgEquivalenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_equivalence_set_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equivalence_set_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEquivalenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEquivalenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEquivalenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEquivalenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15282 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15295 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceStatementStorageClass::pickOutIRNodeData ( SgInterfaceStatement* pointer ) 
   { 
     SgInterfaceStatement* source = (SgInterfaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_generic_spec =  source->p_generic_spec ;
     SgInterfaceBodyPtrList::iterator i_interface_body_list = source->p_interface_body_list.begin() ; 
     unsigned int tempListCountinterface_body_list = 0; 
     SgInterfaceBodyPtrList::value_type *  tempListinterface_body_list = new SgInterfaceBodyPtrList::value_type[ source->p_interface_body_list.size() ]; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          tempListinterface_body_list[tempListCountinterface_body_list] = *i_interface_body_list;
          tempListCountinterface_body_list++; 
          (*i_interface_body_list) = (SgInterfaceBodyPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interface_body_list ) );
        }
     storageOf_interface_body_list.storeDataInEasyStorageClass(source->p_interface_body_list);
     tempListCountinterface_body_list = 0; 
     i_interface_body_list = source->p_interface_body_list.begin() ; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          *i_interface_body_list = tempListinterface_body_list[tempListCountinterface_body_list] ;
          tempListCountinterface_body_list++; 
        }
      delete [] tempListinterface_body_list; 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInterfaceBodyPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInterfaceBodyPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInterfaceBodyPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInterfaceBodyPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15421 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceAliasDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15434 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceAliasDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceAliasDeclarationStatement* pointer ) 
   { 
     SgNamespaceAliasDeclarationStatement* source = (SgNamespaceAliasDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceAliasDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15537 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15550 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockStorageClass::pickOutIRNodeData ( SgCommonBlock* pointer ) 
   { 
     SgCommonBlock* source = (SgCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgCommonBlockObjectPtrList::iterator i_block_list = source->p_block_list.begin() ; 
     unsigned int tempListCountblock_list = 0; 
     SgCommonBlockObjectPtrList::value_type *  tempListblock_list = new SgCommonBlockObjectPtrList::value_type[ source->p_block_list.size() ]; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          tempListblock_list[tempListCountblock_list] = *i_block_list;
          tempListCountblock_list++; 
          (*i_block_list) = (SgCommonBlockObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_block_list ) );
        }
     storageOf_block_list.storeDataInEasyStorageClass(source->p_block_list);
     tempListCountblock_list = 0; 
     i_block_list = source->p_block_list.begin() ; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          *i_block_list = tempListblock_list[tempListCountblock_list] ;
          tempListCountblock_list++; 
        }
      delete [] tempListblock_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCommonBlockObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCommonBlockObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15669 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15682 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefDeclarationStorageClass::pickOutIRNodeData ( SgTypedefDeclaration* pointer ) 
   { 
     SgTypedefDeclaration* source = (SgTypedefDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_typedefBaseTypeContainsDefiningDeclaration =  source->p_typedefBaseTypeContainsDefiningDeclaration ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15791 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementFunctionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15804 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementFunctionStatementStorageClass::pickOutIRNodeData ( SgStatementFunctionStatement* pointer ) 
   { 
     SgStatementFunctionStatement* source = (SgStatementFunctionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementFunctionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementFunctionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementFunctionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementFunctionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15903 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCtorInitializerListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15916 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCtorInitializerListStorageClass::pickOutIRNodeData ( SgCtorInitializerList* pointer ) 
   { 
     SgCtorInitializerList* source = (SgCtorInitializerList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgInitializedNamePtrList::iterator i_ctors = source->p_ctors.begin() ; 
     unsigned int tempListCountctors = 0; 
     SgInitializedNamePtrList::value_type *  tempListctors = new SgInitializedNamePtrList::value_type[ source->p_ctors.size() ]; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          tempListctors[tempListCountctors] = *i_ctors;
          tempListCountctors++; 
          (*i_ctors) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_ctors ) );
        }
     storageOf_ctors.storeDataInEasyStorageClass(source->p_ctors);
     tempListCountctors = 0; 
     i_ctors = source->p_ctors.begin() ; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          *i_ctors = tempListctors[tempListCountctors] ;
          tempListCountctors++; 
        }
      delete [] tempListctors; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCtorInitializerListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCtorInitializerListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCtorInitializerListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCtorInitializerListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16035 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16048 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaDeclarationStorageClass::pickOutIRNodeData ( SgPragmaDeclaration* pointer ) 
   { 
     SgPragmaDeclaration* source = (SgPragmaDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPragmaDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPragmaDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPragmaDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16146 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16159 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDirectiveStatementStorageClass::pickOutIRNodeData ( SgUsingDirectiveStatement* pointer ) 
   { 
     SgUsingDirectiveStatement* source = (SgUsingDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUsingDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16257 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16270 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDeclarationStorageClass::pickOutIRNodeData ( SgClassDeclaration* pointer ) 
   { 
     SgClassDeclaration* source = (SgClassDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16381 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16394 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDecl* pointer ) 
   { 
     SgTemplateInstantiationDecl* source = (SgTemplateInstantiationDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateHeader.pickOutIRNodeData( &(source->p_templateHeader) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16531 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDerivedTypeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16544 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDerivedTypeStatementStorageClass::pickOutIRNodeData ( SgDerivedTypeStatement* pointer ) 
   { 
     SgDerivedTypeStatement* source = (SgDerivedTypeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDerivedTypeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDerivedTypeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDerivedTypeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDerivedTypeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16656 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16669 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModuleStatementStorageClass::pickOutIRNodeData ( SgModuleStatement* pointer ) 
   { 
     SgModuleStatement* source = (SgModuleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModuleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16781 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImplicitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16794 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImplicitStatementStorageClass::pickOutIRNodeData ( SgImplicitStatement* pointer ) 
   { 
     SgImplicitStatement* source = (SgImplicitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_implicit_none =  source->p_implicit_none ;
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImplicitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImplicitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImplicitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImplicitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16914 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16927 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDeclarationStatementStorageClass::pickOutIRNodeData ( SgUsingDeclarationStatement* pointer ) 
   { 
     SgUsingDeclarationStatement* source = (SgUsingDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_initializedName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializedName );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUsingDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17026 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamelistStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17039 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamelistStatementStorageClass::pickOutIRNodeData ( SgNamelistStatement* pointer ) 
   { 
     SgNamelistStatement* source = (SgNamelistStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgNameGroupPtrList::iterator i_group_list = source->p_group_list.begin() ; 
     unsigned int tempListCountgroup_list = 0; 
     SgNameGroupPtrList::value_type *  tempListgroup_list = new SgNameGroupPtrList::value_type[ source->p_group_list.size() ]; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          tempListgroup_list[tempListCountgroup_list] = *i_group_list;
          tempListCountgroup_list++; 
          (*i_group_list) = (SgNameGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_group_list ) );
        }
     storageOf_group_list.storeDataInEasyStorageClass(source->p_group_list);
     tempListCountgroup_list = 0; 
     i_group_list = source->p_group_list.begin() ; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          *i_group_list = tempListgroup_list[tempListCountgroup_list] ;
          tempListCountgroup_list++; 
        }
      delete [] tempListgroup_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamelistStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgNameGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamelistStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgNameGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamelistStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgNameGroupPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamelistStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgNameGroupPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17158 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17171 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImportStatementStorageClass::pickOutIRNodeData ( SgImportStatement* pointer ) 
   { 
     SgImportStatement* source = (SgImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_import_list = source->p_import_list.begin() ; 
     unsigned int tempListCountimport_list = 0; 
     SgExpressionPtrList::value_type *  tempListimport_list = new SgExpressionPtrList::value_type[ source->p_import_list.size() ]; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          tempListimport_list[tempListCountimport_list] = *i_import_list;
          tempListCountimport_list++; 
          (*i_import_list) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_import_list ) );
        }
     storageOf_import_list.storeDataInEasyStorageClass(source->p_import_list);
     tempListCountimport_list = 0; 
     i_import_list = source->p_import_list.begin() ; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          *i_import_list = tempListimport_list[tempListCountimport_list] ;
          tempListCountimport_list++; 
        }
      delete [] tempListimport_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17290 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17303 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDeclarationStorageClass::pickOutIRNodeData ( SgFunctionDeclaration* pointer ) 
   { 
     SgFunctionDeclaration* source = (SgFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17449 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17462 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionDeclarationStorageClass::pickOutIRNodeData ( SgMemberFunctionDeclaration* pointer ) 
   { 
     SgMemberFunctionDeclaration* source = (SgMemberFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17610 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationMemberFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17623 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationMemberFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationMemberFunctionDecl* source = (SgTemplateInstantiationMemberFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17796 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17809 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationFunctionDecl* source = (SgTemplateInstantiationFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17980 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProgramHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17993 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProgramHeaderStatementStorageClass::pickOutIRNodeData ( SgProgramHeaderStatement* pointer ) 
   { 
     SgProgramHeaderStatement* source = (SgProgramHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_program_statement_explicit =  source->p_program_statement_explicit ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProgramHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProgramHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProgramHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProgramHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18141 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProcedureHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18154 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProcedureHeaderStatementStorageClass::pickOutIRNodeData ( SgProcedureHeaderStatement* pointer ) 
   { 
     SgProcedureHeaderStatement* source = (SgProcedureHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_subprogram_kind =  source->p_subprogram_kind ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProcedureHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProcedureHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProcedureHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProcedureHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18303 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEntryStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18316 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEntryStatementStorageClass::pickOutIRNodeData ( SgEntryStatement* pointer ) 
   { 
     SgEntryStatement* source = (SgEntryStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEntryStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEntryStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEntryStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEntryStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18463 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContainsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18476 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgContainsStatementStorageClass::pickOutIRNodeData ( SgContainsStatement* pointer ) 
   { 
     SgContainsStatement* source = (SgContainsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgContainsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContainsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContainsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContainsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18573 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgC_PreprocessorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18586 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgC_PreprocessorDirectiveStatementStorageClass::pickOutIRNodeData ( SgC_PreprocessorDirectiveStatement* pointer ) 
   { 
     SgC_PreprocessorDirectiveStatement* source = (SgC_PreprocessorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgC_PreprocessorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18684 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18697 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeDirectiveStatement* pointer ) 
   { 
     SgIncludeDirectiveStatement* source = (SgIncludeDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncludeDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18795 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18808 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefineDirectiveStatementStorageClass::pickOutIRNodeData ( SgDefineDirectiveStatement* pointer ) 
   { 
     SgDefineDirectiveStatement* source = (SgDefineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18906 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18919 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgUndefDirectiveStatement* pointer ) 
   { 
     SgUndefDirectiveStatement* source = (SgUndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19017 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfdefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19030 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfdefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfdefDirectiveStatement* pointer ) 
   { 
     SgIfdefDirectiveStatement* source = (SgIfdefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfdefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfdefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfdefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfdefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19128 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19141 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfndefDirectiveStatement* pointer ) 
   { 
     SgIfndefDirectiveStatement* source = (SgIfndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19239 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19252 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfDirectiveStatement* pointer ) 
   { 
     SgIfDirectiveStatement* source = (SgIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19350 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeadIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19363 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeadIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgDeadIfDirectiveStatement* pointer ) 
   { 
     SgDeadIfDirectiveStatement* source = (SgDeadIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeadIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeadIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19461 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19474 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseDirectiveStatement* pointer ) 
   { 
     SgElseDirectiveStatement* source = (SgElseDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19572 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19585 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseifDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseifDirectiveStatement* pointer ) 
   { 
     SgElseifDirectiveStatement* source = (SgElseifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19683 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19696 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEndifDirectiveStatementStorageClass::pickOutIRNodeData ( SgEndifDirectiveStatement* pointer ) 
   { 
     SgEndifDirectiveStatement* source = (SgEndifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEndifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19794 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19807 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLineDirectiveStatementStorageClass::pickOutIRNodeData ( SgLineDirectiveStatement* pointer ) 
   { 
     SgLineDirectiveStatement* source = (SgLineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19905 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWarningDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19918 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWarningDirectiveStatementStorageClass::pickOutIRNodeData ( SgWarningDirectiveStatement* pointer ) 
   { 
     SgWarningDirectiveStatement* source = (SgWarningDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWarningDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWarningDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWarningDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWarningDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20016 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgErrorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20029 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgErrorDirectiveStatementStorageClass::pickOutIRNodeData ( SgErrorDirectiveStatement* pointer ) 
   { 
     SgErrorDirectiveStatement* source = (SgErrorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgErrorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgErrorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgErrorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgErrorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20127 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEmptyDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20140 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEmptyDirectiveStatementStorageClass::pickOutIRNodeData ( SgEmptyDirectiveStatement* pointer ) 
   { 
     SgEmptyDirectiveStatement* source = (SgEmptyDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEmptyDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEmptyDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEmptyDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEmptyDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20238 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeNextDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20251 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeNextDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeNextDirectiveStatement* pointer ) 
   { 
     SgIncludeNextDirectiveStatement* source = (SgIncludeNextDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeNextDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20349 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIdentDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20362 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIdentDirectiveStatementStorageClass::pickOutIRNodeData ( SgIdentDirectiveStatement* pointer ) 
   { 
     SgIdentDirectiveStatement* source = (SgIdentDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIdentDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIdentDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIdentDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIdentDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20460 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinemarkerDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20473 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLinemarkerDirectiveStatementStorageClass::pickOutIRNodeData ( SgLinemarkerDirectiveStatement* pointer ) 
   { 
     SgLinemarkerDirectiveStatement* source = (SgLinemarkerDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_linenumber =  source->p_linenumber ;
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_flaglist.storeDataInEasyStorageClass(source->p_flaglist);
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLinemarkerDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20578 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpThreadprivateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20591 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpThreadprivateStatementStorageClass::pickOutIRNodeData ( SgOmpThreadprivateStatement* pointer ) 
   { 
     SgOmpThreadprivateStatement* source = (SgOmpThreadprivateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpThreadprivateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpThreadprivateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpThreadprivateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpThreadprivateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20710 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranIncludeLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20723 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranIncludeLineStorageClass::pickOutIRNodeData ( SgFortranIncludeLine* pointer ) 
   { 
     SgFortranIncludeLine* source = (SgFortranIncludeLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranIncludeLineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranIncludeLineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranIncludeLineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranIncludeLineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20821 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20834 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaImportStatementStorageClass::pickOutIRNodeData ( SgJavaImportStatement* pointer ) 
   { 
     SgJavaImportStatement* source = (SgJavaImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_path.pickOutIRNodeData( &(source->p_path) );
     storageOf_containsWildCard =  source->p_containsWildCard ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20937 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20950 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExprStatementStorageClass::pickOutIRNodeData ( SgExprStatement* pointer ) 
   { 
     SgExprStatement* source = (SgExprStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExprStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21008 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21021 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelStatementStorageClass::pickOutIRNodeData ( SgLabelStatement* pointer ) 
   { 
     SgLabelStatement* source = (SgLabelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label.pickOutIRNodeData( &(source->p_label) );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_gnu_extension_unused =  source->p_gnu_extension_unused ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21086 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCaseOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21099 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCaseOptionStmtStorageClass::pickOutIRNodeData ( SgCaseOptionStmt* pointer ) 
   { 
     SgCaseOptionStmt* source = (SgCaseOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_key = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_key_range_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key_range_end );
     storageOf_case_construct_name.storeDataInEasyStorageClass(source->p_case_construct_name);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCaseOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCaseOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCaseOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCaseOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21164 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTryStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21177 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTryStmtStorageClass::pickOutIRNodeData ( SgTryStmt* pointer ) 
   { 
     SgTryStmt* source = (SgTryStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_catch_statement_seq_root = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_catch_statement_seq_root );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTryStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTryStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTryStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTryStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21236 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21249 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultOptionStmtStorageClass::pickOutIRNodeData ( SgDefaultOptionStmt* pointer ) 
   { 
     SgDefaultOptionStmt* source = (SgDefaultOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_default_construct_name.storeDataInEasyStorageClass(source->p_default_construct_name);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefaultOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21312 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBreakStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21325 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBreakStmtStorageClass::pickOutIRNodeData ( SgBreakStmt* pointer ) 
   { 
     SgBreakStmt* source = (SgBreakStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBreakStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBreakStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBreakStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBreakStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21387 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContinueStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21400 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgContinueStmtStorageClass::pickOutIRNodeData ( SgContinueStmt* pointer ) 
   { 
     SgContinueStmt* source = (SgContinueStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgContinueStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContinueStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContinueStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContinueStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21462 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReturnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21475 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReturnStmtStorageClass::pickOutIRNodeData ( SgReturnStmt* pointer ) 
   { 
     SgReturnStmt* source = (SgReturnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReturnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReturnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReturnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReturnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21533 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21546 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGotoStatementStorageClass::pickOutIRNodeData ( SgGotoStatement* pointer ) 
   { 
     SgGotoStatement* source = (SgGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_label_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21605 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpawnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21618 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSpawnStmtStorageClass::pickOutIRNodeData ( SgSpawnStmt* pointer ) 
   { 
     SgSpawnStmt* source = (SgSpawnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_the_func = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_the_func );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSpawnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpawnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSpawnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSpawnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21676 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21689 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullStatementStorageClass::pickOutIRNodeData ( SgNullStatement* pointer ) 
   { 
     SgNullStatement* source = (SgNullStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21746 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21759 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariantStatementStorageClass::pickOutIRNodeData ( SgVariantStatement* pointer ) 
   { 
     SgVariantStatement* source = (SgVariantStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariantStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21816 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForInitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21829 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForInitStatementStorageClass::pickOutIRNodeData ( SgForInitStatement* pointer ) 
   { 
     SgForInitStatement* source = (SgForInitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_init_stmt = source->p_init_stmt.begin() ; 
     unsigned int tempListCountinit_stmt = 0; 
     SgStatementPtrList::value_type *  tempListinit_stmt = new SgStatementPtrList::value_type[ source->p_init_stmt.size() ]; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          tempListinit_stmt[tempListCountinit_stmt] = *i_init_stmt;
          tempListCountinit_stmt++; 
          (*i_init_stmt) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_init_stmt ) );
        }
     storageOf_init_stmt.storeDataInEasyStorageClass(source->p_init_stmt);
     tempListCountinit_stmt = 0; 
     i_init_stmt = source->p_init_stmt.begin() ; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          *i_init_stmt = tempListinit_stmt[tempListCountinit_stmt] ;
          tempListCountinit_stmt++; 
        }
      delete [] tempListinit_stmt; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForInitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForInitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForInitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForInitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21908 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchStatementSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21921 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCatchStatementSeqStorageClass::pickOutIRNodeData ( SgCatchStatementSeq* pointer ) 
   { 
     SgCatchStatementSeq* source = (SgCatchStatementSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     unsigned int tempListCountcatch_statement_seq = 0; 
     SgStatementPtrList::value_type *  tempListcatch_statement_seq = new SgStatementPtrList::value_type[ source->p_catch_statement_seq.size() ]; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          tempListcatch_statement_seq[tempListCountcatch_statement_seq] = *i_catch_statement_seq;
          tempListCountcatch_statement_seq++; 
          (*i_catch_statement_seq) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_catch_statement_seq ) );
        }
     storageOf_catch_statement_seq.storeDataInEasyStorageClass(source->p_catch_statement_seq);
     tempListCountcatch_statement_seq = 0; 
     i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          *i_catch_statement_seq = tempListcatch_statement_seq[tempListCountcatch_statement_seq] ;
          tempListCountcatch_statement_seq++; 
        }
      delete [] tempListcatch_statement_seq; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCatchStatementSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchStatementSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchStatementSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchStatementSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22000 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStopOrPauseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22013 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStopOrPauseStatementStorageClass::pickOutIRNodeData ( SgStopOrPauseStatement* pointer ) 
   { 
     SgStopOrPauseStatement* source = (SgStopOrPauseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_stop_or_pause =  source->p_stop_or_pause ;
     storageOf_code = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_code );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStopOrPauseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStopOrPauseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStopOrPauseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStopOrPauseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22072 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22085 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIOStatementStorageClass::pickOutIRNodeData ( SgIOStatement* pointer ) 
   { 
     SgIOStatement* source = (SgIOStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIOStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22148 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPrintStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22161 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPrintStatementStorageClass::pickOutIRNodeData ( SgPrintStatement* pointer ) 
   { 
     SgPrintStatement* source = (SgPrintStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPrintStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPrintStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPrintStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPrintStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22225 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReadStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22238 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReadStatementStorageClass::pickOutIRNodeData ( SgReadStatement* pointer ) 
   { 
     SgReadStatement* source = (SgReadStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_eor = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_eor );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReadStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReadStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReadStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReadStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWriteStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWriteStatementStorageClass::pickOutIRNodeData ( SgWriteStatement* pointer ) 
   { 
     SgWriteStatement* source = (SgWriteStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWriteStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWriteStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWriteStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWriteStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22390 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22403 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOpenStatementStorageClass::pickOutIRNodeData ( SgOpenStatement* pointer ) 
   { 
     SgOpenStatement* source = (SgOpenStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_round = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_round );
     storageOf_sign = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sign );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOpenStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOpenStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOpenStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOpenStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22479 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCloseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22492 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCloseStatementStorageClass::pickOutIRNodeData ( SgCloseStatement* pointer ) 
   { 
     SgCloseStatement* source = (SgCloseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCloseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCloseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCloseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCloseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22556 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInquireStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22569 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInquireStatementStorageClass::pickOutIRNodeData ( SgInquireStatement* pointer ) 
   { 
     SgInquireStatement* source = (SgInquireStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_exist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exist );
     storageOf_opened = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opened );
     storageOf_number = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_number );
     storageOf_named = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_sequential = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sequential );
     storageOf_direct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_direct );
     storageOf_formatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_formatted );
     storageOf_unformatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unformatted );
     storageOf_nextrec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nextrec );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_read = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_read );
     storageOf_write = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_write );
     storageOf_readwrite = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_readwrite );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_decimal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decimal );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_pending = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pending );
     storageOf_iolengthExp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iolengthExp );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInquireStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInquireStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInquireStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInquireStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22660 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22673 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFlushStatementStorageClass::pickOutIRNodeData ( SgFlushStatement* pointer ) 
   { 
     SgFlushStatement* source = (SgFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22736 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBackspaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22749 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBackspaceStatementStorageClass::pickOutIRNodeData ( SgBackspaceStatement* pointer ) 
   { 
     SgBackspaceStatement* source = (SgBackspaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBackspaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBackspaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBackspaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBackspaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22812 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRewindStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22825 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRewindStatementStorageClass::pickOutIRNodeData ( SgRewindStatement* pointer ) 
   { 
     SgRewindStatement* source = (SgRewindStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRewindStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRewindStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRewindStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRewindStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22888 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndfileStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22901 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEndfileStatementStorageClass::pickOutIRNodeData ( SgEndfileStatement* pointer ) 
   { 
     SgEndfileStatement* source = (SgEndfileStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEndfileStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndfileStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndfileStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndfileStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22964 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22977 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWaitStatementStorageClass::pickOutIRNodeData ( SgWaitStatement* pointer ) 
   { 
     SgWaitStatement* source = (SgWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23040 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23053 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWhereStatementStorageClass::pickOutIRNodeData ( SgWhereStatement* pointer ) 
   { 
     SgWhereStatement* source = (SgWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23120 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23133 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseWhereStatementStorageClass::pickOutIRNodeData ( SgElseWhereStatement* pointer ) 
   { 
     SgElseWhereStatement* source = (SgElseWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23193 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23206 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullifyStatementStorageClass::pickOutIRNodeData ( SgNullifyStatement* pointer ) 
   { 
     SgNullifyStatement* source = (SgNullifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pointer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pointer_list );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23264 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArithmeticIfStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23277 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArithmeticIfStatementStorageClass::pickOutIRNodeData ( SgArithmeticIfStatement* pointer ) 
   { 
     SgArithmeticIfStatement* source = (SgArithmeticIfStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_less_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_less_label );
     storageOf_equal_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equal_label );
     storageOf_greater_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_greater_label );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArithmeticIfStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArithmeticIfStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArithmeticIfStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArithmeticIfStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23338 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23351 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignStatementStorageClass::pickOutIRNodeData ( SgAssignStatement* pointer ) 
   { 
     SgAssignStatement* source = (SgAssignStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23410 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComputedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23423 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgComputedGotoStatementStorageClass::pickOutIRNodeData ( SgComputedGotoStatement* pointer ) 
   { 
     SgComputedGotoStatement* source = (SgComputedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_labelList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_labelList );
     storageOf_label_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_index );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgComputedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComputedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComputedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComputedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23482 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23495 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignedGotoStatementStorageClass::pickOutIRNodeData ( SgAssignedGotoStatement* pointer ) 
   { 
     SgAssignedGotoStatement* source = (SgAssignedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_targets = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_targets );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23553 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAllocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23566 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAllocateStatementStorageClass::pickOutIRNodeData ( SgAllocateStatement* pointer ) 
   { 
     SgAllocateStatement* source = (SgAllocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_source_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAllocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAllocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAllocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAllocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23627 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeallocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23640 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeallocateStatementStorageClass::pickOutIRNodeData ( SgDeallocateStatement* pointer ) 
   { 
     SgDeallocateStatement* source = (SgDeallocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeallocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeallocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeallocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeallocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23700 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcNotifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23713 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcNotifyStatementStorageClass::pickOutIRNodeData ( SgUpcNotifyStatement* pointer ) 
   { 
     SgUpcNotifyStatement* source = (SgUpcNotifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_notify_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_notify_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcNotifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcNotifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcNotifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcNotifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23771 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23784 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcWaitStatementStorageClass::pickOutIRNodeData ( SgUpcWaitStatement* pointer ) 
   { 
     SgUpcWaitStatement* source = (SgUpcWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_wait_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_wait_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23842 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23855 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBarrierStatementStorageClass::pickOutIRNodeData ( SgUpcBarrierStatement* pointer ) 
   { 
     SgUpcBarrierStatement* source = (SgUpcBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_barrier_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_barrier_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23913 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcFenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23926 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcFenceStatementStorageClass::pickOutIRNodeData ( SgUpcFenceStatement* pointer ) 
   { 
     SgUpcFenceStatement* source = (SgUpcFenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcFenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcFenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcFenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcFenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23983 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23996 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBarrierStatementStorageClass::pickOutIRNodeData ( SgOmpBarrierStatement* pointer ) 
   { 
     SgOmpBarrierStatement* source = (SgOmpBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24053 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskwaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24066 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskwaitStatementStorageClass::pickOutIRNodeData ( SgOmpTaskwaitStatement* pointer ) 
   { 
     SgOmpTaskwaitStatement* source = (SgOmpTaskwaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpTaskwaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskwaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskwaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskwaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24123 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24136 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFlushStatementStorageClass::pickOutIRNodeData ( SgOmpFlushStatement* pointer ) 
   { 
     SgOmpFlushStatement* source = (SgOmpFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24215 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24228 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBodyStatementStorageClass::pickOutIRNodeData ( SgOmpBodyStatement* pointer ) 
   { 
     SgOmpBodyStatement* source = (SgOmpBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24286 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpAtomicStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24299 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpAtomicStatementStorageClass::pickOutIRNodeData ( SgOmpAtomicStatement* pointer ) 
   { 
     SgOmpAtomicStatement* source = (SgOmpAtomicStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpAtomicStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpAtomicStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpAtomicStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpAtomicStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24357 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpMasterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24370 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpMasterStatementStorageClass::pickOutIRNodeData ( SgOmpMasterStatement* pointer ) 
   { 
     SgOmpMasterStatement* source = (SgOmpMasterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpMasterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpMasterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpMasterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpMasterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24428 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24441 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedStatementStorageClass::pickOutIRNodeData ( SgOmpOrderedStatement* pointer ) 
   { 
     SgOmpOrderedStatement* source = (SgOmpOrderedStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpOrderedStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24499 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCriticalStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24512 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCriticalStatementStorageClass::pickOutIRNodeData ( SgOmpCriticalStatement* pointer ) 
   { 
     SgOmpCriticalStatement* source = (SgOmpCriticalStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCriticalStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCriticalStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCriticalStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCriticalStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24575 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24588 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionStatementStorageClass::pickOutIRNodeData ( SgOmpSectionStatement* pointer ) 
   { 
     SgOmpSectionStatement* source = (SgOmpSectionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSectionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24646 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpWorkshareStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24659 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpWorkshareStatementStorageClass::pickOutIRNodeData ( SgOmpWorkshareStatement* pointer ) 
   { 
     SgOmpWorkshareStatement* source = (SgOmpWorkshareStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpWorkshareStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpWorkshareStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpWorkshareStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpWorkshareStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24717 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24730 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseBodyStatementStorageClass::pickOutIRNodeData ( SgOmpClauseBodyStatement* pointer ) 
   { 
     SgOmpClauseBodyStatement* source = (SgOmpClauseBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpClauseBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24810 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpParallelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24823 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpParallelStatementStorageClass::pickOutIRNodeData ( SgOmpParallelStatement* pointer ) 
   { 
     SgOmpParallelStatement* source = (SgOmpParallelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpParallelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpParallelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpParallelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpParallelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24903 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSingleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24916 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSingleStatementStorageClass::pickOutIRNodeData ( SgOmpSingleStatement* pointer ) 
   { 
     SgOmpSingleStatement* source = (SgOmpSingleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSingleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSingleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSingleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSingleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24996 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25009 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskStatementStorageClass::pickOutIRNodeData ( SgOmpTaskStatement* pointer ) 
   { 
     SgOmpTaskStatement* source = (SgOmpTaskStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpTaskStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25089 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25102 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpForStatementStorageClass::pickOutIRNodeData ( SgOmpForStatement* pointer ) 
   { 
     SgOmpForStatement* source = (SgOmpForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25182 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25195 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDoStatementStorageClass::pickOutIRNodeData ( SgOmpDoStatement* pointer ) 
   { 
     SgOmpDoStatement* source = (SgOmpDoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpDoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25275 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25288 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionsStatementStorageClass::pickOutIRNodeData ( SgOmpSectionsStatement* pointer ) 
   { 
     SgOmpSectionsStatement* source = (SgOmpSectionsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSectionsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25368 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSequenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25381 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSequenceStatementStorageClass::pickOutIRNodeData ( SgSequenceStatement* pointer ) 
   { 
     SgSequenceStatement* source = (SgSequenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSequenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSequenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSequenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSequenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25438 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25451 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionStorageClass::pickOutIRNodeData ( SgExpression* pointer ) 
   { 
     SgExpression* source = (SgExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25510 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25523 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryOpStorageClass::pickOutIRNodeData ( SgUnaryOp* pointer ) 
   { 
     SgUnaryOp* source = (SgUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25585 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionRootStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25598 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionRootStorageClass::pickOutIRNodeData ( SgExpressionRoot* pointer ) 
   { 
     SgExpressionRoot* source = (SgExpressionRoot*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExpressionRootStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionRootStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionRootStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionRootStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25660 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25673 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusOpStorageClass::pickOutIRNodeData ( SgMinusOp* pointer ) 
   { 
     SgMinusOp* source = (SgMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25735 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25748 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryAddOpStorageClass::pickOutIRNodeData ( SgUnaryAddOp* pointer ) 
   { 
     SgUnaryAddOp* source = (SgUnaryAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnaryAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25810 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25823 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNotOpStorageClass::pickOutIRNodeData ( SgNotOp* pointer ) 
   { 
     SgNotOp* source = (SgNotOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNotOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25885 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerDerefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25898 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerDerefExpStorageClass::pickOutIRNodeData ( SgPointerDerefExp* pointer ) 
   { 
     SgPointerDerefExp* source = (SgPointerDerefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerDerefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerDerefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerDerefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerDerefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25960 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddressOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25973 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAddressOfOpStorageClass::pickOutIRNodeData ( SgAddressOfOp* pointer ) 
   { 
     SgAddressOfOp* source = (SgAddressOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAddressOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddressOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddressOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddressOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26035 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26048 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusMinusOpStorageClass::pickOutIRNodeData ( SgMinusMinusOp* pointer ) 
   { 
     SgMinusMinusOp* source = (SgMinusMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26110 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusPlusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26123 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPlusPlusOpStorageClass::pickOutIRNodeData ( SgPlusPlusOp* pointer ) 
   { 
     SgPlusPlusOp* source = (SgPlusPlusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPlusPlusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusPlusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusPlusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusPlusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26185 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitComplementOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26198 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitComplementOpStorageClass::pickOutIRNodeData ( SgBitComplementOp* pointer ) 
   { 
     SgBitComplementOp* source = (SgBitComplementOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitComplementOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitComplementOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitComplementOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitComplementOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26260 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCastExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26273 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCastExpStorageClass::pickOutIRNodeData ( SgCastExp* pointer ) 
   { 
     SgCastExp* source = (SgCastExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_cast_type =  source->p_cast_type ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCastExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCastExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCastExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCastExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26337 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThrowOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26350 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgThrowOpStorageClass::pickOutIRNodeData ( SgThrowOp* pointer ) 
   { 
     SgThrowOp* source = (SgThrowOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_throwKind =  source->p_throwKind ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgThrowOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThrowOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThrowOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThrowOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26413 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRealPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26426 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRealPartOpStorageClass::pickOutIRNodeData ( SgRealPartOp* pointer ) 
   { 
     SgRealPartOp* source = (SgRealPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRealPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRealPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRealPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRealPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26488 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImagPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26501 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImagPartOpStorageClass::pickOutIRNodeData ( SgImagPartOp* pointer ) 
   { 
     SgImagPartOp* source = (SgImagPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImagPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImagPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImagPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImagPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26563 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConjugateOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26576 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConjugateOpStorageClass::pickOutIRNodeData ( SgConjugateOp* pointer ) 
   { 
     SgConjugateOp* source = (SgConjugateOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConjugateOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConjugateOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConjugateOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConjugateOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26638 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26651 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedUnaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedUnaryOp* pointer ) 
   { 
     SgUserDefinedUnaryOp* source = (SgUserDefinedUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUserDefinedUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26719 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26732 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryOpStorageClass::pickOutIRNodeData ( SgBinaryOp* pointer ) 
   { 
     SgBinaryOp* source = (SgBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26795 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26808 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrowExpStorageClass::pickOutIRNodeData ( SgArrowExp* pointer ) 
   { 
     SgArrowExp* source = (SgArrowExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrowExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26871 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26884 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDotExpStorageClass::pickOutIRNodeData ( SgDotExp* pointer ) 
   { 
     SgDotExp* source = (SgDotExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDotExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26947 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26960 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDotStarOpStorageClass::pickOutIRNodeData ( SgDotStarOp* pointer ) 
   { 
     SgDotStarOp* source = (SgDotStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDotStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27023 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27036 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrowStarOpStorageClass::pickOutIRNodeData ( SgArrowStarOp* pointer ) 
   { 
     SgArrowStarOp* source = (SgArrowStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrowStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27099 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEqualityOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27112 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEqualityOpStorageClass::pickOutIRNodeData ( SgEqualityOp* pointer ) 
   { 
     SgEqualityOp* source = (SgEqualityOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEqualityOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEqualityOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEqualityOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEqualityOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27175 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27188 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLessThanOpStorageClass::pickOutIRNodeData ( SgLessThanOp* pointer ) 
   { 
     SgLessThanOp* source = (SgLessThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLessThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27251 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27264 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterThanOpStorageClass::pickOutIRNodeData ( SgGreaterThanOp* pointer ) 
   { 
     SgGreaterThanOp* source = (SgGreaterThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGreaterThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27327 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27340 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNotEqualOpStorageClass::pickOutIRNodeData ( SgNotEqualOp* pointer ) 
   { 
     SgNotEqualOp* source = (SgNotEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNotEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27403 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27416 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLessOrEqualOpStorageClass::pickOutIRNodeData ( SgLessOrEqualOp* pointer ) 
   { 
     SgLessOrEqualOp* source = (SgLessOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLessOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27479 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27492 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterOrEqualOpStorageClass::pickOutIRNodeData ( SgGreaterOrEqualOp* pointer ) 
   { 
     SgGreaterOrEqualOp* source = (SgGreaterOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGreaterOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27555 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27568 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAddOpStorageClass::pickOutIRNodeData ( SgAddOp* pointer ) 
   { 
     SgAddOp* source = (SgAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27631 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubtractOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27644 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSubtractOpStorageClass::pickOutIRNodeData ( SgSubtractOp* pointer ) 
   { 
     SgSubtractOp* source = (SgSubtractOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSubtractOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubtractOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubtractOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubtractOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27707 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultiplyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27720 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMultiplyOpStorageClass::pickOutIRNodeData ( SgMultiplyOp* pointer ) 
   { 
     SgMultiplyOp* source = (SgMultiplyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMultiplyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultiplyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultiplyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultiplyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27783 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27796 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDivideOpStorageClass::pickOutIRNodeData ( SgDivideOp* pointer ) 
   { 
     SgDivideOp* source = (SgDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27859 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntegerDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27872 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntegerDivideOpStorageClass::pickOutIRNodeData ( SgIntegerDivideOp* pointer ) 
   { 
     SgIntegerDivideOp* source = (SgIntegerDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntegerDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntegerDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntegerDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntegerDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27935 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27948 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModOpStorageClass::pickOutIRNodeData ( SgModOp* pointer ) 
   { 
     SgModOp* source = (SgModOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAndOpStorageClass::pickOutIRNodeData ( SgAndOp* pointer ) 
   { 
     SgAndOp* source = (SgAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28087 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28100 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOrOpStorageClass::pickOutIRNodeData ( SgOrOp* pointer ) 
   { 
     SgOrOp* source = (SgOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28163 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitXorOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28176 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitXorOpStorageClass::pickOutIRNodeData ( SgBitXorOp* pointer ) 
   { 
     SgBitXorOp* source = (SgBitXorOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitXorOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitXorOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitXorOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitXorOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28239 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28252 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitAndOpStorageClass::pickOutIRNodeData ( SgBitAndOp* pointer ) 
   { 
     SgBitAndOp* source = (SgBitAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28315 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28328 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitOrOpStorageClass::pickOutIRNodeData ( SgBitOrOp* pointer ) 
   { 
     SgBitOrOp* source = (SgBitOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28391 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommaOpExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28404 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommaOpExpStorageClass::pickOutIRNodeData ( SgCommaOpExp* pointer ) 
   { 
     SgCommaOpExp* source = (SgCommaOpExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommaOpExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommaOpExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommaOpExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommaOpExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28467 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28480 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftOpStorageClass::pickOutIRNodeData ( SgLshiftOp* pointer ) 
   { 
     SgLshiftOp* source = (SgLshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28543 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28556 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftOpStorageClass::pickOutIRNodeData ( SgRshiftOp* pointer ) 
   { 
     SgRshiftOp* source = (SgRshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28619 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPntrArrRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28632 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPntrArrRefExpStorageClass::pickOutIRNodeData ( SgPntrArrRefExp* pointer ) 
   { 
     SgPntrArrRefExp* source = (SgPntrArrRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPntrArrRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPntrArrRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPntrArrRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPntrArrRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28695 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28708 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgScopeOpStorageClass::pickOutIRNodeData ( SgScopeOp* pointer ) 
   { 
     SgScopeOp* source = (SgScopeOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgScopeOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28771 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28784 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignOpStorageClass::pickOutIRNodeData ( SgAssignOp* pointer ) 
   { 
     SgAssignOp* source = (SgAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28847 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28860 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPlusAssignOpStorageClass::pickOutIRNodeData ( SgPlusAssignOp* pointer ) 
   { 
     SgPlusAssignOp* source = (SgPlusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPlusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28923 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28936 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusAssignOpStorageClass::pickOutIRNodeData ( SgMinusAssignOp* pointer ) 
   { 
     SgMinusAssignOp* source = (SgMinusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28999 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29012 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAndAssignOpStorageClass::pickOutIRNodeData ( SgAndAssignOp* pointer ) 
   { 
     SgAndAssignOp* source = (SgAndAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAndAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29075 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29088 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIorAssignOpStorageClass::pickOutIRNodeData ( SgIorAssignOp* pointer ) 
   { 
     SgIorAssignOp* source = (SgIorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29151 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29164 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMultAssignOpStorageClass::pickOutIRNodeData ( SgMultAssignOp* pointer ) 
   { 
     SgMultAssignOp* source = (SgMultAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMultAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29227 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29240 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDivAssignOpStorageClass::pickOutIRNodeData ( SgDivAssignOp* pointer ) 
   { 
     SgDivAssignOp* source = (SgDivAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDivAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29303 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29316 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModAssignOpStorageClass::pickOutIRNodeData ( SgModAssignOp* pointer ) 
   { 
     SgModAssignOp* source = (SgModAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29379 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgXorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29392 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgXorAssignOpStorageClass::pickOutIRNodeData ( SgXorAssignOp* pointer ) 
   { 
     SgXorAssignOp* source = (SgXorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgXorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgXorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgXorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgXorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29455 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29468 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftAssignOpStorageClass::pickOutIRNodeData ( SgLshiftAssignOp* pointer ) 
   { 
     SgLshiftAssignOp* source = (SgLshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29531 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29544 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftAssignOpStorageClass::pickOutIRNodeData ( SgRshiftAssignOp* pointer ) 
   { 
     SgRshiftAssignOp* source = (SgRshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29607 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExponentiationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29620 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExponentiationOpStorageClass::pickOutIRNodeData ( SgExponentiationOp* pointer ) 
   { 
     SgExponentiationOp* source = (SgExponentiationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExponentiationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExponentiationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExponentiationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExponentiationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29683 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConcatenationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29696 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConcatenationOpStorageClass::pickOutIRNodeData ( SgConcatenationOp* pointer ) 
   { 
     SgConcatenationOp* source = (SgConcatenationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConcatenationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConcatenationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConcatenationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConcatenationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29759 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29772 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerAssignOpStorageClass::pickOutIRNodeData ( SgPointerAssignOp* pointer ) 
   { 
     SgPointerAssignOp* source = (SgPointerAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29835 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29848 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedBinaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedBinaryOp* pointer ) 
   { 
     SgUserDefinedBinaryOp* source = (SgUserDefinedBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUserDefinedBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29917 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29930 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExprListExpStorageClass::pickOutIRNodeData ( SgExprListExp* pointer ) 
   { 
     SgExprListExp* source = (SgExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarRefExpStorageClass::pickOutIRNodeData ( SgVarRefExp* pointer ) 
   { 
     SgVarRefExp* source = (SgVarRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30085 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassNameRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30098 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassNameRefExpStorageClass::pickOutIRNodeData ( SgClassNameRefExp* pointer ) 
   { 
     SgClassNameRefExp* source = (SgClassNameRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassNameRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassNameRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassNameRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassNameRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30158 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30171 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionRefExpStorageClass::pickOutIRNodeData ( SgFunctionRefExp* pointer ) 
   { 
     SgFunctionRefExp* source = (SgFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30233 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30246 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionRefExpStorageClass::pickOutIRNodeData ( SgMemberFunctionRefExp* pointer ) 
   { 
     SgMemberFunctionRefExp* source = (SgMemberFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_virtual_call =  source->p_virtual_call ;
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgValueExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgValueExpStorageClass::pickOutIRNodeData ( SgValueExp* pointer ) 
   { 
     SgValueExp* source = (SgValueExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgValueExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgValueExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgValueExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgValueExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30382 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBoolValExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30395 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBoolValExpStorageClass::pickOutIRNodeData ( SgBoolValExp* pointer ) 
   { 
     SgBoolValExp* source = (SgBoolValExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBoolValExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBoolValExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBoolValExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBoolValExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30456 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30469 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStringValStorageClass::pickOutIRNodeData ( SgStringVal* pointer ) 
   { 
     SgStringVal* source = (SgStringVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value.storeDataInEasyStorageClass(source->p_value);
     storageOf_wcharString =  source->p_wcharString ;
     storageOf_usesSingleQuotes =  source->p_usesSingleQuotes ;
     storageOf_usesDoubleQuotes =  source->p_usesDoubleQuotes ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStringValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStringValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStringValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30537 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30550 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgShortValStorageClass::pickOutIRNodeData ( SgShortVal* pointer ) 
   { 
     SgShortVal* source = (SgShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30616 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30629 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCharValStorageClass::pickOutIRNodeData ( SgCharVal* pointer ) 
   { 
     SgCharVal* source = (SgCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30695 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30708 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedCharValStorageClass::pickOutIRNodeData ( SgUnsignedCharVal* pointer ) 
   { 
     SgUnsignedCharVal* source = (SgUnsignedCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30774 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWcharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30787 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWcharValStorageClass::pickOutIRNodeData ( SgWcharVal* pointer ) 
   { 
     SgWcharVal* source = (SgWcharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_valueUL =  source->p_valueUL ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWcharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWcharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWcharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWcharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30853 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30866 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedShortValStorageClass::pickOutIRNodeData ( SgUnsignedShortVal* pointer ) 
   { 
     SgUnsignedShortVal* source = (SgUnsignedShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30932 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30945 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntValStorageClass::pickOutIRNodeData ( SgIntVal* pointer ) 
   { 
     SgIntVal* source = (SgIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumValStorageClass::pickOutIRNodeData ( SgEnumVal* pointer ) 
   { 
     SgEnumVal* source = (SgEnumVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_requiresNameQualification =  source->p_requiresNameQualification ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31092 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31105 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedIntValStorageClass::pickOutIRNodeData ( SgUnsignedIntVal* pointer ) 
   { 
     SgUnsignedIntVal* source = (SgUnsignedIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31171 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31184 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongIntValStorageClass::pickOutIRNodeData ( SgLongIntVal* pointer ) 
   { 
     SgLongIntVal* source = (SgLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31250 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31263 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongLongIntValStorageClass::pickOutIRNodeData ( SgLongLongIntVal* pointer ) 
   { 
     SgLongLongIntVal* source = (SgLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31329 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31342 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongLongIntValStorageClass::pickOutIRNodeData ( SgUnsignedLongLongIntVal* pointer ) 
   { 
     SgUnsignedLongLongIntVal* source = (SgUnsignedLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31408 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31421 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongValStorageClass::pickOutIRNodeData ( SgUnsignedLongVal* pointer ) 
   { 
     SgUnsignedLongVal* source = (SgUnsignedLongVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedLongValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31487 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFloatValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31500 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFloatValStorageClass::pickOutIRNodeData ( SgFloatVal* pointer ) 
   { 
     SgFloatVal* source = (SgFloatVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFloatValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFloatValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFloatValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFloatValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31566 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31579 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDoubleValStorageClass::pickOutIRNodeData ( SgDoubleVal* pointer ) 
   { 
     SgDoubleVal* source = (SgDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31645 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31658 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongDoubleValStorageClass::pickOutIRNodeData ( SgLongDoubleVal* pointer ) 
   { 
     SgLongDoubleVal* source = (SgLongDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31724 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComplexValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31737 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgComplexValStorageClass::pickOutIRNodeData ( SgComplexVal* pointer ) 
   { 
     SgComplexVal* source = (SgComplexVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_real_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_real_value );
     storageOf_imaginary_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_imaginary_value );
     storageOf_precisionType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_precisionType );
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgComplexValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComplexValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComplexValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComplexValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31805 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcThreadsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31818 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcThreadsStorageClass::pickOutIRNodeData ( SgUpcThreads* pointer ) 
   { 
     SgUpcThreads* source = (SgUpcThreads*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcThreadsStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcThreadsStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcThreadsStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcThreadsStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31884 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcMythreadStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31897 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcMythreadStorageClass::pickOutIRNodeData ( SgUpcMythread* pointer ) 
   { 
     SgUpcMythread* source = (SgUpcMythread*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcMythreadStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcMythreadStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcMythreadStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcMythreadStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31963 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31976 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionCallExpStorageClass::pickOutIRNodeData ( SgFunctionCallExp* pointer ) 
   { 
     SgFunctionCallExp* source = (SgFunctionCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32038 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSizeOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32051 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSizeOfOpStorageClass::pickOutIRNodeData ( SgSizeOfOp* pointer ) 
   { 
     SgSizeOfOp* source = (SgSizeOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSizeOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSizeOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSizeOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSizeOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32113 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcLocalsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32126 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcLocalsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcLocalsizeofExpression* pointer ) 
   { 
     SgUpcLocalsizeofExpression* source = (SgUpcLocalsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcLocalsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32188 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBlocksizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32201 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBlocksizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcBlocksizeofExpression* pointer ) 
   { 
     SgUpcBlocksizeofExpression* source = (SgUpcBlocksizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBlocksizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32263 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcElemsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32276 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcElemsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcElemsizeofExpression* pointer ) 
   { 
     SgUpcElemsizeofExpression* source = (SgUpcElemsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcElemsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcElemsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32338 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIdOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32351 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIdOpStorageClass::pickOutIRNodeData ( SgTypeIdOp* pointer ) 
   { 
     SgTypeIdOp* source = (SgTypeIdOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeIdOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIdOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIdOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIdOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32413 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConditionalExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32426 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConditionalExpStorageClass::pickOutIRNodeData ( SgConditionalExp* pointer ) 
   { 
     SgConditionalExp* source = (SgConditionalExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional_exp );
     storageOf_true_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_exp );
     storageOf_false_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_exp );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConditionalExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConditionalExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConditionalExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConditionalExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32489 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNewExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32502 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNewExpStorageClass::pickOutIRNodeData ( SgNewExp* pointer ) 
   { 
     SgNewExp* source = (SgNewExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_specified_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_specified_type );
     storageOf_placement_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_placement_args );
     storageOf_constructor_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constructor_args );
     storageOf_builtin_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_builtin_args );
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_newOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_newOperatorDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNewExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNewExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNewExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNewExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32567 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeleteExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32580 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeleteExpStorageClass::pickOutIRNodeData ( SgDeleteExp* pointer ) 
   { 
     SgDeleteExp* source = (SgDeleteExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable );
     storageOf_is_array =  source->p_is_array ;
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_deleteOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_deleteOperatorDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeleteExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeleteExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeleteExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeleteExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32643 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThisExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32656 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgThisExpStorageClass::pickOutIRNodeData ( SgThisExp* pointer ) 
   { 
     SgThisExp* source = (SgThisExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_pobj_this =  source->p_pobj_this ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgThisExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThisExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThisExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThisExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32717 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32730 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRefExpStorageClass::pickOutIRNodeData ( SgRefExp* pointer ) 
   { 
     SgRefExp* source = (SgRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_name );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32790 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32803 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInitializerStorageClass::pickOutIRNodeData ( SgInitializer* pointer ) 
   { 
     SgInitializer* source = (SgInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32863 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAggregateInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32876 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAggregateInitializerStorageClass::pickOutIRNodeData ( SgAggregateInitializer* pointer ) 
   { 
     SgAggregateInitializer* source = (SgAggregateInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_explicit_braces =  source->p_need_explicit_braces ;
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAggregateInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAggregateInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAggregateInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAggregateInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32939 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstructorInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32952 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConstructorInitializerStorageClass::pickOutIRNodeData ( SgConstructorInitializer* pointer ) 
   { 
     SgConstructorInitializer* source = (SgConstructorInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_name =  source->p_need_name ;
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_need_parenthesis_after_name =  source->p_need_parenthesis_after_name ;
     storageOf_associated_class_unknown =  source->p_associated_class_unknown ;
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConstructorInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConstructorInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConstructorInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConstructorInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33019 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33032 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignInitializerStorageClass::pickOutIRNodeData ( SgAssignInitializer* pointer ) 
   { 
     SgAssignInitializer* source = (SgAssignInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33094 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDesignatedInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33107 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDesignatedInitializerStorageClass::pickOutIRNodeData ( SgDesignatedInitializer* pointer ) 
   { 
     SgDesignatedInitializer* source = (SgDesignatedInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_designatorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_designatorList );
     storageOf_memberInit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_memberInit );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDesignatedInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDesignatedInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDesignatedInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDesignatedInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33169 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33182 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOpStorageClass::pickOutIRNodeData ( SgVarArgStartOp* pointer ) 
   { 
     SgVarArgStartOp* source = (SgVarArgStartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgStartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33244 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33257 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgOpStorageClass::pickOutIRNodeData ( SgVarArgOp* pointer ) 
   { 
     SgVarArgOp* source = (SgVarArgOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33318 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgEndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33331 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgEndOpStorageClass::pickOutIRNodeData ( SgVarArgEndOp* pointer ) 
   { 
     SgVarArgEndOp* source = (SgVarArgEndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgEndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgEndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgEndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgEndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33392 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgCopyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33405 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgCopyOpStorageClass::pickOutIRNodeData ( SgVarArgCopyOp* pointer ) 
   { 
     SgVarArgCopyOp* source = (SgVarArgCopyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgCopyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgCopyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgCopyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgCopyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33467 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOneOperandOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33480 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOneOperandOpStorageClass::pickOutIRNodeData ( SgVarArgStartOneOperandOp* pointer ) 
   { 
     SgVarArgStartOneOperandOp* source = (SgVarArgStartOneOperandOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgStartOneOperandOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOneOperandOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33541 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33554 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullExpressionStorageClass::pickOutIRNodeData ( SgNullExpression* pointer ) 
   { 
     SgNullExpression* source = (SgNullExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33613 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33626 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariantExpressionStorageClass::pickOutIRNodeData ( SgVariantExpression* pointer ) 
   { 
     SgVariantExpression* source = (SgVariantExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariantExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33685 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubscriptExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33698 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSubscriptExpressionStorageClass::pickOutIRNodeData ( SgSubscriptExpression* pointer ) 
   { 
     SgSubscriptExpression* source = (SgSubscriptExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lowerBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lowerBound );
     storageOf_upperBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_upperBound );
     storageOf_stride = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stride );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSubscriptExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubscriptExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubscriptExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubscriptExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33760 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgColonShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33773 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgColonShapeExpStorageClass::pickOutIRNodeData ( SgColonShapeExp* pointer ) 
   { 
     SgColonShapeExp* source = (SgColonShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgColonShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgColonShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgColonShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgColonShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33832 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsteriskShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33845 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsteriskShapeExpStorageClass::pickOutIRNodeData ( SgAsteriskShapeExp* pointer ) 
   { 
     SgAsteriskShapeExp* source = (SgAsteriskShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsteriskShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsteriskShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsteriskShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsteriskShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33904 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImpliedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33917 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImpliedDoStorageClass::pickOutIRNodeData ( SgImpliedDo* pointer ) 
   { 
     SgImpliedDo* source = (SgImpliedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_var_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_do_var_initialization );
     storageOf_last_val = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_last_val );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_object_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_list );
     storageOf_implied_do_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_implied_do_scope );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImpliedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImpliedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImpliedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImpliedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33981 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOItemExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33994 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIOItemExpressionStorageClass::pickOutIRNodeData ( SgIOItemExpression* pointer ) 
   { 
     SgIOItemExpression* source = (SgIOItemExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_io_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_item );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIOItemExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOItemExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOItemExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOItemExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34059 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34072 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementExpressionStorageClass::pickOutIRNodeData ( SgStatementExpression* pointer ) 
   { 
     SgStatementExpression* source = (SgStatementExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34132 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34145 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOpStorageClass::pickOutIRNodeData ( SgAsmOp* pointer ) 
   { 
     SgAsmOp* source = (SgAsmOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_constraint =  source->p_constraint ;
     storageOf_modifiers =  source->p_modifiers ;
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_recordRawAsmOperandDescriptions =  source->p_recordRawAsmOperandDescriptions ;
     storageOf_isOutputOperand =  source->p_isOutputOperand ;
     storageOf_constraintString.storeDataInEasyStorageClass(source->p_constraintString);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34215 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34228 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelRefExpStorageClass::pickOutIRNodeData ( SgLabelRefExp* pointer ) 
   { 
     SgLabelRefExp* source = (SgLabelRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34288 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgActualArgumentExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34301 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgActualArgumentExpressionStorageClass::pickOutIRNodeData ( SgActualArgumentExpression* pointer ) 
   { 
     SgActualArgumentExpression* source = (SgActualArgumentExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_argument_name.pickOutIRNodeData( &(source->p_argument_name) );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgActualArgumentExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgActualArgumentExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgActualArgumentExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgActualArgumentExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34366 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownArrayOrFunctionReferenceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34379 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownArrayOrFunctionReferenceStorageClass::pickOutIRNodeData ( SgUnknownArrayOrFunctionReference* pointer ) 
   { 
     SgUnknownArrayOrFunctionReference* source = (SgUnknownArrayOrFunctionReference*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_named_reference = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named_reference );
     storageOf_expression_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_list );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownArrayOrFunctionReferenceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34445 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPseudoDestructorRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34458 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPseudoDestructorRefExpStorageClass::pickOutIRNodeData ( SgPseudoDestructorRefExp* pointer ) 
   { 
     SgPseudoDestructorRefExp* source = (SgPseudoDestructorRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_object_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPseudoDestructorRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPseudoDestructorRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPseudoDestructorRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPseudoDestructorRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34519 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFCoExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34532 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCAFCoExpressionStorageClass::pickOutIRNodeData ( SgCAFCoExpression* pointer ) 
   { 
     SgCAFCoExpression* source = (SgCAFCoExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_teamRank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamRank );
     storageOf_referData = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_referData );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCAFCoExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFCoExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFCoExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFCoExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34594 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34607 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelCallExpStorageClass::pickOutIRNodeData ( SgCudaKernelCallExp* pointer ) 
   { 
     SgCudaKernelCallExp* source = (SgCudaKernelCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_exec_config = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_config );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCudaKernelCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34669 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelExecConfigStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34682 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelExecConfigStorageClass::pickOutIRNodeData ( SgCudaKernelExecConfig* pointer ) 
   { 
     SgCudaKernelExecConfig* source = (SgCudaKernelExecConfig*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_grid = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_grid );
     storageOf_blocks = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blocks );
     storageOf_shared = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shared );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCudaKernelExecConfigStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelExecConfigStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelExecConfigStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelExecConfigStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34745 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTokenStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34758 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTokenStorageClass::pickOutIRNodeData ( SgToken* pointer ) 
   { 
     SgToken* source = (SgToken*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lexeme_string.storeDataInEasyStorageClass(source->p_lexeme_string);
     storageOf_classification_code =  source->p_classification_code ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTokenStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTokenStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTokenStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTokenStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34819 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34832 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolStorageClass::pickOutIRNodeData ( SgSymbol* pointer ) 
   { 
     SgSymbol* source = (SgSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34880 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34893 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableSymbolStorageClass::pickOutIRNodeData ( SgVariableSymbol* pointer ) 
   { 
     SgVariableSymbol* source = (SgVariableSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34942 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34955 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionSymbolStorageClass::pickOutIRNodeData ( SgFunctionSymbol* pointer ) 
   { 
     SgFunctionSymbol* source = (SgFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35004 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35017 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionSymbolStorageClass::pickOutIRNodeData ( SgMemberFunctionSymbol* pointer ) 
   { 
     SgMemberFunctionSymbol* source = (SgMemberFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35066 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenameSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35079 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRenameSymbolStorageClass::pickOutIRNodeData ( SgRenameSymbol* pointer ) 
   { 
     SgRenameSymbol* source = (SgRenameSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_original_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_original_symbol );
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRenameSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenameSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenameSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenameSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35134 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35147 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeSymbolStorageClass::pickOutIRNodeData ( SgFunctionTypeSymbol* pointer ) 
   { 
     SgFunctionTypeSymbol* source = (SgFunctionTypeSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35201 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35214 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassSymbolStorageClass::pickOutIRNodeData ( SgClassSymbol* pointer ) 
   { 
     SgClassSymbol* source = (SgClassSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35263 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35276 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateSymbolStorageClass::pickOutIRNodeData ( SgTemplateSymbol* pointer ) 
   { 
     SgTemplateSymbol* source = (SgTemplateSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35325 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35338 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumSymbolStorageClass::pickOutIRNodeData ( SgEnumSymbol* pointer ) 
   { 
     SgEnumSymbol* source = (SgEnumSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35387 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumFieldSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35400 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumFieldSymbolStorageClass::pickOutIRNodeData ( SgEnumFieldSymbol* pointer ) 
   { 
     SgEnumFieldSymbol* source = (SgEnumFieldSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumFieldSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumFieldSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumFieldSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumFieldSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35449 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35462 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSymbolStorageClass::pickOutIRNodeData ( SgTypedefSymbol* pointer ) 
   { 
     SgTypedefSymbol* source = (SgTypedefSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35511 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35524 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelSymbolStorageClass::pickOutIRNodeData ( SgLabelSymbol* pointer ) 
   { 
     SgLabelSymbol* source = (SgLabelSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_fortran_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_statement );
     storageOf_fortran_alternate_return_parameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_alternate_return_parameter );
     storageOf_numeric_label_value =  source->p_numeric_label_value ;
     storageOf_label_type =  source->p_label_type ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35577 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35590 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultSymbolStorageClass::pickOutIRNodeData ( SgDefaultSymbol* pointer ) 
   { 
     SgDefaultSymbol* source = (SgDefaultSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefaultSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35639 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35652 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceSymbolStorageClass::pickOutIRNodeData ( SgNamespaceSymbol* pointer ) 
   { 
     SgNamespaceSymbol* source = (SgNamespaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_aliasDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_aliasDeclaration );
     storageOf_isAlias =  source->p_isAlias ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35708 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntrinsicSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35721 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntrinsicSymbolStorageClass::pickOutIRNodeData ( SgIntrinsicSymbol* pointer ) 
   { 
     SgIntrinsicSymbol* source = (SgIntrinsicSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntrinsicSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntrinsicSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntrinsicSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntrinsicSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35770 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35783 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModuleSymbolStorageClass::pickOutIRNodeData ( SgModuleSymbol* pointer ) 
   { 
     SgModuleSymbol* source = (SgModuleSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModuleSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35832 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35845 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceSymbolStorageClass::pickOutIRNodeData ( SgInterfaceSymbol* pointer ) 
   { 
     SgInterfaceSymbol* source = (SgInterfaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35894 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35907 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonSymbolStorageClass::pickOutIRNodeData ( SgCommonSymbol* pointer ) 
   { 
     SgCommonSymbol* source = (SgCommonSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35956 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAliasSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35969 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAliasSymbolStorageClass::pickOutIRNodeData ( SgAliasSymbol* pointer ) 
   { 
     SgAliasSymbol* source = (SgAliasSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_alias = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_alias );
     storageOf_isRenamed =  source->p_isRenamed ;
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAliasSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAliasSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAliasSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAliasSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36024 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddressSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36037 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddressSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryAddressSymbol* pointer ) 
   { 
     SgAsmBinaryAddressSymbol* source = (SgAsmBinaryAddressSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address_name.pickOutIRNodeData( &(source->p_address_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddressSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36091 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDataSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36104 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDataSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryDataSymbol* pointer ) 
   { 
     SgAsmBinaryDataSymbol* source = (SgAsmBinaryDataSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable_name.pickOutIRNodeData( &(source->p_variable_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryDataSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryDataSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36158 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36171 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNodeStorageClass::pickOutIRNodeData ( SgAsmNode* pointer ) 
   { 
     SgAsmNode* source = (SgAsmNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36225 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36238 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStatementStorageClass::pickOutIRNodeData ( SgAsmStatement* pointer ) 
   { 
     SgAsmStatement* source = (SgAsmStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36298 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36311 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDeclarationStorageClass::pickOutIRNodeData ( SgAsmDeclaration* pointer ) 
   { 
     SgAsmDeclaration* source = (SgAsmDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36371 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDataStructureDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36384 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDataStructureDeclarationStorageClass::pickOutIRNodeData ( SgAsmDataStructureDeclaration* pointer ) 
   { 
     SgAsmDataStructureDeclaration* source = (SgAsmDataStructureDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDataStructureDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDataStructureDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDataStructureDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDataStructureDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36444 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36457 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFunctionDeclarationStorageClass::pickOutIRNodeData ( SgAsmFunctionDeclaration* pointer ) 
   { 
     SgAsmFunctionDeclaration* source = (SgAsmFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_reason =  source->p_reason ;
     storageOf_function_kind =  source->p_function_kind ;
     storageOf_name_md5.storeDataInEasyStorageClass(source->p_name_md5);
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     SgAsmStatementPtrList::iterator i_dest = source->p_dest.begin() ; 
     unsigned int tempListCountdest = 0; 
     SgAsmStatementPtrList::value_type *  tempListdest = new SgAsmStatementPtrList::value_type[ source->p_dest.size() ]; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          tempListdest[tempListCountdest] = *i_dest;
          tempListCountdest++; 
          (*i_dest) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dest ) );
        }
     storageOf_dest.storeDataInEasyStorageClass(source->p_dest);
     tempListCountdest = 0; 
     i_dest = source->p_dest.begin() ; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          *i_dest = tempListdest[tempListCountdest] ;
          tempListCountdest++; 
        }
      delete [] tempListdest; 
     storageOf_entry_va =  source->p_entry_va ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36563 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFieldDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36576 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFieldDeclarationStorageClass::pickOutIRNodeData ( SgAsmFieldDeclaration* pointer ) 
   { 
     SgAsmFieldDeclaration* source = (SgAsmFieldDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_offset =  source->p_offset ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmFieldDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmFieldDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmFieldDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmFieldDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36638 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36651 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBlockStorageClass::pickOutIRNodeData ( SgAsmBlock* pointer ) 
   { 
     SgAsmBlock* source = (SgAsmBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_next_block_true_address =  source->p_next_block_true_address ;
     storageOf_next_block_false_address =  source->p_next_block_false_address ;
     storageOf_id =  source->p_id ;
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     storageOf_cached_successors.storeDataInEasyStorageClass(source->p_cached_successors);
     storageOf_complete_successors =  source->p_complete_successors ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAddressList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAddressList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgAddressList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgAddressList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36742 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36755 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInstructionStorageClass::pickOutIRNodeData ( SgAsmInstruction* pointer ) 
   { 
     SgAsmInstruction* source = (SgAsmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36844 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmx86InstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36857 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmx86InstructionStorageClass::pickOutIRNodeData ( SgAsmx86Instruction* pointer ) 
   { 
     SgAsmx86Instruction* source = (SgAsmx86Instruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_baseSize =  source->p_baseSize ;
     storageOf_operandSize =  source->p_operandSize ;
     storageOf_addressSize =  source->p_addressSize ;
     storageOf_lockPrefix =  source->p_lockPrefix ;
     storageOf_repeatPrefix =  source->p_repeatPrefix ;
     storageOf_branchPrediction =  source->p_branchPrediction ;
     storageOf_segmentOverride =  source->p_segmentOverride ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmx86InstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmx86InstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmx86InstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmx86InstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36954 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmArmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36967 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmArmInstructionStorageClass::pickOutIRNodeData ( SgAsmArmInstruction* pointer ) 
   { 
     SgAsmArmInstruction* source = (SgAsmArmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_condition =  source->p_condition ;
     storageOf_positionOfConditionInMnemonic =  source->p_positionOfConditionInMnemonic ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmArmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmArmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmArmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmArmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37059 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPowerpcInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37072 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPowerpcInstructionStorageClass::pickOutIRNodeData ( SgAsmPowerpcInstruction* pointer ) 
   { 
     SgAsmPowerpcInstruction* source = (SgAsmPowerpcInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPowerpcInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPowerpcInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPowerpcInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPowerpcInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37162 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37175 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExpressionStorageClass::pickOutIRNodeData ( SgAsmExpression* pointer ) 
   { 
     SgAsmExpression* source = (SgAsmExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37235 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37248 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmValueExpressionStorageClass::pickOutIRNodeData ( SgAsmValueExpression* pointer ) 
   { 
     SgAsmValueExpression* source = (SgAsmValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37312 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmByteValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37325 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmByteValueExpressionStorageClass::pickOutIRNodeData ( SgAsmByteValueExpression* pointer ) 
   { 
     SgAsmByteValueExpression* source = (SgAsmByteValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmByteValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmByteValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmByteValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmByteValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37390 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37403 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmWordValueExpression* pointer ) 
   { 
     SgAsmWordValueExpression* source = (SgAsmWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37468 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDoubleWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37481 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDoubleWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmDoubleWordValueExpression* pointer ) 
   { 
     SgAsmDoubleWordValueExpression* source = (SgAsmDoubleWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDoubleWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37546 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmQuadWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37559 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmQuadWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmQuadWordValueExpression* pointer ) 
   { 
     SgAsmQuadWordValueExpression* source = (SgAsmQuadWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmQuadWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37624 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmSingleFloatValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37637 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmSingleFloatValueExpressionStorageClass::pickOutIRNodeData ( SgAsmSingleFloatValueExpression* pointer ) 
   { 
     SgAsmSingleFloatValueExpression* source = (SgAsmSingleFloatValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmSingleFloatValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37702 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDoubleFloatValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37715 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDoubleFloatValueExpressionStorageClass::pickOutIRNodeData ( SgAsmDoubleFloatValueExpression* pointer ) 
   { 
     SgAsmDoubleFloatValueExpression* source = (SgAsmDoubleFloatValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDoubleFloatValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37780 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmVectorValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37793 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmVectorValueExpressionStorageClass::pickOutIRNodeData ( SgAsmVectorValueExpression* pointer ) 
   { 
     SgAsmVectorValueExpression* source = (SgAsmVectorValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_size =  source->p_size ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmVectorValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmVectorValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmVectorValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmVectorValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37859 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37872 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryExpressionStorageClass::pickOutIRNodeData ( SgAsmBinaryExpression* pointer ) 
   { 
     SgAsmBinaryExpression* source = (SgAsmBinaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37934 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37947 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddStorageClass::pickOutIRNodeData ( SgAsmBinaryAdd* pointer ) 
   { 
     SgAsmBinaryAdd* source = (SgAsmBinaryAdd*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38009 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38022 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractStorageClass::pickOutIRNodeData ( SgAsmBinarySubtract* pointer ) 
   { 
     SgAsmBinarySubtract* source = (SgAsmBinarySubtract*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38084 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryMultiplyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38097 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryMultiplyStorageClass::pickOutIRNodeData ( SgAsmBinaryMultiply* pointer ) 
   { 
     SgAsmBinaryMultiply* source = (SgAsmBinaryMultiply*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryMultiplyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryMultiplyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryMultiplyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryMultiplyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38159 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDivideStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38172 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDivideStorageClass::pickOutIRNodeData ( SgAsmBinaryDivide* pointer ) 
   { 
     SgAsmBinaryDivide* source = (SgAsmBinaryDivide*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryDivideStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDivideStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDivideStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryDivideStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38234 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryModStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38247 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryModStorageClass::pickOutIRNodeData ( SgAsmBinaryMod* pointer ) 
   { 
     SgAsmBinaryMod* source = (SgAsmBinaryMod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryModStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryModStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryModStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryModStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddPreupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddPreupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryAddPreupdate* pointer ) 
   { 
     SgAsmBinaryAddPreupdate* source = (SgAsmBinaryAddPreupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddPreupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38384 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractPreupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38397 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractPreupdateStorageClass::pickOutIRNodeData ( SgAsmBinarySubtractPreupdate* pointer ) 
   { 
     SgAsmBinarySubtractPreupdate* source = (SgAsmBinarySubtractPreupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractPreupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38459 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddPostupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38472 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddPostupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryAddPostupdate* pointer ) 
   { 
     SgAsmBinaryAddPostupdate* source = (SgAsmBinaryAddPostupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddPostupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38534 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractPostupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38547 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractPostupdateStorageClass::pickOutIRNodeData ( SgAsmBinarySubtractPostupdate* pointer ) 
   { 
     SgAsmBinarySubtractPostupdate* source = (SgAsmBinarySubtractPostupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractPostupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38609 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLslStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38622 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLslStorageClass::pickOutIRNodeData ( SgAsmBinaryLsl* pointer ) 
   { 
     SgAsmBinaryLsl* source = (SgAsmBinaryLsl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryLslStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLslStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLslStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryLslStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38684 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38697 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLsrStorageClass::pickOutIRNodeData ( SgAsmBinaryLsr* pointer ) 
   { 
     SgAsmBinaryLsr* source = (SgAsmBinaryLsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryLsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryLsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38759 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38772 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAsrStorageClass::pickOutIRNodeData ( SgAsmBinaryAsr* pointer ) 
   { 
     SgAsmBinaryAsr* source = (SgAsmBinaryAsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38834 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryRorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38847 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryRorStorageClass::pickOutIRNodeData ( SgAsmBinaryRor* pointer ) 
   { 
     SgAsmBinaryRor* source = (SgAsmBinaryRor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryRorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryRorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryRorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryRorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38909 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38922 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryExpressionStorageClass::pickOutIRNodeData ( SgAsmUnaryExpression* pointer ) 
   { 
     SgAsmUnaryExpression* source = (SgAsmUnaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38983 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryPlusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38996 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryPlusStorageClass::pickOutIRNodeData ( SgAsmUnaryPlus* pointer ) 
   { 
     SgAsmUnaryPlus* source = (SgAsmUnaryPlus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryPlusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryPlusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryPlusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryPlusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39057 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryMinusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39070 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryMinusStorageClass::pickOutIRNodeData ( SgAsmUnaryMinus* pointer ) 
   { 
     SgAsmUnaryMinus* source = (SgAsmUnaryMinus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryMinusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryMinusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryMinusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryMinusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39131 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryRrxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39144 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryRrxStorageClass::pickOutIRNodeData ( SgAsmUnaryRrx* pointer ) 
   { 
     SgAsmUnaryRrx* source = (SgAsmUnaryRrx*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryRrxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryRrxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryRrxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryRrxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39205 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryArmSpecialRegisterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39218 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryArmSpecialRegisterListStorageClass::pickOutIRNodeData ( SgAsmUnaryArmSpecialRegisterList* pointer ) 
   { 
     SgAsmUnaryArmSpecialRegisterList* source = (SgAsmUnaryArmSpecialRegisterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryArmSpecialRegisterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39279 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmMemoryReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39292 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmMemoryReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmMemoryReferenceExpression* pointer ) 
   { 
     SgAsmMemoryReferenceExpression* source = (SgAsmMemoryReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_segment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmMemoryReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39355 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39368 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmRegisterReferenceExpression* pointer ) 
   { 
     SgAsmRegisterReferenceExpression* source = (SgAsmRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39430 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmx86RegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39443 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmx86RegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmx86RegisterReferenceExpression* pointer ) 
   { 
     SgAsmx86RegisterReferenceExpression* source = (SgAsmx86RegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmx86RegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39505 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmArmRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39518 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmArmRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmArmRegisterReferenceExpression* pointer ) 
   { 
     SgAsmArmRegisterReferenceExpression* source = (SgAsmArmRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_psr_mask =  source->p_psr_mask ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmArmRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39581 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPowerpcRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39594 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmPowerpcRegisterReferenceExpression* pointer ) 
   { 
     SgAsmPowerpcRegisterReferenceExpression* source = (SgAsmPowerpcRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39656 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmControlFlagsExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39669 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmControlFlagsExpressionStorageClass::pickOutIRNodeData ( SgAsmControlFlagsExpression* pointer ) 
   { 
     SgAsmControlFlagsExpression* source = (SgAsmControlFlagsExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bit_flags =  source->p_bit_flags ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmControlFlagsExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmControlFlagsExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39730 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCommonSubExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39743 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCommonSubExpressionStorageClass::pickOutIRNodeData ( SgAsmCommonSubExpression* pointer ) 
   { 
     SgAsmCommonSubExpression* source = (SgAsmCommonSubExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_subexpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subexpression );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCommonSubExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCommonSubExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCommonSubExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCommonSubExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39804 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39817 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExprListExpStorageClass::pickOutIRNodeData ( SgAsmExprListExp* pointer ) 
   { 
     SgAsmExprListExp* source = (SgAsmExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgAsmExpressionPtrList::value_type *  tempListexpressions = new SgAsmExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39899 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39912 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationStorageClass::pickOutIRNodeData ( SgAsmInterpretation* pointer ) 
   { 
     SgAsmInterpretation* source = (SgAsmInterpretation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_dwarf_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dwarf_info );
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_global_block = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_global_block );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInterpretationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInterpretationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInterpretationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInterpretationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39969 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOperandListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39982 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOperandListStorageClass::pickOutIRNodeData ( SgAsmOperandList* pointer ) 
   { 
     SgAsmOperandList* source = (SgAsmOperandList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgAsmExpressionPtrList::value_type *  tempListoperands = new SgAsmExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmOperandListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOperandListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmOperandListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmOperandListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40058 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40071 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeStorageClass::pickOutIRNodeData ( SgAsmType* pointer ) 
   { 
     SgAsmType* source = (SgAsmType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40125 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeByteStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40138 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeByteStorageClass::pickOutIRNodeData ( SgAsmTypeByte* pointer ) 
   { 
     SgAsmTypeByte* source = (SgAsmTypeByte*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeByteStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeByteStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeByteStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeByteStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40192 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40205 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeWordStorageClass::pickOutIRNodeData ( SgAsmTypeWord* pointer ) 
   { 
     SgAsmTypeWord* source = (SgAsmTypeWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40259 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40272 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleWordStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleWord* pointer ) 
   { 
     SgAsmTypeDoubleWord* source = (SgAsmTypeDoubleWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40326 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeQuadWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40339 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeQuadWordStorageClass::pickOutIRNodeData ( SgAsmTypeQuadWord* pointer ) 
   { 
     SgAsmTypeQuadWord* source = (SgAsmTypeQuadWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeQuadWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeQuadWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeQuadWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeQuadWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40393 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleQuadWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40406 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleQuadWordStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleQuadWord* pointer ) 
   { 
     SgAsmTypeDoubleQuadWord* source = (SgAsmTypeDoubleQuadWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleQuadWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40460 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmType80bitFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40473 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmType80bitFloatStorageClass::pickOutIRNodeData ( SgAsmType80bitFloat* pointer ) 
   { 
     SgAsmType80bitFloat* source = (SgAsmType80bitFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmType80bitFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmType80bitFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmType80bitFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmType80bitFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40527 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmType128bitFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40540 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmType128bitFloatStorageClass::pickOutIRNodeData ( SgAsmType128bitFloat* pointer ) 
   { 
     SgAsmType128bitFloat* source = (SgAsmType128bitFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmType128bitFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmType128bitFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmType128bitFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmType128bitFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40594 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeSingleFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40607 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeSingleFloatStorageClass::pickOutIRNodeData ( SgAsmTypeSingleFloat* pointer ) 
   { 
     SgAsmTypeSingleFloat* source = (SgAsmTypeSingleFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeSingleFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeSingleFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeSingleFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeSingleFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40661 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40674 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleFloatStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleFloat* pointer ) 
   { 
     SgAsmTypeDoubleFloat* source = (SgAsmTypeDoubleFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40728 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeVectorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40741 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeVectorStorageClass::pickOutIRNodeData ( SgAsmTypeVector* pointer ) 
   { 
     SgAsmTypeVector* source = (SgAsmTypeVector*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_elementCount =  source->p_elementCount ;
     storageOf_elementType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elementType );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeVectorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeVectorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeVectorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeVectorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40797 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExecutableFileFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40810 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExecutableFileFormatStorageClass::pickOutIRNodeData ( SgAsmExecutableFileFormat* pointer ) 
   { 
     SgAsmExecutableFileFormat* source = (SgAsmExecutableFileFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExecutableFileFormatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExecutableFileFormatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExecutableFileFormatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExecutableFileFormatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40864 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40877 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLStorageClass::pickOutIRNodeData ( SgAsmGenericDLL* pointer ) 
   { 
     SgAsmGenericDLL* source = (SgAsmGenericDLL*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericDLLStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40937 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40950 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFormatStorageClass::pickOutIRNodeData ( SgAsmGenericFormat* pointer ) 
   { 
     SgAsmGenericFormat* source = (SgAsmGenericFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_family =  source->p_family ;
     storageOf_purpose =  source->p_purpose ;
     storageOf_sex =  source->p_sex ;
     storageOf_version =  source->p_version ;
     storageOf_is_current_version =  source->p_is_current_version ;
     storageOf_abi =  source->p_abi ;
     storageOf_abi_version =  source->p_abi_version ;
     storageOf_word_size =  source->p_word_size ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFormatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFormatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFormatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFormatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41012 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41025 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLListStorageClass::pickOutIRNodeData ( SgAsmGenericDLLList* pointer ) 
   { 
     SgAsmGenericDLLList* source = (SgAsmGenericDLLList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericDLLPtrList::iterator i_dlls = source->p_dlls.begin() ; 
     unsigned int tempListCountdlls = 0; 
     SgAsmGenericDLLPtrList::value_type *  tempListdlls = new SgAsmGenericDLLPtrList::value_type[ source->p_dlls.size() ]; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          tempListdlls[tempListCountdlls] = *i_dlls;
          tempListCountdlls++; 
          (*i_dlls) = (SgAsmGenericDLLPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dlls ) );
        }
     storageOf_dlls.storeDataInEasyStorageClass(source->p_dlls);
     tempListCountdlls = 0; 
     i_dlls = source->p_dlls.begin() ; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          *i_dlls = tempListdlls[tempListCountdlls] ;
          tempListCountdlls++; 
        }
      delete [] tempListdlls; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericDLLListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericDLLPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericDLLPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41101 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41114 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFD* pointer ) 
   { 
     SgAsmElfEHFrameEntryFD* source = (SgAsmElfEHFrameEntryFD*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_begin_rva =  source->p_begin_rva ;
     storageOf_size =  source->p_size ;
     storageOf_augmentation_data.storeDataInEasyStorageClass(source->p_augmentation_data);
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41176 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41189 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileStorageClass::pickOutIRNodeData ( SgAsmGenericFile* pointer ) 
   { 
     SgAsmGenericFile* source = (SgAsmGenericFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fd =  source->p_fd ;
     storageOf_sb =  source->p_sb ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_holes = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_holes );
     storageOf_truncate_zeros =  source->p_truncate_zeros ;
     storageOf_tracking_references =  source->p_tracking_references ;
     storageOf_referenced_extents.storeDataInEasyStorageClass(source->p_referenced_extents);
     storageOf_neuter =  source->p_neuter ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41265 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41278 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionStorageClass::pickOutIRNodeData ( SgAsmGenericSection* pointer ) 
   { 
     SgAsmGenericSection* source = (SgAsmGenericSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41354 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41367 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderStorageClass::pickOutIRNodeData ( SgAsmGenericHeader* pointer ) 
   { 
     SgAsmGenericHeader* source = (SgAsmGenericHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41458 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41471 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmPEFileHeader* pointer ) 
   { 
     SgAsmPEFileHeader* source = (SgAsmPEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_time =  source->p_e_time ;
     storageOf_e_coff_symtab =  source->p_e_coff_symtab ;
     storageOf_e_nt_hdr_size =  source->p_e_nt_hdr_size ;
     storageOf_e_coff_nsyms =  source->p_e_coff_nsyms ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_opt_magic =  source->p_e_opt_magic ;
     storageOf_e_lmajor =  source->p_e_lmajor ;
     storageOf_e_lminor =  source->p_e_lminor ;
     storageOf_e_code_size =  source->p_e_code_size ;
     storageOf_e_data_size =  source->p_e_data_size ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_code_rva =  source->p_e_code_rva ;
     storageOf_e_data_rva =  source->p_e_data_rva ;
     storageOf_e_section_align =  source->p_e_section_align ;
     storageOf_e_file_align =  source->p_e_file_align ;
     storageOf_e_os_major =  source->p_e_os_major ;
     storageOf_e_os_minor =  source->p_e_os_minor ;
     storageOf_e_user_major =  source->p_e_user_major ;
     storageOf_e_user_minor =  source->p_e_user_minor ;
     storageOf_e_subsys_major =  source->p_e_subsys_major ;
     storageOf_e_subsys_minor =  source->p_e_subsys_minor ;
     storageOf_e_reserved9 =  source->p_e_reserved9 ;
     storageOf_e_image_size =  source->p_e_image_size ;
     storageOf_e_header_size =  source->p_e_header_size ;
     storageOf_e_file_checksum =  source->p_e_file_checksum ;
     storageOf_e_subsystem =  source->p_e_subsystem ;
     storageOf_e_dll_flags =  source->p_e_dll_flags ;
     storageOf_e_stack_reserve_size =  source->p_e_stack_reserve_size ;
     storageOf_e_stack_commit_size =  source->p_e_stack_commit_size ;
     storageOf_e_heap_reserve_size =  source->p_e_heap_reserve_size ;
     storageOf_e_heap_commit_size =  source->p_e_heap_commit_size ;
     storageOf_e_loader_flags =  source->p_e_loader_flags ;
     storageOf_e_num_rvasize_pairs =  source->p_e_num_rvasize_pairs ;
     storageOf_rvasize_pairs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvasize_pairs );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_coff_symtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_coff_symtab );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41600 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41613 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmLEFileHeader* pointer ) 
   { 
     SgAsmLEFileHeader* source = (SgAsmLEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_byte_order =  source->p_e_byte_order ;
     storageOf_e_word_order =  source->p_e_word_order ;
     storageOf_e_format_level =  source->p_e_format_level ;
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_os_type =  source->p_e_os_type ;
     storageOf_e_module_version =  source->p_e_module_version ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_eip_section =  source->p_e_eip_section ;
     storageOf_e_esp_section =  source->p_e_esp_section ;
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_page_offset_shift =  source->p_e_page_offset_shift ;
     storageOf_e_fixup_sect_cksum =  source->p_e_fixup_sect_cksum ;
     storageOf_e_loader_sect_cksum =  source->p_e_loader_sect_cksum ;
     storageOf_e_secttab_nentries =  source->p_e_secttab_nentries ;
     storageOf_e_rsrctab_nentries =  source->p_e_rsrctab_nentries ;
     storageOf_e_fmtdirtab_nentries =  source->p_e_fmtdirtab_nentries ;
     storageOf_e_import_modtab_nentries =  source->p_e_import_modtab_nentries ;
     storageOf_e_preload_npages =  source->p_e_preload_npages ;
     storageOf_e_nonresnametab_size =  source->p_e_nonresnametab_size ;
     storageOf_e_nonresnametab_cksum =  source->p_e_nonresnametab_cksum ;
     storageOf_e_auto_ds_section =  source->p_e_auto_ds_section ;
     storageOf_e_debug_info_size =  source->p_e_debug_info_size ;
     storageOf_e_num_instance_preload =  source->p_e_num_instance_preload ;
     storageOf_e_num_instance_demand =  source->p_e_num_instance_demand ;
     storageOf_e_heap_size =  source->p_e_heap_size ;
     storageOf_e_npages =  source->p_e_npages ;
     storageOf_e_eip =  source->p_e_eip ;
     storageOf_e_esp =  source->p_e_esp ;
     storageOf_e_page_size =  source->p_e_page_size ;
     storageOf_e_fixup_sect_size =  source->p_e_fixup_sect_size ;
     storageOf_e_loader_sect_size =  source->p_e_loader_sect_size ;
     storageOf_e_secttab_rfo =  source->p_e_secttab_rfo ;
     storageOf_e_pagetab_rfo =  source->p_e_pagetab_rfo ;
     storageOf_e_iterpages_offset =  source->p_e_iterpages_offset ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_fmtdirtab_rfo =  source->p_e_fmtdirtab_rfo ;
     storageOf_e_fixup_pagetab_rfo =  source->p_e_fixup_pagetab_rfo ;
     storageOf_e_fixup_rectab_rfo =  source->p_e_fixup_rectab_rfo ;
     storageOf_e_import_modtab_rfo =  source->p_e_import_modtab_rfo ;
     storageOf_e_import_proctab_rfo =  source->p_e_import_proctab_rfo ;
     storageOf_e_ppcksumtab_rfo =  source->p_e_ppcksumtab_rfo ;
     storageOf_e_data_pages_offset =  source->p_e_data_pages_offset ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_debug_info_rfo =  source->p_e_debug_info_rfo ;
     storageOf_dos2_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2_header );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_page_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_page_table );
     storageOf_resname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_resname_table );
     storageOf_nonresname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresname_table );
     storageOf_entry_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entry_table );
     storageOf_reloc_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reloc_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41757 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41770 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmNEFileHeader* pointer ) 
   { 
     SgAsmNEFileHeader* source = (SgAsmNEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_linker_major =  source->p_e_linker_major ;
     storageOf_e_linker_minor =  source->p_e_linker_minor ;
     storageOf_e_checksum =  source->p_e_checksum ;
     storageOf_e_flags1 =  source->p_e_flags1 ;
     storageOf_e_autodata_sn =  source->p_e_autodata_sn ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_stack_size =  source->p_e_stack_size ;
     storageOf_e_csip =  source->p_e_csip ;
     storageOf_e_sssp =  source->p_e_sssp ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_nmodrefs =  source->p_e_nmodrefs ;
     storageOf_e_nnonresnames =  source->p_e_nnonresnames ;
     storageOf_e_nmovable_entries =  source->p_e_nmovable_entries ;
     storageOf_e_sector_align =  source->p_e_sector_align ;
     storageOf_e_nresources =  source->p_e_nresources ;
     storageOf_e_exetype =  source->p_e_exetype ;
     storageOf_e_flags2 =  source->p_e_flags2 ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_winvers =  source->p_e_winvers ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_entrytab_size =  source->p_e_entrytab_size ;
     storageOf_e_sectab_rfo =  source->p_e_sectab_rfo ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_modreftab_rfo =  source->p_e_modreftab_rfo ;
     storageOf_e_importnametab_rfo =  source->p_e_importnametab_rfo ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_fastload_sector =  source->p_e_fastload_sector ;
     storageOf_e_fastload_nsectors =  source->p_e_fastload_nsectors ;
     storageOf_dos2_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2_header );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_resname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_resname_table );
     storageOf_nonresname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresname_table );
     storageOf_module_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_module_table );
     storageOf_entry_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entry_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41896 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41909 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSFileHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSFileHeader* pointer ) 
   { 
     SgAsmDOSFileHeader* source = (SgAsmDOSFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_total_pages =  source->p_e_total_pages ;
     storageOf_e_nrelocs =  source->p_e_nrelocs ;
     storageOf_e_header_paragraphs =  source->p_e_header_paragraphs ;
     storageOf_e_minalloc =  source->p_e_minalloc ;
     storageOf_e_maxalloc =  source->p_e_maxalloc ;
     storageOf_e_ss =  source->p_e_ss ;
     storageOf_e_sp =  source->p_e_sp ;
     storageOf_e_cksum =  source->p_e_cksum ;
     storageOf_e_ip =  source->p_e_ip ;
     storageOf_e_cs =  source->p_e_cs ;
     storageOf_e_overlay =  source->p_e_overlay ;
     storageOf_e_relocs_offset =  source->p_e_relocs_offset ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_relocs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_relocs );
     storageOf_rm_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rm_section );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDOSFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDOSFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDOSFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42016 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42029 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfFileHeaderStorageClass::pickOutIRNodeData ( SgAsmElfFileHeader* pointer ) 
   { 
     SgAsmElfFileHeader* source = (SgAsmElfFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_ident_file_class =  source->p_e_ident_file_class ;
     storageOf_e_ident_data_encoding =  source->p_e_ident_data_encoding ;
     storageOf_e_ident_file_version =  source->p_e_ident_file_version ;
     storageOf_e_ident_padding.storeDataInEasyStorageClass(source->p_e_ident_padding);
     storageOf_e_type =  source->p_e_type ;
     storageOf_e_machine =  source->p_e_machine ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_ehsize =  source->p_e_ehsize ;
     storageOf_phextrasz =  source->p_phextrasz ;
     storageOf_e_phnum =  source->p_e_phnum ;
     storageOf_shextrasz =  source->p_shextrasz ;
     storageOf_e_shnum =  source->p_e_shnum ;
     storageOf_e_shstrndx =  source->p_e_shstrndx ;
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_segment_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42139 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42152 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionStorageClass::pickOutIRNodeData ( SgAsmElfSection* pointer ) 
   { 
     SgAsmElfSection* source = (SgAsmElfSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42231 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42244 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymbolSection* pointer ) 
   { 
     SgAsmElfSymbolSection* source = (SgAsmElfSymbolSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_is_dynamic =  source->p_is_dynamic ;
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42325 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42338 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocSectionStorageClass::pickOutIRNodeData ( SgAsmElfRelocSection* pointer ) 
   { 
     SgAsmElfRelocSection* source = (SgAsmElfRelocSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_uses_addend =  source->p_uses_addend ;
     storageOf_target_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_target_section );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42420 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42433 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicSectionStorageClass::pickOutIRNodeData ( SgAsmElfDynamicSection* pointer ) 
   { 
     SgAsmElfDynamicSection* source = (SgAsmElfDynamicSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42513 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42526 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStringSectionStorageClass::pickOutIRNodeData ( SgAsmElfStringSection* pointer ) 
   { 
     SgAsmElfStringSection* source = (SgAsmElfStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42606 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42619 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteSectionStorageClass::pickOutIRNodeData ( SgAsmElfNoteSection* pointer ) 
   { 
     SgAsmElfNoteSection* source = (SgAsmElfNoteSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42699 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42712 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameSectionStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameSection* pointer ) 
   { 
     SgAsmElfEHFrameSection* source = (SgAsmElfEHFrameSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_ci_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ci_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42792 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42805 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverSection* pointer ) 
   { 
     SgAsmElfSymverSection* source = (SgAsmElfSymverSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42885 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42898 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedSection* pointer ) 
   { 
     SgAsmElfSymverDefinedSection* source = (SgAsmElfSymverDefinedSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42978 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42991 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededSection* pointer ) 
   { 
     SgAsmElfSymverNeededSection* source = (SgAsmElfSymverNeededSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43071 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43084 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableStorageClass::pickOutIRNodeData ( SgAsmElfSectionTable* pointer ) 
   { 
     SgAsmElfSectionTable* source = (SgAsmElfSectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43160 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43173 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTable* pointer ) 
   { 
     SgAsmElfSegmentTable* source = (SgAsmElfSegmentTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43249 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43262 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionStorageClass::pickOutIRNodeData ( SgAsmPESection* pointer ) 
   { 
     SgAsmPESection* source = (SgAsmPESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43339 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43352 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportSectionStorageClass::pickOutIRNodeData ( SgAsmPEImportSection* pointer ) 
   { 
     SgAsmPEImportSection* source = (SgAsmPEImportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_import_directories = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_import_directories );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43430 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43443 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportSectionStorageClass::pickOutIRNodeData ( SgAsmPEExportSection* pointer ) 
   { 
     SgAsmPEExportSection* source = (SgAsmPEExportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_export_dir = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_export_dir );
     storageOf_exports = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exports );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43522 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43535 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEStringSectionStorageClass::pickOutIRNodeData ( SgAsmPEStringSection* pointer ) 
   { 
     SgAsmPEStringSection* source = (SgAsmPEStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43613 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43626 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableStorageClass::pickOutIRNodeData ( SgAsmPESectionTable* pointer ) 
   { 
     SgAsmPESectionTable* source = (SgAsmPESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43702 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSExtendedHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43715 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSExtendedHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSExtendedHeader* pointer ) 
   { 
     SgAsmDOSExtendedHeader* source = (SgAsmDOSExtendedHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_oemid =  source->p_e_oemid ;
     storageOf_e_oeminfo =  source->p_e_oeminfo ;
     storageOf_e_res2 =  source->p_e_res2 ;
     storageOf_e_res3 =  source->p_e_res3 ;
     storageOf_e_res4 =  source->p_e_res4 ;
     storageOf_e_res5 =  source->p_e_res5 ;
     storageOf_e_res6 =  source->p_e_res6 ;
     storageOf_e_lfanew =  source->p_e_lfanew ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDOSExtendedHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43800 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43813 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolTableStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolTable* pointer ) 
   { 
     SgAsmCoffSymbolTable* source = (SgAsmCoffSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43891 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43904 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionStorageClass::pickOutIRNodeData ( SgAsmNESection* pointer ) 
   { 
     SgAsmNESection* source = (SgAsmNESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_st_entry );
     storageOf_reloc_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reloc_table );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43982 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43995 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableStorageClass::pickOutIRNodeData ( SgAsmNESectionTable* pointer ) 
   { 
     SgAsmNESectionTable* source = (SgAsmNESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44075 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44088 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNENameTableStorageClass::pickOutIRNodeData ( SgAsmNENameTable* pointer ) 
   { 
     SgAsmNENameTable* source = (SgAsmNENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44174 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEModuleTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44187 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEModuleTableStorageClass::pickOutIRNodeData ( SgAsmNEModuleTable* pointer ) 
   { 
     SgAsmNEModuleTable* source = (SgAsmNEModuleTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_name_offsets.storeDataInEasyStorageClass(source->p_name_offsets);
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEModuleTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAddressList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEModuleTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAddressList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEModuleTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAddressList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEModuleTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAddressList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44274 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEStringTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44287 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEStringTableStorageClass::pickOutIRNodeData ( SgAsmNEStringTable* pointer ) 
   { 
     SgAsmNEStringTable* source = (SgAsmNEStringTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEStringTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEStringTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEStringTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEStringTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44363 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44376 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryTableStorageClass::pickOutIRNodeData ( SgAsmNEEntryTable* pointer ) 
   { 
     SgAsmNEEntryTable* source = (SgAsmNEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmNEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNEEntryPointPtrList::value_type *  tempListentries = new SgAsmNEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44479 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44492 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocTableStorageClass::pickOutIRNodeData ( SgAsmNERelocTable* pointer ) 
   { 
     SgAsmNERelocTable* source = (SgAsmNERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmNERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNERelocEntryPtrList::value_type *  tempListentries = new SgAsmNERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmNERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44590 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44603 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionStorageClass::pickOutIRNodeData ( SgAsmLESection* pointer ) 
   { 
     SgAsmLESection* source = (SgAsmLESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_st_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44680 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44693 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableStorageClass::pickOutIRNodeData ( SgAsmLESectionTable* pointer ) 
   { 
     SgAsmLESectionTable* source = (SgAsmLESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44769 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44782 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLENameTableStorageClass::pickOutIRNodeData ( SgAsmLENameTable* pointer ) 
   { 
     SgAsmLENameTable* source = (SgAsmLENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44868 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44881 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableStorageClass::pickOutIRNodeData ( SgAsmLEPageTable* pointer ) 
   { 
     SgAsmLEPageTable* source = (SgAsmLEPageTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLEPageTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEPageTableEntryPtrList::value_type *  tempListentries = new SgAsmLEPageTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEPageTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEPageTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEPageTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEPageTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEPageTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44979 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44992 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryTableStorageClass::pickOutIRNodeData ( SgAsmLEEntryTable* pointer ) 
   { 
     SgAsmLEEntryTable* source = (SgAsmLEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45095 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45108 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLERelocTableStorageClass::pickOutIRNodeData ( SgAsmLERelocTable* pointer ) 
   { 
     SgAsmLERelocTable* source = (SgAsmLERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLERelocEntryPtrList::value_type *  tempListentries = new SgAsmLERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45206 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45219 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolStorageClass::pickOutIRNodeData ( SgAsmGenericSymbol* pointer ) 
   { 
     SgAsmGenericSymbol* source = (SgAsmGenericSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45280 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45293 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolStorageClass::pickOutIRNodeData ( SgAsmCoffSymbol* pointer ) 
   { 
     SgAsmCoffSymbol* source = (SgAsmCoffSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_name.storeDataInEasyStorageClass(source->p_st_name);
     storageOf_st_name_offset =  source->p_st_name_offset ;
     storageOf_st_section_num =  source->p_st_section_num ;
     storageOf_st_type =  source->p_st_type ;
     storageOf_st_storage_class =  source->p_st_storage_class ;
     storageOf_st_num_aux_entries =  source->p_st_num_aux_entries ;
     storageOf_aux_data.storeDataInEasyStorageClass(source->p_aux_data);
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45369 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45382 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolStorageClass::pickOutIRNodeData ( SgAsmElfSymbol* pointer ) 
   { 
     SgAsmElfSymbol* source = (SgAsmElfSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_info =  source->p_st_info ;
     storageOf_st_res1 =  source->p_st_res1 ;
     storageOf_st_shndx =  source->p_st_shndx ;
     storageOf_st_size =  source->p_st_size ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45452 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45465 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStrtabStorageClass::pickOutIRNodeData ( SgAsmGenericStrtab* pointer ) 
   { 
     SgAsmGenericStrtab* source = (SgAsmGenericStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45549 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45562 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStrtabStorageClass::pickOutIRNodeData ( SgAsmElfStrtab* pointer ) 
   { 
     SgAsmElfStrtab* source = (SgAsmElfStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45646 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45659 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffStrtabStorageClass::pickOutIRNodeData ( SgAsmCoffStrtab* pointer ) 
   { 
     SgAsmCoffStrtab* source = (SgAsmCoffStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45743 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45756 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolListStorageClass::pickOutIRNodeData ( SgAsmGenericSymbolList* pointer ) 
   { 
     SgAsmGenericSymbolList* source = (SgAsmGenericSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmGenericSymbolPtrList::value_type *  tempListsymbols = new SgAsmGenericSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmGenericSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45832 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45845 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionListStorageClass::pickOutIRNodeData ( SgAsmGenericSectionList* pointer ) 
   { 
     SgAsmGenericSectionList* source = (SgAsmGenericSectionList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericSectionPtrList::iterator i_sections = source->p_sections.begin() ; 
     unsigned int tempListCountsections = 0; 
     SgAsmGenericSectionPtrList::value_type *  tempListsections = new SgAsmGenericSectionPtrList::value_type[ source->p_sections.size() ]; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          tempListsections[tempListCountsections] = *i_sections;
          tempListCountsections++; 
          (*i_sections) = (SgAsmGenericSectionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sections ) );
        }
     storageOf_sections.storeDataInEasyStorageClass(source->p_sections);
     tempListCountsections = 0; 
     i_sections = source->p_sections.begin() ; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          *i_sections = tempListsections[tempListCountsections] ;
          tempListCountsections++; 
        }
      delete [] tempListsections; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSectionListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSectionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSectionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45921 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45934 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderListStorageClass::pickOutIRNodeData ( SgAsmGenericHeaderList* pointer ) 
   { 
     SgAsmGenericHeaderList* source = (SgAsmGenericHeaderList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericHeaderPtrList::iterator i_headers = source->p_headers.begin() ; 
     unsigned int tempListCountheaders = 0; 
     SgAsmGenericHeaderPtrList::value_type *  tempListheaders = new SgAsmGenericHeaderPtrList::value_type[ source->p_headers.size() ]; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          tempListheaders[tempListCountheaders] = *i_headers;
          tempListCountheaders++; 
          (*i_headers) = (SgAsmGenericHeaderPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_headers ) );
        }
     storageOf_headers.storeDataInEasyStorageClass(source->p_headers);
     tempListCountheaders = 0; 
     i_headers = source->p_headers.begin() ; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          *i_headers = tempListheaders[tempListCountheaders] ;
          tempListCountheaders++; 
        }
      delete [] tempListheaders; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericHeaderListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericHeaderPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46010 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46023 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStringStorageClass::pickOutIRNodeData ( SgAsmGenericString* pointer ) 
   { 
     SgAsmGenericString* source = (SgAsmGenericString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46077 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBasicStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46090 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBasicStringStorageClass::pickOutIRNodeData ( SgAsmBasicString* pointer ) 
   { 
     SgAsmBasicString* source = (SgAsmBasicString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBasicStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBasicStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBasicStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBasicStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46149 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStoredStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46162 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStoredStringStorageClass::pickOutIRNodeData ( SgAsmStoredString* pointer ) 
   { 
     SgAsmStoredString* source = (SgAsmStoredString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_storage = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storage );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStoredStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStoredStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStoredStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStoredStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46217 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46230 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSectionTableEntry* pointer ) 
   { 
     SgAsmElfSectionTableEntry* source = (SgAsmElfSectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_sh_name =  source->p_sh_name ;
     storageOf_sh_type =  source->p_sh_type ;
     storageOf_sh_link =  source->p_sh_link ;
     storageOf_sh_info =  source->p_sh_info ;
     storageOf_sh_flags =  source->p_sh_flags ;
     storageOf_sh_addr =  source->p_sh_addr ;
     storageOf_sh_offset =  source->p_sh_offset ;
     storageOf_sh_size =  source->p_sh_size ;
     storageOf_sh_addralign =  source->p_sh_addralign ;
     storageOf_sh_entsize =  source->p_sh_entsize ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46299 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46312 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntry* pointer ) 
   { 
     SgAsmElfSegmentTableEntry* source = (SgAsmElfSegmentTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_index =  source->p_index ;
     storageOf_type =  source->p_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_offset =  source->p_offset ;
     storageOf_vaddr =  source->p_vaddr ;
     storageOf_paddr =  source->p_paddr ;
     storageOf_filesz =  source->p_filesz ;
     storageOf_memsz =  source->p_memsz ;
     storageOf_align =  source->p_align ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46380 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46393 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolListStorageClass::pickOutIRNodeData ( SgAsmElfSymbolList* pointer ) 
   { 
     SgAsmElfSymbolList* source = (SgAsmElfSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmElfSymbolPtrList::value_type *  tempListsymbols = new SgAsmElfSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmElfSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46469 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportILTEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46482 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportILTEntryStorageClass::pickOutIRNodeData ( SgAsmPEImportILTEntry* pointer ) 
   { 
     SgAsmPEImportILTEntry* source = (SgAsmPEImportILTEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entry_type =  source->p_entry_type ;
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_hnt_entry_rva =  source->p_hnt_entry_rva ;
     storageOf_hnt_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_hnt_entry );
     storageOf_bound_rva =  source->p_bound_rva ;
     storageOf_extra_bits =  source->p_extra_bits ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportILTEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportILTEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportILTEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportILTEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46542 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46555 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntry* pointer ) 
   { 
     SgAsmElfRelocEntry* source = (SgAsmElfRelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_r_offset =  source->p_r_offset ;
     storageOf_r_addend =  source->p_r_addend ;
     storageOf_sym =  source->p_sym ;
     storageOf_type =  source->p_type ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46618 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46631 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryListStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntryList* pointer ) 
   { 
     SgAsmElfRelocEntryList* source = (SgAsmElfRelocEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfRelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfRelocEntryPtrList::value_type *  tempListentries = new SgAsmElfRelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfRelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfRelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46707 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46720 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryStorageClass::pickOutIRNodeData ( SgAsmPEExportEntry* pointer ) 
   { 
     SgAsmPEExportEntry* source = (SgAsmPEExportEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_export_rva =  source->p_export_rva ;
     storageOf_forwarder = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forwarder );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46778 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46791 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryListStorageClass::pickOutIRNodeData ( SgAsmPEExportEntryList* pointer ) 
   { 
     SgAsmPEExportEntryList* source = (SgAsmPEExportEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEExportEntryPtrList::iterator i_exports = source->p_exports.begin() ; 
     unsigned int tempListCountexports = 0; 
     SgAsmPEExportEntryPtrList::value_type *  tempListexports = new SgAsmPEExportEntryPtrList::value_type[ source->p_exports.size() ]; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          tempListexports[tempListCountexports] = *i_exports;
          tempListCountexports++; 
          (*i_exports) = (SgAsmPEExportEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exports ) );
        }
     storageOf_exports.storeDataInEasyStorageClass(source->p_exports);
     tempListCountexports = 0; 
     i_exports = source->p_exports.begin() ; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          *i_exports = tempListexports[tempListCountexports] ;
          tempListCountexports++; 
        }
      delete [] tempListexports; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEExportEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46867 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46880 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntry* pointer ) 
   { 
     SgAsmElfDynamicEntry* source = (SgAsmElfDynamicEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_d_tag =  source->p_d_tag ;
     storageOf_d_val =  source->p_d_val ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46942 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46955 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryListStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntryList* pointer ) 
   { 
     SgAsmElfDynamicEntryList* source = (SgAsmElfDynamicEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfDynamicEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfDynamicEntryPtrList::value_type *  tempListentries = new SgAsmElfDynamicEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfDynamicEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47031 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47044 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntryList* pointer ) 
   { 
     SgAsmElfSegmentTableEntryList* source = (SgAsmElfSegmentTableEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSegmentTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSegmentTableEntryPtrList::value_type *  tempListentries = new SgAsmElfSegmentTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSegmentTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47120 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStringStorageStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47133 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStringStorageStorageClass::pickOutIRNodeData ( SgAsmStringStorage* pointer ) 
   { 
     SgAsmStringStorage* source = (SgAsmStringStorage*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_offset =  source->p_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStringStorageStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStringStorageStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStringStorageStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStringStorageStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47194 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47207 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntry* pointer ) 
   { 
     SgAsmElfNoteEntry* source = (SgAsmElfNoteEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type =  source->p_type ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_payload.storeDataInEasyStorageClass(source->p_payload);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47268 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47281 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryListStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntryList* pointer ) 
   { 
     SgAsmElfNoteEntryList* source = (SgAsmElfNoteEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfNoteEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfNoteEntryPtrList::value_type *  tempListentries = new SgAsmElfNoteEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfNoteEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfNoteEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47357 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47370 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntry* pointer ) 
   { 
     SgAsmElfSymverEntry* source = (SgAsmElfSymverEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47425 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47438 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntryList* pointer ) 
   { 
     SgAsmElfSymverEntryList* source = (SgAsmElfSymverEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47514 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47527 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntry* pointer ) 
   { 
     SgAsmElfSymverDefinedEntry* source = (SgAsmElfSymverDefinedEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_flags =  source->p_flags ;
     storageOf_index =  source->p_index ;
     storageOf_hash =  source->p_hash ;
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47586 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47599 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntryList* pointer ) 
   { 
     SgAsmElfSymverDefinedEntryList* source = (SgAsmElfSymverDefinedEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverDefinedEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47675 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47688 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAux* pointer ) 
   { 
     SgAsmElfSymverDefinedAux* source = (SgAsmElfSymverDefinedAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedAuxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47743 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47756 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAuxList* pointer ) 
   { 
     SgAsmElfSymverDefinedAuxList* source = (SgAsmElfSymverDefinedAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverDefinedAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47832 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47845 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntry* pointer ) 
   { 
     SgAsmElfSymverNeededEntry* source = (SgAsmElfSymverNeededEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_file_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file_name );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47902 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47915 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntryList* pointer ) 
   { 
     SgAsmElfSymverNeededEntryList* source = (SgAsmElfSymverNeededEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverNeededEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47991 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48004 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAux* pointer ) 
   { 
     SgAsmElfSymverNeededAux* source = (SgAsmElfSymverNeededAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_hash =  source->p_hash ;
     storageOf_flags =  source->p_flags ;
     storageOf_other =  source->p_other ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededAuxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48062 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48075 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAuxList* pointer ) 
   { 
     SgAsmElfSymverNeededAuxList* source = (SgAsmElfSymverNeededAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverNeededAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48151 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48164 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectory* pointer ) 
   { 
     SgAsmPEImportDirectory* source = (SgAsmPEImportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_ilt_rva =  source->p_ilt_rva ;
     storageOf_ilt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ilt );
     storageOf_time =  source->p_time ;
     storageOf_forwarder_chain =  source->p_forwarder_chain ;
     storageOf_dll_name_rva =  source->p_dll_name_rva ;
     storageOf_dll_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dll_name );
     storageOf_iat_rva =  source->p_iat_rva ;
     storageOf_iat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iat );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48226 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportHNTEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48239 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportHNTEntryStorageClass::pickOutIRNodeData ( SgAsmPEImportHNTEntry* pointer ) 
   { 
     SgAsmPEImportHNTEntry* source = (SgAsmPEImportHNTEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_hint =  source->p_hint ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_padding =  source->p_padding ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportHNTEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportHNTEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportHNTEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportHNTEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48296 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48309 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmPESectionTableEntry* pointer ) 
   { 
     SgAsmPESectionTableEntry* source = (SgAsmPESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_rva =  source->p_rva ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_physical_offset =  source->p_physical_offset ;
     storageOf_coff_line_nums =  source->p_coff_line_nums ;
     storageOf_n_relocs =  source->p_n_relocs ;
     storageOf_n_coff_line_nums =  source->p_n_coff_line_nums ;
     storageOf_flags =  source->p_flags ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48376 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48389 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEExportDirectory* pointer ) 
   { 
     SgAsmPEExportDirectory* source = (SgAsmPEExportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_res1 =  source->p_res1 ;
     storageOf_timestamp =  source->p_timestamp ;
     storageOf_vmajor =  source->p_vmajor ;
     storageOf_vminor =  source->p_vminor ;
     storageOf_name_rva =  source->p_name_rva ;
     storageOf_ord_base =  source->p_ord_base ;
     storageOf_expaddr_n =  source->p_expaddr_n ;
     storageOf_nameptr_n =  source->p_nameptr_n ;
     storageOf_expaddr_rva =  source->p_expaddr_rva ;
     storageOf_nameptr_rva =  source->p_nameptr_rva ;
     storageOf_ordinals_rva =  source->p_ordinals_rva ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48455 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48468 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairStorageClass::pickOutIRNodeData ( SgAsmPERVASizePair* pointer ) 
   { 
     SgAsmPERVASizePair* source = (SgAsmPERVASizePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_rva =  source->p_e_rva ;
     storageOf_e_size =  source->p_e_size ;
     storageOf_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPERVASizePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPERVASizePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPERVASizePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPERVASizePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48525 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48538 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolListStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolList* pointer ) 
   { 
     SgAsmCoffSymbolList* source = (SgAsmCoffSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmCoffSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmCoffSymbolPtrList::value_type *  tempListsymbols = new SgAsmCoffSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmCoffSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmCoffSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48614 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48627 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairListStorageClass::pickOutIRNodeData ( SgAsmPERVASizePairList* pointer ) 
   { 
     SgAsmPERVASizePairList* source = (SgAsmPERVASizePairList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPERVASizePairPtrList::iterator i_pairs = source->p_pairs.begin() ; 
     unsigned int tempListCountpairs = 0; 
     SgAsmPERVASizePairPtrList::value_type *  tempListpairs = new SgAsmPERVASizePairPtrList::value_type[ source->p_pairs.size() ]; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          tempListpairs[tempListCountpairs] = *i_pairs;
          tempListCountpairs++; 
          (*i_pairs) = (SgAsmPERVASizePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_pairs ) );
        }
     storageOf_pairs.storeDataInEasyStorageClass(source->p_pairs);
     tempListCountpairs = 0; 
     i_pairs = source->p_pairs.begin() ; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          *i_pairs = tempListpairs[tempListCountpairs] ;
          tempListCountpairs++; 
        }
      delete [] tempListpairs; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPERVASizePairListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPERVASizePairListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPERVASizePairListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPERVASizePairPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPERVASizePairListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48703 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48716 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCI* pointer ) 
   { 
     SgAsmElfEHFrameEntryCI* source = (SgAsmElfEHFrameEntryCI*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_augmentation_string.storeDataInEasyStorageClass(source->p_augmentation_string);
     storageOf_code_alignment_factor =  source->p_code_alignment_factor ;
     storageOf_data_alignment_factor =  source->p_data_alignment_factor ;
     storageOf_augmentation_data_length =  source->p_augmentation_data_length ;
     storageOf_lsda_encoding =  source->p_lsda_encoding ;
     storageOf_prh_encoding =  source->p_prh_encoding ;
     storageOf_prh_arg =  source->p_prh_arg ;
     storageOf_prh_addr =  source->p_prh_addr ;
     storageOf_addr_encoding =  source->p_addr_encoding ;
     storageOf_sig_frame =  source->p_sig_frame ;
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_fd_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fd_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48791 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportHNTEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48804 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportHNTEntryListStorageClass::pickOutIRNodeData ( SgAsmPEImportHNTEntryList* pointer ) 
   { 
     SgAsmPEImportHNTEntryList* source = (SgAsmPEImportHNTEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEImportHNTEntryPtrList::iterator i_hintnames = source->p_hintnames.begin() ; 
     unsigned int tempListCounthintnames = 0; 
     SgAsmPEImportHNTEntryPtrList::value_type *  tempListhintnames = new SgAsmPEImportHNTEntryPtrList::value_type[ source->p_hintnames.size() ]; 
     for ( ; i_hintnames != source->p_hintnames.end(); ++i_hintnames ) 
        {
          tempListhintnames[tempListCounthintnames] = *i_hintnames;
          tempListCounthintnames++; 
          (*i_hintnames) = (SgAsmPEImportHNTEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_hintnames ) );
        }
     storageOf_hintnames.storeDataInEasyStorageClass(source->p_hintnames);
     tempListCounthintnames = 0; 
     i_hintnames = source->p_hintnames.begin() ; 
     for ( ; i_hintnames != source->p_hintnames.end(); ++i_hintnames ) 
        {
          *i_hintnames = tempListhintnames[tempListCounthintnames] ;
          tempListCounthintnames++; 
        }
      delete [] tempListhintnames; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportHNTEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportHNTEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportHNTEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportHNTEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportHNTEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportHNTEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportHNTEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportHNTEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48880 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportILTEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48893 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportILTEntryListStorageClass::pickOutIRNodeData ( SgAsmPEImportILTEntryList* pointer ) 
   { 
     SgAsmPEImportILTEntryList* source = (SgAsmPEImportILTEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEImportILTEntryPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportILTEntryPtrList::value_type *  tempListvector = new SgAsmPEImportILTEntryPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportILTEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportILTEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportILTEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportILTEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportILTEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportILTEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportILTEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportILTEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportILTEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48969 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportLookupTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48982 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportLookupTableStorageClass::pickOutIRNodeData ( SgAsmPEImportLookupTable* pointer ) 
   { 
     SgAsmPEImportLookupTable* source = (SgAsmPEImportLookupTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_table_kind =  source->p_table_kind ;
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportLookupTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportLookupTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportLookupTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportLookupTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49038 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49051 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryListStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectoryList* pointer ) 
   { 
     SgAsmPEImportDirectoryList* source = (SgAsmPEImportDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEImportDirectoryPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportDirectoryPtrList::value_type *  tempListvector = new SgAsmPEImportDirectoryPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49127 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49140 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryPointStorageClass::pickOutIRNodeData ( SgAsmNEEntryPoint* pointer ) 
   { 
     SgAsmNEEntryPoint* source = (SgAsmNEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_int3f =  source->p_int3f ;
     storageOf_section_idx =  source->p_section_idx ;
     storageOf_section_offset =  source->p_section_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49198 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49211 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocEntryStorageClass::pickOutIRNodeData ( SgAsmNERelocEntry* pointer ) 
   { 
     SgAsmNERelocEntry* source = (SgAsmNERelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_src_type =  source->p_src_type ;
     storageOf_modifier =  source->p_modifier ;
     storageOf_tgt_type =  source->p_tgt_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_src_offset =  source->p_src_offset ;
     storageOf_iref =  source->p_iref ;
     storageOf_iord =  source->p_iord ;
     storageOf_iname =  source->p_iname ;
     storageOf_osfixup =  source->p_osfixup ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNERelocEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNERelocEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNERelocEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNERelocEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49274 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49287 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmNESectionTableEntry* pointer ) 
   { 
     SgAsmNESectionTableEntry* source = (SgAsmNESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49345 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49358 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCIList* pointer ) 
   { 
     SgAsmElfEHFrameEntryCIList* source = (SgAsmElfEHFrameEntryCIList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfEHFrameEntryCIPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryCIPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryCIPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryCIPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49434 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49447 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableEntryStorageClass::pickOutIRNodeData ( SgAsmLEPageTableEntry* pointer ) 
   { 
     SgAsmLEPageTableEntry* source = (SgAsmLEPageTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pageno =  source->p_pageno ;
     storageOf_flags =  source->p_flags ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEPageTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEPageTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEPageTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEPageTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49503 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49516 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryPointStorageClass::pickOutIRNodeData ( SgAsmLEEntryPoint* pointer ) 
   { 
     SgAsmLEEntryPoint* source = (SgAsmLEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_flags =  source->p_flags ;
     storageOf_objnum =  source->p_objnum ;
     storageOf_entry_type =  source->p_entry_type ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_entry_offset =  source->p_entry_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49597 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49610 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmLESectionTableEntry* pointer ) 
   { 
     SgAsmLESectionTableEntry* source = (SgAsmLESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_pagemap_index =  source->p_pagemap_index ;
     storageOf_pagemap_nentries =  source->p_pagemap_nentries ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_base_addr =  source->p_base_addr ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49670 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49683 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFDList* pointer ) 
   { 
     SgAsmElfEHFrameEntryFDList* source = (SgAsmElfEHFrameEntryFDList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfEHFrameEntryFDPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryFDPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryFDPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryFDPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49759 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInformationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49772 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInformationStorageClass::pickOutIRNodeData ( SgAsmDwarfInformation* pointer ) 
   { 
     SgAsmDwarfInformation* source = (SgAsmDwarfInformation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInformationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInformationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInformationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInformationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49826 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49839 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroStorageClass::pickOutIRNodeData ( SgAsmDwarfMacro* pointer ) 
   { 
     SgAsmDwarfMacro* source = (SgAsmDwarfMacro*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_macro_string.storeDataInEasyStorageClass(source->p_macro_string);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMacroStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49898 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49911 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroListStorageClass::pickOutIRNodeData ( SgAsmDwarfMacroList* pointer ) 
   { 
     SgAsmDwarfMacroList* source = (SgAsmDwarfMacroList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfMacroPtrList::iterator i_macro_list = source->p_macro_list.begin() ; 
     unsigned int tempListCountmacro_list = 0; 
     SgAsmDwarfMacroPtrList::value_type *  tempListmacro_list = new SgAsmDwarfMacroPtrList::value_type[ source->p_macro_list.size() ]; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          tempListmacro_list[tempListCountmacro_list] = *i_macro_list;
          tempListCountmacro_list++; 
          (*i_macro_list) = (SgAsmDwarfMacroPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_macro_list ) );
        }
     storageOf_macro_list.storeDataInEasyStorageClass(source->p_macro_list);
     tempListCountmacro_list = 0; 
     i_macro_list = source->p_macro_list.begin() ; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          *i_macro_list = tempListmacro_list[tempListCountmacro_list] ;
          tempListCountmacro_list++; 
        }
      delete [] tempListmacro_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMacroListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfMacroPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49987 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50000 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineStorageClass::pickOutIRNodeData ( SgAsmDwarfLine* pointer ) 
   { 
     SgAsmDwarfLine* source = (SgAsmDwarfLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_column =  source->p_column ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50058 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50071 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineListStorageClass::pickOutIRNodeData ( SgAsmDwarfLineList* pointer ) 
   { 
     SgAsmDwarfLineList* source = (SgAsmDwarfLineList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfLinePtrList::iterator i_line_list = source->p_line_list.begin() ; 
     unsigned int tempListCountline_list = 0; 
     SgAsmDwarfLinePtrList::value_type *  tempListline_list = new SgAsmDwarfLinePtrList::value_type[ source->p_line_list.size() ]; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          tempListline_list[tempListCountline_list] = *i_line_list;
          tempListCountline_list++; 
          (*i_line_list) = (SgAsmDwarfLinePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_line_list ) );
        }
     storageOf_line_list.storeDataInEasyStorageClass(source->p_line_list);
     tempListCountline_list = 0; 
     i_line_list = source->p_line_list.begin() ; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          *i_line_list = tempListline_list[tempListCountline_list] ;
          tempListCountline_list++; 
        }
      delete [] tempListline_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLineListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLineListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLineListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfLinePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLineListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfLinePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50147 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50160 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitListStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnitList* pointer ) 
   { 
     SgAsmDwarfCompilationUnitList* source = (SgAsmDwarfCompilationUnitList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfCompilationUnitPtrList::iterator i_cu_list = source->p_cu_list.begin() ; 
     unsigned int tempListCountcu_list = 0; 
     SgAsmDwarfCompilationUnitPtrList::value_type *  tempListcu_list = new SgAsmDwarfCompilationUnitPtrList::value_type[ source->p_cu_list.size() ]; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          tempListcu_list[tempListCountcu_list] = *i_cu_list;
          tempListCountcu_list++; 
          (*i_cu_list) = (SgAsmDwarfCompilationUnitPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_cu_list ) );
        }
     storageOf_cu_list.storeDataInEasyStorageClass(source->p_cu_list);
     tempListCountcu_list = 0; 
     i_cu_list = source->p_cu_list.begin() ; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          *i_cu_list = tempListcu_list[tempListCountcu_list] ;
          tempListCountcu_list++; 
        }
      delete [] tempListcu_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50236 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50249 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfConstruct* pointer ) 
   { 
     SgAsmDwarfConstruct* source = (SgAsmDwarfConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50312 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50325 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfArrayTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfArrayType* pointer ) 
   { 
     SgAsmDwarfArrayType* source = (SgAsmDwarfArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50389 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50402 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfClassType* pointer ) 
   { 
     SgAsmDwarfClassType* source = (SgAsmDwarfClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50466 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50479 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEntryPointStorageClass::pickOutIRNodeData ( SgAsmDwarfEntryPoint* pointer ) 
   { 
     SgAsmDwarfEntryPoint* source = (SgAsmDwarfEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50542 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumerationTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50555 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumerationTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerationType* pointer ) 
   { 
     SgAsmDwarfEnumerationType* source = (SgAsmDwarfEnumerationType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumerationTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50619 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormalParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50632 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormalParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfFormalParameter* pointer ) 
   { 
     SgAsmDwarfFormalParameter* source = (SgAsmDwarfFormalParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFormalParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormalParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50695 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50708 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedDeclaration* pointer ) 
   { 
     SgAsmDwarfImportedDeclaration* source = (SgAsmDwarfImportedDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50771 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50784 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfLabel* pointer ) 
   { 
     SgAsmDwarfLabel* source = (SgAsmDwarfLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50847 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLexicalBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50860 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLexicalBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfLexicalBlock* pointer ) 
   { 
     SgAsmDwarfLexicalBlock* source = (SgAsmDwarfLexicalBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLexicalBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50924 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMemberStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50937 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMemberStorageClass::pickOutIRNodeData ( SgAsmDwarfMember* pointer ) 
   { 
     SgAsmDwarfMember* source = (SgAsmDwarfMember*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMemberStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMemberStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMemberStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMemberStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51000 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51013 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPointerTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPointerType* pointer ) 
   { 
     SgAsmDwarfPointerType* source = (SgAsmDwarfPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51076 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51089 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfReferenceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfReferenceType* pointer ) 
   { 
     SgAsmDwarfReferenceType* source = (SgAsmDwarfReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51152 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51165 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnit* pointer ) 
   { 
     SgAsmDwarfCompilationUnit* source = (SgAsmDwarfCompilationUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_producer.storeDataInEasyStorageClass(source->p_producer);
     storageOf_language.storeDataInEasyStorageClass(source->p_language);
     storageOf_low_pc =  source->p_low_pc ;
     storageOf_hi_pc =  source->p_hi_pc ;
     storageOf_version_stamp =  source->p_version_stamp ;
     storageOf_abbrev_offset =  source->p_abbrev_offset ;
     storageOf_address_size =  source->p_address_size ;
     storageOf_offset_length =  source->p_offset_length ;
     storageOf_line_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_line_info );
     storageOf_language_constructs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_language_constructs );
     storageOf_macro_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_macro_info );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51239 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStringTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51252 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStringTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStringType* pointer ) 
   { 
     SgAsmDwarfStringType* source = (SgAsmDwarfStringType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfStringTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStringTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStringTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfStringTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51315 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStructureTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51328 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStructureTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStructureType* pointer ) 
   { 
     SgAsmDwarfStructureType* source = (SgAsmDwarfStructureType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfStructureTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfStructureTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51392 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubroutineTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51405 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubroutineTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubroutineType* pointer ) 
   { 
     SgAsmDwarfSubroutineType* source = (SgAsmDwarfSubroutineType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubroutineTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51469 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTypedefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51482 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTypedefStorageClass::pickOutIRNodeData ( SgAsmDwarfTypedef* pointer ) 
   { 
     SgAsmDwarfTypedef* source = (SgAsmDwarfTypedef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTypedefStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTypedefStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTypedefStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTypedefStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51545 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51558 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnionTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnionType* pointer ) 
   { 
     SgAsmDwarfUnionType* source = (SgAsmDwarfUnionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51622 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedParametersStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51635 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedParametersStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedParameters* pointer ) 
   { 
     SgAsmDwarfUnspecifiedParameters* source = (SgAsmDwarfUnspecifiedParameters*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedParametersStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51698 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51711 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantStorageClass::pickOutIRNodeData ( SgAsmDwarfVariant* pointer ) 
   { 
     SgAsmDwarfVariant* source = (SgAsmDwarfVariant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51774 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51787 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonBlock* pointer ) 
   { 
     SgAsmDwarfCommonBlock* source = (SgAsmDwarfCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51851 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonInclusionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51864 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonInclusionStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonInclusion* pointer ) 
   { 
     SgAsmDwarfCommonInclusion* source = (SgAsmDwarfCommonInclusion*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonInclusionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51927 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInheritanceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51940 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInheritanceStorageClass::pickOutIRNodeData ( SgAsmDwarfInheritance* pointer ) 
   { 
     SgAsmDwarfInheritance* source = (SgAsmDwarfInheritance*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInheritanceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInheritanceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInheritanceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInheritanceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52003 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInlinedSubroutineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52016 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInlinedSubroutineStorageClass::pickOutIRNodeData ( SgAsmDwarfInlinedSubroutine* pointer ) 
   { 
     SgAsmDwarfInlinedSubroutine* source = (SgAsmDwarfInlinedSubroutine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInlinedSubroutineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52080 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52093 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfModule* pointer ) 
   { 
     SgAsmDwarfModule* source = (SgAsmDwarfModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52156 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPtrToMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52169 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPtrToMemberTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPtrToMemberType* pointer ) 
   { 
     SgAsmDwarfPtrToMemberType* source = (SgAsmDwarfPtrToMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPtrToMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52232 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSetTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52245 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSetTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSetType* pointer ) 
   { 
     SgAsmDwarfSetType* source = (SgAsmDwarfSetType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSetTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSetTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSetTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSetTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52308 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubrangeTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52321 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubrangeTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubrangeType* pointer ) 
   { 
     SgAsmDwarfSubrangeType* source = (SgAsmDwarfSubrangeType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubrangeTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52384 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfWithStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52397 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfWithStmtStorageClass::pickOutIRNodeData ( SgAsmDwarfWithStmt* pointer ) 
   { 
     SgAsmDwarfWithStmt* source = (SgAsmDwarfWithStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfWithStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfWithStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfWithStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfWithStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52460 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfAccessDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52473 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfAccessDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfAccessDeclaration* pointer ) 
   { 
     SgAsmDwarfAccessDeclaration* source = (SgAsmDwarfAccessDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfAccessDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52536 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfBaseTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52549 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfBaseTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfBaseType* pointer ) 
   { 
     SgAsmDwarfBaseType* source = (SgAsmDwarfBaseType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfBaseTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfBaseTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52612 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCatchBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52625 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCatchBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCatchBlock* pointer ) 
   { 
     SgAsmDwarfCatchBlock* source = (SgAsmDwarfCatchBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCatchBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCatchBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52688 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52701 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfConstType* pointer ) 
   { 
     SgAsmDwarfConstType* source = (SgAsmDwarfConstType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52764 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52777 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstantStorageClass::pickOutIRNodeData ( SgAsmDwarfConstant* pointer ) 
   { 
     SgAsmDwarfConstant* source = (SgAsmDwarfConstant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52840 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumeratorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52853 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumeratorStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerator* pointer ) 
   { 
     SgAsmDwarfEnumerator* source = (SgAsmDwarfEnumerator*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEnumeratorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumeratorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52916 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52929 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfFileType* pointer ) 
   { 
     SgAsmDwarfFileType* source = (SgAsmDwarfFileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52992 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFriendStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53005 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFriendStorageClass::pickOutIRNodeData ( SgAsmDwarfFriend* pointer ) 
   { 
     SgAsmDwarfFriend* source = (SgAsmDwarfFriend*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFriendStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFriendStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFriendStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFriendStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53068 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53081 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelist* pointer ) 
   { 
     SgAsmDwarfNamelist* source = (SgAsmDwarfNamelist*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamelistStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53144 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53157 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistItemStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelistItem* pointer ) 
   { 
     SgAsmDwarfNamelistItem* source = (SgAsmDwarfNamelistItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamelistItemStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistItemStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53220 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPackedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53233 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPackedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPackedType* pointer ) 
   { 
     SgAsmDwarfPackedType* source = (SgAsmDwarfPackedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPackedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPackedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53296 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubprogramStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53309 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubprogramStorageClass::pickOutIRNodeData ( SgAsmDwarfSubprogram* pointer ) 
   { 
     SgAsmDwarfSubprogram* source = (SgAsmDwarfSubprogram*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubprogramStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubprogramStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubprogramStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubprogramStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53373 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateTypeParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53386 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateTypeParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateTypeParameter* pointer ) 
   { 
     SgAsmDwarfTemplateTypeParameter* source = (SgAsmDwarfTemplateTypeParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateTypeParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53449 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateValueParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53462 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateValueParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateValueParameter* pointer ) 
   { 
     SgAsmDwarfTemplateValueParameter* source = (SgAsmDwarfTemplateValueParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateValueParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53525 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfThrownTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53538 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfThrownTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfThrownType* pointer ) 
   { 
     SgAsmDwarfThrownType* source = (SgAsmDwarfThrownType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfThrownTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfThrownTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53601 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTryBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53614 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTryBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfTryBlock* pointer ) 
   { 
     SgAsmDwarfTryBlock* source = (SgAsmDwarfTryBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTryBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTryBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTryBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTryBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53677 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantPartStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53690 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantPartStorageClass::pickOutIRNodeData ( SgAsmDwarfVariantPart* pointer ) 
   { 
     SgAsmDwarfVariantPart* source = (SgAsmDwarfVariantPart*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariantPartStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantPartStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantPartStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantPartStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53753 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53766 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariableStorageClass::pickOutIRNodeData ( SgAsmDwarfVariable* pointer ) 
   { 
     SgAsmDwarfVariable* source = (SgAsmDwarfVariable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53829 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVolatileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53842 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVolatileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfVolatileType* pointer ) 
   { 
     SgAsmDwarfVolatileType* source = (SgAsmDwarfVolatileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVolatileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53905 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfDwarfProcedureStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53918 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfDwarfProcedureStorageClass::pickOutIRNodeData ( SgAsmDwarfDwarfProcedure* pointer ) 
   { 
     SgAsmDwarfDwarfProcedure* source = (SgAsmDwarfDwarfProcedure*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfDwarfProcedureStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53981 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfRestrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53994 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfRestrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfRestrictType* pointer ) 
   { 
     SgAsmDwarfRestrictType* source = (SgAsmDwarfRestrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfRestrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54057 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInterfaceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54070 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInterfaceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfInterfaceType* pointer ) 
   { 
     SgAsmDwarfInterfaceType* source = (SgAsmDwarfInterfaceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInterfaceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54133 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamespaceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54146 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamespaceStorageClass::pickOutIRNodeData ( SgAsmDwarfNamespace* pointer ) 
   { 
     SgAsmDwarfNamespace* source = (SgAsmDwarfNamespace*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamespaceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamespaceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamespaceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamespaceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54210 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54223 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedModule* pointer ) 
   { 
     SgAsmDwarfImportedModule* source = (SgAsmDwarfImportedModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54286 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54299 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedType* pointer ) 
   { 
     SgAsmDwarfUnspecifiedType* source = (SgAsmDwarfUnspecifiedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54362 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPartialUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54375 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPartialUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfPartialUnit* pointer ) 
   { 
     SgAsmDwarfPartialUnit* source = (SgAsmDwarfPartialUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPartialUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPartialUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54438 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54451 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedUnit* pointer ) 
   { 
     SgAsmDwarfImportedUnit* source = (SgAsmDwarfImportedUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54514 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMutableTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54527 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMutableTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfMutableType* pointer ) 
   { 
     SgAsmDwarfMutableType* source = (SgAsmDwarfMutableType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMutableTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMutableTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54590 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConditionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54603 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConditionStorageClass::pickOutIRNodeData ( SgAsmDwarfCondition* pointer ) 
   { 
     SgAsmDwarfCondition* source = (SgAsmDwarfCondition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConditionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConditionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConditionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConditionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54666 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54679 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSharedType* pointer ) 
   { 
     SgAsmDwarfSharedType* source = (SgAsmDwarfSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54742 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormatLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54755 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormatLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfFormatLabel* pointer ) 
   { 
     SgAsmDwarfFormatLabel* source = (SgAsmDwarfFormatLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFormatLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormatLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54818 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFunctionTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54831 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFunctionTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfFunctionTemplate* pointer ) 
   { 
     SgAsmDwarfFunctionTemplate* source = (SgAsmDwarfFunctionTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFunctionTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54894 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54907 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfClassTemplate* pointer ) 
   { 
     SgAsmDwarfClassTemplate* source = (SgAsmDwarfClassTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfClassTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54970 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54983 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcSharedType* pointer ) 
   { 
     SgAsmDwarfUpcSharedType* source = (SgAsmDwarfUpcSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55046 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcStrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55059 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcStrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcStrictType* pointer ) 
   { 
     SgAsmDwarfUpcStrictType* source = (SgAsmDwarfUpcStrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcStrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55122 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcRelaxedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55135 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcRelaxedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcRelaxedType* pointer ) 
   { 
     SgAsmDwarfUpcRelaxedType* source = (SgAsmDwarfUpcRelaxedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcRelaxedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55198 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnknownConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55211 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnknownConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfUnknownConstruct* pointer ) 
   { 
     SgAsmDwarfUnknownConstruct* source = (SgAsmDwarfUnknownConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnknownConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55274 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55287 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructListStorageClass::pickOutIRNodeData ( SgAsmDwarfConstructList* pointer ) 
   { 
     SgAsmDwarfConstructList* source = (SgAsmDwarfConstructList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfConstructPtrList::iterator i_list = source->p_list.begin() ; 
     unsigned int tempListCountlist = 0; 
     SgAsmDwarfConstructPtrList::value_type *  tempListlist = new SgAsmDwarfConstructPtrList::value_type[ source->p_list.size() ]; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          tempListlist[tempListCountlist] = *i_list;
          tempListCountlist++; 
          (*i_list) = (SgAsmDwarfConstructPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_list ) );
        }
     storageOf_list.storeDataInEasyStorageClass(source->p_list);
     tempListCountlist = 0; 
     i_list = source->p_list.begin() ; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          *i_list = tempListlist[tempListCountlist] ;
          tempListCountlist++; 
        }
      delete [] tempListlist; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstructListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfConstructPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55363 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55376 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationListStorageClass::pickOutIRNodeData ( SgAsmInterpretationList* pointer ) 
   { 
     SgAsmInterpretationList* source = (SgAsmInterpretationList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmInterpretationPtrList::iterator i_interpretations = source->p_interpretations.begin() ; 
     unsigned int tempListCountinterpretations = 0; 
     SgAsmInterpretationPtrList::value_type *  tempListinterpretations = new SgAsmInterpretationPtrList::value_type[ source->p_interpretations.size() ]; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          tempListinterpretations[tempListCountinterpretations] = *i_interpretations;
          tempListCountinterpretations++; 
          (*i_interpretations) = (SgAsmInterpretationPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interpretations ) );
        }
     storageOf_interpretations.storeDataInEasyStorageClass(source->p_interpretations);
     tempListCountinterpretations = 0; 
     i_interpretations = source->p_interpretations.begin() ; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          *i_interpretations = tempListinterpretations[tempListCountinterpretations] ;
          tempListCountinterpretations++; 
        }
      delete [] tempListinterpretations; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInterpretationListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInterpretationListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInterpretationListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmInterpretationPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInterpretationListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmInterpretationPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55452 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55465 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileListStorageClass::pickOutIRNodeData ( SgAsmGenericFileList* pointer ) 
   { 
     SgAsmGenericFileList* source = (SgAsmGenericFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericFilePtrList::iterator i_files = source->p_files.begin() ; 
     unsigned int tempListCountfiles = 0; 
     SgAsmGenericFilePtrList::value_type *  tempListfiles = new SgAsmGenericFilePtrList::value_type[ source->p_files.size() ]; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          tempListfiles[tempListCountfiles] = *i_files;
          tempListCountfiles++; 
          (*i_files) = (SgAsmGenericFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_files ) );
        }
     storageOf_files.storeDataInEasyStorageClass(source->p_files);
     tempListCountfiles = 0; 
     i_files = source->p_files.begin() ; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          *i_files = tempListfiles[tempListCountfiles] ;
          tempListCountfiles++; 
        }
      delete [] tempListfiles; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericFilePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericFilePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/g/g15/bronevet/Compilers/ROSE/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55541 "../../../src/frontend/SageIII//StorageClasses.C" */



#endif // STORAGE_CLASSES_H

