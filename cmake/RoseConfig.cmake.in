# RoseConfig.cmake - CMake Package Configuration File for ROSE
# This file is used by external CMake projects to find and use ROSE.
# It is generated from RoseConfig.cmake.in during the build process.

@PACKAGE_INIT@

set(Rose_VERSION "@ROSE_PACKAGE_VERSION@")

# Enable CMP0144 to allow find_package() to use upper-case _ROOT variables
if(POLICY CMP0144)
  cmake_policy(SET CMP0144 NEW)
endif()

# Installation directory
# ======================
# The directory where ROSE was installed
set(Rose_INSTALL_PREFIX "@CMAKE_INSTALL_PREFIX@")

# Feature detection variables
# ============================
# These variables indicate which features ROSE was built with.
# External projects can query these to conditionally enable functionality.

# Language frontends
set(Rose_ENABLE_BINARY_ANALYSIS @ENABLE_BINARY_ANALYSIS@)
set(Rose_ENABLE_C @ENABLE_C@)
set(Rose_ENABLE_CUDA @ENABLE_CUDA@)
set(Rose_ENABLE_JAVA @ENABLE_JAVA@)
set(Rose_ENABLE_OPENCL @ENABLE_OPENCL@)
set(Rose_ENABLE_FORTRAN @ENABLE_FORTRAN@)
set(Rose_ENABLE_PHP @ENABLE_PHP@)
set(Rose_ENABLE_PYTHON @ENABLE_PYTHON@)
set(Rose_ENABLE_ADA @ENABLE_ADA@)
set(Rose_ENABLE_JOVIAL @ENABLE_JOVIAL@)

# Build options
set(Rose_ENABLE_ASSEMBLY_SEMANTICS @ENABLE_ASSEMBLY_SEMANTICS@)
set(Rose_ENABLE_CLANG_FRONTEND @ENABLE_CLANG_FRONTEND@)
set(Rose_BUILD_TYPE "@CMAKE_BUILD_TYPE@")

# Include CMake modules for finding dependencies
include(CMakeFindDependencyMacro)

# Find Threads (required for Boost::thread and ROSE threading support)
find_dependency(Threads)

# Find Boost (always required)
# ROSE requires Boost for its public API
set(Boost_USE_STATIC_LIBS @Boost_USE_STATIC_LIBS@)
find_dependency(Boost @Boost_VERSION@ REQUIRED COMPONENTS
  chrono
  date_time
  filesystem
  iostreams
  program_options
  random
  regex
  system
  thread
  wave
  serialization
)

# Optional dependencies
# ======================
# These dependencies are only required if ROSE was built with specific features enabled.
# They are marked as PRIVATE in ROSE's link interface, so they're not strictly required
# for projects using ROSE, but the Find modules need to be available for completeness.

# Set up module path for ROSE's custom Find modules
# Append rather than prepend to respect consumer's Find module preferences
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}")

# Find Gcrypt if it was enabled
# NOTE: Gcrypt is marked PUBLIC in ROSE's link interface because ROSE public headers
# conditionally include <gcrypt.h> (InstructionSemantics/PartialSymbolicSemantics.h).
# When ROSE was built with Gcrypt, consumers MUST be able to find Gcrypt headers.
set(Rose_GCRYPT_FOUND @GCRYPT_FOUND@)
if(Rose_GCRYPT_FOUND)
  # Find GpgError first (required by Gcrypt)
  if(NOT DEFINED GPGERROR_ROOT)
    set(GPGERROR_ROOT "@GPGERROR_ROOT@")
  endif()
  include(FindGpgError)
  find_gpgerror()
  if(NOT GPGERROR_FOUND)
    set(Rose_FOUND FALSE)
    set(Rose_NOT_FOUND_MESSAGE "Rose requires GpgError headers (Rose was built with Gcrypt support and Gcrypt headers appear in ROSE public API)")
  endif()

  # Find Gcrypt
  if(NOT DEFINED GCRYPT_ROOT)
    set(GCRYPT_ROOT "@GCRYPT_ROOT@")
  endif()
  include(FindGcrypt)
  find_gcrypt()
  if(NOT GCRYPT_FOUND)
    set(Rose_FOUND FALSE)
    set(Rose_NOT_FOUND_MESSAGE "Rose requires Gcrypt headers (Rose was built with Gcrypt support and Gcrypt headers appear in ROSE public API)")
  endif()
endif()

# Find Z3 SMT solver (optional - used for symbolic execution)
set(Rose_Z3_FOUND @ROSE_HAVE_Z3@)
if(Rose_Z3_FOUND)
  if(NOT DEFINED Z3_ROOT)
    set(Z3_ROOT "@Z3_ROOT@")
  endif()
  include(FindZ3)
  find_z3()
  # Z3 is PRIVATE, so we don't fail if it's not found - consumer doesn't need it
  # This just makes the variables available for reference
endif()

# Find DWARF debugging information library (optional - for binary analysis)
set(Rose_DWARF_FOUND @DWARF_FOUND@)
if(Rose_DWARF_FOUND)
  if(NOT DEFINED DWARF_ROOT)
    set(DWARF_ROOT "@DWARF_ROOT@")
  endif()
  # Find Elf first (required by Dwarf)
  if(NOT DEFINED ELF_ROOT)
    set(ELF_ROOT "@ELF_ROOT@")
  endif()
  include(FindElf)
  include(FindDwarf)
  # DWARF is PRIVATE, so we don't fail if it's not found
endif()

# Find Capstone disassembly library
# NOTE: Capstone is marked PUBLIC in ROSE's link interface because ROSE public headers
# include <capstone/*.h> (InstructionEnumsAarch32.h, InstructionEnumsAarch64.h,
# Disassembler/Aarch32.h, Disassembler/Aarch64.h).
# When ROSE was built with Capstone, consumers MUST be able to find Capstone headers.
set(Rose_CAPSTONE_FOUND @CAPSTONE_FOUND@)
if(Rose_CAPSTONE_FOUND)
  if(NOT DEFINED CAPSTONE_ROOT)
    set(CAPSTONE_ROOT "@CAPSTONE_ROOT@")
  endif()
  include(FindCapstone)
  find_capstone()
  if(NOT CAPSTONE_FOUND)
    set(Rose_FOUND FALSE)
    set(Rose_NOT_FOUND_MESSAGE "Rose requires Capstone headers (Rose was built with Capstone support and Capstone headers appear in ROSE public API)")
  endif()
endif()

# Find Dlib C++ library
# NOTE: Dlib is marked PUBLIC in ROSE's link interface because ROSE public headers
# include <dlib/matrix.h> (Rose/BinaryAnalysis/Matrix.h and others).
# When ROSE was built with Dlib, consumers MUST be able to find Dlib headers.
set(Rose_DLIB_FOUND @DLIB_FOUND@)
if(Rose_DLIB_FOUND)
  if(NOT DEFINED DLIB_ROOT)
    set(DLIB_ROOT "@DLIB_ROOT@")
  endif()
  include(FindDlib)
  find_dlib()
  if(NOT DLIB_FOUND)
    set(Rose_FOUND FALSE)
    set(Rose_NOT_FOUND_MESSAGE "Rose requires Dlib headers (Rose was built with Dlib support and Dlib headers appear in ROSE public API)")
  endif()
endif()

# Find YAML-CPP library
# NOTE: YAML-CPP is marked PUBLIC in ROSE's link interface because ROSE public headers
# include <yaml-cpp/yaml.h> (ModelChecker/SemanticCallbacks.h).
# When ROSE was built with YAML-CPP, consumers MUST be able to find YAML-CPP headers.
set(Rose_YAMLCPP_FOUND @YAMLCPP_FOUND@)
if(Rose_YAMLCPP_FOUND)
  if(NOT DEFINED YAMLCPP_ROOT)
    set(YAMLCPP_ROOT "@YAMLCPP_ROOT@")
  endif()
  include(FindYamlcpp)
  find_yamlcpp()
  if(NOT YAMLCPP_FOUND)
    set(Rose_FOUND FALSE)
    set(Rose_NOT_FOUND_MESSAGE "Rose requires YAML-CPP headers (Rose was built with YAML-CPP support and YAML-CPP headers appear in ROSE public API)")
  endif()
endif()

# Find Readline library (optional - for interactive tools)
set(Rose_READLINE_FOUND @READLINE_FOUND@)
if(Rose_READLINE_FOUND)
  if(NOT DEFINED READLINE_ROOT)
    set(READLINE_ROOT "@READLINE_ROOT@")
  endif()
  include(FindReadline)
  # Readline is PRIVATE, so we don't fail if it's not found
endif()

# Find SQLite3 library (optional - for database functionality)
set(Rose_SQLITE3_FOUND @SQLITE3_FOUND_LIB@)
if(Rose_SQLITE3_FOUND)
  if(NOT DEFINED SQLITE3_ROOT)
    set(SQLITE3_ROOT "@SQLITE3_ROOT@")
  endif()
  include(FindSqlite3)
  # SQLite3 is PRIVATE, so we don't fail if it's not found
endif()

# Find Yices SMT solver (optional - for symbolic execution)
set(Rose_YICES_FOUND @YICES_FOUND@)
if(Rose_YICES_FOUND)
  if(NOT DEFINED YICES_ROOT)
    set(YICES_ROOT "@YICES_ROOT@")
  endif()
  include(FindYices)
  # Yices is PRIVATE, so we don't fail if it's not found
endif()

# Find Magic library (optional - for file type detection)
set(Rose_MAGIC_FOUND @MAGIC_FOUND@)
if(Rose_MAGIC_FOUND)
  if(NOT DEFINED MAGIC_ROOT)
    set(MAGIC_ROOT "@MAGIC_ROOT@")
  endif()
  include(FindMagic)
  # Magic is PRIVATE, so we don't fail if it's not found
endif()

# Find Zlib (optional - used by Boost and compression)
set(Rose_ZLIB_FOUND @ZLIB_FOUND@)
if(Rose_ZLIB_FOUND)
  find_dependency(ZLIB)
endif()

# Import the ROSE targets
# This brings in Rose::rose and all its properties
if(NOT TARGET Rose::rose)
  include("${CMAKE_CURRENT_LIST_DIR}/RoseTargets.cmake")
endif()

# Check that all required components are present
check_required_components(Rose)
