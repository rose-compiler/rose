
#ifndef _CT_EXTERNAL_MANGLING_HPP
#define _CT_EXTERNAL_MANGLING_HPP 251003

#include <string>
#include <iosfwd>
#include <functional>

struct SgType;
struct SgInitializedName;
struct SgDeclarationStatement;

namespace CodeThorn
{

using NameShortener = std::function<std::string(std::string)>;

NameShortener longNames(); /// full mangled names
NameShortener hashNames(); /// mangled name hashing (similar to ROSE internal name shortening)

#if 0
disabled because method requires string compression
// NameShortener compressNames(int windowsize = 32); // removes repetitive substrings
#endif

/// Generates unique mangled external names for SgDeclarationStatements
/// \param  n              the SgDeclarationStatement for which the mangled name is generated.
/// \param  shorten        a function that creates unique short names (currently mangled
///                        names can get quite long).
/// \param  withUniqueMain if true the main function is made unique (enables processing projects with
///                        multiple main functions).
/// \return a mangled name
/// \details
///    the mangled name, as generated by these functions, resolves types to their respective
///    canonical representation, similar (but different) to compiler generated mangled names.
///    e.g., the two foo's below have the same mangled name when they are declared in
///          different translation units. The standard ROSE name mangling generates
///          different mangled names due to the presence of a typedef/using declaration.
/// \code
/// // unit1.cc
/// using XInt = int;
/// void foo(XInt);
/// // unit2.cc
/// void foo(int);
/// \endcode
/// \{
const std::string&
mangle(const SgDeclarationStatement& n, NameShortener shorten = longNames(), bool withUniqueMain = false);

const std::string&
mangle(const SgDeclarationStatement* n, NameShortener shorten = longNames(), bool withUniqueMain = false);
/// \}

/// Generates unique mangled external names for SgType nodes
/// \param  n              the SgType for which the mangled name is generated.
/// \param  shorten        a function that creates unique short names (currently mangled
///                        names can get quite long).
/// \param  withReturnType if true, the return type of a function type is included in the mangled name.
/// \param  withArrayToPointerDecay if true arrays are mangled as pointers
/// \return a mangled name
/// \details
///    withReturnType and withArrayToPointerDecay provide context for the name mangling.
///    e.g.,
///    * to mangle the type of f in int f (float nums[]); would require
///      withReturnType = false (return type not relevant)
///      withArrayToPointerDecay = true (nums will be mangled as pointer)
///    * to mangle the type of sum in int f (float (*sum)(float nums[])); would require
///      withReturnType = true (return type is relevant)
///      withArrayToPointerDecay = true (nums will be mangled as pointer)
/// \{
const std::string&
mangle(const SgType& n, NameShortener shorten = longNames(), bool withReturnType=true, bool withArrayToPointerDecay=false);

const std::string&
mangle(const SgType* n, NameShortener shorten = longNames(), bool withReturnType=true, bool withArrayToPointerDecay=false);
/// \}

/// Generates unique mangled external names for SgInitializedName nodes
/// \param  n              the SgType for which the mangled name is generated.
/// \param  shorten        a function that creates unique short names (currently mangled
///                        names can get quite long).
/// \return a mangled name
/// \{
const std::string&
mangle(const SgInitializedName& n, NameShortener shorten = longNames());

const std::string&
mangle(const SgInitializedName* n, NameShortener shorten = longNames());
/// \}

/// clears maps to cache repetitive mangling of the same nodes
/// \details
///    Can be called after name mangling has finished. Affects only
///    runtime but not the generated mangled name.
void clearManglingCache();

/// Prints nodes for which the name mangling is not properly defined
/// \details
///    may be called after name mangling to report unhandled IR nodes.
///    (for internal debugging purposes)
void printUnhandledNodes(std::ostream& os);


}

#endif /*_CT_EXTERNAL_MANGLING_HPP */
