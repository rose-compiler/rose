static const char *purpose = "show memory map";
static const char *description =
    "Given a BAT state for a binary specimen, show the memory map on standard output.";

#include <batSupport.h>

#include <Rose/BinaryAnalysis/AddressInterval.h>
#include <Rose/BinaryAnalysis/Hexdump.h>
#include <Rose/BinaryAnalysis/Partitioner2/Engine.h>
#include <Rose/BinaryAnalysis/Partitioner2/Partitioner.h>
#include <Rose/BinaryAnalysis/SRecord.h>
#include <Rose/CommandLine.h>
#include <Rose/Initialize.h>

#include <BinaryVxcoreParser.h>                         // rose

#include <Sawyer/Stopwatch.h>

#include <boost/algorithm/string/predicate.hpp>
#include <boost/filesystem.hpp>

using namespace Rose;
using namespace Rose::BinaryAnalysis;
using namespace Sawyer::Message::Common;
namespace P2 = Rose::BinaryAnalysis::Partitioner2;

namespace {

Sawyer::Message::Facility mlog;

enum class OutputFormat { UNSPECIFIED, NONE, HEXDUMP, SRECORDS, INTEL_HEX, BINARY, VXCORE_1, VXCORE_2 };

struct Settings {
    SerialIo::Format stateFormat = SerialIo::BINARY;
    OutputFormat outputFormat = OutputFormat::UNSPECIFIED;
    Sawyer::Optional<SRecord::Syntax> srecordSyntax;
    std::string outputPrefix;
    std::vector<AddressInterval> where;
};

// Create a command-line switch parser
Sawyer::CommandLine::Parser
createSwitchParser(Settings &settings) {
    using namespace Sawyer::CommandLine;

    //---------- Output switches ----------
    SwitchGroup output("Output Switches");
    output.name("out");

    output.insert(Switch("format", 'F')
                  .argument("fmt", enumParser<OutputFormat>(settings.outputFormat)
                            ->with("none",      OutputFormat::NONE)
                            ->with("hexdump",   OutputFormat::HEXDUMP)
                            ->with("srec",      OutputFormat::SRECORDS)
                            ->with("hex",       OutputFormat::INTEL_HEX)
                            ->with("binary",    OutputFormat::BINARY)
                            ->with("vxcore-1",  OutputFormat::VXCORE_1)
                            ->with("vxcore-2",  OutputFormat::VXCORE_2)
                            ->with("vxcore",    OutputFormat::VXCORE_1)  // backward compatibility, no longer documented
                            ->with("srecord",   OutputFormat::SRECORDS)  // backward compatibility, no longer documented
                            ->with("srecords",  OutputFormat::SRECORDS)) // backward compatibility, no longer documented
                  .doc("Style of output to use when dumping memory.  The choices are:"

                       "@named{none}{Don't dump any data; just show basic information about the memory map. This "
                       "is the default if no addresses are specified with @s{where}.}"

                       "@named{hexdump}{Show the data in a format similar to the @man{hexdump}{1} command. This is "
                       "the default if addresses are specified with @s{where}.}"

                       "@named{srec}{Emit the data as Motorola S-Records.}"

                       "@named{hex}{Emit the data in Intel-HEX format.}"

                       "@named{binary}{Save the data to one or more binary files, one per region of memory. The file "
                       "names are generated by appending the hexadecimal starting address (without leading \"0x\") and "
                       "the file extension \".data\" to the name supplied by the @s{prefix} switch. Additionally, an "
                       "index file is emitted to standard output and contains the command-line arguments that describe "
                       "how to load the binary files back into memory.}"

                       "@named{vxcore-1}{Save the data to a binary file whose format is defined by ROSE. Use the version 1 "
                       "variant of this format. The @s{prefix} is used as the output file name.}"

                       "@named{vxcore-2}{Save the data to a binary file whose format is defined by ROSE. Use the version 2 "
                       "variant of this format. The @s{prefix} is used as the output file name.}"));

    output.insert(Switch("srecord-syntax")
                  .argument("syntax", enumParser<SRecord::Syntax>(settings.srecordSyntax)
                            ->with("motorola", SRecord::SREC_MOTOROLA)
                            ->with("intel", SRecord::SREC_INTEL))
                  .hidden(true));                       // backward compatibility, no longer documented

    output.insert(Switch("output", 'o')
                  .longName("prefix")
                  .argument("name", anyParser(settings.outputPrefix))
                  .doc("When generating binary files (@s{format}=binary), the string argument for this switch is "
                       "prepended to the names of the binary output files as described by @s{format}. The default "
                       "is to use the base name of the input RBA file after also removing the \".rba\" extension."));

    output.insert(Switch("where", 'a')
                  .argument("interval", P2::addressIntervalParser(settings.where))
                  .whichValue(SAVE_ALL)
                  .doc("Specifies the addresses that should be dumped. The default is to dump all mapped addresses. " +
                       P2::AddressIntervalParser::docString() + "  The specified interval may include addresses "
                       "that aren't mapped and which are silently ignored. This switch may appear more than once."));

    //---------- Generic switches ----------
    SwitchGroup generic = Rose::CommandLine::genericSwitches();
    generic.insert(Bat::stateFileFormatSwitch(settings.stateFormat));

    //---------- Parsing -----------
    Parser parser = Rose::CommandLine::createEmptyParser(purpose, description);
    parser.errorStream(mlog[FATAL]);
    parser.with(output).with(generic);
    parser.doc("Synopsis", "@prop{programName} [@v{switches}] [@v{specimen}]");

    return parser;
}

// Parses the command-line and returns the positional arguments that specify a specimen.
std::vector<std::string>
parseCommandLine(int argc, char *argv[], Sawyer::CommandLine::Parser &parser, Settings &settings) {
    std::vector<std::string> specimen = parser.parse(argc, argv).apply().unreachedArgs();
    if (specimen.empty())
        specimen.push_back("-");
    if (OutputFormat::UNSPECIFIED == settings.outputFormat)
        settings.outputFormat = settings.where.empty() ? OutputFormat::NONE : OutputFormat::HEXDUMP;
    if (settings.where.empty())
        settings.where.push_back(AddressInterval::whole());

    return specimen;
}

class Dumper {
public:
    void operator()(const Settings&, const MemoryMap::Ptr &map, const AddressInterval &dataInterval,
                    std::ostream &stream) {
        MemoryMap::ConstNodeIterator inode = map->at(dataInterval.least()).nodes().begin();
        ASSERT_forbid(inode == map->nodes().end());
        const AddressInterval &segmentInterval = inode->key();
        ASSERT_require(segmentInterval.contains(dataInterval));
        const MemoryMap::Segment &segment = inode->value();
        if (const uint8_t *data = segment.buffer()->data()) {
            Address bufferOffset = segment.offset() + dataInterval.least() - segmentInterval.least();
            ASSERT_require(segment.buffer()->available(bufferOffset) >= dataInterval.size());
            formatData(stream, segmentInterval, segment, dataInterval, data+bufferOffset);
        }
    }

    virtual void formatData(std::ostream&, const AddressInterval &segmentInterval, const MemoryMap::Segment&,
                            const AddressInterval &dataInterval, const uint8_t *data) = 0;
};

class HexDumper: public Dumper {
    HexdumpFormat fmt_;
public:
    HexDumper() {
        fmt_.numeric_fmt_special[0] = "..";
        fmt_.numeric_fmt_special[0xff]= "##";
    }

    virtual void formatData(std::ostream &stream, const AddressInterval &segmentInterval, const MemoryMap::Segment &segment,
                            const AddressInterval &dataInterval, const uint8_t *data) override {
        Address va = dataInterval.least();
        Address nRemain = dataInterval.size();

        if (dataInterval.least() == segmentInterval.least())
            stream <<"Dumping segment " <<segmentInterval <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"\n";
        if (dataInterval != segmentInterval)
            stream <<"Data for addresses " <<dataInterval <<":\n";

        // Hexdumps are typically aligned so the first byte on each line is aligned on a 16-byte address, so print
        // out some stuff to get the rest aligned if necessary.
        Address nLeader = std::min(16 - va % 16, nRemain);
        if (nLeader != 16) {
            hexdump(stream, va, data, nLeader, fmt_);
            va += nLeader;
            data += nLeader;
            nRemain -= nLeader;
            stream <<"\n";
        }

        hexdump(stream, va, data, nRemain, fmt_);
        stream <<"\n";
    }
};

class SRecordDumper: public Dumper {
    SRecord::Syntax syntax_;

public:
    explicit SRecordDumper(SRecord::Syntax syntax)
        : syntax_(syntax) {}

    virtual void formatData(std::ostream &stream, const AddressInterval &/*segmentInterval*/, const MemoryMap::Segment &/*segment*/,
                            const AddressInterval &dataInterval, const uint8_t *data) override {
        MemoryMap::Ptr map = MemoryMap::instance();
        map->insert(dataInterval, MemoryMap::Segment::staticInstance(data, dataInterval.size(), MemoryMap::READABLE));
        std::vector<SRecord> srecs = SRecord::create(map, syntax_);
        for (const SRecord &srec: srecs)
            stream <<srec <<"\n";
    }
};

class BinaryDumper: public Dumper {
public:
    virtual void formatData(std::ostream &stream, const AddressInterval &segmentInterval, const MemoryMap::Segment &segment,
                            const AddressInterval &dataInterval, const uint8_t *data) override {
        stream.write((const char*)data, dataInterval.size());
        if (!stream.good()) {
            std::ostringstream mesg;
            mesg <<"write failed for virtual addresses " <<dataInterval <<" in segment " <<segmentInterval
                 <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"";
            throw std::runtime_error(mesg.str());
        }
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace

int
main(int argc, char *argv[]) {
    ROSE_INITIALIZE;
    Diagnostics::initAndRegister(&mlog, "tool");
    mlog.comment("listing info about virtual memory maps");
    Bat::checkRoseVersionNumber(MINIMUM_ROSE_LIBRARY_VERSION, mlog[FATAL]);
    Bat::registerSelfTests();

    Settings settings;
    Sawyer::CommandLine::Parser switchParser = createSwitchParser(settings);
    auto engine = P2::Engine::forge(argc, argv, switchParser /*in,out*/);
    std::vector<std::string> specimen = parseCommandLine(argc, argv, switchParser, settings /*in,out*/);

    MemoryMap::Ptr map;
    if (specimen.size() == 1 && (specimen[0] == "-" || boost::ends_with(specimen[0], ".rba"))) {
        map = P2::Partitioner::instanceFromRbaFile(specimen[0], settings.stateFormat)->memoryMap();
    } else {
        map = engine->loadSpecimens(specimen);
    }
    ASSERT_not_null(map);

    if (OutputFormat::NONE == settings.outputFormat) {
        switch (map->byteOrder()) {
            case ByteOrder::ORDER_LSB:
                std::cout <<"default byte order is little-endian\n";
                break;
            case ByteOrder::ORDER_MSB:
                std::cout <<"default byte order is big-endian\n";
                break;
            case ByteOrder::ORDER_UNSPECIFIED:
                std::cout <<"default byte order is unspecified\n";
                break;
        }
        map->dump(std::cout);

    } else if (OutputFormat::VXCORE_1 == settings.outputFormat || OutputFormat::VXCORE_2 == settings.outputFormat) {
        if (settings.outputPrefix.empty()) {
            mlog[FATAL] <<"an output file must be specified for binary output formats\n";
            exit(1);
        }
        std::string outputName = settings.outputPrefix;
        std::ofstream output(outputName.c_str(), std::ios_base::binary);
        if (!output.good())
            throw std::runtime_error("cannot create \"" + outputName);
        Rose::BinaryAnalysis::VxcoreParser parser;
        parser.settings().version = OutputFormat::VXCORE_1 == settings.outputFormat ? 1 : 2;
        for (AddressInterval where: settings.where)
            parser.unparse(output, map, where, "output");
        exit(0);

    } else {
        for (AddressInterval where: settings.where) {
            Address va = where.least();
            while (AddressInterval interval = map->atOrAfter(va).singleSegment().available()) {
                interval = interval.intersection(where);
                ASSERT_forbid(interval.isEmpty());
                MemoryMap::ConstNodeIterator inode = map->at(interval.least()).nodes().begin();
                const AddressInterval &segmentInterval = inode->key();
                const MemoryMap::Segment &segment = inode->value();

                switch (settings.outputFormat) {
                    case OutputFormat::UNSPECIFIED:
                        ASSERT_not_reachable("should have been initialized in parseCommandLine");
                    case OutputFormat::NONE:
                        ASSERT_not_reachable("handled already above");
                    case OutputFormat::HEXDUMP:
                        HexDumper{}(settings, map, interval, std::cout);
                        break;
                    case OutputFormat::SRECORDS:
                        SRecordDumper{settings.srecordSyntax.orElse(SRecord::SREC_MOTOROLA)}(settings, map, interval, std::cout);
                        break;
                    case OutputFormat::INTEL_HEX:
		        SRecordDumper{SRecord::SREC_INTEL}(settings, map, interval, std::cout);
                        break;
                    case OutputFormat::BINARY: {
                        boost::filesystem::path outputName = settings.outputPrefix +
                                                             StringUtility::addrToString(interval.least()).substr(2) +
                                                             ".data";
                        std::ofstream output(outputName.native().c_str());
                        if (!output.good()) {
                            mlog[FATAL] <<"cannot create output file " <<outputName <<"\n";
                            exit(1);
                        }
                        BinaryDumper{}(settings, map, interval, output);
                        std::cout <<"# Segment " <<segmentInterval <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"\n"
                                  <<"map:" <<StringUtility::addrToString(segmentInterval.least())
                                  <<"+" <<StringUtility::addrToString(segmentInterval.size())
                                  <<"=" <<(0!=(segment.accessibility() & MemoryMap::READABLE) ? "r" : "")
                                  <<(0!=(segment.accessibility() & MemoryMap::WRITABLE) ? "w" : "")
                                  <<(0!=(segment.accessibility() & MemoryMap::EXECUTABLE) ? "x" : "")
                                  <<"::" <<outputName <<"\n\n";
                        break;
                    }
                    case OutputFormat::VXCORE_1:
                    case OutputFormat::VXCORE_2:
                        ASSERT_not_reachable("handled above");
                }
                if (interval.greatest() == where.greatest())
                    break;                                  // to prevent possible overflow
                va = interval.greatest() + 1;
            }
        }
    }
}
