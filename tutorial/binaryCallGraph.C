//! [headers]
#include <rose.h>

#include <Diagnostics.h>
#include <Partitioner2/Engine.h>
#include <Partitioner2/GraphViz.h>
#include <Sawyer/CommandLine.h>
//! [headers]

//! [namespaces]
using namespace Rose;
using namespace Rose::Diagnostics;
using namespace Rose::BinaryAnalysis;
//! [namespaces]

//! [settings]
struct Settings {
    std::string outputName;

    Settings()
        : outputName("cg.dot") {}
};
//! [settings]

//! [commandline]
static std::vector<std::string>
parseCommandLine(int argc, char *argv[], Partitioner2::Engine &engine, Settings &settings) {
    using namespace Sawyer::CommandLine;

    std::string purpose = "obtains a function call graph from a binary specimen";
    std::string description =
        "This tool disassembles the specified file and generates a function call "
        "graph named \"cg.dot\" in the current working directory.  The dot file "
        "can be processed with GraphViz commands or viewed directly with ZGRViewer.";

    Parser parser = engine.commandLineParser(purpose, description);

    SwitchGroup tool("Tool switches");
    tool.insert(Switch("output", 'O')
                .argument("filename", anyParser(settings.outputName))
                .doc("Specifies the name of the call graph that is generated by "
                     "this tool. The default is \"" +
                     StringUtility::cEscape(settings.outputName) + "\""));

    return parser.with(tool).parse(argc, argv).apply().unreachedArgs();
}
//! [commandline]

int
main(int argc, char *argv[]) {
    //! [setup]
    ROSE_INITIALIZE;
    Settings settings;
    Partitioner2::Engine engine;
    std::vector<std::string> specimen = parseCommandLine(argc, argv, engine, settings);
    if (specimen.empty()) {
        mlog[FATAL] <<"no binary specimen specified; see --help\n";
        exit(1);
    }
    //! [setup]
    
    //! [partition]
    Partitioner2::Partitioner partitioner = engine.partition(specimen);
    //! [partition]

    //! [callgraph]
    Partitioner2::FunctionCallGraph callgraph = partitioner.functionCallGraph(Partitioner2::AllowParallelEdges::NO);
    //! [callgraph]

    //! [emit]
    std::ofstream output(settings.outputName.c_str());
    Partitioner2::GraphViz::CgEmitter emitter(partitioner, callgraph);
    emitter.emitCallGraph(output);
    //! [emit]
}
